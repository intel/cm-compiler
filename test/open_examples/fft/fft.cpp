/*
 * Copyright (c) 2017-2019, Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

#include <algorithm>
#include <complex>
#include <iomanip>
#include <iostream>
#include <stdint.h>
#include <time.h>
#include <vector>

#define HAS_MKL 0
#define ERROR_TOLERANCE 0.001f

#if HAS_MKL
#include "mkl/include/mkl_dfti.h"
#endif

// The only CM runtime header file that you need is cm_rt.h.
// It includes all of the CM runtime.
#include "cm_rt.h"

// Includes cm_rt_helpers.h to convert the integer return code returned from
// the CM runtime to a meaningful string message.
#include "common/cm_rt_helpers.h"

// Includes isa_helpers.h to load the ISA file generated by the CM compiler.
#include "common/isa_helpers.h"

using namespace std;

static float MaxAbsError(const complex<float>& ref, float x, float y)
{
    float deltax = abs(ref.real() - x);
    float deltay = abs(ref.imag() - y);

    if (!isfinite(deltax))
        return numeric_limits<float>::infinity();

    if (!isfinite(deltay))
        return numeric_limits<float>::infinity();

    return max(deltax, deltay);
}

static void print(size_t width, size_t height,
                  const vector<complex<float>>& c)
{
    cout << std::fixed;
    cout << std::setprecision(4);

    for (size_t i = 0; i < height; i++) {
        cout << "\n";
        for (size_t j = 0; j < width; j++) {
            cout << c[i * width + j].real() << "+"
                 << c[i * width + j].imag() << "I" << "\n";
        }
    }
    cout << endl;
}

static void printGotExpected(size_t width, size_t height,
                             const vector<float>& got,
                             const vector<complex<float>>& exp)
{
    cout << std::fixed;
    cout << std::setprecision(4);
    cout << left << setw(25) << "    Got" << "Expected\n";
    cout << left << setw(25) << "    ~~~" << "~~~~~~~~\n";

    for (size_t i = 0; i < height; i++) {
        cout << "\n";
        for (size_t j = 0; j < width; j++) {
            float got_re = got[i*2*width + 2*j + 0];
            float got_im = got[i*2*width + 2*j + 1];
            const complex<float>& expValue = exp[i*width + j];
            float error = MaxAbsError(expValue, got_re, got_im);
            cout << right << setw(8) << got_re << "+"
                 << right << setw(8) << got_im << "I"
                 << "   ";
            cout << right << setw(8) << expValue.real() << "+"
                 << right << setw(8) << expValue.imag() << "I";
            if (error > ERROR_TOLERANCE) {
                cout << "  <=== error: " << error;
            }
            cout << "\n";
        }
    }
    cout << endl;
}

#if HAS_MKL
// ----------------------------------------------------------------------------
// CPU MKL 1D DFT in-place on columns of fftsize.
// ----------------------------------------------------------------------------
void mkl_dft_1d(vector<complex<float>>& data, const size_t& fftsize,
                const size_t& rows, const size_t& cols, const bool& forward)
{
    size_t length = data.size();

    DFTI_DESCRIPTOR_HANDLE mklFFT;

    MKL_LONG status;

    status = DftiCreateDescriptor(&mklFFT, DFTI_SINGLE, DFTI_COMPLEX,
                                  1, fftsize);

    status = DftiSetValue(mklFFT, DFTI_NUMBER_OF_TRANSFORMS, cols);
    status = DftiSetValue(mklFFT, DFTI_INPUT_DISTANCE, 1);
    status = DftiSetValue(mklFFT, DFTI_OUTPUT_DISTANCE, 1);

    MKL_LONG stride[2] = { 0, (long)cols };
    status = DftiSetValue(mklFFT, DFTI_INPUT_STRIDES, stride);
    status = DftiSetValue(mklFFT, DFTI_OUTPUT_STRIDES, stride);

    status = DftiCommitDescriptor(mklFFT);

    for (size_t block = 0; block < rows / fftsize; block++) {
        size_t offset = block * cols * fftsize;

        switch (forward) {
        case true:  status = DftiComputeForward(mklFFT, &data[offset]);  break;
        case false: status = DftiComputeBackward(mklFFT, &data[offset]); break;
        }
    }

    status = DftiFreeDescriptor(&mklFFT);
}
#endif

// ------------------
// Compare results.
// ------------------
static float MaxAbsError(const vector<float>& got,
                         const vector<complex<float>>& expected)
{
    float maxAbsError = -1.0f;

    for (size_t i = 0; i < expected.size(); i++) {
        float absError = MaxAbsError(expected[i], got[2*i], got[2*i+1]);
        if (maxAbsError < absError)
            maxAbsError = absError;
    }

    return maxAbsError;
}

static float checkResult(size_t width, size_t height, unsigned fftsize,
                          const vector<float>& gpuOutput,
                          vector<complex<float>>& cpuData)
{
#if HAS_MKL
    // perform CPU MKL FFT once for validation; notice this is done in-place
    mkl_dft_1d(cpuData, fftsize, height, width, true);
#else
    // overwrite cpuData with expected result of transforming constant signal
    for (size_t block = 0; block < height / fftsize; block++) {
        size_t offset = block * width * fftsize;
        for (size_t col = 0; col < width; col++) {
            cpuData[offset + col] = {1.0f*fftsize, 2.0f*fftsize};
            for (size_t row = 1; row < fftsize; row++) {
                cpuData[offset + row*width + col] = {0.0f, 0.0f};
            }
        }
    }
#endif

    if (width <= 64 && height <= 64) {
        printGotExpected(width, height, gpuOutput, cpuData);
    }

    // get the error between GPU and CPU
    return MaxAbsError(gpuOutput, cpuData);
}


// ---------------------------
// Initialize the GPU signal.
// ---------------------------
static void initialize(vector<float>& gpuSignal,
                       const vector<complex<float>>& cpuSignal)
{
    for (size_t i = 0; i < cpuSignal.size(); i++) {
        gpuSignal[2 * i + 0] = cpuSignal[i].real();
        gpuSignal[2 * i + 1] = cpuSignal[i].imag();
    }
}

// --------------------------
// Generate an input signal.
// --------------------------
static vector<complex<float>> generateSignal(size_t size)
{
    vector<complex<float>> output(size);
#if HAS_MKL
    // Random generation--result will be checked against MKL.
    float vmax = 1.0f;
    float vmin = -1.0f;
    float factor = (vmax - vmin) / RAND_MAX;

    for (size_t i = 0; i < size; i++) {
        output[i] = { vmin + (float)std::rand() * factor,
                      vmin + (float)std::rand() * factor };
    }
#else
    // Constant signal generation.
    for (size_t i = 0; i < size; i++) {
        output[i] = {1.0f, 2.0f};
    }
#endif

    return output;
}

bool runTest(size_t width, size_t height, unsigned fftsize, unsigned simd)
{
    vector<complex<float>> cpuData = generateSignal(width * height);
    vector<float> gpuData(width * height * 2);
    initialize(gpuData, cpuData);

    // Creates a CmDevice from scratch.
    // Param device: pointer to the CmDevice object.
    // Param version: CM API version supported by the runtime library.
    CmDevice *device = nullptr;
    unsigned version = 0;
    cm_result_check(::CreateCmDevice(device, version));

    // Load the virtual ISA file.
    std::string isa_code = cm::util::isa::loadFile("fft_genx.isa");
    if (isa_code.empty()) {
        std::cerr << "Error: empty ISA binary.\n";
        std::exit(1);
    }

    // Creates a CmProgram object of the kernels loaded from the code buffer.
    CmProgram *program = nullptr;
    cm_result_check(device->LoadProgram(const_cast<char *>(isa_code.data()),
                                        isa_code.size(), program));

    // Creates the kernel.
    CmKernel *kernel = nullptr;
    if (fftsize == 8 && simd == 8)
        cm_result_check(device->CreateKernel(program, "fft8_simd8_io", kernel));
    else if (fftsize == 8 && simd == 16)
        cm_result_check(device->CreateKernel(program, "fft8_simd16_io", kernel));
    else if (fftsize == 16 && simd == 8)
        cm_result_check(device->CreateKernel(program, "fft16_simd8_io", kernel));
    else if (fftsize == 16 && simd == 16)
        cm_result_check(device->CreateKernel(program, "fft16_simd16_io", kernel));
    else if (fftsize == 32 && simd == 8)
        cm_result_check(device->CreateKernel(program, "fft32_simd8_io", kernel));
    else {
        std::cerr << "Not implemented: fftsize = " << fftsize
                  << ", simd = " << simd << "\n";
        exit(1);
    }

    // Each CmKernel can be executed by multiple concurrent threads.
    unsigned batch_size = width * height / fftsize;
    unsigned thread_width = width / simd;
    unsigned thread_height = height / fftsize;
    unsigned group_width = 1;
    unsigned group_height = 1;

    unsigned maxThreadGroupCount;
    size_t size = 4;
    cm_result_check(device->GetCaps(CAP_USER_DEFINED_THREAD_COUNT_PER_THREAD_GROUP,
                    size, &maxThreadGroupCount));

    //ThreadGroupCount should be power of 2
    unsigned GroupWidth = 32;
    while (GroupWidth > maxThreadGroupCount)
    {
        GroupWidth = GroupWidth >> 1;
    }

    if (thread_width > GroupWidth) {
    group_width = thread_width / GroupWidth;
    thread_width = GroupWidth;
    }

    if (thread_height > 1) {
        group_height = thread_height / 1;
        thread_height = 1;
    }

    // Creates a CmThreadGroupSpace object.
    CmThreadGroupSpace *tg_space = nullptr;
    cm_result_check(device->CreateThreadGroupSpace(thread_width, thread_height,
                                         group_width, group_height, tg_space));

    // Gets the input/output surface index and set per kernel arguments.
    CmBuffer *io_surface = nullptr;
    SurfaceIndex *io_surface_idx = nullptr;
    cm_result_check(device->CreateBuffer(width * height * sizeof(float) * 2,
                                         io_surface));
    cm_result_check(io_surface->WriteSurface((uint8_t*)gpuData.data(), nullptr));
    cm_result_check(io_surface->GetIndex(io_surface_idx));
    cm_result_check(kernel->SetKernelArg(0, sizeof(SurfaceIndex), io_surface_idx));

    unsigned ncols = width;
    cm_result_check(kernel->SetKernelArg(1, sizeof(unsigned), &ncols));

    // Creates a task queue and add the kernel.
    CmQueue *cmd_queue = nullptr;
    CmTask *task = nullptr;
    cm_result_check(device->CreateQueue(cmd_queue));
    cm_result_check(device->CreateTask(task));
    cm_result_check(task->AddKernel(kernel));

    // Warm up.
    CmEvent *e = nullptr;
    unsigned long time_out = -1;
    cm_result_check(cmd_queue->EnqueueWithGroup(task, e, tg_space));
    cm_result_check(e->WaitForTaskFinished(time_out));

    // Check results.
    cm_result_check(io_surface->ReadSurface((uint8_t*)gpuData.data(), e));
    float maxAbsError = checkResult(width, height, fftsize, gpuData, cpuData);

    // Timed tests.
    unsigned num_iters = 100;
    vector<UINT64> exeTimesGPU(num_iters);

    for (int i = 0; i < num_iters; ++i) {
        UINT64 time_in_ns = 0;
        cm_result_check(cmd_queue->EnqueueWithGroup(task, e, tg_space));
        cm_result_check(e->WaitForTaskFinished(time_out));
        cm_result_check(e->GetExecutionTime(time_in_ns));
        exeTimesGPU[i] = time_in_ns;
    }

    cm_result_check(cmd_queue->DestroyEvent(e));
    cm_result_check(::DestroyCmDevice(device));
    sort(exeTimesGPU.begin(), exeTimesGPU.end());
    double minTimeGPU = exeTimesGPU[0] / 1000.0 / batch_size;

    cout << "Buffer size:            " << width*height*sizeof(float)*2 << "B\n";
    cout << "FFT length:             " << fftsize << "\n";
    cout << "SIMD size:              " << simd << "\n";
    cout << "Execution time per FFT: " << minTimeGPU << "us\n";
    cout << "Max abs error:          " << maxAbsError << endl;

    return maxAbsError <= ERROR_TOLERANCE;
}

int main(int argc, char *argv[])
{
    // input buffer dimensions
    int cols = 1024;
    int rows = 768;
    int fftsize = 8;
    int simd = 8;

    // read the cmd line arguments if any
    for (int i = 1; i < argc; i++) {
        if (strcmp(argv[i], "-cols") == 0)
            cols = atoi(argv[++i]);
        else if (strcmp(argv[i], "-rows") == 0)
            rows = atoi(argv[++i]);
        else if (strcmp(argv[i], "-fft") == 0)
            fftsize = atoi(argv[++i]);
        else if (strcmp(argv[i], "-simd") == 0)
            simd = atoi(argv[++i]);
        else if (strcmp(argv[i], "-h") == 0) {
            cout << "-cols c ... Signal width.       Default " << cols
                 << "\n";
            cout << "-rows r ... Signal height.      Default " << rows
                 << "  (Must be a multiple of FFT length)\n";
            cout << "-fft  l ... FFT length.         Default " << fftsize
                 << "\n";
            cout << "-simd s ... Logical SIMD width. Default " << simd
                 << "\n";
            cout << "-h      ... Display this help.\n";
            cout << endl;
            return 0;
        }
    }

    bool success = true;
    success &= runTest(cols, rows, fftsize, simd);
    cout << (success ? "PASSED\n" : "FAILED\n");
    return !success;
}
