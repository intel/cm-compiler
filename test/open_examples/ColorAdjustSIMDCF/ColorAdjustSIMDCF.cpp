/*
 * Copyright (c) 2017, Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

#include "cm_rt.h"

// Includes bitmap_helpers.h for bitmap file open/save operations.
#include "common/bitmap_helpers.h"

// Includes cm_rt_helpers.h to convert the integer return code returned from
// the CM runtime to a meaningful string message.
#include "common/cm_rt_helpers.h"

// Includes isa_helpers.h to load the ISA file generated by the CM compiler.
#include "common/isa_helpers.h"

#define MIN(X,Y) ((X) < (Y) ? (X) : (Y))
#define MAX(X,Y) ((X) > (Y) ? (X) : (Y))

#include "ColorAdjustSIMDCF.h"

using cm::util::bitmap::BitMap;

#define INDEX_RED    0
#define INDEX_GREEN  1
#define INDEX_BLUE   2
#define SLICE_HEIGHT 8

static void AdjustHueSaturationPixel(unsigned char *src_bmp,
                                     unsigned char *dst_bmp,
                                     int delta_hue,
                                     int delta_saturation,
                                     int *scale_table);

static void AdjustSaturationOnlyPixel(unsigned char *src_bmp,
                                      unsigned char *dst_bmp,
                                      int delta_hue,
                                      int delta_saturation,
                                      int *scale_table);

static void AdjustHueOnlyPixel(unsigned char *src_bmp,
                               unsigned char *dst_bmp,
                               int delta_hue,
                               int delta_saturation,
                               int *scale_table);

void ProcessHnsOnly(unsigned char *src_bmp,
                    unsigned char *dst_bmp,
                    int pixel_per_line,
                    int delta_hue,
                    int delta_saturation,
                    int *scale_table,
                    HueSaturationFuncPtr hls_func_ptr,
                    unsigned char *gray_map);

void ProcessBncOnly(unsigned char *src_bmp,
                    unsigned char *dst_bmp,
                    int pixel_per_line,
                    int delta_hue,
                    int delta_saturation,
                    int *scale_table,
                    HueSaturationFuncPtr hls_func_ptr,
                    unsigned char *gray_map);

void ProcessHnsAndBnc(unsigned char *src_bmp,
                      unsigned char *dst_bmp,
                      int pixel_per_line,
                      int delta_hue,
                      int delta_saturation,
                      int *scale_table,
                      HueSaturationFuncPtr hls_func_ptr,
                      unsigned char *gray_map);

static void CalcBright(DsColorAdjust *option, unsigned char *arbitrary_map);
static void CalcGammaMap(DsColorAdjust *option, unsigned char *arbitrary_map);
static void CalcLevelMap(DsColorAdjust *option, unsigned char *arbitrary_map);
static double CalcInverseGamma(int mid_level);

void AdjustHueSaturationPixel(unsigned char *src_bmp,
                              unsigned char *dst_bmp,
                              int delta_hue,
                              int delta_saturation,
                              int *scale_table) {
    int min = 0, max = 0, mid = 0;
    int min_color = 0, max_color = 0, mid_color = 0;
    int range = 0;
    int brightness = 0;
    int hue = 0;

    int blue = src_bmp[0];
    int green = src_bmp[1];
    int red = src_bmp[2];

    if (red < blue) {
        min = red;
        min_color = INDEX_RED;
        max = blue;
        max_color = INDEX_BLUE;
    } else {
        max = red;
        max_color = INDEX_RED;
        min = blue;
        min_color = INDEX_BLUE;
    }
    if (green < min) {
        mid = min;
        mid_color = min_color;
        min = green;
        min_color = INDEX_GREEN;
    } else if (green > max) {
        mid = max;
        mid_color = max_color;
        max = green;
        max_color = INDEX_GREEN;
    } else {
        mid = green;
        mid_color = INDEX_GREEN;
    }

    range = max - min;
    brightness = (max + min) / 2;

    if (range == 0) {
        dst_bmp[0] = dst_bmp[1] = dst_bmp[2] = max;
        return;
    }

    if (max_color == INDEX_RED) {
        if (min_color == INDEX_GREEN) {
            hue = 436906 + scale_table[range] * (max - mid);
        } else {
            hue = scale_table[range] * (mid - min);
        }
    } else if (max_color == INDEX_GREEN) {
        if (min_color == INDEX_BLUE) {
            hue = 87381 + scale_table[range] * (max - mid);
        } else {
            hue = 174762 + scale_table[range] * (mid - min);
        }
    } else {
        if (min_color == INDEX_RED) {
            hue = 262144 + scale_table[range] * (max - mid);
        } else {
            hue = 349525 + scale_table[range] * (mid - min);
        }
    }

    if (hue < 0)
        hue = 0;
    else if (hue > 524287)
        hue = 524287;

    hue += delta_hue;

    if (brightness <= 127) {
        range += ((2 * brightness * delta_saturation + 128) >> 8);
        range = MIN(range, 2 * brightness);
    } else {
        range += ((2 * (255 - brightness) * delta_saturation + 128) >> 8);
        range = MIN(range, 2 * (255 - brightness));
    }
    range = MAX(range, 0);

    if (range == 0) {
        dst_bmp[0] = (unsigned char)brightness;
        dst_bmp[1] = (unsigned char)brightness;
        dst_bmp[2] = (unsigned char)brightness;
    } else {
        if (hue > 524287)
            hue -= 524288;
        else if (hue < 0)
            hue += 524288;

        int index = (hue * 6) >> 19;
        int color = (hue - index * 87381);

        max = brightness + range / 2;
        min = brightness - range / 2;
        int offset = ((color * range + 43690) * 6) >> 19;

        switch (index) {
        case 1:
            dst_bmp[2] = (unsigned char)(max - offset);
            dst_bmp[1] = (unsigned char)max;
            dst_bmp[0] = (unsigned char)min;
            break;

        case 2:
            dst_bmp[2] = (unsigned char)min;
            dst_bmp[1] = (unsigned char)max;
            dst_bmp[0] = (unsigned char)(min + offset);
            break;

        case 3:
            dst_bmp[2] = (unsigned char)min;
            dst_bmp[1] = (unsigned char)(max - offset);
            dst_bmp[0] = (unsigned char)max;
            break;

        case 4:
            dst_bmp[2] = (unsigned char)(min + offset);
            dst_bmp[1] = (unsigned char)min;
            dst_bmp[0] = (unsigned char)max;
            break;

        case 5:
            dst_bmp[2] = (unsigned char)max;
            dst_bmp[1] = (unsigned char)min;
            dst_bmp[0] = (unsigned char)(max - offset);
            break;

        default:
            dst_bmp[2] = (unsigned char)max;
            dst_bmp[1] = (unsigned char)(min + offset);
            dst_bmp[0] = (unsigned char)min;
        }
    }
}

void AdjustSaturationOnlyPixel(unsigned char *src_bmp,
                               unsigned char *dst_bmp,
                               int delta_hue,
                               int delta_saturation,
                               int *scale_table) {
    int min = 0, max = 0, mid = 0;
    int min_color = 0, max_color = 0, mid_color = 0;
    int range = 0;
    int brightness = 0;

    int blue = src_bmp[0];
    int green = src_bmp[1];
    int red = src_bmp[2];

    if (red < blue) {
        min = red;
        min_color = INDEX_RED;
        max = blue;
        max_color = INDEX_BLUE;
    } else {
        max = red;
        max_color = INDEX_RED;
        min = blue;
        min_color = INDEX_BLUE;
    }
    if (green < min) {
        mid = min;
        mid_color = min_color;
        min = green;
        min_color = INDEX_GREEN;
    } else if (green > max) {
        mid = max;
        mid_color = max_color;
        max = green;
        max_color = INDEX_GREEN;
    } else {
        mid = green;
        mid_color = INDEX_GREEN;
    }

    range = max - min;
    brightness = (max + min) / 2;

    if (range == 0) {
        dst_bmp[0] = dst_bmp[1] = dst_bmp[2] = max;
        return;
    }
    int new_range = 0;
    if (brightness <= 127) {
        new_range = range +
                  ((2 * brightness * delta_saturation + 128) >> 8);
        new_range = MIN(new_range, 2 * brightness);
    } else {
        new_range = range +
                  ((2 * (255 - brightness) * delta_saturation + 128) >> 8);
        new_range = MIN(new_range, 2 * (255 - brightness));
    }

    if (new_range <= 0) {
        dst_bmp[0] = (unsigned char)brightness;
        dst_bmp[1] = (unsigned char)brightness;
        dst_bmp[2] = (unsigned char)brightness;
        return;
    }

    int new_max = brightness + new_range / 2;
    int new_min = brightness - new_range / 2;
    int color = 0;

    if (max_color == INDEX_RED) {
        if (min_color == INDEX_GREEN) {
            color = scale_table[range] * (max - mid);
            int offset = ((color * new_range + 43690) * 6) >> 19;
            dst_bmp[0] = (unsigned char)(new_max - offset);
            dst_bmp[1] = (unsigned char)new_min;
            dst_bmp[2] = (unsigned char)new_max;
        } else {
            color = scale_table[range] * (mid - min);
            int offset = ((color * new_range + 43690) * 6) >> 19;
            dst_bmp[0] = (unsigned char)new_min;
            dst_bmp[1] = (unsigned char)(new_min + offset);
            dst_bmp[2] = (unsigned char)new_max;
        }
    } else if (max_color == INDEX_GREEN) {
        if (min_color == INDEX_BLUE) {
            color = scale_table[range] * (max - mid);
            int offset = ((color * new_range + 43690) * 6) >> 19;
            dst_bmp[0] = (unsigned char)new_min;
            dst_bmp[1] = (unsigned char)new_max;
            dst_bmp[2] = (unsigned char)(new_max - offset);
        } else {
            color = scale_table[range] * (mid - min);
            int offset = ((color * new_range + 43690) * 6) >> 19;
            dst_bmp[0] = (unsigned char)(new_min + offset);
            dst_bmp[1] = (unsigned char)new_max;
            dst_bmp[2] = (unsigned char)new_min;
        }
    } else {
        if (min_color == INDEX_RED) {
            color = scale_table[range] * (max - mid);
            int offset = ((color * new_range + 43690) * 6) >> 19;
            dst_bmp[0] = (unsigned char)new_max;
            dst_bmp[1] = (unsigned char)(new_max - offset);
            dst_bmp[2] = (unsigned char)new_min;
        } else {
            color = scale_table[range] * (mid - min);
            int offset = ((color * new_range + 43690) * 6) >> 19;
            dst_bmp[0] = (unsigned char)new_max;
            dst_bmp[1] = (unsigned char)new_min;
            dst_bmp[2] = (unsigned char)(new_min + offset);
        }
    }
}

void AdjustHueOnlyPixel(unsigned char *src_bmp,
                        unsigned char *dst_bmp,
                        int delta_hue,
                        int delta_saturation,
                        int *scale_table) {
    int min = 0, max = 0, mid = 0;
    int min_color = 0, max_color = 0, mid_color = 0;
    int range = 0;
    int hue = 0;

    int blue = src_bmp[0];
    int green = src_bmp[1];
    int red = src_bmp[2];

    if (red < blue) {
        min = red;
        min_color = INDEX_RED;
        max = blue;
        max_color = INDEX_BLUE;
    } else {
        max = red;
        max_color = INDEX_RED;
        min = blue;
        min_color = INDEX_BLUE;
    }
    if (green < min) {
        mid = min;
        mid_color = min_color;
        min = green;
        min_color = INDEX_GREEN;
    } else if (green > max) {
        mid = max;
        mid_color = max_color;
        max = green;
        max_color = INDEX_GREEN;
    } else {
        mid = green;
        mid_color = INDEX_GREEN;
    }

    range = max - min;

    if (range == 0) {
       dst_bmp[0] = dst_bmp[1] = dst_bmp[2] = max;
        return;
    }

    if (max_color == INDEX_RED) {
        if (min_color == INDEX_GREEN) {
            hue = 436906 + scale_table[range] * (max - mid);
        } else {
            hue = scale_table[range] * (mid - min);
        }
    } else if (max_color == INDEX_GREEN) {
        if (min_color == INDEX_BLUE) {
            hue = 87381 + scale_table[range] * (max - mid);
        } else {
            hue = 174762 + scale_table[range] * (mid - min);
        }
    } else {
        if (min_color == INDEX_RED) {
            hue = 262144 + scale_table[range] * (max - mid);
        } else {
            hue = 349525 + scale_table[range] * (mid - min);
        }
    }
    if (hue < 0)
        hue = 0;
    else if (hue > 524287)
        hue = 524287;

    hue += delta_hue;

    if (hue > 524287)
        hue -= 524288;
    else if (hue < 0)
        hue += 524288;

    int index = (hue * 6) >> 19;
    int color = (hue - index * 87381);

    int offset = ((color * range + 43690) * 6) >> 19;

    switch (index) {
    case 1:
        dst_bmp[0] = (unsigned char)min;
        dst_bmp[1] = (unsigned char)max;
        dst_bmp[2] = (unsigned char)(max - offset);
        break;

    case 2:
        dst_bmp[0] = (unsigned char)(min + offset);
        dst_bmp[1] = (unsigned char)max;
        dst_bmp[2] = (unsigned char)min;
        break;

    case 3:
        dst_bmp[0] = (unsigned char)max;
        dst_bmp[1] = (unsigned char)(max - offset);
        dst_bmp[2] = (unsigned char)min;
        break;

    case 4:
        dst_bmp[0] = (unsigned char)max;
        dst_bmp[1] = (unsigned char)min;
        dst_bmp[2] = (unsigned char)(min + offset);
        break;

    case 5:
        dst_bmp[0] = (unsigned char)(max - offset);
        dst_bmp[1] = (unsigned char)min;
        dst_bmp[2] = (unsigned char)max;
        break;

    default:
        dst_bmp[0] = (unsigned char)min;
        dst_bmp[1] = (unsigned char)(min + offset);
        dst_bmp[2] = (unsigned char)max;
    }
}

void ProcessHnsOnly(unsigned char *src_bmp,
                    unsigned char *dst_bmp,
                    int pixel_per_line,
                    int delta_hue,
                    int delta_saturation,
                    int *scale_table,
                    HueSaturationFuncPtr hls_func_ptr,
                    unsigned char *gray_map) {
    for (int pixel = 0;
         pixel < pixel_per_line;
         pixel++, src_bmp += 3, dst_bmp += 3) {
        hls_func_ptr(src_bmp,
                     dst_bmp,
                     delta_hue,
                     delta_saturation,
                     scale_table);
    }
}

void ProcessBncOnly(unsigned char *src_bmp,
                    unsigned char *dst_bmp,
                    int pixel_per_line,
                    int delta_hue,
                    int delta_saturation,
                    int *scale_table,
                    HueSaturationFuncPtr hls_func_ptr,
                    unsigned char *gray_map) {
    unsigned char *red_map = gray_map;
    unsigned char *green_map = gray_map + 256;
    unsigned char *blue_map = gray_map + 512;

    for (int nPixel = 0;
         nPixel < pixel_per_line;
         nPixel++, src_bmp += 3, dst_bmp += 3) {
        dst_bmp[0] = blue_map[src_bmp[0]];
        dst_bmp[1] = green_map[src_bmp[1]];
        dst_bmp[2] = red_map[src_bmp[2]];
    }
}

void ProcessHnsAndBnc(unsigned char *src_bmp,
                      unsigned char *dst_bmp,
                      int pixel_per_line,
                      int delta_hue,
                      int delta_saturation,
                      int *scale_table,
                      HueSaturationFuncPtr hls_func_ptr,
                      unsigned char *gray_map) {
    unsigned char *red_map = gray_map;
    unsigned char *green_map = gray_map + 256;
    unsigned char *blue_map = gray_map + 512;

    unsigned char rgb[3];

    for (int pixel = 0;
         pixel < pixel_per_line;
         pixel++, src_bmp += 3, dst_bmp += 3) {
        hls_func_ptr(src_bmp,
                     rgb,
                     delta_hue,
                     delta_saturation,
                     scale_table);

        dst_bmp[0] = blue_map[rgb[0]];
        dst_bmp[1] = green_map[rgb[1]];
        dst_bmp[2] = red_map[rgb[2]];
    }
}

static void CalcBright(DsColorAdjust *option,
                       unsigned char *arbitrary_map) {
    int x1 = 0, y1 = 0;
    int x2 = 255, y2 = 255, dx = 255, dy = 255;
    int bright = 0, contrast = 0, type = 0;

    type = option->type;
    for (int i = 0; i < 4; i++) {
        option->type = i;
        bright = option->scroll_value1[i];
        contrast = option->scroll_value2[i];

        bright = bright * 128 / 100;
        if (bright == -128)
            bright++;
        if (bright == 128)
            bright--;
        contrast = contrast * 128 / 100;
        if (contrast == -128)
            contrast++;
        if (contrast == 128)
            contrast--;

        if (contrast >= 0) {
            x1 += contrast;
            x2 -= contrast;
            dx -= 2 * contrast;
            x1 -= bright;
            x2 -= bright;
            if (x1 < 0) {
                y1 += (-x1 * dy + (dx >> 1)) / dx;
                x1 = 0;
            }
            if (x2 > 255) {
                y2 -= ((x2 - 255) * dy + (dx >> 1)) / dx;
                x2 = 255;
            }
        } else {
            y1 -= contrast;
            y2 += contrast;
            dy -= 2 * contrast;
            y1 += bright;
            y2 += bright;
            if (y1 < 0) {
                x1 += (-y1 * dx + (dy >> 1)) / dy;
                y1 = 0;
            }
            if (y2 > 255) {
                x2 -= (int)((y2 - 255) * dx + (dy >> 1)) / dy;
                y2 = 255;
            }
        }
        option->adjust_value[i][0] = x1;
        option->adjust_value[i][1] = x2;
        option->adjust_value[i][2] = y1;
        option->adjust_value[i][3] = y2;
        CalcGammaMap(option, arbitrary_map);
        CalcLevelMap(option, arbitrary_map);
    }
    option->type = type;
}

static void CalcGammaMap(DsColorAdjust *option,
                         unsigned char *arbitrary_map) {
    double output = 0.0;

    if (!arbitrary_map)
        return;

    unsigned char *map = arbitrary_map + (option->type + 4) * 256;
    double gamma = option->inverse_gamma[option->type];

    if (gamma == 1.0) {
        for (int i = 0; i < 256; i++)
            *map++ = (unsigned int)i;
    } else {
        for (int i = 0; i < 256; i++) {
            output = pow((double)i / 255.0, gamma);
            *map++ = (unsigned int)(output * 255.0);
        }
    }
}

static void CalcLevelMap(DsColorAdjust *option,
                         unsigned char *arbitrary_map) {
    unsigned short step = 0, step_rem = 0;
    unsigned short x = 0, y = 0;

    if (!arbitrary_map)
        return;

    unsigned char *map = arbitrary_map + option->type * 256;
    unsigned char *gamma = map + 1024;

    unsigned short x1 = (unsigned short)option->adjust_value[option->type][0];
    unsigned short x2 = (unsigned short)option->adjust_value[option->type][1];
    unsigned short y1 = (unsigned short)option->adjust_value[option->type][2];
    unsigned short y2 = (unsigned short)option->adjust_value[option->type][3];
    for (int i = 0; i < x1; i++, map++)
        *map = (unsigned int)y1;

    unsigned short dx = x2 - x1;
    unsigned short dy = y2 - y1;
    if (dx == 0) {
        step = 0;
        step_rem = 0;
    } else {
        step = 255 / dx;
        step_rem = 255 % dx;
    }
    unsigned short x_rem = dx >> 1;

    for (int i = x1; i <= x2; i++) {
        y = gamma[x];
        *map++ = (unsigned int)(((y * dy + 127) / 255) + y1);
        x += step;
        x_rem += step_rem;
        if (x_rem > dx) {
            x++;
            x_rem -= dx;
        }
    }

    x2++;
    for (int i = x2; i < 256; i++, map++)
        *map = (unsigned int)y2;
}

static double CalcInverseGamma(int mid_level) {
    mid_level = 255 - mid_level;
    if (mid_level == 127)
        return 1.0;
    return log(0.5) / log((double)mid_level / 255.0);
}

ColorAdjust::ColorAdjust() {
    scale_table[0] = 1;
    for (int i = 1; i < 256; i++) {
        scale_table[i] = 87381 / i;
    }
    bnc_table_init = false;
}

ColorAdjust::~ColorAdjust() {}

int ColorAdjust::GetDefaultOption(int key, void *option) {
    DsColorAdjust ds_color_adjust_def1 = {
        sizeof(DsColorAdjust), 0,
        10, 10,
        0,
        0,  0,  0,  0, 0,
        0,  0,  0,  0, 0,
        0,  0,  0,  0, 0,
        100,100,100,100, 0,
        0, 255, 0, 255, 0,
        0,  0,  0,  0, 0,
        0,  0,  0,  0, 0,
        0,  0,  0,  0, 0,
        1.0,1.0,1.0,1.0,1.0
    };

    DsColorAdjust ds_color_adjust_def2 = {
        sizeof(DsColorAdjust), 0,
        0, 0,
        0,
        0, 0,  0,  0, 0,
        0,  0,  0,  0, 0,
        0,  0,  0,  0, 0,
        128,128,128,128, 0,
        0, 255, 0, 255, 0,
        0,  0,  0,  0, 0,
        0,  0,  0,  0, 0,
        0,  0,  0,  0, 0,
        1.0,1.0,1.0,1.0,1.0
    };

    *(DsColorAdjust*)option = (key == 0)?
        ds_color_adjust_def1 : ds_color_adjust_def2;

    return true;
}

int ColorAdjust::ProcessPic(bool do_hns,
                            bool do_bnc,
                            unsigned char *src_bmp,
                            unsigned char *dst_bmp,
                            int pixel_per_line,
                            int lines,
                            int bytes_per_pixel,
                            int row_bytes,
                            void *v_option,
                            void *inst_data) {
    int hue = 0, sat = 0, ret = 1;
    DsColorAdjust *option = (DsColorAdjust *)v_option;
    DsInfo *ds_info = (DsInfo *)inst_data;

    HueSaturationFuncPtr adjust_hue_saturation_pixel = nullptr;

    if (do_hns) {
        hue = option->hue;
        hue = hue * 524288 / 360;
        sat = option->sat;
        sat = (sat * 255 + 50) / 100;

        if (sat == 0)
            adjust_hue_saturation_pixel = AdjustHueOnlyPixel;
        else if (hue == 0)
            adjust_hue_saturation_pixel = AdjustSaturationOnlyPixel;
        else
            adjust_hue_saturation_pixel = AdjustHueSaturationPixel;
    }

    if (do_bnc) {
        if (!bnc_table_init
            || current_option.adjust_gamma[option->type]
               != option->adjust_gamma[option->type]
            || current_option.scroll_value1[option->type]
               != option->scroll_value1[option->type]
            || current_option.scroll_value2[option->type]
               != option->scroll_value2[option->type]) {
            unsigned char *arbitrary_map = nullptr;
            unsigned char *gray_map = nullptr;
            unsigned char *map = nullptr;
            unsigned char *map_dst = nullptr;

            for (int i = 0; i < 4; i++) {
                option->adjust_gamma[i] =
                   MAX(1, MIN(option->adjust_gamma[i], 254));
                option->inverse_gamma[i] =
                    CalcInverseGamma(option->adjust_gamma[i]);
            }

            map = arbitrary_map = ds_info->arbitrary_map;
            for (int i = 0; i < 256; i++, map++)
                *map = (unsigned int)i;

            map = arbitrary_map + 256;
            for (int i = 0; i < 7; i++, map += 256)
                memcpy(map, arbitrary_map, 256);

            map = gray_map = ds_info->gray_map;
            for (int i = 0; i < 256; i++, map++)
                *map = (unsigned int)i;
            map = gray_map + 256;
            for (int i = 0; i < 3; i++, map += 256)
                memcpy(map, gray_map, 256);

            CalcBright(option, arbitrary_map);
            map = arbitrary_map + 256;
            map_dst = gray_map;
            for (int i = 0; i < 768; i++)
                *map_dst++ = arbitrary_map[*map++];

            memcpy(&current_option, option, sizeof(DsColorAdjust));
            bnc_table_init = true;
        }
    }

    ProcessPixeFuncPtr pixel_func_ptr;

    if (do_hns && do_bnc)
        pixel_func_ptr = ProcessHnsAndBnc;
    else if (do_hns)
        pixel_func_ptr = ProcessHnsOnly;
    else if (do_bnc)
        pixel_func_ptr = ProcessBncOnly;

    for (int j = 0; j < lines; j++) {
        pixel_func_ptr(src_bmp,
                       dst_bmp,
                       pixel_per_line,
                       hue,
                       sat,
                       scale_table,
                       adjust_hue_saturation_pixel,
                       ds_info->gray_map);
        src_bmp += row_bytes;
        dst_bmp += row_bytes;
    }
    return ret;
}

int ColorAdjust::ProcessPicCm(bool do_hns,
                              bool do_bnc,
                              unsigned char *src_bmp,
                              unsigned char *dst_bmp,
                              int width,
                              int height,
                              void *v_option,
                              void *inst_data) {
    int hue = 0, sat = 0, ret = 1;
    DsColorAdjust *option  = (DsColorAdjust *)v_option;
    DsInfo *ds_info = (DsInfo *)inst_data;

    // Allocates system memory to convert image format between
    // RGB and RGBA.
    unsigned char *rgba_src = new unsigned char[width * height * 4];
    unsigned char *rgba_dst = new unsigned char[width * height * 4];

    // Converts image format from RGB to RGBA.
    // Copies the RGB values from the image, set the 4th byte with zero.
    unsigned char *tmp = src_bmp;
    unsigned char *tmp2 = rgba_src;
    for (int i = 0; i < width * height; i++) {
        tmp2[i * 4] = tmp[i * 3];
        tmp2[i * 4 + 1] = tmp[i * 3 + 1];
        tmp2[i * 4 + 2] = tmp[i * 3 + 2];
        tmp2[i * 4 + 3] = 0;
    }

    // Creates a CmDevice from scratch.
    // Param device: pointer to the CmDevice object.
    // Param version: CM API version supported by the runtime library.
    CmDevice *device = nullptr;
    unsigned int version = 0;
    cm_result_check(::CreateCmDevice(device, version));

    // Creates input surface with given width and height in pixels and format.
    // Sets surface format as CM_SURFACE_FORMAT_A8R8G8B8. For this format, each
    // pixel occupies 32 bits.
    CmSurface2D *input_surface = nullptr;
    cm_result_check(device->CreateSurface2D(width,
                                            height,
                                            CM_SURFACE_FORMAT_A8R8G8B8,
                                            input_surface));

    // Creates the output surface. The width, height and format is the same as
    // the input surface.
    CmSurface2D *output_surface = nullptr;
    cm_result_check(device->CreateSurface2D(width,
                                            height,
                                            CM_SURFACE_FORMAT_A8R8G8B8,
                                            output_surface));

    // Creates the temporary surface. The width, height and format is the same
    // as the input surface.
    CmSurface2D *temp_surface = nullptr;
    cm_result_check(device->CreateSurface2D(width,
                                            height,
                                            CM_SURFACE_FORMAT_A8R8G8B8,
                                            temp_surface));

    // When a surface is created by the CmDevice a SurfaceIndex object is
    // created. This object contains a unique index value that is mapped to the
    // surface.
    // Gets the input surface index.
    SurfaceIndex *input_surface_idx = nullptr;
    cm_result_check(input_surface->GetIndex(input_surface_idx));

    // Gets the output surface index.
    SurfaceIndex *output_surface_idx = nullptr;
    cm_result_check(output_surface->GetIndex(output_surface_idx));

    // Gets the temporary surface index.
    SurfaceIndex *temp_surface_idx = nullptr;
    cm_result_check(temp_surface->GetIndex(temp_surface_idx));

    // The file ColorAdjustSIMDCF_genx.isa is generated when the kernels in the
    // file ColorAdjustSIMDCF_genx.cpp are compiled by the CM compiler.
    // Reads in the virtual ISA from "ColorAdjustSIMDCF_genx.isa" to the code
    // buffer.
    std::string isa_code = cm::util::isa::loadFile("ColorAdjustSIMDCF_genx.isa");
    if (isa_code.size() == 0) {
        std::cerr << "Error: empty ISA binary.\n";
        std::exit(1);
    }

    // Creates a CmProgram object consisting of the kernels loaded from the code
    // buffer.
    // Param isa_code.data(): Pointer to the code buffer containing the virtual
    // ISA.
    // Param isa_code.size(): Size in bytes of the code buffer containing the
    // virtual ISA.
    CmProgram *program = nullptr;
    cm_result_check(device->LoadProgram(const_cast<char *>(isa_code.data()),
                                        isa_code.size(),
                                        program,
                                        "-nolocalra"));

    // Creates a task queue.
    // The CmQueue is an in-order queue. Tasks get executed according to the
    // order they are enqueued. The next task does not start execution until the
    // current task finishes.
    CmQueue *cmd_queue = nullptr;
    cm_result_check(device->CreateQueue(cmd_queue));

    // Creates the kernel.
    // Param program: CM Program from which the kernel is created.
    // Param "AdjustHueOnly": The kernel name which should be no more than 256
    // bytes including the null terminator.
    CmKernel *adjust_hue_only_kernel = nullptr;
    cm_result_check(device->CreateKernel(program,
                                         "AdjustHueOnly",
                                         adjust_hue_only_kernel));

    // Creates the kernel.
    // Param program: CM Program from which the kernel is created.
    // Param "AdjustSaturationOnly": The kernel name which should be no more
    // than 256 bytes including the null terminator.
    CmKernel *adjust_saturation_only_kernel = nullptr;
    cm_result_check(device->CreateKernel(program,
                                         "AdjustSaturationOnly",
                                         adjust_saturation_only_kernel));

    // Creates the kernel.
    // Param program: CM Program from which the kernel is created.
    // Param "AdjustHueSaturation": The kernel name which should be no more
    // than 256 bytes including the null terminator.
    CmKernel *adjust_hue_saturation_kernel = nullptr;
    cm_result_check(device->CreateKernel(program,
                                         "AdjustHueSaturation",
                                         adjust_hue_saturation_kernel));

    // Creates the kernel.
    // Param program: CM Program from which the kernel is created.
    // Param "ProcessBNC": The kernel name which should be no more than 256
    // bytes including the null terminator.
    CmKernel *process_bnc_kernel = nullptr;
    cm_result_check(device->CreateKernel(program,
                                         "ProcessBNC",
                                         process_bnc_kernel));

    // Each thread processes a 8 × width slice.
    // The thread height is equal to input image height divided by 8.
    int thread_height = height / SLICE_HEIGHT;

    CmKernel *adjust_kernel = nullptr;
    CmThreadSpace *thread_space = nullptr;
    if (do_hns) {
        hue = option->hue;
        hue = hue * 524288 / 360;
        sat = option->sat;
        sat = (sat * 255 + 50) / 100;

        if (sat == 0) {
            adjust_kernel = adjust_hue_only_kernel;
        } else if (hue == 0) {
            adjust_kernel = adjust_saturation_only_kernel;
        } else {
            adjust_kernel = adjust_hue_saturation_kernel;
        }

        // Sets a per kernel argument.
        // Sets input surface index as the first argument of kernel.
        // Sets temporary surface index as the second argument of kernel.
        // Sets hue, sat, width as the third, the fourth, the fifth argument
        // of kernel.
        cm_result_check(adjust_kernel->SetKernelArg(0,
                                                   sizeof(SurfaceIndex),
                                                   input_surface_idx));
        cm_result_check(adjust_kernel->SetKernelArg(1,
                                                   sizeof(SurfaceIndex),
                                                   temp_surface_idx));
        cm_result_check(adjust_kernel->SetKernelArg(2, 4, &hue));
        cm_result_check(adjust_kernel->SetKernelArg(3, 4, &sat));
        cm_result_check(adjust_kernel->SetKernelArg(4, 4, &width));

        // Creates a CmThreadSpace object.
        // There are two usage models for the thread space. One is to define the
        // dependency between threads to run in the GPU. The other is to define a
        // thread space where each thread can get a pair of coordinates during
        // kernel execution. For this example, we use the latter usage model.
        cm_result_check(device->CreateThreadSpace(1,
                                                  thread_height,
                                                  thread_space));

        // Creates a CmTask object.
        // The CmTask object is a container for CmKernel pointers. It is used to
        // enqueue the kernels for execution.
        CmTask *task = nullptr;
        cm_result_check(device->CreateTask(task));

        // Adds a CmKernel pointer to CmTask.
        // This task has one kernel.
        cm_result_check(task->AddKernel(adjust_kernel));

        // Copies system memory content to the input surface using the CPU.
        // The system memory content is the data of the input image. The size
        // of data copied is the size of data in the surface.
        cm_result_check(input_surface->WriteSurface(rgba_src, nullptr));

        // Launches the task on the GPU. Enqueue is a non-blocking call, i.e.
        // the function returns immediately without waiting for the GPU to
        // start or finish execution of the task. The runtime will query the
        // HW status. If the hardware is not busy, the runtime will submit the
        // task to the driver/HW; otherwise, the runtime will submit the task
        // to the driver/HW at another time.
        // An event, "sync_event0", is created to track the status of the task.
        CmEvent *sync_event0 = nullptr;
        cm_result_check(cmd_queue->Enqueue(task,
                                           sync_event0,
                                           thread_space));

        // Destroys a CmTask object.
        // CmTask will be destroyed when CmDevice is destroyed.
        // Here, the application destroys the CmTask object by itself.
        cm_result_check(device->DestroyTask(task));

        // Waits for the task associated with the sync_event0 finishing
        // execution on the GPU.
        unsigned long time_out = -1;
        cm_result_check(sync_event0->WaitForTaskFinished(time_out));

        // Queries the execution time of a task in the unit of nanoseconds.
        // The execution time is measured from the time the task started
        // execution in the GPU to the time when the task finished execution.
        UINT64 execution_time = 0;
        cm_result_check(sync_event0->GetExecutionTime(execution_time));
        printf("\n\nKernel pAdjustKernel execution time is %lld nanoseconds,"
               " %4.2f ms\n",
               execution_time,
               ((double)execution_time/1000000.00));
    }

    if (do_bnc) {
        if (!bnc_table_init
            || current_option.adjust_gamma[option->type]
                != option->adjust_gamma[option->type]
            || current_option.scroll_value1[option->type]
                != option->scroll_value1[option->type]
            || current_option.scroll_value2[option->type]
                != option->scroll_value2[option->type]) {
            unsigned char *arbitrary_map = nullptr;
            unsigned char *gray_map = nullptr;
            unsigned char *map = nullptr;
            unsigned char *map_dst = nullptr;

            for (int i = 0; i < 4; i++) {
                option->adjust_gamma[i] =
                    MAX(1, MIN(option->adjust_gamma[i], 254));
                option->inverse_gamma[i] =
                    CalcInverseGamma(option->adjust_gamma[i]);
            }

            map = arbitrary_map = ds_info->arbitrary_map;
            for (int i = 0; i < 256; i++, map++)
                *map = (unsigned char)i;

            map = arbitrary_map + 256;
            for (int i = 0; i < 7; i++, map += 256)
                memcpy(map, arbitrary_map, 256);

            map = gray_map = ds_info->gray_map;
            for (int i = 0; i < 256; i++, map++)
                *map = (unsigned char)i;
            map = gray_map + 256;
            for (int i = 0; i < 3; i++, map += 256)
                memcpy(map, gray_map, 256);

            CalcBright(option, arbitrary_map);
            map = arbitrary_map + 256;
            map_dst = gray_map;
            for (int i = 0; i < 768; i++)
                *map_dst++ = arbitrary_map[*map++];

            memcpy(&current_option, option, sizeof(DsColorAdjust));
            bnc_table_init = true;
        }

        unsigned int *gray_map = new unsigned int[1028 * 4];
        for (int i = 0; i < 1028; i++) {
            gray_map[i] = ds_info->gray_map[i];
        }

        // Creates a CmBuffer with the specified size in bytes.
        // CmBuffer represents a 1D surface in video memory.
        CmBuffer *graymap_surface = nullptr;
        cm_result_check(device->CreateBuffer(1028 * 4, graymap_surface));

        // When a CmBuffer is created by the CmDevice a SurfaceIndex object is
        // created. This object contains a unique index value that is mapped
        // to the CmBuffer.
        // Gets the CmBuffer index.
        SurfaceIndex *graymap_surface_idx = nullptr;
        cm_result_check(graymap_surface->GetIndex(graymap_surface_idx));

        // Copies system memory content to the CmBuffer using the CPU. The
        // system memory content is the data in the gray_map. The size of
        // data copied is the size of data in the CmBuffer.
        cm_result_check(graymap_surface->WriteSurface((unsigned char *)gray_map,
                                                      nullptr));

        // Sets a per kernel argument.
        if (do_hns) {
            // Sets temporary surface index as the first argument of kernel.
            cm_result_check(process_bnc_kernel->SetKernelArg(0,
                                                             sizeof(SurfaceIndex),
                                                             temp_surface_idx));
        } else {
            // Sets input surface index as the first argument of kernel.
            cm_result_check(process_bnc_kernel->SetKernelArg(0,
                                                             sizeof(SurfaceIndex),
                                                             input_surface_idx));

            // Copies system memory content to the input surface using the CPU.
            // The system memory content is the data of the input image. The
            // size of data copied is the size of data in the surface.
            cm_result_check(input_surface->WriteSurface(rgba_src,
                                                        nullptr));
        }

        // Sets output surface index as the second argument of kernel.
        cm_result_check(process_bnc_kernel->SetKernelArg(1,
                                                         sizeof(SurfaceIndex),
                                                         output_surface_idx));

        // Sets CmBuffer index and image width as the third and the fourth
        // argument of kernel.
        cm_result_check(process_bnc_kernel->SetKernelArg(2,
                                                         sizeof(SurfaceIndex),
                                                         graymap_surface_idx));
        cm_result_check(process_bnc_kernel->SetKernelArg(3,
                                                         4,
                                                         &width));

        // Creates a CmThreadSpace object.
        // There are two usage models for the thread space. One is to define the
        // dependency between threads to run in the GPU. The other is to define a
        // thread space where each thread can get a pair of coordinates during
        // kernel execution. For this example, we use the latter usage model.
        cm_result_check(device->CreateThreadSpace(1,
                                                  thread_height,
                                                  thread_space));

        // Creates a CmTask object.
        // The CmTask object is a container for CmKernel pointers. It is used to
        // enqueue the kernels for execution.
        CmTask *task = nullptr;
        cm_result_check(device->CreateTask(task));

        // Adds a CmKernel pointer to CmTask.
        // This task has one kernel.
        cm_result_check(task->AddKernel(process_bnc_kernel));

        // Launches the task on the GPU. Enqueue is a non-blocking call, i.e.
        // the function returns immediately without waiting for the GPU to
        // start or finish execution of the task. The runtime will query the
        // HW status. If the hardware is not busy, the runtime will submit the
        // task to the driver/HW; otherwise, the runtime will submit the task
        // to the driver/HW at another time.
        // An event, "sync_event1", is created to track the status of the task.
        CmEvent *sync_event1 = nullptr;
        cm_result_check(cmd_queue->Enqueue(task,
                                           sync_event1,
                                           thread_space));

        // Destroys a CmTask object.
        // CmTask will be destroyed when CmDevice is destroyed.
        // Here, the application destroys the CmTask object by itself.
        cm_result_check(device->DestroyTask(task));

        // Waits for the task associated with the sync_event1 finishing
        // execution on the GPU.
        unsigned long time_out = -1;
        cm_result_check(sync_event1->WaitForTaskFinished(time_out));

        // Queries the execution time of a task in the unit of nanoseconds.
        // The execution time is measured from the time the task started
        // execution in the GPU to the time when the task finished execution.
        UINT64 execution_time = 0;
        cm_result_check(sync_event1->GetExecutionTime(execution_time));
        printf("\n\nKernel process_bnc_kernel execution time is %lld nanoseconds,"
               " %4.2f ms\n",
               execution_time,
               ((double)execution_time/1000000.00));

        // Reads the output surface content to the system memory using the CPU.
        // The size of data copied is the size of data in Surface.
        // It is a blocking call. The function will not return until the copy
        // operation is completed.
        // The dependent event "sync_event" ensures that the reading of the
        // surface will not happen until its state becomes CM_STATUS_FINISHED.
        cm_result_check(output_surface->ReadSurface(rgba_dst, nullptr));

        delete[] gray_map;
    } else {
        cm_result_check(temp_surface->ReadSurface(rgba_dst, nullptr));
    }

    // Converts image format from RGBA to RGB.
    tmp = dst_bmp;
    tmp2 = rgba_dst;
    for (int i = 0; i < width * height; i++) {
        tmp[i * 3] = tmp2[i * 4];
        tmp[i * 3 + 1] = tmp2[i * 4 + 1];
        tmp[i * 3 + 2] = tmp2[i * 4 + 2];
    }

    // Destroys the CmDevice.
    // Also destroys surfaces, kernels, tasks, thread spaces, and queues that
    // were created using this device instance that have not explicitly been
    // destroyed by calling the respective destroy functions.
    cm_result_check(::DestroyCmDevice(device));

    // Frees memory.
    delete[] rgba_src;
    delete[] rgba_dst;

    return ret;
}

int main(int argc, char *argv[]) {
    // Loads an input image named "riverbed_1.bmp".
    auto input_image = BitMap::load("riverbed_1.bmp");

    // Gets the width and height of the input image.
    unsigned int width = input_image.getWidth();
    unsigned int height = input_image.getHeight();

    // Checks the value of width and height of the image.
    // Only images with width a multiple of 16 are supported.
    // Only images with height a multiple of 8 are supported.
    if ((width & 15) || (height & 7)) {
        printf("Only images with width and height a multiple of "
               "16 and 8 are supported\n");
        return 3;
    }

    // Copies input image to output except for the data.
    auto output_image = input_image;

    // Sets image size in bytes. There are a total of width*height pixels and
    // each pixel occupies (out.getBPP()/8) bytes.
    unsigned int img_size = width * height * output_image.getBPP() / 8;

    // Sets output to blank image.
    output_image.setData(new unsigned char[img_size]);

    unsigned char *src_bmp = new unsigned char[width * height * 3];
    unsigned char *dst_bmp  = new unsigned char[width * height * 3];
    unsigned char *src_bmp_cm = new unsigned char[width * height * 3];
    unsigned char *dst_bmp_cm = new unsigned char[width * height * 3];

    memcpy(src_bmp, input_image.getData(), width * 3 * height);
    memcpy(src_bmp_cm, src_bmp, width * 3 * height);
    memset(dst_bmp, 0, width * 3 * height);
    memset(dst_bmp_cm, 0, width * 3 * height);

    ColorAdjust color_adjust;
    DsColorAdjust color_adjust_option;
    color_adjust.GetDefaultOption(0, (void*)&color_adjust_option);

    unsigned long size_table = (height + 1) * sizeof(unsigned char *);
    unsigned long size = sizeof(DsInfo) + (size_table * 2) + 2056 + 1028;
    DsInfo *ds_info = new DsInfo[size];
    ds_info->in_table = (unsigned char *)(ds_info + 1);
    ds_info->out_table = (unsigned char *)((unsigned char *)(ds_info + 1)
        + size_table * 1);
    ds_info->arbitrary_map = (unsigned char *)(ds_info + 1)
        + size_table * 2;
    ds_info->gray_map = ds_info->arbitrary_map + 2056;

    bool do_hns = false;
    bool do_bnc = false;
    if (color_adjust_option.hue != 0 || color_adjust_option.sat != 0)
        do_hns = true;
    if (color_adjust_option.scroll_value1[color_adjust_option.type] != 0
        || color_adjust_option.scroll_value2[color_adjust_option.type]
        || color_adjust_option.adjust_gamma[color_adjust_option.type] != 128)
        do_bnc = true;

    unsigned int bytes_per_pixel = 3;
    unsigned int row_bytes = (width * bytes_per_pixel + 3) & ~3;

    if (!do_hns && !do_bnc) {
        int total_bytes = height * row_bytes;
        memcpy(dst_bmp, src_bmp, total_bytes);
    } else {
        color_adjust.ProcessPic(do_hns,
                                do_bnc,
                                src_bmp,
                                dst_bmp,
                                width,
                                height,
                                bytes_per_pixel,
                                row_bytes,
                                &color_adjust_option,
                                ds_info);
    }

    if (!do_hns && !do_bnc) {
        int total_bytes = height * row_bytes;
        memcpy(dst_bmp_cm, src_bmp_cm, total_bytes);
    } else {
        color_adjust.ProcessPicCm(do_hns,
                                  do_bnc,
                                  src_bmp_cm,
                                  dst_bmp_cm,
                                  width,
                                  height,
                                  &color_adjust_option,
                                  ds_info);
    }

    // Checks result.
    unsigned char *temp = dst_bmp;
    unsigned char *temp_cm = dst_bmp_cm;
    int different = 0;
    for (int counter = 0; counter < width * height; counter++) {
        if ((temp[0] != temp_cm[0])
            || (temp[1] != temp_cm[1])
            || (temp[2] != temp_cm[2])) {
            different++;
            printf("\n%d Pixel Diff : C=[%3d : %3d : %3d],"
                   " CM=[%3d : %3d : %3d]",
                   counter,
                   temp[0], temp[1], temp[2],
                   temp_cm[0], temp_cm[1], temp_cm[2]);
        }
        temp += 3;
        temp_cm += 3;
    }
    printf("\nTesting picture size: %d x %d,"
           " different pixel count: %d \n",
           width, height, different);

    // Saves the output image data of the CPU into the file "Output_C.bmp".
    output_image.setData(dst_bmp);
    output_image.save("Output_C.bmp");

    // Saves the output image data of the GPU into the file "Output_CM.bmp".
    output_image.setData(dst_bmp_cm);
    output_image.save("Output_CM.bmp");

    // Frees memory.
    delete[] src_bmp;
    delete[] src_bmp_cm;
    delete[] ds_info;

    return different;
}
