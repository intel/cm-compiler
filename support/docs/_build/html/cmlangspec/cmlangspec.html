

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>CM (C for Media) Language Specification &#8212; CM 6.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/llvm-theme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '6.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="CMC User Guide" href="../cmcuserguide/cmcuserguide.html" />
    <link rel="prev" title="Documentation for CM" href="../index.html" />
<style type="text/css">
  table.right { float: right; margin-left: 20px; }
  table.right td { border: 1px solid #ccc; }
</style>

  </head>
  <body>
<div class="logo">
  <a href="../index.html">
    <img src="../_static/logo.png"
         alt="Intel Logo"/></a>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../cmcuserguide/cmcuserguide.html" title="CMC User Guide"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="../index.html" title="Documentation for CM"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">CM 6.0 documentation</a> &#187;</li> 
      </ul>
    </div>


    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <div class="section" id="cm-c-for-media-language-specification">
<h1><a class="toc-backref" href="#id29">CM (C for Media) Language Specification</a><a class="headerlink" href="#cm-c-for-media-language-specification" title="Permalink to this headline">¶</a></h1>
<p>Revision 6.0</p>
<p>Primary Author(s): Kai Yu Chen, Guei-Yuan Lueh</p>
<p>Contributor(s): Chu-cheow Lim, Somnath Ghosh, Chunling Hu, Biju
George, Weiyu Chen, Alexander Yermolovich, Puyan Lotfi,
Julia Gould, Wei Pan, David Stuttard, Tim Renouf, Tim Corringham,
Stephen Thomas</p>
<div class="section" id="legal-notices-and-disclaimers">
<h2><a class="toc-backref" href="#id30">Legal Notices and Disclaimers</a><a class="headerlink" href="#legal-notices-and-disclaimers" title="Permalink to this headline">¶</a></h2>
<p>INFORMATION IN THIS DOCUMENT IS PROVIDED IN CONNECTION WITH INTEL® PRODUCTS. NO LICENSE,
EXPRESS OR IMPLIED, BY ESTOPPEL OR OTHERWISE, TO ANY INTELLECTUAL PROPERTY RIGHTS IS
GRANTED BY THIS DOCUMENT. EXCEPT AS PROVIDED IN INTEL’S TERMS AND CONDITIONS OF SALE FOR
SUCH PRODUCTS, INTEL ASSUMES NO LIABILITY WHATSOEVER, AND INTEL DISCLAIMS ANY EXPRESS OR
IMPLIED WARRANTY, RELATING TO SALE AND/OR USE OF INTEL PRODUCTS INCLUDING LIABILITY OR
WARRANTIES RELATING TO FITNESS FOR A PARTICULAR PURPOSE, MERCHANTABILITY, OR
INFRINGEMENT OF ANY PATENT, COPYRIGHT OR OTHER INTELLECTUAL PROPERTY RIGHT.
UNLESS OTHERWISE AGREED IN WRITING BY INTEL, THE INTEL PRODUCTS ARE NOT DESIGNED NOR
INTENDED FOR ANY APPLICATION IN WHICH THE FAILURE OF THE INTEL PRODUCT COULD CREATE A
SITUATION WHERE PERSONAL INJURY OR DEATH MAY OCCUR.
Intel may make changes to specifications and product descriptions at any time, without notice. Designers
must not rely on the absence or characteristics of any features or instructions marked “reserved” or
“undefined.” Intel reserves these for future definition and shall have no responsibility whatsoever for
conflicts or incompatibilities arising from future changes to them. The information here is subject to
change without notice. Do not finalize a design with this information.
The products described in this document may contain design defects or errors known as errata which may
cause the product to deviate from published specifications. Current characterized errata are available on
request.
Contact your local Intel sales office or your distributor to obtain the latest specifications and before
placing your product order.
Copies of documents which have an order number and are referenced in this document, or other Intel
literature, may be obtained by calling 1-800-548-4725, or by visiting Intel’s Web Site.
Intel processor numbers are not a measure of performance. Processor numbers differentiate features
within each processor family, not across different processor families. See
<a class="reference external" href="http://www.intel.com/products/processor_number">http://www.intel.com/products/processor_number</a> for details.
This document contains information on products in the design phase of development.
BunnyPeople, Celeron, Celeron Inside, Centrino, Centrino Atom, Centrino Atom Inside, Centrino Inside,
Centrino logo, Core Inside, FlashFile, i960, InstantIP, Intel, Intel logo, Intel386, Intel486, IntelDX2,
IntelDX4, IntelSX2, Intel Atom, Intel Atom Inside, Intel Core, Intel Inside, Intel Inside logo, Intel. Leap
ahead., Intel. Leap ahead. logo, Intel NetBurst, Intel NetMerge, Intel NetStructure, Intel SingleDriver, Intel
SpeedStep, Intel StrataFlash, Intel Viiv, Intel vPro, Intel XScale, Itanium, Itanium Inside, MCS, MMX, Oplus,
OverDrive, PDCharm, Pentium, Pentium Inside, skoool, Sound Mark, The Journey Inside, Viiv Inside, vPro
Inside, VTune, Xeon, and Xeon Inside are trademarks of Intel Corporation in the U.S. and other countries.
* Other names and brands may be claimed as the property of others.</p>
<p>Copyright (C) 2009-2016, Intel Corporation. All rights reserved.</p>
<div class="contents topic" id="table-of-contents">
<p class="topic-title first">Table of Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#cm-c-for-media-language-specification" id="id29">CM (C for Media) Language Specification</a><ul>
<li><a class="reference internal" href="#legal-notices-and-disclaimers" id="id30">Legal Notices and Disclaimers</a></li>
<li><a class="reference internal" href="#introduction" id="id31">1 Introduction</a><ul>
<li><a class="reference internal" href="#purpose-scope" id="id32">1.1 Purpose / Scope</a></li>
<li><a class="reference internal" href="#definitions-acronyms-and-abbreviation" id="id33">1.2 Definitions, Acronyms, and Abbreviation</a></li>
<li><a class="reference internal" href="#references-and-related-information" id="id34">1.3 References and Related Information</a></li>
<li><a class="reference internal" href="#revision-history" id="id35">1.4 Revision History</a></li>
</ul>
</li>
<li><a class="reference internal" href="#data-types" id="id36">2 Data Types</a><ul>
<li><a class="reference internal" href="#scalar-data-types" id="id37">2.1 Scalar Data Types</a></li>
<li><a class="reference internal" href="#compound-data-types" id="id38">2.2 Compound Data Types</a></li>
<li><a class="reference internal" href="#other-built-in-data-types" id="id39">2.3 Other Built-in Data Types</a></li>
<li><a class="reference internal" href="#variable-qualifiers" id="id40">2.4 Variable Qualifiers</a></li>
<li><a class="reference internal" href="#type-conversions-and-casting" id="id41">2.5 Type Conversions and Casting</a></li>
<li><a class="reference internal" href="#restrictions" id="id42">2.6 Restrictions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#operations" id="id43">3 Operations</a><ul>
<li><a class="reference internal" href="#scalar-data-operations" id="id44">3.1 Scalar Data Operations</a></li>
<li><a class="reference internal" href="#compound-data-operations" id="id45">3.2 Compound Data Operations</a></li>
<li><a class="reference internal" href="#evaluation-order" id="id46">3.3 Evaluation Order</a></li>
<li><a class="reference internal" href="#control-flow" id="id47">3.4 Control flow</a></li>
</ul>
</li>
<li><a class="reference internal" href="#functions" id="id48">4 Functions</a><ul>
<li><a class="reference internal" href="#function-qualifiers" id="id49">4.1 Function Qualifiers</a></li>
<li><a class="reference internal" href="#user-defined-functions" id="id50">4.2 User-defined functions</a></li>
<li><a class="reference internal" href="#built-in-functions" id="id51">4.3 Built-in Functions</a></li>
<li><a class="reference internal" href="#common-types-for-memory-operations" id="id52">4.4 Common Types For Memory Operations</a></li>
<li><a class="reference internal" href="#dataport-interface" id="id53">4.5 Dataport Interface</a></li>
<li><a class="reference internal" href="#shared-local-memory-slm-and-groups-interface-gen7" id="id54">4.6 Shared Local Memory (SLM) and Groups Interface {Gen7+}</a></li>
<li><a class="reference internal" href="#sampler-interface" id="id55">4.7 Sampler Interface</a></li>
<li><a class="reference internal" href="#adaptive-video-scaling" id="id56">4.8 Adaptive Video Scaling</a></li>
<li><a class="reference internal" href="#video-analytics-functions-gen8" id="id57">4.9 Video Analytics Functions (Gen8+)</a></li>
<li><a class="reference internal" href="#video-analytics-functions-gen9" id="id58">4.10 Video Analytics Functions (Gen9+)</a></li>
<li><a class="reference internal" href="#video-analytics-functions-hdc-write-gen9" id="id59">4.11 Video Analytics Functions HDC Write {Gen9+}</a></li>
<li><a class="reference internal" href="#vme-interface" id="id60">4.12 VME Interface</a></li>
<li><a class="reference internal" href="#media-walker-interface" id="id61">4.13 Media Walker Interface</a></li>
<li><a class="reference internal" href="#synchronization-functions" id="id62">4.14 Synchronization Functions</a></li>
<li><a class="reference internal" href="#raw-send-functions" id="id63">4.15 Raw Send Functions</a></li>
<li><a class="reference internal" href="#cm-label-function" id="id64">4.16 CM label function</a></li>
<li><a class="reference internal" href="#formatted-output" id="id65">4.17 Formatted Output</a></li>
<li><a class="reference internal" href="#shared-virtual-memory-svm" id="id66">4.18 Shared Virtual Memory (SVM)</a></li>
<li><a class="reference internal" href="#preprocessor-directives" id="id67">4.19 Preprocessor Directives</a></li>
<li><a class="reference internal" href="#rounding-mode-and-float-control-support" id="id68">4.20 Rounding mode and float control support</a></li>
<li><a class="reference internal" href="#miscellaneous-functions" id="id69">4.21 Miscellaneous Functions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#cm-template-library" id="id70">5 CM Template Library</a><ul>
<li><a class="reference internal" href="#i-o" id="id71">5.1 I/O</a></li>
<li><a class="reference internal" href="#vectorization" id="id72">5.2 Vectorization</a></li>
<li><a class="reference internal" href="#slm" id="id73">5.3 SLM</a></li>
<li><a class="reference internal" href="#iselect" id="id74">5.4 Iselect</a></li>
<li><a class="reference internal" href="#cachedstack" id="id75">5.5 CachedStack</a></li>
<li><a class="reference internal" href="#matrix-transform" id="id76">5.6 Matrix transform</a></li>
<li><a class="reference internal" href="#init-and-assignment" id="id77">5.7 Init and assignment</a></li>
<li><a class="reference internal" href="#extended-math" id="id78">5.8 Extended math</a></li>
</ul>
</li>
<li><a class="reference internal" href="#appendix-a-media-kernel-example" id="id79">Appendix A Media Kernel Example</a><ul>
<li><a class="reference internal" href="#linear-filter-example" id="id80">Linear Filter Example</a></li>
</ul>
</li>
<li><a class="reference internal" href="#appendix-b-vme-interface-access-macros" id="id81">Appendix B VME Interface Access Macros</a><ul>
<li><a class="reference internal" href="#vme-interface-access-macros-for-gen6" id="id82">VME Interface Access Macros for Gen6</a></li>
<li><a class="reference internal" href="#vme-interface-access-macros-for-gen7-5" id="id83">VME Interface Access Macros for Gen7_5</a></li>
<li><a class="reference internal" href="#vme-interface-access-macros-for-gen8" id="id84">VME Interface Access Macros for Gen8</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div class="section" id="introduction">
<h2><a class="toc-backref" href="#id31">1 Introduction</a><a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<div class="section" id="purpose-scope">
<h3><a class="toc-backref" href="#id32">1.1 Purpose / Scope</a><a class="headerlink" href="#purpose-scope" title="Permalink to this headline">¶</a></h3>
<p>This document provides a specification for the CM (C for Media) language. CM is intended to support
high-level programming of media kernels for the Intel® Graphics Media Accelerators [1]. The language is
based on standard C++ language with some restrictions, plus additional features that are designed for
easy expression of the inherent data parallelism in media applications and simplified interface with the
architecture specific hardware features. The organization of this document is as follows:</p>
<ul class="simple">
<li>Section 2 describes the data types, including the supported subset of C++ data types, CM-defined
vector and matrix object types, variable qualifiers, type conversion/casting rules, and restrictions.</li>
<li>Section 3 describes the operations and member functions, in particular the set of overloaded
operations on vectors and matrices.</li>
<li>Section 4 describes the functions, user/kernel function qualifiers, calling conventions, built-in
functions and inline assembly.</li>
<li>Section 5 describes the functions that can be found in the CM Template Library</li>
<li>Appendix A provides the media kernel example written in CM.</li>
<li>Appendix B describes the access macros for VME interface.</li>
</ul>
<p>This document assumes reader familiarity with the standard C++ language. It is not intended to describe
details of the target device, CM software stack, or the CM compiler usage. Some background
information is provided in the relevant sections. Please refer to the references listed in section 1.3 for
further information.</p>
</div>
<div class="section" id="definitions-acronyms-and-abbreviation">
<h3><a class="toc-backref" href="#id33">1.2 Definitions, Acronyms, and Abbreviation</a><a class="headerlink" href="#definitions-acronyms-and-abbreviation" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<colgroup>
<col width="13%" />
<col width="87%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Term</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>CM</td>
<td>C for Media Language</td>
</tr>
<tr class="row-odd"><td>C++  FE</td>
<td>Standard Intel® C++ Compiler Front-End</td>
</tr>
<tr class="row-even"><td>CM FE</td>
<td>CM Compiler Front-End</td>
</tr>
<tr class="row-odd"><td>SIMD</td>
<td>Single Instruction Multiple Data</td>
</tr>
<tr class="row-even"><td>GPU</td>
<td>Graphics Processing Unit</td>
</tr>
<tr class="row-odd"><td>GenX</td>
<td>Graphics core generations for Intel® Graphics Media Accelerators [1]</td>
</tr>
<tr class="row-even"><td>Host</td>
<td>IA-32 and Intel® 64 architecture processors</td>
</tr>
<tr class="row-odd"><td>Device</td>
<td>Intel® GenX GPU</td>
</tr>
<tr class="row-even"><td>Kernel</td>
<td>A program that can be executed on GenX hardware</td>
</tr>
<tr class="row-odd"><td>Thread</td>
<td>An instance of a kernel program that is executed on a GenX hardware</td>
</tr>
<tr class="row-even"><td>LSB</td>
<td>Least Significant Bit</td>
</tr>
<tr class="row-odd"><td>GRF</td>
<td>General Register File, a set of general-purpose registers available in GenX</td>
</tr>
<tr class="row-even"><td>DWORD</td>
<td>Double-word, represents 4 bytes for GenX</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="references-and-related-information">
<h3><a class="toc-backref" href="#id34">1.3 References and Related Information</a><a class="headerlink" href="#references-and-related-information" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>[1] “Intel® Graphics Media Accelerator Developer’s Guide”,
<a class="reference external" href="http://software.intel.com/en-us/articles/intel-graphics-media-accelerator-developers-guide/">http://software.intel.com/en-us/articles/intel-graphics-media-accelerator-developers-guide/</a>.</li>
<li>[2] United States Patent 7257695, 2007.</li>
<li>[3] “Intel® C++ Compiler User and Reference Guides”,
<a class="reference external" href="http://www.intel.com/cd/software/products/asmo-na/eng/347618.htm">http://www.intel.com/cd/software/products/asmo-na/eng/347618.htm</a>.</li>
<li>[4] “Graphics BSpec”, Vol5c.6, Intel Corporation.</li>
<li>[5] CM Usage Model.</li>
<li>[6] CM Runtime API specification.</li>
<li>[7] <cite>CMC User Guide</cite>.</li>
<li>[8] <cite>CM LLVM Porting Guide</cite>.</li>
</ul>
</div>
<div class="section" id="revision-history">
<h3><a class="toc-backref" href="#id35">1.4 Revision History</a><a class="headerlink" href="#revision-history" title="Permalink to this headline">¶</a></h3>
<div class="section" id="changes-since-cm-4-0">
<h4>Changes since CM 4.0<a class="headerlink" href="#changes-since-cm-4-0" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>Updated definition of sample32 API with new Output Format Control field</li>
<li>Added cm_bf_insert, cm_bf_extract and cm_bf_reverse intrinsics</li>
<li>Modified scatter/gather read/write to reflect the support for non dword types (e.g. now supports
char, uchar, short, ushort) as well as being byte addressable (not supported pre IVB)</li>
<li>Description of Gen10 HEVC VME Interface</li>
</ul>
</div>
<div class="section" id="changes-since-cm-5-0">
<h4>Changes since CM 5.0<a class="headerlink" href="#changes-since-cm-5-0" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>Update the description of the cm_sincos() intrinsic</li>
<li>Remove the requirement that the arguments to cm_min() and cm_max() have the same kind of type</li>
<li>Clarified that a mask used as a SIMD control flow condition has each
element considered “true” if not equal to zero. This is different to a mask’s
use in the merge function, where only the least significant bit is
considered.</li>
<li>Added cm_pause intrinsic information</li>
<li>Added new style write_typed_atomic (cm-llvm/cmc only)</li>
<li>Removed the deprecated function genx_select, and appendix describing clang-cm</li>
<li>Removed non-supported cm_fgetround and cm_fsetround intrinsics. Added description of
_GENX_ROUNDING_MODE_ kernel directive</li>
<li>Added scalar variant for scatter write (enables writing a scalar to buffers - only way to do this
as all other variants require 2D surface)</li>
<li>Moved topics relating to compiler usage to the CMC User Guide document.</li>
</ul>
</div>
<div class="section" id="changes-since-cm-6-0">
<h4>Changes since CM 6.0<a class="headerlink" href="#changes-since-cm-6-0" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>For oword load read(), documented the deprecated MODIFIED_DWALIGNED modifier
in addition to DWALIGNED.</li>
<li>Clarified behaviour of cm_shr for different input types, added docs for cm_asr and newly
implemented cm_lsr.</li>
<li>Noted that <code class="docutils literal"><span class="pre">cm_send</span></code> and <code class="docutils literal"><span class="pre">cm_sends</span></code> can be inside SIMD control flow, and that
causes the SIMD width of the resulting <code class="docutils literal"><span class="pre">send</span></code> or <code class="docutils literal"><span class="pre">sends</span></code> to be adjusted from
its default of 16.</li>
<li>Added new _GENX_FLOAT_CONTROL_ support to extend floating point control from just rounding modes
(that _GENX_ROUNDING_MODE_ implements). The new support includes denorm control and ALT/IEEE for
single precision float.</li>
<li>Added half-precision floating-point (half) as one of basic scalar data types.</li>
<li>Added new predicate arguments to write_atomic and typed_write_atomic.</li>
<li>Added read_scaled and write_scaled.</li>
</ul>
</div>
</div>
</div>
<div class="section" id="data-types">
<h2><a class="toc-backref" href="#id36">2 Data Types</a><a class="headerlink" href="#data-types" title="Permalink to this headline">¶</a></h2>
<div class="section" id="scalar-data-types">
<h3><a class="toc-backref" href="#id37">2.1 Scalar Data Types</a><a class="headerlink" href="#scalar-data-types" title="Permalink to this headline">¶</a></h3>
<p>CM supports the following basic scalar data types defined in C++:</p>
<ul class="simple">
<li>char, unsigned char (uchar), short, unsigned short (ushort), int, unsigned int (uint), float, half<ul>
<li>CM supports IEEE-754 conformant 16-bit half-precision floating point type.
To enable this, use namespace “half_float” for host code, and keyword “half” for variable declaration.</li>
</ul>
</li>
<li>double: double-precision floating-point data type is only supported for Gen7+ hardware platform,
with the following usage restrictions:<ul>
<li>Double operands can be used with usual CM operators where floating-point operands are
allowed, except division.</li>
<li>Double operands can be used with the following CM intrinsic functions:
cm_abs/cm_min/cm_max/cm_add/cm_mul/cm_sum (all operands must be of double type).</li>
<li>Double operands cannot be used in DWord scattered read/write and DWord atomic write.</li>
</ul>
</li>
<li>unsigned long long, long long: unsigned and signed long long data types are 64-bit integers that are
supported for Gen8+ hardware platform with strict restrictions:<ul>
<li>unsigned long long and long long operands can be used with usual CM operators where long
long operands are allowed, except multiplication and division.</li>
<li>No CM intrinsic functions are allowed for unsigned long long and long long types.</li>
<li>Unsigned long long and long long operands cannot be used in DWord scattered read/write
and DWord atomic write.</li>
</ul>
</li>
<li>svmptr_t: represents an integer of pointer size for SVM (shared virtual memory, Gen8+). When
declaring a struct that is in SVM, use svmptr_t for a pointer field. The size of svmptr_t is set by
compiler options /DCM_PTRSIZE=32 or /DCM_PTRSIZE=64; use the size appropriate to whether the
CM program will be run from a 32 bit or 64 bit application. See <a class="reference internal" href="#sharedvirtualmemory"><span class="std std-ref">4.18 Shared Virtual Memory (SVM)</span></a>.</li>
</ul>
<p>The CM compiler will issue an error message for unsupported data types.</p>
</div>
<div class="section" id="compound-data-types">
<h3><a class="toc-backref" href="#id38">2.2 Compound Data Types</a><a class="headerlink" href="#compound-data-types" title="Permalink to this headline">¶</a></h3>
<div class="section" id="base-object">
<h4>2.2.1 Base Object<a class="headerlink" href="#base-object" title="Permalink to this headline">¶</a></h4>
<p>To facilitate the expression of high-level data-parallel operations, CM provides the users with two kinds of
compound data types for base objects: vector and matrix. These types are defined using syntax similar to C++
template classes. The parameters are the type of data element and the size of a vector/matrix, as described
below, which must be compile-time constants according to the C++ language specification.</p>
<ul class="simple">
<li>“Vector&lt; type, size&gt;” represents a vector of length “size” with elements of type “type”.</li>
<li>“Matrix&lt;type, rows, columns&gt;” represents a “rows” x “columns” matrix with elements of type
“type”.</li>
</ul>
<p>Note: The data element type must be a supported scalar data type as described in Section 2.1.</p>
<p>Note: The total size of a matrix or vector must be less than 4096 bytes.</p>
<p>Some examples of base object declarations:</p>
<a class="reference internal image-reference" href="../_images/base_object_declaration_example.png"><img alt="../_images/base_object_declaration_example.png" src="../_images/base_object_declaration_example.png" style="width: 600px;" /></a>
</div>
<div class="section" id="reference-object">
<h4>2.2.2 Reference Object<a class="headerlink" href="#reference-object" title="Permalink to this headline">¶</a></h4>
<p>In addition, CM allows the user to define two types of reference objects: vector_ref and matrix_ref, as
described below:</p>
<ul class="simple">
<li>“vector_ref&lt;type, size&gt;” represents a reference to the elements of some base object that form a
vector of length “size” with elements of type “type”.</li>
<li>“matrix_ref&lt;type, rows, columns&gt;” represents a reference to the elements of some base object that
form a “rows” x “columns” matrix with elements of type “type”.</li>
</ul>
<p>The reference objects represent subsets of the base objects. While a base object occupies a storage space
in the GRF that does not overlap with the storage space of other base objects, a reference object is used
internally to refer to a region in the base object and share the storage space. All operations on a reference
object result in applying these operations to the corresponding elements of the base object.</p>
<p>An example of reference object declaration:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span>  <span class="n">matrix</span><span class="o">&lt;</span><span class="kt">short</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="o">&gt;</span> <span class="n">m</span><span class="p">;</span>
  <span class="n">vector_ref</span><span class="o">&lt;</span><span class="kt">short</span><span class="p">,</span> <span class="mi">8</span><span class="o">&gt;</span> <span class="n">r</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span> <span class="c1">// row() returns the reference to a row</span>
</pre></div>
</div>
</div>
<div class="section" id="structures">
<h4>2.2.3 Structures<a class="headerlink" href="#structures" title="Permalink to this headline">¶</a></h4>
<p>CM supports C structures containing all the supported scalar data types and vector/matrix object types
described above, with the restriction that the structure data members must be properly aligned.  The
reference object cannot be declared as a structure field.</p>
</div>
<div class="section" id="masks">
<h4>2.2.4 Masks<a class="headerlink" href="#masks" title="Permalink to this headline">¶</a></h4>
<p>Masks for SIMD comparison and merge operations are represented in CM as follows:</p>
<ul class="simple">
<li>int – a vector mask packed into a single int type scalar.</li>
<li>vector&lt;ushort, size&gt; – a vector mask.</li>
<li>matrix&lt;ushort, rows, columns&gt; – a matrix mask.</li>
</ul>
<p>Note: Only LSB of each vector/matrix mask element is significant when used in a
merge function. However, when used as a SIMD control flow condition, each
element is compared with 0, thus any non-zero value signifies “true”.</p>
</div>
</div>
<div class="section" id="other-built-in-data-types">
<h3><a class="toc-backref" href="#id39">2.3 Other Built-in Data Types</a><a class="headerlink" href="#other-built-in-data-types" title="Permalink to this headline">¶</a></h3>
<p>The following built-in data types are defined in CM to represent different objects created and managed by
the CM host runtime [6]. Variables of such data types must be passed through kernel function
parameters, except the reserved global surface indexes CM_STATIC_BUFFER_0 / CM_STATIC_BUFFER_1 /
CM_STATIC_BUFFER_2 / CM_STATIC_BUFFER_3. CM does not allow the explicit use of local/global
variable or modification of such data types in kernel functions, except used as function call argument.
CM does not allow alias among SurfaceIndexes used for dataport functions, as the ordering
between typed and untyped accesses may not be guaranteed by either compiler or hardware.</p>
<ul class="simple">
<li>SurfaceIndex: represents a surface object used in dataport or other shared functions.</li>
<li>SamplerIndex: represents a Sampler state object used in Sampler functions.</li>
<li>VmeIndex: represents a VME state object used in VME functions.</li>
</ul>
<p>CM supports the use of vector of SurfaceIndex in kernel function, which must be passed from host as
kernel function parameters. CM does not allow modification, reference, or sub-vector select/iselect
operation of SurfaceIndex vector (only basic member select operation vector(i) is allowed).</p>
<p>Usage example:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;cm/cm.h&gt;</span><span class="cp"></span>

<span class="n">_GENX_MAIN_</span> <span class="kt">void</span>
<span class="nf">linear</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SurfaceIndex</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">surf_ids</span><span class="p">,</span> <span class="n">uint</span> <span class="n">h_pos</span><span class="p">,</span> <span class="n">uint</span> <span class="n">v_pos</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="mi">8</span><span class="o">&gt;</span> <span class="n">in</span><span class="p">,</span> <span class="n">out</span><span class="p">;</span>
  <span class="c1">// ...</span>
  <span class="n">read</span><span class="p">(</span><span class="n">surf_ids</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">h_pos</span><span class="o">*</span><span class="mi">24</span><span class="p">,</span> <span class="n">v_pos</span><span class="o">*</span><span class="mi">6</span><span class="p">,</span> <span class="n">in</span><span class="p">);</span>
  <span class="c1">//  ...</span>
  <span class="n">write</span><span class="p">(</span><span class="n">surf_ids</span><span class="p">(</span><span class="n">j</span><span class="p">),</span> <span class="n">h_pos</span><span class="o">*</span><span class="mi">24</span><span class="p">,</span> <span class="n">v_pos</span><span class="o">*</span><span class="mi">6</span><span class="p">,</span> <span class="n">out</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="variable-qualifiers">
<h3><a class="toc-backref" href="#id40">2.4 Variable Qualifiers</a><a class="headerlink" href="#variable-qualifiers" title="Permalink to this headline">¶</a></h3>
<p>Global variable example:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;cm/cm.h&gt;</span><span class="cp"></span>

<span class="n">_GENX_</span> <span class="n">matrix</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">M</span><span class="p">;</span>      <span class="c1">// global variable declaration</span>

<span class="n">_GENX_</span> <span class="kt">float</span> <span class="nf">foo</span><span class="p">(</span><span class="n">matrix</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">cm_sum</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">_GENX_</span> <span class="kt">void</span> <span class="nf">bar</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">16</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">,</span> <span class="kt">float</span> <span class="n">f</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">matrix</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">m1</span><span class="p">;</span>
  <span class="n">m1</span> <span class="o">=</span> <span class="n">v</span> <span class="o">+</span> <span class="n">f</span><span class="p">;</span>
  <span class="kt">float</span> <span class="n">s</span> <span class="o">=</span> <span class="n">foo</span><span class="p">(</span><span class="n">m1</span><span class="p">);</span>
  <span class="n">M</span> <span class="o">=</span> <span class="n">m1</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">_GENX_MAIN_</span> <span class="kt">void</span> <span class="nf">kernel</span><span class="p">(</span><span class="n">SurfaceIndex</span> <span class="n">inbuf</span><span class="p">,</span> <span class="n">SurfaceIndex</span> <span class="n">outbuf</span><span class="p">,</span>
                        <span class="kt">int</span> <span class="n">x_pos</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y_pos</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">matrix</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">m</span><span class="p">;</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">16</span><span class="o">&gt;</span>   <span class="n">v</span><span class="p">;</span>

  <span class="n">read</span><span class="p">(</span><span class="n">inbuf</span><span class="p">,</span> <span class="n">x_pos</span><span class="p">,</span> <span class="n">y_pos</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>
  <span class="n">v</span> <span class="o">=</span> <span class="n">m</span><span class="p">;</span>
  <span class="n">bar</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="mf">0.5f</span><span class="p">);</span>
  <span class="n">write</span><span class="p">(</span><span class="n">outbuf</span><span class="p">,</span> <span class="n">x_pos</span><span class="p">,</span> <span class="n">y_pos</span><span class="p">,</span> <span class="n">M</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>CM supports the “__declspec(genx)” (#define’d to _GENX_) qualifier for global variables, which can be
vector/matrix objects described above.  Such variables are treated as normal local C++ variables declared
in kernel functions. Functions marked with “__declspec(genx)”/”__declspec(genx_main)” can lexically
reference variables marked with “__declspec(genx)”. This allows using them like global variables in
addition to function parameters, which helps decreases GRF registers pressure and increases
performance.  Note that these global variables are thread private (i.e., a global variable is shared among
the GenX kernel function marked with “__declspec(genx_main)” and all its callee GenX user functions
marked with “__declspec(genx)” within the same GenX hardware thread). An example is given above
(please refer to Section 3 and Section 4 for description on the operations and functions). CM does not
support the initialization of global variables.</p>
</div>
<div class="section" id="type-conversions-and-casting">
<h3><a class="toc-backref" href="#id41">2.5 Type Conversions and Casting</a><a class="headerlink" href="#type-conversions-and-casting" title="Permalink to this headline">¶</a></h3>
<p>Mixed type operation example:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">matrix</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">m1</span><span class="p">;</span>
  <span class="n">matrix</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">m2</span><span class="p">;</span>

  <span class="n">vector_ref</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">v1</span><span class="p">(</span><span class="n">m1</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>
  <span class="n">m2</span> <span class="o">=</span> <span class="n">v1</span><span class="p">;</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>CM allows mixed operations of vector and matrix objects of different shapes if the operands have the
same number of data elements. The operand shape conformance is checked at compile time by C++ FE
using template specialization rules for vector/matrix classes. An example is given above.</p>
<p>In such cases, CM compiler determines the data element type in the destination operand based on the
source operand data types using standard C++ rules for handling mixed type computation for scalars
(using template specialization mechanisms). Just like in standard C++, users may want to add explicit type
conversions to change the default type promotion and conversion rules. An example is given here:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">8</span><span class="o">&gt;</span> <span class="n">f</span><span class="p">;</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">8</span><span class="o">&gt;</span> <span class="n">i</span><span class="p">;</span>
  <span class="c1">// ...</span>
  <span class="n">f</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>                    <span class="c1">// implicit type conversion</span>
  <span class="n">f</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">short</span><span class="p">,</span> <span class="mi">8</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>  <span class="c1">// explicit type conversion</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="restrictions">
<h3><a class="toc-backref" href="#id42">2.6 Restrictions</a><a class="headerlink" href="#restrictions" title="Permalink to this headline">¶</a></h3>
<p>CM places restrictions on using the following standard C++ features in kernel functions and user defined
functions written for the graphics device (described in Section 3.4):</p>
<ul class="simple">
<li>Pointers</li>
<li>C++ references</li>
<li>Classes other than the supported C structures and vector/matrix/vector_ref/matrix_ref types</li>
<li>Class inheritance</li>
<li>Arrays</li>
<li>Exception handling</li>
<li>Dynamic type identification</li>
<li>Memory allocation</li>
<li>Static variables</li>
<li>Volatile variables</li>
<li>Calls to external functions</li>
</ul>
</div>
</div>
<div class="section" id="operations">
<h2><a class="toc-backref" href="#id43">3 Operations</a><a class="headerlink" href="#operations" title="Permalink to this headline">¶</a></h2>
<div class="section" id="scalar-data-operations">
<h3><a class="toc-backref" href="#id44">3.1 Scalar Data Operations</a><a class="headerlink" href="#scalar-data-operations" title="Permalink to this headline">¶</a></h3>
<p>CM supports the standard C++ operations for the allowed scalar data types described in Section 2.1.</p>
<p>For floating point operations, CM supports the operation modes implemented in GenX hardware which
have deviations from the IEEE* Floating-point standard IEEE-754.</p>
</div>
<div class="section" id="compound-data-operations">
<h3><a class="toc-backref" href="#id45">3.2 Compound Data Operations</a><a class="headerlink" href="#compound-data-operations" title="Permalink to this headline">¶</a></h3>
<p>CM provides a set of overloaded operators for manipulating vector and matrix objects. These are
described below.</p>
<div class="section" id="assignment-operators">
<h4>3.2.1 Assignment Operators<a class="headerlink" href="#assignment-operators" title="Permalink to this headline">¶</a></h4>
<p>CM allows the user to assign the value for each data element in a vector/matrix object, as well as to use
component-wise assignment between two objects. If a source operand is of scalar type then it is
replicated. An example is given here:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span>  <span class="n">vector</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">vi</span><span class="p">,</span> <span class="n">vo</span><span class="p">;</span>
  <span class="n">vi</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="mi">117</span><span class="p">;</span>
  <span class="n">vi</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="mi">231</span><span class="p">;</span>
  <span class="n">vo</span> <span class="o">=</span> <span class="n">vi</span><span class="p">;</span>  <span class="c1">// vo(0) = 117, vo(1) = 231</span>

  <span class="n">matrix</span><span class="o">&lt;</span><span class="n">uint</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span>      <span class="n">m1</span><span class="p">,</span> <span class="n">m2</span><span class="p">;</span>
  <span class="n">matrix_ref</span><span class="o">&lt;</span><span class="n">uint</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span>  <span class="n">m3</span> <span class="o">=</span> <span class="n">m1</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="sc">&#39;?&#39;</span><span class="p">;</span>

  <span class="n">m1</span> <span class="o">=</span> <span class="n">m2</span><span class="p">;</span>  <span class="c1">// elements of m2 are copied to m1</span>
  <span class="n">m1</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>   <span class="c1">// c is copied to all elements of m1</span>
            <span class="c1">// (implicit type conversion char --&gt; uint is performed)</span>
  <span class="n">m2</span> <span class="o">=</span> <span class="n">m3</span><span class="p">;</span>  <span class="c1">// elements of m1 are copied to m2</span>
</pre></div>
</div>
<p>The assignment operator can be used between two matrix/vector objects with different shapes, if they
have the same total number of data elements. The data elements are copied in the row-major fashion.</p>
</div>
<div class="section" id="vector-matrix-constructors">
<h4>3.2.2 Vector/matrix Constructors<a class="headerlink" href="#vector-matrix-constructors" title="Permalink to this headline">¶</a></h4>
<p>Constructor example:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span>  <span class="n">vector</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">vi</span><span class="p">;</span>
  <span class="n">vi</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="mi">117</span><span class="p">;</span>
  <span class="n">vi</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="mi">231</span><span class="p">;</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">vo</span><span class="p">(</span><span class="n">vi</span><span class="p">);</span> <span class="c1">// vo(0) = 117, vo(1) = 231</span>
</pre></div>
</div>
<p>Similar to standard C++, constructors can be also used in CM to set the data elements in vector/matrix
objects. One restriction is that vector_ref constructor can only take vector/vector_ref object with the
same data type/size, which must be contiguous. Similarly, the matrix_ref constructor can only take
matrix/matrix_ref object with the same data type/size, which must be contiguous. An example is given
above.</p>
<p>To model the data movement instructions with saturation on the target device, CM provides a special
variant of matrix/vector constructor with the “SAT” parameter, as illustrated here:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span>  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">vi</span><span class="p">;</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">vo</span><span class="p">;</span>
  <span class="n">vi</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="mi">155</span><span class="p">;</span>
  <span class="n">vi</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="mi">275</span><span class="p">;</span>
  <span class="n">vo</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">vi</span><span class="p">);</span>        <span class="c1">// vo(0) = 155, vo(1) = 20</span>
  <span class="n">vo</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">vi</span><span class="p">,</span> <span class="n">SAT</span><span class="p">);</span>   <span class="c1">// vo(0) = 155, vo(1) = 255</span>
</pre></div>
</div>
<p>CM provides the following member functions that return the size of a matrix/vector object.</p>
<p>n_rows(): returns the number of rows in a matrix.</p>
<p>n_cols(): returns the number of columns in a matrix.</p>
<p>n_elems(): returns the number of elements in a vector.</p>
</div>
<div class="section" id="vector-matrix-initializers">
<h4>3.2.3 Vector/Matrix Initializers<a class="headerlink" href="#vector-matrix-initializers" title="Permalink to this headline">¶</a></h4>
<p>This feature allows users to initialize matrices and vectors through normal C array-initializers. Even though
arrays cannot be used within GenX functions, this feature enables full C syntax of array-initialization for
initializing matrices and vectors. It is advisable to use this feature instead of initializing matrices and
vectors through assignments in the GenX kernels because the compiler would be able to analyze the
initialization sequence and produce optimized vector-immediate or constant moves whenever possible.
The syntax for initializing a vector or matrix during its declaration is simply passing an initialized global
static array (initializer array) as shown in the example here:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;cm/cm.h&gt;</span><span class="cp"></span>

<span class="k">const</span> <span class="kt">short</span> <span class="n">init_v_B</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">33</span><span class="p">,</span> <span class="mi">41</span><span class="p">,</span> <span class="mi">49</span><span class="p">,</span> <span class="mi">57</span><span class="p">};</span>
<span class="k">const</span> <span class="kt">short</span> <span class="n">init_Table</span><span class="p">[</span><span class="mi">5</span><span class="p">][</span><span class="mi">16</span><span class="p">]</span> <span class="o">=</span> <span class="p">{{</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">},{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">},{</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">6</span><span class="p">},{</span><span class="mi">23</span><span class="p">},{</span><span class="mi">45</span><span class="p">}};</span>
<span class="k">const</span> <span class="kt">short</span> <span class="n">init_0_7</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">};</span>

<span class="k">extern</span> <span class="s">&quot;C&quot;</span>
<span class="n">_GENX_MAIN_</span> <span class="kt">void</span> <span class="n">test1</span><span class="p">(</span><span class="n">SurfaceIndex</span> <span class="n">OUT</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="n">ushort</span><span class="p">,</span> <span class="mi">8</span><span class="o">&gt;</span>     <span class="n">v_0_7</span><span class="p">(</span><span class="n">init_0_7</span><span class="p">);</span>
  <span class="n">matrix</span><span class="o">&lt;</span><span class="n">uint</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">16</span><span class="o">&gt;</span>   <span class="n">m_Table</span><span class="p">(</span><span class="n">init_Table</span><span class="p">);</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">short</span><span class="p">,</span> <span class="mi">8</span><span class="o">&gt;</span>      <span class="n">v_B</span><span class="p">(</span><span class="n">init_v_B</span><span class="p">);</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The initial values of the global array or the initializer-array are sequentially copied to the
vector or matrix. Currently, only integer values can be used for initialization using this feature. Floating-
point values will be supported soon. Initializer array could be bigger or smaller than the initialized array –
initialization would be done up to the minimum of their sizes. Initializer array can have more than one
dimension – this gives more flexibility to users allowing them to skip initialization of some segments of the
matrix or vector.</p>
<p>A matrix can also be efficiently declared and initialized with an arithmetic sequence by the built-in
function cm_matrix as shown below. This function uses optimized GenX instruction sequence to perform
the desired initialization. <strong>Note: requires inclusion of cm/cmtl.h header</strong></p>
<p>Syntax: cm_matrix(M,T,R,C,I,S);</p>
<p>Where M – Name of the matrix; T – Type of the elements; R - #Rows; C - #Columns; I – Initial value of the
sequence; S – Step of the sequence.</p>
<p>Example:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;cm/cm.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cm/cmtl.h&gt;</span><span class="cp"></span>

<span class="n">_GENX_</span> <span class="kt">void</span> <span class="nf">test1</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">cm_matrix</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">ushort</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here, matrix ‘m’ is declared as a 4x8 ushort matrix and initialized to the values 10, 15, 20, 25, …
Note that, you must not declare ‘m’ before as this function declares ‘m’ and then initializes.</p>
<p>Similarly, a vector can be declared and initialized efficiently with cm_vector function.
<strong>Note: requires inclusion of cm/cmtl.h header</strong>:</p>
<p>Syntax: cm_vector(V,T,N,I,S);</p>
<p>Where V – Name of the vector; T – Type of the elements; N - #Elements; I – Initial value of the sequence; S
– Step of the sequence.</p>
<p>Example:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;cm/cm.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cm/cmtl.h&gt;</span><span class="cp"></span>

<span class="n">_GENX_</span> <span class="kt">void</span> <span class="nf">test1</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">cm_vector</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">ushort</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here, vector ‘v’ is declared as a 16-element ushort vector and initialized to the values 2, 5, 8, …
Note that, you must not declare ‘v’ before as this function declares ‘v’ and then initializes.</p>
<p>A pre-declared vector or matrix can also be efficiently assigned an arithmetic sequence with the following
cmtl function (requires cm/cmtl header to be included):</p>
<p>Syntax: cmtl::cm_vector_assign(V,I,S);</p>
<p>Where V – Name of the vector (can use a matrix ‘format’-ed to a vector); I – Initial value of the sequence;
S – Step of the sequence. Here initial value ‘I’ can be a variable.</p>
<p>Example:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span>  <span class="n">cmtl</span><span class="o">::</span><span class="n">cm_vector_assign</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">i</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
</pre></div>
</div>
<p>Here, 10 elements of vector ‘v’ are assigned as follows: v(2) =  i; v(3) = i+3; v(4) =  i+6, …</p>
<p>Note that, here ‘v’ is assumed to be already declared before.</p>
</div>
<div class="section" id="arithmetic-operators">
<h4>3.2.4 Arithmetic Operators<a class="headerlink" href="#arithmetic-operators" title="Permalink to this headline">¶</a></h4>
<p>CM supports the following arithmetic operators for vector/matrix objects:</p>
<p>+, -, *, /, %, +=, -=, *=</p>
<p>These are all component-wise operations that follow standard C++ rules for the corresponding scalar data
computation. The operands must conform to the type conversion rules described in 2.5. Only when an
operand is of scalar type, it is replicated as needed.</p>
<p>Arithmetic operation example:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span>  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">8</span><span class="o">&gt;</span>   <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">,</span> <span class="n">v3</span><span class="p">;</span>
  <span class="n">matrix</span><span class="o">&lt;</span><span class="n">uint</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">m1</span><span class="p">;</span>
  <span class="n">matrix</span><span class="o">&lt;</span><span class="n">uint</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">m2</span><span class="p">;</span>

  <span class="n">v1</span> <span class="o">=</span> <span class="n">v2</span> <span class="o">+</span> <span class="n">v3</span><span class="p">;</span>
  <span class="n">v1</span> <span class="o">*=</span> <span class="mf">2.0f</span><span class="p">;</span>
  <span class="n">m2</span> <span class="o">=</span> <span class="n">m1</span> <span class="o">-</span> <span class="n">v1</span><span class="p">;</span>   <span class="c1">// the data elements of m1 and v1 are</span>
                  <span class="c1">// selected in row major ordering for the operation</span>
                  <span class="c1">// i.e. v1[0-3] is subtracted from m1.row(0),</span>
                  <span class="c1">// and v1[4-7] is subtracted from m1.row(1).</span>
</pre></div>
</div>
</div>
<div class="section" id="shift-operators">
<h4>3.2.5 Shift Operators<a class="headerlink" href="#shift-operators" title="Permalink to this headline">¶</a></h4>
<p>CM supports the following shift operators for vector/matrix objects:</p>
<p>&gt;&gt;, &lt;&lt;, &gt;&gt;=, &lt;&lt;=</p>
<p>These are all component-wise operations that follow standard C++ rules for the corresponding scalar data
computation.</p>
</div>
<div class="section" id="bitwise-operators">
<h4>3.2.6 Bitwise Operators<a class="headerlink" href="#bitwise-operators" title="Permalink to this headline">¶</a></h4>
<p>CM supports the following bitwise operators for vector/matrix objects:</p>
<p>&amp;, |, ^, !, &amp;=, |=, ^=, ~</p>
<p>These are all component-wise operations that follow standard C++ rules for the corresponding scalar data
computation.</p>
</div>
<div class="section" id="logical-operators">
<h4>3.2.7 Logical Operators<a class="headerlink" href="#logical-operators" title="Permalink to this headline">¶</a></h4>
<p>CM supports logical operators which operate on values that are contextually converted to bool. These
are guaranteed to be evaluated left-to-right within an expression.</p>
<p>&amp;&amp; ||</p>
</div>
<div class="section" id="comparison-operators">
<h4>3.2.8 Comparison Operators<a class="headerlink" href="#comparison-operators" title="Permalink to this headline">¶</a></h4>
<p>CM provides a set of overloaded comparison operators for vector/matrix objects. They perform
component-wise comparison for the operands “x” and “y” and the result value is 0 for False, 1 for True. If
one operand is of scalar type then it is replicated to match the size of another operand.</p>
<ul class="simple">
<li>vector&lt;ushort, size&gt;  operator OP (VM x, VMC y);</li>
<li>vector&lt;ushort, size&gt;  operator OP (VMC x, VM y);</li>
</ul>
<p>Note:</p>
<ul class="simple">
<li>OP is one of {&lt;; &lt;=; &gt;; &gt;=; ==; !=}</li>
<li>VM is any type of vector/vector_ref/matrix/matrix_ref</li>
<li>VMC is any type of vector/vector_ref/matrix/matrix_ref/&lt;scalar_type&gt;</li>
</ul>
<p>The comparison operations can be used for assignment to a mask, as in the following example.</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span>  <span class="n">matrix</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="o">&gt;</span>    <span class="n">m1</span><span class="p">,</span> <span class="n">m2</span><span class="p">;</span>
  <span class="n">matrix</span><span class="o">&lt;</span><span class="n">ushort</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="o">&gt;</span> <span class="n">m_mask</span><span class="p">;</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span>       <span class="n">v</span><span class="p">;</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="n">ushort</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span>    <span class="n">v_mask</span><span class="p">;</span>

  <span class="n">m_mask</span> <span class="o">=</span> <span class="p">(</span> <span class="n">m1</span> <span class="o">&gt;=</span> <span class="n">m2</span> <span class="p">);</span>
  <span class="n">v_mask</span> <span class="o">=</span> <span class="p">(</span> <span class="n">v</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="select-member-functions">
<span id="selectmemberfunctions"></span><h4>3.2.9 Select Member Functions<a class="headerlink" href="#select-member-functions" title="Permalink to this headline">¶</a></h4>
<p>CM provides a set of “select” functions for referencing a subset of the elements of vector/matrix objects.
All these operations (except “iselect” and “replicate”) return a reference to the elements
of matrix/vector objects, so they can be used as L-values in the statements.</p>
<div class="section" id="operator-standard-matrix-vector-element-access-operator">
<h5>() Operator: Standard Matrix/Vector Element-Access Operator<a class="headerlink" href="#operator-standard-matrix-vector-element-access-operator" title="Permalink to this headline">¶</a></h5>
<p>The two basic operators are described below:</p>
<ul class="simple">
<li>operator(ushort i): returns the i-th scalar element of a vector.</li>
<li>operator(ushort i, ushort j): returns the (i, j)-th scalar element of a matrix, where “i” is the index
of a row and “j” is the index of a column (the index starts from 0).</li>
</ul>
<p>() select operation example:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span>  <span class="n">vector</span><span class="o">&lt;</span><span class="n">uint</span><span class="p">,</span> <span class="mi">8</span><span class="o">&gt;</span> <span class="n">v1</span><span class="p">;</span>
  <span class="n">matrix</span><span class="o">&lt;</span><span class="n">uint</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">m1</span><span class="p">;</span>

  <span class="n">m1</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="o">=</span> <span class="n">v1</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
</pre></div>
</div>
<p>Alternatively, CM supports the following syntax that is similar to the standard C array access operator:</p>
</div>
<div class="section" id="id1">
<h5>[] Operator: Standard Matrix/Vector Element-Access Operator<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h5>
<p>The two basic operators are described below:</p>
<ul class="simple">
<li>operator[ushort i]: returns the i-th scalar element of a vector.</li>
<li>operator[ushort i][ushort j]: returns the [i][j]-th scalar element of a matrix, where “i” is the index
of a row and “j” is the index of a column (the index starts from 0)..</li>
</ul>
<p>[] select operation example:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span>  <span class="n">vector</span><span class="o">&lt;</span><span class="n">uint</span><span class="p">,</span> <span class="mi">8</span><span class="o">&gt;</span> <span class="n">v1</span><span class="p">;</span>
  <span class="n">matrix</span><span class="o">&lt;</span><span class="n">uint</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">m1</span><span class="p">;</span>
  <span class="n">matrix</span><span class="o">&lt;</span><span class="n">ushort</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">m2</span><span class="p">;</span>

  <span class="n">m1</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">v1</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
  <span class="n">v1</span><span class="p">[</span><span class="n">m2</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">3</span><span class="p">]]</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="select-sub-matrix-or-sub-vector-selection-with-regular-stride">
<h5>select: Sub-Matrix or Sub-Vector Selection with Regular Stride<a class="headerlink" href="#select-sub-matrix-or-sub-vector-selection-with-regular-stride" title="Permalink to this headline">¶</a></h5>
<p>CM also allows users to select a sub-matrix or sub-vector with regular strides using the following:</p>
<ul class="simple">
<li><strong>select&lt;size, stride&gt;(ushort i=0)</strong>: returns a reference to the sub-vector starting from the i-th
element (“size” indicates the number of selected elements; “stride” indicates the distance
between two adjacent selected elements).</li>
<li><strong>select&lt;v_size, v_stride, h_size, h_stride&gt;(ushort i=0, ushort j=0)</strong>: returns a reference to the sub-
matrix starting from the (i, j)-th element (“v_size” indicates the number of selected rows;
“v_stride” indicates the distance between two adjacent selected rows; “h_size” indicates the
number of selected columns; “h_stride” indicates the distance between two adjacent selected
columns).</li>
</ul>
<p>Sub-matrix/sub-vector select operation example:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span>  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">8</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">;</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">b</span><span class="p">;</span>
  <span class="c1">// ...</span>
  <span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>  <span class="c1">// size=4, stride=2, offset=1 (elements a(1),</span>
                          <span class="c1">// a(3), a(5) and a(7) are copied to b)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/a_dot_select_4,2_(1).png"><img alt="../_images/a_dot_select_4,2_(1).png" src="../_images/a_dot_select_4,2_(1).png" style="width: 600px;" /></a>
<div class="highlight-c++"><div class="highlight"><pre><span></span>  <span class="n">a</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>  <span class="c1">// selected elements of a are replaced</span>
                          <span class="c1">// with elements of b (all elements of b are</span>
                          <span class="c1">// copied to elements a(0), a(2), a(4), a(6))</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/a_dot_select_4,2_(0).png"><img alt="../_images/a_dot_select_4,2_(0).png" src="../_images/a_dot_select_4,2_(0).png" style="width: 600px;" /></a>
<div class="highlight-c++"><div class="highlight"><pre><span></span>  <span class="n">matrix</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="o">&gt;</span>  <span class="n">m1</span><span class="p">;</span>
  <span class="n">matrix</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span>  <span class="n">m2</span><span class="p">;</span>
  <span class="c1">// ...</span>
  <span class="n">m2</span> <span class="o">=</span> <span class="n">m1</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>  <span class="c1">// v_size = 2, v_stride = 2,</span>
                                     <span class="c1">// h_size = 2, h_stride = 4,</span>
                                     <span class="c1">// v_offset = 1, h_offset = 2.</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/m1_dot_select_2,2,2,4_(1,2).png"><img alt="../_images/m1_dot_select_2,2,2,4_(1,2).png" src="../_images/m1_dot_select_2,2,2,4_(1,2).png" style="width: 600px;" /></a>
<div class="highlight-c++"><div class="highlight"><pre><span></span>  <span class="n">m1</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">;</span> <span class="c1">// selected elements of m1</span>
                                      <span class="c1">// are replaced with 0.0f</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/m1_dot_select_4,1,4,2_(0,0).png"><img alt="../_images/m1_dot_select_4,1,4,2_(0,0).png" src="../_images/m1_dot_select_4,1,4,2_(0,0).png" style="width: 600px;" /></a>
<p>Note: CM currently has the following restrictions on “select” operation:</p>
<ul class="simple">
<li>The selected sub-matrix / sub-vector must fit in the original matrix / vector (e.g., a row in the
selected sub-matrix cannot exceed the original matrix width).</li>
<li>The horizontal stride and vertical stride must be greater than 0.</li>
<li>The horizontal / vertical stride must be 1 if the horizontal / vertical size is 1.</li>
</ul>
<p>The following can be used in CM to return a reference to the whole object.</p>
<ul class="simple">
<li><strong>select_all()</strong></li>
</ul>
<p>For instance, for a matrix object this function is equivalent to “select&lt;rows, 1, columns, 1&gt;(0, 0)”, where
(rows, columns) specifies the original matrix size. An example is given below.</p>
<p>Select_all( ) operation example:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;cm/cm.h&gt;</span><span class="cp"></span>

<span class="c1">//A template function that multiplies an arbitrary matrix by 3</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="n">uint</span> <span class="n">R</span><span class="p">,</span> <span class="n">uint</span> <span class="n">C</span><span class="o">&gt;</span>
<span class="n">_GENX_</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="n">mult3</span><span class="p">(</span><span class="n">matrix_ref</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">C</span><span class="o">&gt;</span> <span class="n">par</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">par</span> <span class="o">=</span> <span class="n">par</span> <span class="o">*</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>
   
<span class="n">_GENX_MAIN_</span> <span class="kt">void</span>
<span class="n">kern</span><span class="p">(</span><span class="n">matrix</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">matrix</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">m</span><span class="p">(</span><span class="n">p</span><span class="p">);</span> <span class="c1">// m = p;</span>
  <span class="n">mult3</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">select_all</span><span class="p">());</span>  <span class="c1">// m = p * 3;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="iselect-indirect-select-or-vector-indexing">
<h5>iselect: Indirect-Select or Vector Indexing<a class="headerlink" href="#iselect-indirect-select-or-vector-indexing" title="Permalink to this headline">¶</a></h5>
<p>CM allows selecting a stream of elements from a vector based on the index-values in another vector.
<strong>Doesn’t support Double data type on IVB.</strong></p>
<p><strong>iselect(idx)</strong> – which means indirectly select the vector elements as specified by the index or offset
values  in the vector ‘idx’, and return a new vector of length that is equal to the length of ‘idx’ vector. ‘idx’
vector could be of any arbitrary length. The data type of idx must be unsigned short. An example of its use
is shown below:</p>
<p>iselect(idx) operation example:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span>  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">65</span><span class="o">&gt;</span> <span class="n">inVector</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">8</span><span class="o">&gt;</span>  <span class="n">outVector</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">12</span><span class="o">&gt;</span> <span class="n">tempVector</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="n">ushort</span><span class="p">,</span> <span class="mi">12</span><span class="o">&gt;</span>  <span class="n">idx</span><span class="p">;</span>

  <span class="n">inVector</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">=</span> <span class="mi">19</span><span class="p">;</span> <span class="c1">// Here: inVector(4) = 19, inVector(7) = 19</span>
  <span class="c1">//Now: inVector = {0,0,0,19,0,0,0,19,0...}</span>

  <span class="n">outVector</span> <span class="o">=</span> <span class="n">inVector</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">8</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="c1">//Now: outVector = {0,0,0,19,0,0,0,19}</span>
 
  <span class="n">idx</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span> <span class="n">idx</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">idx</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> <span class="n">idx</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
  <span class="c1">// Now: idx = {2,7,4,10,7,7,7,7,7,7,7,7}</span>

  <span class="n">tempVector</span> <span class="o">=</span> <span class="n">inVector</span><span class="p">.</span><span class="n">iselect</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span>
  <span class="c1">// Now: tempVector = {0,19,19,0,19,19,0,0,0,0}</span>
  
  <span class="n">tempVector</span> <span class="o">=</span> <span class="n">tempVector</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
  <span class="c1">// Now: tempVector = {0,38,38,0,38,38, ... }</span>

  <span class="n">outVector</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">8</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+=</span> <span class="n">tempVector</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">8</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="c1">// Now: outVector = {38,38,0,57,38,38,57,38}</span>
</pre></div>
</div>
<p>CM also allows selecting a stream of elements from a matrix based on vector offsets.</p>
<p><strong>iselect(row, col)</strong> – which means indirectly select the matrix elements as specified by the row and column
indices: row and col, both of which have unsigned short type, and return a new vector of length that is
equal to the length of row or col vector. Note that row and col must have the same length. An example of
its use is shown below.</p>
<p>iselect(row, col) operation example:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span>  <span class="c1">// Here: init_a = {{0, 2}, {4, 6}, {8, 10}, {12, 14}};</span>
  <span class="n">matrix</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">(</span><span class="n">init_a</span><span class="p">);</span>
  <span class="c1">// Here: init_b = {0, 2, 3}; init_c = {1, 0, 0}</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">b</span><span class="p">(</span><span class="n">init_b</span><span class="p">),</span> <span class="n">c</span><span class="p">(</span><span class="n">init_c</span><span class="p">);</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">out</span><span class="p">;</span>
  <span class="n">out</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">iselect</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span> <span class="c1">// out = {2, 8, 12}</span>
</pre></div>
</div>
<p>The iselect method returns a vector or matrix, rather than a vector_ref or a matrix_ref. Therefore iselect
cannot be used as an lvalue.</p>
</div>
<div class="section" id="replicate-source-region-replication-operations">
<h5>replicate: source region replication operations<a class="headerlink" href="#replicate-source-region-replication-operations" title="Permalink to this headline">¶</a></h5>
<p>The replicate operations all operate on linear (one dimensional) regions of matrix/vectors. A row major
layout is assumed for matrix objects in determining the linear order.</p>
<p>The following can be used in CM to replicate a matrix/vector object “REP” times and return a new vector
of “REP” * “rows” * “columns” length, where (rows, columns) specifies the original matrix size.</p>
<ul class="simple">
<li><strong>replicate&lt;REP&gt;()</strong></li>
</ul>
<p>The following can be used in CM to replicate “W” consecutive elements starting at  (i,j)/ (i) from the
matrix/vector object “REP” times, and return a new vector of “REP” * “W” length.</p>
<ul class="simple">
<li><strong>replicate&lt;REP, W&gt;( ushort i=0, ushort j=0) )</strong></li>
<li><strong>replicate&lt;REP, W&gt;( ushort i=0 )</strong></li>
</ul>
<p>The following can be used in CM to select/replicate “REP” blocks of “W” consecutive elements starting at
(i,j)/(i) from the matrix/vector object with each block strided by “VS” elements, and return a new vector
of “REP” * “W” length. Selected blocks of “W” elements will overlap if “VS” &lt; “W”.</p>
<ul class="simple">
<li><strong>replicate&lt;REP, VS, W&gt;( ushort i=0, ushort j=0) )</strong></li>
<li><strong>replicate&lt;REP, VS, W&gt;( ushort i=0 )</strong></li>
</ul>
<p>The following can be used in CM to select/replicate “REP” blocks of “W” sequential elements with a stride
of “HS” starting at  (i,j)/(i) from the matrix/vector object with each block strided by “VS” elements, and
return a new vector of “REP” * “W” length. Selected blocks of “W” elements will overlap if “VS” &lt; “W”.</p>
<ul class="simple">
<li><strong>replicate&lt;REP, VS, W, HS&gt;( ushort i=0, ushort j=0) )</strong></li>
<li><strong>replicate&lt;REP, VS, W, HS&gt;( ushort i=0 )</strong></li>
</ul>
</div>
<div class="section" id="row-and-column-row-and-column-region-selection-operations">
<h5>row and column: Row and column region selection operations<a class="headerlink" href="#row-and-column-row-and-column-region-selection-operations" title="Permalink to this headline">¶</a></h5>
<p>The following can be used in CM to return a reference to the i-th row/column of a matrix object:</p>
<ul class="simple">
<li><strong>row(i)</strong></li>
<li><strong>column(i)</strong></li>
</ul>
<p>Row/column select operation example:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span>  <span class="n">matrix</span><span class="o">&lt;</span><span class="n">uint</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">m</span><span class="p">;</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="n">uint</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span>    <span class="n">v</span><span class="p">;</span>
  <span class="c1">// ...</span>
  <span class="n">v</span> <span class="o">=</span> <span class="n">m</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>         <span class="c1">// the 2nd row of m is copied to v</span>
  <span class="n">m</span><span class="p">.</span><span class="n">column</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>      <span class="c1">// the 3rd column of m are replaced with 0.</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="format-member-functions">
<h4>3.2.10 Format Member Functions<a class="headerlink" href="#format-member-functions" title="Permalink to this headline">¶</a></h4>
<p>The following can be used in CM to reinterpret the basic type (the type of data elements) of a
matrix/vector and change the shape to another matrix/vector.</p>
<ul class="simple">
<li><strong>format&lt;type, rows, columns&gt;( )</strong>: returns a reference to the calling object interpreted as a new
matrix with the shape determined by the template parameters. The size of the new matrix must
not exceed the size of the source object.</li>
<li><strong>format&lt;type&gt;( )</strong>: returns a reference to the calling object interpreted as a new vector with the
size determined by the template type parameter.</li>
</ul>
<p>The object to be formatted must be contiguous and aligned. Generally it is the user’s responsibility to
ensure that the format usage is correct, and a warning is issued for each format operation. When a
discontinuity is determined at compile time the CM compiler will issue an error message.</p>
<p>Format operation example:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span>  <span class="n">matrix</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span>       <span class="n">m1</span><span class="p">;</span>
  <span class="c1">// ...</span>
  <span class="n">matrix_ref</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">16</span><span class="o">&gt;</span> <span class="n">m2</span> <span class="o">=</span> <span class="n">m1</span><span class="p">.</span><span class="n">format</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">16</span><span class="o">&gt;</span><span class="p">(</span> <span class="p">);</span>
  <span class="c1">// m2 is a reference to the location of m1</span>
  <span class="c1">// interpreted as a matrix 4x16 of chars.</span>
  <span class="n">matrix_ref</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="o">&gt;</span>   <span class="n">m3</span> <span class="o">=</span> <span class="n">m1</span><span class="p">.</span><span class="n">format</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="o">&gt;</span><span class="p">(</span> <span class="p">);</span>
  <span class="c1">// m3 is a reference to the location of m1</span>
  <span class="c1">// interpreted as a 2x8 integer matrix.</span>
  <span class="c1">// (assuming little endian layout, i.e.</span>
  <span class="c1">//  the lowest byte address of element</span>
  <span class="c1">//  m1(0,0) is referenced by m2(0,0))</span>

  <span class="n">matrix</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="o">&gt;</span>  <span class="n">m4</span><span class="p">;</span>
  <span class="c1">// ...</span>
  <span class="n">vector_ref</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">16</span><span class="o">&gt;</span> <span class="n">v1</span> <span class="o">=</span> <span class="n">m4</span><span class="p">.</span><span class="n">format</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">();</span>
  <span class="c1">// v1 is a reference to the location of m4</span>
  <span class="c1">// interpreted as a vector of 16 floats.</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="merge-member-functions">
<h4>3.2.11 Merge Member Functions<a class="headerlink" href="#merge-member-functions" title="Permalink to this headline">¶</a></h4>
<p>To model the masked move operations on the target device, CM provides a set of “merge” functions for
vector/matrix objects.</p>
<p>Merge operations with one source operand are defined as follows:</p>
<ul class="simple">
<li>void VM::merge(VMC x, int mask)</li>
<li>void VM::merge(VMC x, VM mask)</li>
</ul>
<p>Note:</p>
<ul class="simple">
<li>VM is any type of vector/vector_ref/matrix/matrix_ref</li>
<li>VMC is any type of vector/vector_ref/matrix/matrix_ref/&lt;scalar_type&gt;</li>
</ul>
<p>The semantic is that if a bit of the mask (or the LSB of the element of a vector/matrix mask) is set, the
value of x (or the corresponding element of x if it is a vector/matrix object) is copied to the corresponding
position of the method’s invoking vector/matrix object.</p>
<p>One-source merge operation example:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span>  <span class="n">matrix</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="o">&gt;</span>   <span class="n">m</span><span class="p">,</span> <span class="n">src</span><span class="p">;</span>
  <span class="n">matrix</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="o">&gt;</span> <span class="n">mask</span><span class="p">;</span>
  <span class="c1">// ...</span>
  <span class="n">m</span><span class="p">.</span><span class="n">merge</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
  <span class="c1">// m           src         mask      ---&gt;  m</span>
  <span class="c1">// 2 2 2 2     4 4 4 4     1 1 0 1         4 4 2 4</span>
  <span class="c1">// 2 2 2 2     4 4 4 4     0 1 1 0         2 4 4 2</span>

  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">imask</span> <span class="o">=</span> <span class="mh">0xA</span><span class="p">;</span>
  <span class="c1">// ...</span>
  <span class="n">v1</span><span class="p">.</span><span class="n">merge</span><span class="p">(</span><span class="n">v2</span><span class="p">,</span> <span class="n">imask</span><span class="p">);</span>
  <span class="c1">// v1          v2          imask     ---&gt;  v1</span>
  <span class="c1">// 2 2 2 2     4 4 4 4     0xA: 1010       2 4 2 4</span>
</pre></div>
</div>
<p>Merge operations with two source operands are defined as follows:</p>
<ul class="simple">
<li>void VM::merge(VMC x, VMC y, int mask)</li>
<li>void VM::merge(VMC x, VMC y, VM mask)</li>
</ul>
<p>Note:</p>
<ul class="simple">
<li>VM is any type of vector/vector_ref/matrix/matrix_ref</li>
<li>VMC is any type of vector/vector_ref/matrix/matrix_ref/&lt;scalar_type&gt;</li>
</ul>
<p>Two-source merge operation example:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span>  <span class="n">matrix</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span>   <span class="n">m</span><span class="p">,</span> <span class="n">src1</span><span class="p">,</span> <span class="n">src2</span><span class="p">;</span>
  <span class="n">matrix</span><span class="o">&lt;</span><span class="n">ushort</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span> <span class="n">mask</span><span class="p">;</span>
  <span class="c1">// ...</span>
  <span class="n">m</span><span class="p">.</span><span class="n">merge</span><span class="p">(</span><span class="n">src1</span><span class="p">,</span> <span class="n">src2</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
  <span class="c1">// m       src_1   src_2   mask   ---&gt;   m</span>
  <span class="c1">// 2 2     4 4     8 8     1 0           4 8</span>
  <span class="c1">// 2 2     4 4     8 8     1 1           4 4</span>
  <span class="c1">// 2 2     4 4     8 8     0 1           8 4</span>
  <span class="c1">// 2 2     4 4     8 8     0 0           8 8</span>
</pre></div>
</div>
<p>The semantic is that if a bit of the mask (or the LSB of the element of a vector/matrix mask) is set, the
value of x (or the corresponding element of x if it is a vector/matrix object) is copied to the corresponding
position of the destination vector/matrix. Otherwise, the value of y (or the corresponding element of y if
it is a vector/matrix object) is copied to the corresponding position of the method’s invoking
vector/matrix object.</p>
</div>
<div class="section" id="boolean-reduction-functions">
<h4>3.2.12 Boolean Reduction Functions<a class="headerlink" href="#boolean-reduction-functions" title="Permalink to this headline">¶</a></h4>
<p>To facilitate boolean operations, CM provides two predefined boolean reduction functions on mask
objects:</p>
<ul>
<li><p class="first">ushort vector&lt;ushort, size&gt;::any(void) / ushort matrix&lt;ushort, R, C&gt;::any(void)</p>
<p>This function will return a 1 if any of the value in the mask is non-zero; it will return 0 otherwise.</p>
</li>
<li><p class="first">ushort vector&lt;ushort, size&gt;::all(void) / ushort matrix&lt;ushort, R, C&gt;::all(void)</p>
<p>This function will return a 1 if all the values in the mask are non-zero; it will return 0 otherwise.</p>
</li>
</ul>
<p>There is no restriction on the size of the mask.  The result of either function can be used as a scalar value
and can be used in the standard C++ control-flow constructs.</p>
<p>Boolean reduction example:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span>  <span class="n">matrix</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="o">&gt;</span> <span class="n">m1</span><span class="p">;</span>
  <span class="c1">// ...</span>
 
  <span class="c1">// Vector mask</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="n">ushort</span><span class="p">,</span> <span class="mi">64</span><span class="o">&gt;</span> <span class="n">v_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">m1</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">ushort</span> <span class="n">result</span> <span class="o">=</span> <span class="n">v_mask</span><span class="p">.</span><span class="n">any</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// At least one value in m1 is &gt; 0</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">v_mask</span><span class="p">.</span><span class="n">all</span><span class="p">())</span> <span class="p">{</span>
    <span class="c1">// All values in m1 are &gt; 0</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
  
  <span class="c1">// Matrix mask</span>
  <span class="n">matrix</span><span class="o">&lt;</span><span class="n">ushort</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="o">&gt;</span> <span class="n">m_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">m1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">m_mask</span><span class="p">.</span><span class="n">all</span><span class="p">())</span> <span class="p">{</span>
    <span class="c1">// All values in m1 are 0</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">((</span><span class="n">m1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">).</span><span class="n">all</span><span class="p">())</span> <span class="p">{</span>
    <span class="c1">// Another way to express the same thing without using an</span>
    <span class="c1">// intermediate variable</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
  <span class="k">while</span> <span class="p">((</span><span class="n">m1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">).</span><span class="n">any</span><span class="p">())</span> <span class="p">{</span>
    <span class="c1">// As long as m1 still has a 0, keep looping...</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="evaluation-order">
<h3><a class="toc-backref" href="#id46">3.3 Evaluation Order</a><a class="headerlink" href="#evaluation-order" title="Permalink to this headline">¶</a></h3>
<p>For all operations (including both scalar and compound data operations), all operands are read first and
then the operation is performed. For the example below, v2 is equal to the result of the
original values of m1’s rows 0 and 1 plus m1’s row 1 and 2.</p>
<p>Evaluation order example:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span>  <span class="n">matrix</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">m1</span><span class="p">;</span>
  <span class="c1">// ...</span>
  <span class="n">vector_ref</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">v1</span><span class="p">(</span><span class="n">m1</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">).</span><span class="n">format</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">());</span>
  <span class="c1">// v1 is a reference to rows 0 and 1 of m1</span>

  <span class="n">vector_ref</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">v2</span><span class="p">(</span><span class="n">m1</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">).</span><span class="n">format</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">());</span>
  <span class="c1">// v2 is a reference to rows 1 and 2 of m1</span>

  <span class="n">v2</span> <span class="o">=</span> <span class="n">v1</span> <span class="o">+</span> <span class="n">v2</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="control-flow">
<h3><a class="toc-backref" href="#id47">3.4 Control flow</a><a class="headerlink" href="#control-flow" title="Permalink to this headline">¶</a></h3>
<p>CM supports both scalar as well as SIMD control flow statements. Control flow statements define control
flow (statement) blocks that are subject to the control condition.</p>
<div class="section" id="scalar-control-flow">
<h4>3.4.1 Scalar control flow<a class="headerlink" href="#scalar-control-flow" title="Permalink to this headline">¶</a></h4>
<p>Scalar control flow in CM is expressed by means of the standard C++ control flow statements – conditional
statements (if-else/switch), loop statements (for/while/do-while), jump statements (break/continue/goto
/return) or function calls.</p>
<p>In scalar control flow statements, the condition must be a scalar and all channels of statements within
scalar control flow blocks are subject to the same scalar condition. The control flow is thus stated to be
uniform for all SIMD channels within control flow blocks. There are no other restrictions imposed by using
just scalar control flow statements.</p>
<p>The boolean reduction example above shows the use of scalar control flow.</p>
</div>
<div class="section" id="simd-control-flow">
<h4>3.4.2 SIMD control flow<a class="headerlink" href="#simd-control-flow" title="Permalink to this headline">¶</a></h4>
<p>SIMD control flow in CM is expressed by means of predefined C++ macros. The predefined macros used to
express SIMD control flow and their scalar equivalents as shown in Table 3-1. The SIMD control flow
statements allow the CM programmer to take advantage of the native SIMD control flow support
available in GenX hardware. The execution semantics of these statements match the corresponding
instructions available in GenX instruction set architecture.</p>
<p>SIMD control flow statements:</p>
<table border="1" class="docutils">
<colgroup>
<col width="18%" />
<col width="46%" />
<col width="36%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Statement type</th>
<th class="head">SIMD control flow statement</th>
<th class="head">Scalar control flow equivalent</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Conditional</td>
<td>SIMD_IF_BEGIN/SIMD_ELSE/
SIMD_ELSEIF/SIMD_IF_END</td>
<td>if-else</td>
</tr>
<tr class="row-odd"><td>Loop</td>
<td>SIMD_DO_WHILE_BEGIN/SIMD_DO_WHILE_END</td>
<td>do-while</td>
</tr>
<tr class="row-even"><td>Jump</td>
<td>SIMD_BREAK/SIMD_CONTINUE</td>
<td>break/continue</td>
</tr>
</tbody>
</table>
<p>In SIMD control flow statements, the condition is generally a SIMD (vector or matrix) condition in place of
a scalar condition. Optionally the condition may also be a scalar  if the SIMD control flow statement is
nested in a SIMD control flow block;
such a scalar is considered to be replicated to the size of the SIMD width of the enclosing SIMD control flow block.
The scalar size of the SIMD condition is stated to be the SIMD width
of the associated block. The SIMD width of a SIMD control flow block with a scalar condition is defined to
be the SIMD width of its enclosing SIMD control flow block.</p>
<p>SIMD control flow is defined on a per channel basis for all statements within a control flow block such that
each channel may take independent control paths within the block. The control flow is thus stated to be
divergent for different channels computed within the block. Generally the scalar size of all statements
(number of channels) within SIMD control flow blocks must correspond with the scalar size of the SIMD
condition, in which case each scalar condition component associates to each corresponding statement
channel; optionally scalar statements with a SIMD width of one are allowed, in which case the scalar
condition associated with the scalar statements is determined to be true if any of the channels in the
SIMD control flow block is active and false otherwise.</p>
<p>SIMD control flow usage example:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span>  <span class="c1">// ...</span>
  <span class="n">SIMD_IF_BEGIN</span> <span class="p">(</span><span class="n">cond</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">}</span> <span class="n">SIMD_ELSE</span> <span class="p">{</span>
    <span class="n">SIMD_IF_BEGIN</span> <span class="p">(</span><span class="n">cond</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">16</span><span class="o">&gt;</span> <span class="n">local</span><span class="p">;</span>
      <span class="c1">// ...</span>
      <span class="n">local</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">16</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">offsetx</span> <span class="o">+</span> <span class="n">offsety</span> <span class="o">*</span> <span class="n">sizex</span><span class="p">);</span>
      <span class="c1">// ...</span>
    <span class="p">}</span> <span class="n">SIMD_ELSE</span> <span class="p">{</span>
      <span class="c1">// ...</span>
    <span class="p">}</span> <span class="n">SIMD_IF_END</span><span class="p">;</span>
  <span class="p">}</span> <span class="n">SIMD_IF_END</span><span class="p">;</span>
  <span class="c1">// ...</span>
  <span class="n">SIMD_DO_WHILE_BEGIN</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">16</span><span class="o">&gt;</span> <span class="n">local</span><span class="p">;</span>
    <span class="c1">// ...</span>
    <span class="n">SIMD_IF_BEGIN</span> <span class="p">(</span><span class="n">local</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">SIMD_BREAK</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">SIMD_IF_END</span><span class="p">;</span>
    <span class="c1">// ...</span>
  <span class="p">}</span> <span class="n">SIMD_DO_WHILE_END</span> <span class="p">(</span><span class="n">cond</span> <span class="o">&lt;</span> <span class="mi">32</span><span class="p">);</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The following constraints are placed on statements appearing within SIMD control flow blocks in order to
guarantee consistent semantics and to allow for an efficient implementation.</p>
<ul class="simple">
<li>The SIMD width of a SIMD control flow block must be a power of two, greater than one and less
than or equal to 16.</li>
<li>Nested SIMD control flow blocks must have the same SIMD width as their enclosing SIMD blocks.
Thus the SIMD width of all nested SIMD control flow blocks is determined by the SIMD width of
outermost SIMD control flow block.</li>
<li>All statements within a SIMD control flow block must either have their SIMD widths correspond
to the SIMD width of its block, or must have a SIMD width equal to one. For statements  that
have destinations, requiring the statement to have a SIMD width equal to the SIMD width of its
block implies that the destinations must be a vector/matrix of SIMD width elements; source
expressions of statements may be either scalars of size one or vectors/matrices of SIMD width
elements as permitted  by the existing CM semantics.</li>
<li>Scalar control flow statements and conditional expressions are not permitted in SIMD control
flow blocks.</li>
<li>Jump statements other than the SIMD_BREAK and SIMD_CONTINUE statements are not allowed
in a SIMD control flow blocks. Likewise SIMD_BREAK and SIMD_CONTINUE statements are not
allowed in a non-SIMD context.</li>
<li>Calling user-defined functions within a SIMD context is not permitted. There are no restrictions
imposed on calling intrinsic functions provided none of the other constraints are violated.</li>
<li>If it is not possible to determine the SIMD width of an statement in a SIMD context, then that
statement is considered illegal in a SIMD context. For example an statement such as (scalar1 *
scalar2) without a destination is considered illegal in SIMD context.</li>
<li>The source operands of CM reduction operators reduction operators (any(), all(), cm_sum(),
cm_prod(), cm_reduction_max(), cm_reduction_min()) are required to have a size equal to the
SIMD width of its immediate context. Furthermore reduction functions will perform reduction
only on active scalar sub-elements of its source as determined by its context’s SIMD mask.</li>
<li>The dot product, the sum of absolute differences and the line operators are not allowed in SIMD
control flow blocks as they operate on tuple variable which are not well-defined when we use
SIMD masks.</li>
<li>Block read/write, sampler, VME and thread communication intrinsics are not allowed in SIMD
control flow context. It is however possible to use scatter read/write statements in a SIMD
context provided the read/write destination/source size is equal to the SIMD width of the block.</li>
</ul>
</div>
</div>
</div>
<div class="section" id="functions">
<h2><a class="toc-backref" href="#id48">4 Functions</a><a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h2>
<div class="section" id="function-qualifiers">
<h3><a class="toc-backref" href="#id49">4.1 Function Qualifiers</a><a class="headerlink" href="#function-qualifiers" title="Permalink to this headline">¶</a></h3>
<p>CM allows the user to write standard C++ functions. In addition, the following attribute qualifiers are used
to specify functions to be compiled for the graphics device. These cannot be used for the functions
running on the host.</p>
<ul>
<li><p class="first">“_GENX_MAIN_” is used to specify a GenX kernel function, which cannot be called from another
kernel function.</p>
<p>_GENX_MAIN_ void kernel(formal_parameters)</p>
<p>The formal parameter declarations must comply with the parameter passing restrictions described in
Section 4.2. There can be more than one kernel function in a file.</p>
</li>
<li><p class="first">“_GENX_” may be used (but is not required) to specify a user defined GenX function, which can be
called from kernel functions or other user defined functions.</p>
<p>_GENX_ [inline] return_type function(formal_ parameters)</p>
<p>The optional “inline” qualifier is used to indicate if the function should be inlined by the CM compiler at
the call site. If a user defined function with the “inline” specifier is not inlined, the CM compiler will
issue a warning/error message.</p>
</li>
</ul>
<p>A “genx_main” kernel function and all of the “genx” functions that it invokes transitively must be in the
same file.</p>
</div>
<div class="section" id="user-defined-functions">
<h3><a class="toc-backref" href="#id50">4.2 User-defined functions</a><a class="headerlink" href="#user-defined-functions" title="Permalink to this headline">¶</a></h3>
<p>CM supports user-defined function calls without recursion.  Parameters to a user-defined CM function
may have scalar type, vector/matrix type, or  SurfaceIndex/SamplerIndex/VmeIndex type.  In addition,
vector_ref and matrix_ref types may be used to pass a vector/matrix object by reference.  A user-defined
function can return scalar values or vector/matrix types. vector_ref/matrix_ref return types are not
supported.</p>
<p>Function usage example:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;cm/cm.h&gt;</span><span class="cp"></span>

<span class="n">_GENX_</span> <span class="n">matrix</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">M</span><span class="p">;</span>                        <span class="c1">// global data declaration</span>

<span class="n">_GENX_</span> <span class="n">matrix</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">plusone</span><span class="p">(</span><span class="n">matrix</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">m</span><span class="o">+</span><span class="mf">1.0f</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">_GENX_</span> <span class="kt">float</span> <span class="n">foo</span><span class="p">(</span><span class="n">matrix</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">m</span><span class="p">)</span>              <span class="c1">// user defined GenX function</span>
<span class="p">{</span>
  <span class="n">matrix</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">newm</span> <span class="o">=</span> <span class="n">plusone</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">cm_sum</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">newm</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">_GENX_</span> <span class="kt">void</span> <span class="n">bar_value</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">16</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">,</span> <span class="kt">float</span> <span class="n">f</span><span class="p">)</span>  <span class="c1">// user defined GenX function</span>
                                                     <span class="c1">// using pass-by-value for &quot;v&quot;</span>
<span class="p">{</span>
  <span class="n">matrix</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">m1</span><span class="p">;</span>
  <span class="n">m1</span> <span class="o">=</span> <span class="n">v</span> <span class="o">+</span> <span class="n">f</span><span class="p">;</span>
  <span class="kt">float</span> <span class="n">s</span> <span class="o">=</span> <span class="n">foo</span><span class="p">(</span><span class="n">m1</span><span class="p">);</span>
  <span class="n">M</span> <span class="o">=</span> <span class="n">m1</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">_GENX_</span> <span class="kt">void</span> <span class="n">bar_ref</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">16</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">,</span> <span class="kt">float</span> <span class="n">f</span><span class="p">,</span>    <span class="c1">// user defined GenX function</span>
                    <span class="n">matrix_ref</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">m</span><span class="p">)</span>       <span class="c1">// using pass-by-reference for &quot;m&quot;</span>
<span class="p">{</span>
  <span class="n">matrix</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">m1</span><span class="p">;</span>
  <span class="n">m1</span> <span class="o">=</span> <span class="n">v</span> <span class="o">+</span> <span class="n">f</span><span class="p">;</span>
  <span class="kt">float</span> <span class="n">s</span> <span class="o">=</span> <span class="n">foo</span><span class="p">(</span><span class="n">m1</span><span class="p">);</span>
  <span class="n">m</span> <span class="o">=</span> <span class="n">m1</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">_GENX_MAIN_</span> <span class="kt">void</span> <span class="n">kernel</span><span class="p">(</span><span class="n">SurfaceIndex</span> <span class="n">inbuf</span><span class="p">,</span> <span class="n">SurfaceIndex</span> <span class="n">outbuf</span><span class="p">,</span> <span class="c1">// GenX kernel function</span>
                        <span class="kt">int</span> <span class="n">x_pos</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y_pos</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">matrix</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">m</span><span class="p">;</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">16</span><span class="o">&gt;</span>   <span class="n">v</span><span class="p">;</span>

  <span class="n">read</span><span class="p">(</span><span class="n">inbuf</span><span class="p">,</span> <span class="n">x_pos</span><span class="p">,</span> <span class="n">y_pos</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>
  <span class="n">v</span> <span class="o">=</span> <span class="n">m</span><span class="p">;</span>
  <span class="n">bar_value</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="mf">0.5f</span><span class="p">);</span>
  <span class="n">write</span><span class="p">(</span><span class="n">outbuf</span><span class="p">,</span> <span class="n">x_pos</span><span class="p">,</span> <span class="n">y_pos</span><span class="p">,</span> <span class="n">M</span><span class="p">);</span>
  <span class="n">bar_ref</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">,</span> <span class="n">M</span><span class="p">);</span>
  <span class="n">write</span><span class="p">(</span><span class="n">outbuf</span><span class="p">,</span> <span class="n">x_pos</span><span class="p">,</span> <span class="n">y_pos</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">M</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In the pass-by-value parameter passing scheme a copy of the function call argument value is associated
with the corresponding subprogram parameter, whereas in the pass-by-reference scheme the address of
the argument is associated with the subprogram pass-by-reference parameter. In the subprogram body
every reference to the pass-by-reference formal becomes an indirect access using the address associated
with the parameter. The pass-by-reference arguments are therefore required to be l-values (named
objects having an address).  Pass-by-reference parameters are declared by specifying the parameter types
to be either of a matrix_ref or vector_ref type.  No other pass-by-reference parameter types are allowed.</p>
<p>The pass-by-reference scheme is useful to copy-out values from the subprogram back to the caller. It also
may be useful to convey large inputs to subprograms, as the amount of parameter conveying code will be
reduced.</p>
<p>There is a restriction imposed on arguments passed by reference in order to allow for an efficient CM
implementation. Specifically the restriction is that for a subprogram that uses pass-by-reference, the
behavior must be the same as if we use a copy-in/copy-out semantic to convey the pass-by-reference
argument; otherwise the CM program is said to be erroneous and may produce incorrect results. Such
errors are not caught by the compiler and it’s up to the user to guarantee safety.</p>
<p>The implication of the above stated restriction is that no pass-by-reference argument that is written to in
a subprogram (either directly or transitively by means of a nested subprogram call pass-by-reference
argument) may overlap with another pass-by-reference parameter or a global variable that is referenced
in the subprogram; in addition no pass-by-reference subprogram argument that is referenced may
overlap with a global variable that is written to in the subprogram.</p>
<p>The reason for the above rule is to allow the implementation to opportunistically use copy-in/copy-out
operations at the call/return sites in order to produce more optimal code by guaranteeing whole register
alignment to the subprogram parameter.</p>
<p>Pass-by-reference parameters may be semantically classified as:</p>
<div class="line-block">
<div class="line">IN  - parameters that are only read</div>
<div class="line">OUT  - parameters that are only written</div>
<div class="line">INOUT - parameters that are both read and written</div>
</div>
<p>An important point to consider when using pass-by-reference parameters is that all reads and writes to
pass-by-reference parameters involve register-indirect operations in GEN ASM. Register-indirect
operations are limited to be SIMD8 (as opposed to SIMD16) in the GEN architecture. In addition there will
be additional address computation code generated. This can result in increased code size if there are a lot
of references to pass-by-ref parameters in the subprogram body. In addition, code involving register-
indirect operations may execute in hardware with more latency because of more conservative
dependency checks in hardware.</p>
<p>Another important point to consider is that arguments of pass-by-reference parameters are enforced to
be whole register aligned at call sites. If the argument cannot be guaranteed to be whole register aligned
then copy-in/copy-out operations are inserted which increases code size. In addition copy-in/copy-out
operations are also inserted if the argument is not contiguous to guarantee correctness; however this is
expected to be rare.</p>
<p>The implications are:</p>
<ol class="arabic simple">
<li>If the IN parameter size is less than or equal to two GRFs it is better to use pass-by-value for it.</li>
<li>OUT parameters are best updated only as a final statement in the subprogram body in order to
reduce code involving register-indirect.</li>
<li>If the arguments to most of the calls involving pass-by-reference IN parameters, are not whole
register aligned then it is disadvantages to use pass-by-reference because of the compiler generated
copy-in operations inserted to guarantee whole register alignment. Pass-by-value should probably
not be used for such parameters. This is because the price paid involves both the copy-in/copy-out
operations as well as the impact of the register-indirect operations. It’s better to use pass-by-value
for IN parameters in such situations.</li>
<li>If the arguments to most of the call to pass-by-reference OUT parameters are not whole register
aligned then it is disadvantages to use pass-by-reference for the same reason as for IN parameters.
For OUT parameters a global variable could be used to convey the return value back to the caller (a
user generated copy-out operation).</li>
<li>If the arguments to most of the calls to pass-by-reference are discontinuous then pass-by-reference
should not be used.</li>
<li>If there are a lot of references to pass-by-reference parameters in the subprogram body, it may be
disadvantageous to use pass-by-reference for the parameter as the amount of register-indirect code
produced increases. On the other hand if the parameter size is large and there are a lot of call sites
then it may be advantageous to use pass-by-reference for the parameter.</li>
</ol>
</div>
<div class="section" id="built-in-functions">
<h3><a class="toc-backref" href="#id51">4.3 Built-in Functions</a><a class="headerlink" href="#built-in-functions" title="Permalink to this headline">¶</a></h3>
<p>CM defines a set of built-in or intrinsic functions that are efficiently translated to GenX instructions based
on the target platform. It is advisable to use the intrinsic functions whenever possible to get better
performance. The intrinsic functions have the following format:</p>
<blockquote>
<div>Intrinsic_Function_Name&lt;Template_Parameters&gt; (Function_ Parameters)</div></blockquote>
<p>The template parameters cannot be variables and are usually optional as they are determined by the
compiler from the types of the function parameters. If present, template parameter ‘T’ represents the
data type of the return value. Most intrinsic functions have a flag parameter, which is a bit mask that
specifies the execution mode (e.g., the SAT bit indicates the saturation mode). Other bits in the flags are
reserved. The default value of the flag is 0.</p>
<p>Usually, the intrinsic functions have the same type restrictions as the corresponding GenX instructions.</p>
<div class="section" id="cm-abs-t">
<h4>cm_abs&lt;T&gt;<a class="headerlink" href="#cm-abs-t" title="Permalink to this headline">¶</a></h4>
<p>Absolute value. The behavior is undefined if the result cannot fit in T.</p>
<ul class="simple">
<li>Parameter 1: matrix(_ref), vector(_ref) or scalar</li>
<li>Parameter 2: flags (default is 0; use SAT for saturation)</li>
<li>Return: vector or scalar</li>
</ul>
</div>
<div class="section" id="cm-add-t">
<h4>cm_add&lt;T&gt;<a class="headerlink" href="#cm-add-t" title="Permalink to this headline">¶</a></h4>
<p>Add.</p>
<ul class="simple">
<li>Parameter 1: matrix(_ref), vector(_ref) or scalar</li>
<li>Parameter 2: matrix(_ref), vector(_ref) or scalar</li>
<li>Parameter 3: flags (default is 0; use SAT for saturation)</li>
<li>Return: vector or scalar</li>
</ul>
</div>
<div class="section" id="cm-mul-t">
<h4>cm_mul&lt;T&gt;<a class="headerlink" href="#cm-mul-t" title="Permalink to this headline">¶</a></h4>
<p>Multiply.</p>
<ul class="simple">
<li>Parameter 1: matrix(_ref), vector(_ref) or scalar</li>
<li>Parameter 2: matrix(_ref), vector(_ref) or scalar</li>
<li>Parameter 3: flags (default is 0; use SAT for saturation)</li>
<li>Return: vector or scalar</li>
</ul>
<p>Restrictions:</p>
<ol class="arabic simple">
<li>The destination cannot be a float if any source operand is an integer;</li>
<li>If one source operand is a float, the other source operand cannot be an integer;</li>
<li>If one source operand is int/uint type, the SAT flag cannot be 1.</li>
</ol>
</div>
<div class="section" id="cm-quot-t">
<h4>cm_quot&lt;T&gt;<a class="headerlink" href="#cm-quot-t" title="Permalink to this headline">¶</a></h4>
<p>Quotient of division.</p>
<ul class="simple">
<li>Parameter 1: matrix(_ref), vector(_ref) or scalar</li>
<li>Parameter 2: matrix(_ref), vector(_ref) or scalar</li>
<li>Parameter 3: flags (default is 0; no saturation available)</li>
<li>Return: vector or scalar</li>
</ul>
<p>Only integer type arguments are supported.</p>
</div>
<div class="section" id="cm-mod-t">
<h4>cm_mod&lt;T&gt;<a class="headerlink" href="#cm-mod-t" title="Permalink to this headline">¶</a></h4>
<p>Remainder (modulus) of division.</p>
<ul class="simple">
<li>Parameter 1: matrix(_ref), vector(_ref) or scalar</li>
<li>Parameter 2: matrix(_ref), vector(_ref) or scalar</li>
<li>Parameter 3: flags (default is 0; no saturation available)</li>
<li>Return: vector or scalar</li>
</ul>
<p>Only integer type arguments are supported.</p>
</div>
<div class="section" id="cm-fmod-t">
<h4>cm_fmod&lt;T&gt;<a class="headerlink" href="#cm-fmod-t" title="Permalink to this headline">¶</a></h4>
<p>Floating-point Remainder, same as C standard function fmod():
cm_fmod(y,x)=r, if y = qx + r where q is an integer and r&lt;x.</p>
<p>NOTE: now part of cmtl; see <a class="reference internal" href="#cmtemplatelibrary"><span class="std std-ref">5 CM Template Library</span></a> (requires cmtl:: namespace)</p>
<ul class="simple">
<li>Parameter 1: matrix(_ref), vector(_ref) or scalar</li>
<li>Parameter 2: matrix(_ref), vector(_ref) or scalar</li>
<li>Parameter 3: flags (default is 0; use SAT for saturation)</li>
<li>Return: vector or scalar</li>
</ul>
<p>Only floating-point type arguments are supported.</p>
</div>
<div class="section" id="cm-div-t">
<h4>cm_div&lt;T&gt;<a class="headerlink" href="#cm-div-t" title="Permalink to this headline">¶</a></h4>
<p>Quotient and remainder of division.</p>
<ul class="simple">
<li>Parameter 1: matrix(_ref), vector(_ref)</li>
<li>Parameter 2: matrix(_ref), vector(_ref) or scalar</li>
<li>Parameter 3: matrix(_ref), vector(_ref) or scalar</li>
<li>Parameter 4: flags (default is 0; no saturation available)</li>
<li>Return: vector or scalar (quotient); the
remainder is returned into the 1st parameter (passed by ref).</li>
</ul>
<p>Only integer type arguments are supported.</p>
</div>
<div class="section" id="cm-avg-t">
<h4>cm_avg&lt;T&gt;<a class="headerlink" href="#cm-avg-t" title="Permalink to this headline">¶</a></h4>
<p>Average value rounded up.</p>
<ul class="simple">
<li>Parameter 1: matrix(_ref), vector(_ref)</li>
<li>Parameter 2: matrix(_ref), vector(_ref) or scalar</li>
<li>Parameter 3: flags (default is 0; use SAT for saturation)</li>
<li>Return: vector or scalar</li>
</ul>
</div>
<div class="section" id="cm-dp2-cm-dp3-cm-dp4">
<h4>cm_dp2, cm_dp3, cm_dp4<a class="headerlink" href="#cm-dp2-cm-dp3-cm-dp4" title="Permalink to this headline">¶</a></h4>
<p>Two-, three- and four-wide dot product.</p>
<ul class="simple">
<li>Parameter 1: matrix(_ref), vector(_ref)</li>
<li>Parameter 2: matrix(_ref), vector(_ref) or scalar</li>
<li>Parameter 3: flags (default is 0; use SAT for saturation)</li>
<li>Return: vector</li>
</ul>
<p>Only floating-point type arguments are supported.</p>
<p>Dot product, line and sum of difference operators are not permitted in a SIMD
control flow context.</p>
<p>cm_dp4 performs the 4-wide dot product operation for each 4-tuple of elements
in the input vector/matrix parameters, and sets the same scalar product result
to each element of the corresponding 4-tuple in the return value.</p>
</div>
<div class="section" id="cm-dph">
<h4>cm_dph<a class="headerlink" href="#cm-dph" title="Permalink to this headline">¶</a></h4>
<p>Four-wide homogeneous dot product.</p>
<ul class="simple">
<li>Parameter 1: matrix(_ref), vector(_ref)</li>
<li>Parameter 2: matrix(_ref), vector(_ref) or scalar</li>
<li>Parameter 3: flags (default is 0; use SAT for saturation)</li>
<li>Return: vector</li>
</ul>
<p>Only floating-point type arguments are supported.</p>
<p>Dot product, line and sum of difference operators are not permitted in a SIMD
control flow context.</p>
</div>
<div class="section" id="cm-frc">
<h4>cm_frc<a class="headerlink" href="#cm-frc" title="Permalink to this headline">¶</a></h4>
<p>Fraction.</p>
<ul class="simple">
<li>Parameter 1: matrix(_ref), vector(_ref)</li>
<li>Return: vector</li>
</ul>
<p>Only floating-point type arguments are supported.</p>
<p>This function returns a vector that contains the fractional portion of each component in the
input vector/matrix.</p>
</div>
<div class="section" id="cm-line">
<h4>cm_line<a class="headerlink" href="#cm-line" title="Permalink to this headline">¶</a></h4>
<p>Component-wise linear equation. First vector provides the scalar
coefficients – Only 1st and 4th element of the vector are used as the two
scalar coefficients needed for this function.</p>
<ul class="simple">
<li>Parameter 1: vector of length 4</li>
<li>Parameter 2: matrix(_ref), vector(_ref), multiple of 8 elements</li>
<li>Parameter 3: flags (default is NOSAT; use SAT for saturation)</li>
<li>Return: vector</li>
</ul>
<p>This function computes the linear equation R[i] = X[0] * Y[i] + X[3] for each element Y[i] in the
second input parameter, and sets the result to the corresponding element R[i] in the return value.
The scalar values X[0] and X[3] used in the linear equation correspond to the first and fourth
elements of the 4-tuple in the first input parameter.</p>
<p>Only floating-point type arguments are supported.</p>
<p>Dot product, line and sum of difference operators are not permitted in a SIMD
control flow context.</p>
</div>
<div class="section" id="cm-lzd">
<h4>cm_lzd<a class="headerlink" href="#cm-lzd" title="Permalink to this headline">¶</a></h4>
<p>Leading zero detection.</p>
<ul class="simple">
<li>Parameter 1: matrix(_ref), vector(_ref) or scalar</li>
<li>Parameter 2: flags (default is 0)</li>
<li>Return: vector or scalar</li>
</ul>
<p>This function computes the number of leading zeros in each component of the
input parameter, and returns the result stored in a vector (for vector/matrix
input parameter) or a scalar (for scalar input parameter).</p>
</div>
<div class="section" id="cm-max-t-cm-min-t">
<h4>cm_max&lt;T&gt;, cm_min&lt;T&gt;<a class="headerlink" href="#cm-max-t-cm-min-t" title="Permalink to this headline">¶</a></h4>
<p>Maximum and minimum.</p>
<ul class="simple">
<li>Parameter 1: matrix(_ref), vector(_ref) or scalar</li>
<li>Parameter 2: matrix(_ref), vector(_ref) or scalar</li>
<li>Parameter 3: saturation (default is NOSAT; use SAT for saturation)</li>
<li>Return: vector or scalar</li>
</ul>
</div>
<div class="section" id="cm-rndd">
<h4>cm_rndd<a class="headerlink" href="#cm-rndd" title="Permalink to this headline">¶</a></h4>
<p>Round down.</p>
<ul class="simple">
<li>Parameter 1: matrix(_ref), vector(_ref) or scalar.</li>
<li>Parameter 2: flags (default is 0; use SAT for saturation).</li>
<li>Return: vector or scalar.</li>
</ul>
</div>
<div class="section" id="cm-floor-t">
<h4>cm_floor&lt;T&gt;<a class="headerlink" href="#cm-floor-t" title="Permalink to this headline">¶</a></h4>
<p>floor(x) is the largest integer not greater than x – same functionality as
cm_rndd.</p>
<p>NOTE: now part of cmtl; see <a class="reference internal" href="#cmtemplatelibrary"><span class="std std-ref">5 CM Template Library</span></a> (requires cmtl:: namespace)</p>
<ul class="simple">
<li>Parameter 1: matrix(_ref), vector(_ref) or scalar.</li>
<li>Parameter 2: flags (default is 0; use SAT for saturation).</li>
<li>Return: vector or scalar.</li>
</ul>
</div>
<div class="section" id="cm-rndu">
<h4>cm_rndu<a class="headerlink" href="#cm-rndu" title="Permalink to this headline">¶</a></h4>
<p>Round up.</p>
<ul class="simple">
<li>Parameter 1: matrix(_ref), vector(_ref) or scalar.</li>
<li>Parameter 2: flags (default is 0; use SAT for saturation).</li>
<li>Return: vector or scalar.</li>
</ul>
</div>
<div class="section" id="cm-ceil-t">
<h4>cm_ceil&lt;T&gt;<a class="headerlink" href="#cm-ceil-t" title="Permalink to this headline">¶</a></h4>
<p>ceil(x) is the smallest integer not less than x – same functionality as
cm_rndu.</p>
<p>NOTE: now part of cmtl; see <a class="reference internal" href="#cmtemplatelibrary"><span class="std std-ref">5 CM Template Library</span></a> (requires cmtl:: namespace)</p>
<ul class="simple">
<li>Parameter 1: matrix(_ref), vector(_ref) or scalar.</li>
<li>Parameter 2: flags (default is 0; use SAT for saturation).</li>
<li>Return: vector or scalar.</li>
</ul>
</div>
<div class="section" id="cm-rnde">
<h4>cm_rnde<a class="headerlink" href="#cm-rnde" title="Permalink to this headline">¶</a></h4>
<p>Round even.</p>
<ul class="simple">
<li>Parameter 1: matrix(_ref), vector(_ref) or scalar.</li>
<li>Parameter 2: flags (default is 0; use SAT for saturation).</li>
<li>Return: vector or scalar.</li>
</ul>
</div>
<div class="section" id="cm-rndz">
<h4>cm_rndz<a class="headerlink" href="#cm-rndz" title="Permalink to this headline">¶</a></h4>
<p>Round zero.</p>
<ul class="simple">
<li>Parameter 1: matrix(_ref), vector(_ref) or scalar.</li>
<li>Parameter 2: flags (default is 0; use SAT for saturation).</li>
<li>Return: vector or scalar.</li>
</ul>
</div>
<div class="section" id="cm-sad2-t">
<h4>cm_sad2&lt;T&gt;<a class="headerlink" href="#cm-sad2-t" title="Permalink to this headline">¶</a></h4>
<p>Two-wide sum of absolute difference.</p>
<ul class="simple">
<li>Parameter 1: matrix(_ref), vector(_ref)</li>
<li>Parameter 2: matrix(_ref), vector(_ref) or scalar</li>
<li>Parameter 3: flags (default is 0; use SAT for saturation).</li>
<li>Return: vector or scalar</li>
</ul>
<p>In a SIMD control flow context reduction functions will perform reduction only
on active channels of its source as determined by its context’s SIMD mask.</p>
<p>Dot product, line and sum of difference operators are not permitted in a SIMD
control flow context.</p>
</div>
<div class="section" id="cm-sada2-t">
<h4>cm_sada2&lt;T&gt;<a class="headerlink" href="#cm-sada2-t" title="Permalink to this headline">¶</a></h4>
<p>Compute two-wide sum of absolute difference between src1 and src2, add that to
src3, and store the result to the first channel per 2-tuple in dst.</p>
<ul class="simple">
<li>Parameter 1: matrix(_ref) or  vector(_ref)</li>
<li>Parameter 2: matrix(_ref), vector(_ref) or scalar</li>
<li>Parameter 3: matrix(_ref) or vector(_ref)</li>
<li>Parameter 4: flags (default is 0; use SAT for saturation).</li>
<li>Return: vector or scalar</li>
</ul>
<p>In a SIMD control flow context reduction functions will perform reduction only
on active channels of its source as determined by its context’s SIMD mask.</p>
<p>Dot product, line and sum of difference operators are not permitted in a SIMD
control flow context.</p>
</div>
<div class="section" id="cm-sum-t">
<h4>cm_sum&lt;T&gt;<a class="headerlink" href="#cm-sum-t" title="Permalink to this headline">¶</a></h4>
<p>Sum of all elements.</p>
<ul class="simple">
<li>Parameter 1: matrix(_ref) or vector(_ref).</li>
<li>Parameter 2: saturation (default is NOSAT; use SAT for saturation).</li>
<li>Return: scalar.</li>
</ul>
<p>In a SIMD control flow context reduction functions will perform reduction only
on active channels of its source as determined by its context’s SIMD mask.</p>
<p>The order of continuant scalar operation is not guaranteed and the
correctness of result should not depend on computation order.</p>
</div>
<div class="section" id="cm-reduced-min-t">
<h4>cm_reduced_min&lt;T&gt;<a class="headerlink" href="#cm-reduced-min-t" title="Permalink to this headline">¶</a></h4>
<p>Find the minimum element of a matrix/vector. T is the type of the elements.</p>
<ul class="simple">
<li>Parameter 1: matrix(_ref) or vector(_ref).</li>
<li>Parameter 2: saturation (default is NOSAT; use SAT for saturation).</li>
<li>Return: scalar.</li>
</ul>
<p>In a SIMD control flow context reduction functions will perform reduction only
on active channels of its source as determined by its context’s SIMD mask.</p>
</div>
<div class="section" id="cm-reduced-max-t">
<h4>cm_reduced_max&lt;T&gt;<a class="headerlink" href="#cm-reduced-max-t" title="Permalink to this headline">¶</a></h4>
<p>Find the maximum element of a matrix/vector. T is the type of the elements.</p>
<ul class="simple">
<li>Parameter 1: matrix(_ref) or vector(_ref).</li>
<li>Parameter 2: saturation (default is NOSAT; use SAT for saturation).</li>
<li>Return: scalar.</li>
</ul>
<p>In a SIMD control flow context reduction functions will perform reduction only
on active channels of its source as determined by its context’s SIMD mask.</p>
</div>
<div class="section" id="cm-prod-t">
<h4>cm_prod&lt;T&gt;<a class="headerlink" href="#cm-prod-t" title="Permalink to this headline">¶</a></h4>
<p>Product of all elements.</p>
<ul class="simple">
<li>Parameter 1: matrix(_ref) or vector(_ref).</li>
<li>Parameter 2: saturation (default is NOSAT; use SAT for saturation).</li>
<li>Return: scalar4.</li>
</ul>
<p>Restrictions:</p>
<ol class="arabic simple">
<li>The destination cannot be a float if any source operand is an integer;</li>
<li>If one source operand is a float, the other source operand cannot be an integer;</li>
<li>If one source operand is int/uint type, the SAT flag cannot be 1.</li>
</ol>
<p>The order of continuant scalar operation is not guaranteed and the
correctness of result should not depend on computation order.</p>
<p>This operation is currently not supported in the SIMD control flow context.</p>
</div>
<div class="section" id="cm-inv">
<h4>cm_inv<a class="headerlink" href="#cm-inv" title="Permalink to this headline">¶</a></h4>
<p>Inversion (dst = 1.0/src).</p>
<ul class="simple">
<li>Parameter 1: matrix(_ref), vector(_ref) or
scalar</li>
<li>Parameter 2: flags (default is 0; use SAT for saturation).</li>
<li>Return: vector or scalar</li>
</ul>
<p>Only half and single precision floating-point type arguments are supported.</p>
</div>
<div class="section" id="cm-log">
<h4>cm_log<a class="headerlink" href="#cm-log" title="Permalink to this headline">¶</a></h4>
<p>Logarithm of base 2.
* Parameter 1: matrix(_ref), vector(_ref) or scalar
* Parameter 2: flags (default is 0; use SAT for saturation)
* Return: vector or scalar</p>
<p>Restrictions:</p>
<ol class="arabic simple">
<li>The destination cannot be a floating-point type if any source operand is an integer;</li>
<li>If one source operand is a floating-point type, the other source operand cannot be an integer;</li>
<li>If one source operand is int/uint type, the SAT flag cannot be 1.</li>
<li>double-precision floating-point types are not supported.</li>
</ol>
</div>
<div class="section" id="cm-exp">
<h4>cm_exp<a class="headerlink" href="#cm-exp" title="Permalink to this headline">¶</a></h4>
<p>Exponent of base 2.</p>
<ul class="simple">
<li>Parameter 1: matrix(_ref), vector(_ref) or
scalar</li>
<li>Parameter 2: flags (default is 0; use SAT for saturation).</li>
<li>Return: vector or scalar</li>
</ul>
<p>Only half and single precision floating-point type arguments are supported.</p>
</div>
<div class="section" id="cm-sqrt">
<h4>cm_sqrt<a class="headerlink" href="#cm-sqrt" title="Permalink to this headline">¶</a></h4>
<p>Square root.</p>
<ul class="simple">
<li>Parameter 1: matrix(_ref), vector(_ref) or scalar</li>
<li>Parameter 2: flags (default is 0; use SAT for saturation).</li>
<li>Return: vector or scalar</li>
</ul>
<p>Only half and single precision floating-point type arguments are supported.</p>
</div>
<div class="section" id="cm-sqrt-ieee">
<h4>cm_sqrt_ieee<a class="headerlink" href="#cm-sqrt-ieee" title="Permalink to this headline">¶</a></h4>
<p>Square root with IEEE compliant semantics.</p>
<ul class="simple">
<li>Parameter 1: matrix(_ref), vector(_ref) or scalar</li>
<li>Parameter 2: flags (default is 0; use SAT for saturation).</li>
<li>Return: vector or scalar</li>
</ul>
<p>Only single or double precision floating-point type arguments are supported.</p>
</div>
<div class="section" id="cm-rsqrt">
<h4>cm_rsqrt<a class="headerlink" href="#cm-rsqrt" title="Permalink to this headline">¶</a></h4>
<p>dst = 1.0/sqrt(src).</p>
<ul class="simple">
<li>Parameter 1: matrix(_ref), vector(_ref) or scalar</li>
<li>Parameter 2: flags (default is 0; use SAT for saturation)</li>
<li>Return: vector or scalar</li>
</ul>
<p>Only half or single precision floating-point type arguments are supported.</p>
</div>
<div class="section" id="cm-pow">
<h4>cm_pow<a class="headerlink" href="#cm-pow" title="Permalink to this headline">¶</a></h4>
<p>Power.</p>
<ul class="simple">
<li>Parameter 1: matrix(_ref), vector(_ref) or scalar</li>
<li>Parameter 2: scalar for Gen6, matrix(_ref),
vector(_ref) or scalar for Gen6.</li>
<li>Parameter 3: flags (default is 0; use SAT for saturation).</li>
<li>Return: vector or scalar</li>
</ul>
<p>Only half or single precision floating-point type arguments are supported.</p>
</div>
<div class="section" id="cm-sin">
<h4>cm_sin<a class="headerlink" href="#cm-sin" title="Permalink to this headline">¶</a></h4>
<p>Sine.
* Parameter 1: matrix(_ref), vector(_ref) or scalar
* Parameter 2: flags (default is 0; use SAT for saturation).
* Return: vector or scalar</p>
<p>Only half and single precision floating-point type arguments are supported.</p>
</div>
<div class="section" id="cm-cos">
<h4>cm_cos<a class="headerlink" href="#cm-cos" title="Permalink to this headline">¶</a></h4>
<p>Cosine.</p>
<ul class="simple">
<li>Parameter 1: matrix(_ref), vector(_ref) or
scalar</li>
<li>Parameter 2: flags (default is 0; use SAT for saturation).</li>
<li>Return: vector or scalar</li>
</ul>
<p>Only half and single precision floating-point type arguments are supported.</p>
</div>
<div class="section" id="cm-sincos">
<h4>cm_sincos<a class="headerlink" href="#cm-sincos" title="Permalink to this headline">¶</a></h4>
<p>Sine and cosine.</p>
<ul class="simple">
<li>Parameter 1:  matrix_ref, vector_ref</li>
<li>Parameter 2: matrix(_ref) or vector(_ref)</li>
<li>Parameter 3: flags (default is 0; use SAT for saturation)</li>
<li>Return: vector or matrix (sine) and cosine
into the 1st parameter (passed by ref)</li>
</ul>
<p>Only half and single precision floating-point type arguments are supported.</p>
</div>
<div class="section" id="cm-asin">
<h4>cm_asin<a class="headerlink" href="#cm-asin" title="Permalink to this headline">¶</a></h4>
<p>Inverse function of sine.</p>
<ul class="simple">
<li>Parameter 1: matrix(_ref), vector(_ref) or scalar</li>
<li>Parameter 2: flags (default is 0; use SAT for saturation).</li>
<li>Return: vector or scalar</li>
</ul>
<p>Only floating-point type arguments are supported.</p>
</div>
<div class="section" id="cm-acos">
<h4>cm_acos<a class="headerlink" href="#cm-acos" title="Permalink to this headline">¶</a></h4>
<p>Inverse function of cosine.</p>
<ul class="simple">
<li>Parameter 1: matrix(_ref), vector(_ref) or scalar</li>
<li>Parameter 2: flags (default is 0; use SAT for saturation).</li>
<li>Return: vector or scalar</li>
</ul>
<p>Only floating-point type arguments are supported.</p>
</div>
<div class="section" id="cm-atan">
<h4>cm_atan<a class="headerlink" href="#cm-atan" title="Permalink to this headline">¶</a></h4>
<p>Inverse function of tangent.</p>
<ul class="simple">
<li>Parameter 1: matrix(_ref), vector(_ref) or scalar</li>
<li>Parameter 2: flags (default is 0; use SAT for saturation).</li>
<li>Return: vector or scalar</li>
</ul>
<p>Only floating-point type arguments are supported.</p>
</div>
<div class="section" id="cm-atan2">
<h4>cm_atan2<a class="headerlink" href="#cm-atan2" title="Permalink to this headline">¶</a></h4>
<p>Same as C standard function atan2().</p>
<p>NOTE: now part of cmtl; see <a class="reference internal" href="#cmtemplatelibrary"><span class="std std-ref">5 CM Template Library</span></a> (requires cmtl:: namespace)</p>
<ul class="simple">
<li>Parameter 1: matrix(_ref), vector(_ref) or scalar</li>
<li>Parameter 2: matrix(_ref), vector(_ref) or scalar</li>
<li>Parameter 3: flags (default is 0; use SAT for saturation).</li>
<li>Return: matrix, vector or scalar</li>
</ul>
<p>Only floating-point type arguments are supported.</p>
</div>
<div class="section" id="cm-atan2-fast">
<h4>cm_atan2_fast<a class="headerlink" href="#cm-atan2-fast" title="Permalink to this headline">¶</a></h4>
<p>Faster version of cm_atan2, but has a lower precision – only accurate up to
0.01, where cm_atan2 is precise up to 0.00001.</p>
<p>NOTE: now part of cmtl; see <a class="reference internal" href="#cmtemplatelibrary"><span class="std std-ref">5 CM Template Library</span></a> (requires cmtl:: namespace)</p>
<ul class="simple">
<li>Parameter 1: matrix(_ref), vector(_ref) or scalar</li>
<li>Parameter 2: matrix(_ref), vector(_ref) or scalar</li>
<li>Parameter 3: flags (default is 0; use SAT for saturation).</li>
<li>Return: matrix, vector or scalar</li>
</ul>
<p>Only floating-point type arguments are supported.</p>
</div>
<div class="section" id="cm-div-ieee">
<h4>cm_div_ieee<a class="headerlink" href="#cm-div-ieee" title="Permalink to this headline">¶</a></h4>
<p>Division with IEEE compliant semantics.</p>
<ul class="simple">
<li>Parameter 1: matrix(_ref), vector(_ref) or scalar</li>
<li>Parameter 2: matrix(_ref), vector(_ref) or scalar</li>
<li>Parameter 3: flags (default is 0; use SAT for saturation)</li>
<li>Return: vector or scalar.</li>
</ul>
<p>Only single or double precision floating-point type arguments are supported.</p>
</div>
<div class="section" id="cm-imul">
<h4>cm_imul<a class="headerlink" href="#cm-imul" title="Permalink to this headline">¶</a></h4>
<p>Hi 32 bits and low 32 bits of the 64-bit result of integer multiply.</p>
<ul class="simple">
<li>Parameter 1:  matrix(_ref), vector(_ref)</li>
<li>Parameter 2: matrix(_ref) or vector(_ref) or scalar</li>
<li>Parameter 3: matrix(_ref) or vector(_ref) or scalar</li>
<li>Parameter 4: flags (default is 0; no saturation available)</li>
<li>Return: vector or scalar (hi 32 bits); the
low 32 bits is returned into the 1st
parameter (passed by ref)</li>
</ul>
<p>Only integer type arguments are supported.</p>
</div>
<div class="section" id="cm-pack-mask">
<h4>cm_pack_mask<a class="headerlink" href="#cm-pack-mask" title="Permalink to this headline">¶</a></h4>
<p>Pack a vector / matrix mask into an integer</p>
<ul class="simple">
<li>Parameter 1:  matrix(_ref), vector(_ref) .</li>
<li>Return: scalar.</li>
</ul>
<p>The vector/matrix data type must be unsigned short, and the size must be 8, 16, or 32.</p>
<p>This operation is currently not supported in the SIMD control flow context.</p>
</div>
<div class="section" id="cm-unpack-mask-t-sz">
<h4>cm_unpack_mask&lt;T, SZ&gt;<a class="headerlink" href="#cm-unpack-mask-t-sz" title="Permalink to this headline">¶</a></h4>
<p>Unpack an integer to a vector mask</p>
<ul class="simple">
<li>Parameter 1:  scalar.</li>
<li>Return: vector</li>
</ul>
<p>The vector/matrix data type must be unsigned short, and the size must be 8, 16, or 32.</p>
<p>This operation is currently not supported in the SIMD control flow context.</p>
</div>
<div class="section" id="cm-cbit-gen7">
<h4>cm_cbit {Gen7+}<a class="headerlink" href="#cm-cbit-gen7" title="Permalink to this headline">¶</a></h4>
<p>Count component-wise the total bits set in source operand .</p>
<ul class="simple">
<li>Parameter 1:  matrix(_ref), vector(_ref) or scalar.</li>
<li>Return: vector or scalar.</li>
</ul>
<p>The source operand must be of “int” type. The destination operand must be of
“unsigned int” type.</p>
</div>
<div class="section" id="cm-fbl-gen7">
<h4>cm_fbl {Gen7+}<a class="headerlink" href="#cm-fbl-gen7" title="Permalink to this headline">¶</a></h4>
<p>Find component-wise the first bit from LSB side.</p>
<ul class="simple">
<li>Parameter 1:  matrix(_ref), vector(_ref) or scalar</li>
<li>Return: vector or scalar</li>
</ul>
<p>The source operand must be of integer type.
The destination operand must be of “unsigned int” type.
If the source operand is equal to 0, returns 0xFFFFFFFF.</p>
</div>
<div class="section" id="cm-fbh-gen7">
<h4>cm_fbh {Gen7+}<a class="headerlink" href="#cm-fbh-gen7" title="Permalink to this headline">¶</a></h4>
<p>Find component-wise the first bit from MSB side.</p>
<ul class="simple">
<li>Parameter 1:  matrix(_ref), vector(_ref) or scalar.</li>
<li>Return: vector.</li>
</ul>
<p>Both the source and destination operands must be of the same “int” or “unsigned
int” type. If the source operand type is unsigned, returns the count of leading
zeros from the MSB side. If the source operand type is signed and positive,
returns the count of leading zeros from MSB side. If the operand type is signed
and negative, returns the count of leading ones from MSB side. If the source
operand is equal to 0 and the type is unsigned, returns 0xFFFFFFFF. If the
source operand is equal to 0 or 0xFFFFFFFF and the type is signed, returns
0xFFFFFFFF.</p>
</div>
<div class="section" id="cm-rdtsc">
<h4>cm_rdtsc<a class="headerlink" href="#cm-rdtsc" title="Permalink to this headline">¶</a></h4>
<p>Returns time stamp information as a vector of 4 32bit values: 1st and 2nd are
the low and high bits of the 64bit timestamp, 3rd contain a bit that is set
when a context switch occurs, and the 4th is unused.</p>
<ul class="simple">
<li>Return: vector</li>
</ul>
<p>The return vector data type must be unsigned int.</p>
</div>
<div class="section" id="cm-shr">
<h4>cm_shr<a class="headerlink" href="#cm-shr" title="Permalink to this headline">¶</a></h4>
<p>Perform right bit shift. The sign of parameter 1 dictates what operation is actually carred out and
this matches the behavior of the &gt;&gt; operator (lsr for unsigned, asr for signed)</p>
<ul class="simple">
<li>Parameter 1:  matrix(_ref), vector(_ref)</li>
<li>Parameter 2:  matrix(_ref), vector(_ref)</li>
<li>Parameter 3:  saturation (default is NOSAT; use SAT for saturation)</li>
<li>Return: vector</li>
</ul>
<p>Only bits 0-5 are read from second operand, MSBs are disregarded.</p>
<p>Note: It is usually simpler to use the &gt;&gt; operator with appropriate cast to an unsigned or signed
type to get the desired behavior from &gt;&gt;, followed by an optional saturation intrinsic to achieve
the same effect for the same cost and with clearer meaning.</p>
</div>
<div class="section" id="cm-lsr">
<h4>cm_lsr<a class="headerlink" href="#cm-lsr" title="Permalink to this headline">¶</a></h4>
<p>Perform logical right bit shift.</p>
<ul class="simple">
<li>Parameter 1:  matrix(_ref), vector(_ref)</li>
<li>Parameter 2:  matrix(_ref), vector(_ref)</li>
<li>Parameter 3:  saturation (default is NOSAT; use SAT for saturation)</li>
<li>Return: vector</li>
</ul>
<p>The semantics of the operation are the usual integer promotions but with an implicit cast to an
unsigned type prior to the shift. This can be described by the following pseudo code:</p>
<ul class="simple">
<li>Parameter 1 is cast according to integer promotion rules for bitwise shift (e.g. char -&gt; int)</li>
<li>Result of this case is then cast to equivalent unsigned type (e.g. int -&gt; unsigned int)</li>
<li>Result of this is then shifted (e.g. Val &gt;&gt; Parameter 2)</li>
<li>Result is then converted to the result type with optional saturation</li>
</ul>
<p>Only bits 0-5 are read from second operand, MSBs are disregarded.</p>
<p>Note: It is usually simpler to use the &gt;&gt; operator with appropriate cast to an unsigned type,
followed by an optional saturation intrinsic to achieve the same effect for the same cost and with
clearer meaning.</p>
</div>
<div class="section" id="cm-asr">
<h4>cm_asr<a class="headerlink" href="#cm-asr" title="Permalink to this headline">¶</a></h4>
<p>Perform arithmetic right bit shift.</p>
<ul class="simple">
<li>Parameter 1:  matrix(_ref), vector(_ref)</li>
<li>Parameter 2:  matrix(_ref), vector(_ref)</li>
<li>Parameter 3:  saturation (default is NOSAT; use SAT for saturation)</li>
<li>Return: vector</li>
</ul>
<p>The semantics of the operation are the usual integer promotions but with an implicit cast to a
signed type prior to the shift. This can be described by the following pseudo code:</p>
<ul class="simple">
<li>Parameter 1 is cast according to integer promotion rules for bitwise shift (e.g. unsigned char -&gt; unsigned int)</li>
<li>Result of this case is then cast to equivalent signed type (e.g. unsigned int -&gt; int)</li>
<li>Result of this is then shifted (i.e. Val &gt;&gt; Parameter 2)</li>
<li>Result is then converted to the result type with optional saturation</li>
</ul>
<p>Only bits 0-5 are read from second operand, MSBs are disregarded.</p>
<p>Note: It is usually simpler to use the &gt;&gt; operator with appropriate cast to a signed type,
followed by an optional saturation intrinsic to achieve the same effect for the same cost and with
clearer meaning.</p>
</div>
<div class="section" id="cm-shl">
<h4>cm_shl<a class="headerlink" href="#cm-shl" title="Permalink to this headline">¶</a></h4>
<p>Perform logical left bit shift.</p>
<ul class="simple">
<li>Parameter 1:  matrix(_ref), vector(_ref)</li>
<li>Parameter 2:  matrix(_ref), vector(_ref)</li>
<li>Parameter 3:  saturation (default is NOSAT; use SAT for saturation), if
33 bits are over flown behavior is
undefined. Only lower 5 bits of src 2
are used for shifting.</li>
<li>Return: vector</li>
</ul>
<p>Parameter 1 should be of unsigned type, otherwise behavior is unspecified.</p>
<p>Only bits 0-5 are read from second operand, MSBs are disregarded.</p>
</div>
<div class="section" id="cm-pln">
<h4>cm_pln<a class="headerlink" href="#cm-pln" title="Permalink to this headline">¶</a></h4>
<p>Component-wise plane function:
dst[i] =
src0[0] * src1[i] +
src0[1] * src2[i] +
src0[3]</p>
<ul class="simple">
<li>Parameter 1: vector of length 4</li>
<li>Parameter 2: matrix(_ref) or vector(_ref)</li>
<li>Parameter 3: matrix(_ref) or vector(_ref)</li>
<li>Parameter 4: saturation (default is NOSAT; use SAT for saturation)</li>
<li>Return: vector.</li>
</ul>
<p>This is not allowed in SIMD Control Flow context. The size of destination,
2nd and 3rd source operands must be a multiple of 8. The operand type must be
float.</p>
</div>
<div class="section" id="cm-lrp">
<h4>cm_lrp<a class="headerlink" href="#cm-lrp" title="Permalink to this headline">¶</a></h4>
<p>Component-wise linear interpolation function:
dst[i] =
src1[i]*src0[i] +
src2[i]*(1.0 - src0[i])</p>
<ul class="simple">
<li>Parameter 1: matrix(_ref) or vector(_ref)</li>
<li>Parameter 2: matrix(_ref) or vector(_ref)</li>
<li>Parameter 3: matrix(_ref) or vector(_ref)</li>
<li>Return: vector.</li>
</ul>
<p>This is not allowed in SIMD Control Flow context. The operand type must be
float and the size must be a multiple of 4.</p>
</div>
<div class="section" id="cm-bf-insert">
<h4>cm_bf_insert<a class="headerlink" href="#cm-bf-insert" title="Permalink to this headline">¶</a></h4>
<p>Bitfield insert.</p>
<p>Dst = src with bits defined as width bits starting at offset
replaced with value.</p>
<p>Only int and uint
supported.</p>
<ul class="simple">
<li>Parameter 1: width (vector)</li>
<li>Parameter 2: offset (vector)</li>
<li>Parameter 3: val (vector)</li>
<li>Parameter 4: src (vector)</li>
<li>Return: vector</li>
</ul>
</div>
<div class="section" id="cm-bf-extract">
<h4>cm_bf_extract<a class="headerlink" href="#cm-bf-extract" title="Permalink to this headline">¶</a></h4>
<p>Bitfield extract.</p>
<p>Dst = field from src
at offset for width
bits.</p>
<p>Dst sign extended
for signed types.</p>
<p>Only int and uint
supported.</p>
<ul class="simple">
<li>Parameter 1: width (vector)</li>
<li>Parameter 2: offset (vector)</li>
<li>Parameter 3: src (vector)</li>
<li>Return: vector</li>
</ul>
</div>
<div class="section" id="cm-bf-reverse">
<h4>cm_bf_reverse<a class="headerlink" href="#cm-bf-reverse" title="Permalink to this headline">¶</a></h4>
<p>Bitfield reverse.
Bitwise reverse of unsigned 32 bit src operand.</p>
<ul class="simple">
<li>Parameter 1: src (vector)</li>
<li>Return: vector</li>
</ul>
<p>An example of intrinsic function usage:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span>  <span class="n">matrix</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span>  <span class="n">angle</span><span class="p">;</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span>  <span class="n">r</span><span class="p">;</span>
  <span class="c1">// angle = ...;</span>
  <span class="c1">// r = ...;</span>

  <span class="c1">//Possible values of the elements of r is 0, 1, 2, ... 255</span>
  <span class="n">r</span> <span class="o">=</span> <span class="n">cm_mul</span><span class="o">&lt;</span><span class="n">uchar</span><span class="o">&gt;</span><span class="p">(</span><span class="n">cm_sin</span><span class="p">(</span><span class="n">angle</span><span class="p">),</span> <span class="n">r</span><span class="p">,</span> <span class="n">SAT</span><span class="p">);</span>

  <span class="n">matrix</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span>  <span class="n">m1</span><span class="p">(</span><span class="mi">20000</span><span class="p">),</span> <span class="n">m2</span><span class="p">(</span><span class="mi">20000</span><span class="p">);</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="mi">6</span><span class="o">&gt;</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">;</span>
  <span class="c1">//</span>
  <span class="n">v1</span> <span class="o">=</span> <span class="n">cm_add</span><span class="o">&lt;</span><span class="kt">short</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m1</span><span class="p">,</span> <span class="n">m2</span><span class="p">,</span> <span class="n">SAT</span><span class="p">);</span>  <span class="c1">// v1 = 32767</span>
  <span class="n">v2</span> <span class="o">=</span> <span class="n">cm_add</span><span class="o">&lt;</span><span class="kt">short</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m1</span><span class="p">,</span> <span class="n">m2</span><span class="p">);</span>       <span class="c1">// v2 = -25536</span>
  <span class="c1">//</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">8</span><span class="o">&gt;</span> <span class="n">v3</span><span class="p">;</span> <span class="c1">// v3 = {1.0, 1.0, 1.0, 1.0, 2.0, 2.0, 2.0, 2.0};</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">8</span><span class="o">&gt;</span> <span class="n">v4</span><span class="p">;</span> <span class="c1">// v4 = {0.2, 0.2, 0.2, 0.2, 0.3, 0.3, 0.3, 0.3};</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">8</span><span class="o">&gt;</span> <span class="n">v5</span><span class="p">;</span>
  <span class="c1">// ...</span>
  <span class="n">v5</span> <span class="o">=</span> <span class="n">cm_dp4</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">v3</span><span class="p">,</span> <span class="n">v4</span><span class="p">);</span>  <span class="c1">// v5 = {0.8, 0.8, 0.8, 0.8, 2.4, 2.4, 2.4, 2.4}</span>

  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">v6</span><span class="p">;</span> <span class="c1">//v6 = {0.1, 0.2, 0.3, 0.4};</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">8</span><span class="o">&gt;</span> <span class="n">v7</span><span class="p">;</span> <span class="c1">// v7 = {1.0, 2.0, 4.0, 8.0, 16.0, 32.0, 64.0, 128.0};</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">8</span><span class="o">&gt;</span> <span class="n">v8</span><span class="p">;</span>
  <span class="c1">// ...</span>
  <span class="n">v8</span> <span class="o">=</span> <span class="n">cm_line</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">v6</span><span class="p">,</span> <span class="n">v7</span><span class="p">);</span> <span class="c1">// v8 = {0.5, 0.6, 0.8, 1.2, 2.0, 3.6, 6.8, 13.2}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="common-types-for-memory-operations">
<h3><a class="toc-backref" href="#id52">4.4 Common Types For Memory Operations</a><a class="headerlink" href="#common-types-for-memory-operations" title="Permalink to this headline">¶</a></h3>
<p><strong>ChannelMaskType</strong> – an
enumeration constant that specifies which of the R,G,B,A channels should be
enabled for a dataport or sampler operation.  At least one of the channels must be
activated, and there are 15 possible values:</p>
<ul class="simple">
<li>CM_R_ENABLE</li>
<li>CM_G_ENABLE</li>
<li>CM_GR_ENABLE</li>
<li>CM_B_ENABLE</li>
<li>CM_BR_ENABLE</li>
<li>CM_BG_ENABLE</li>
<li>CM_BGR_ENABLE</li>
<li>CM_A_ENABLE</li>
<li>CM_AR_ENABLE</li>
<li>CM_AG_ENABLE</li>
<li>CM_AGR_ENABLE</li>
<li>CM_AB_ENABLE</li>
<li>CM_ABR_ENABLE</li>
<li>CM_ABG_ENABLE</li>
<li>CM_ABGR_ENABLE</li>
</ul>
<p><strong>CmAtomicOpType</strong> – an enumeration constant that specifies the operation performed for the various
atomic read-modify-write library functions.  The atomic operation and the returned result for a single
destination location are described in the table below. The new value of the destination (new_dst) is
computed as indicated based on the old value of the destination (old_dst) and up to two sources included
in the message (src0 and src1).  All operations below, except ATOMIC_MAXSINT and ATOMIC_MINSINT,
treat all values as unsigned integers.</p>
<table border="1" class="docutils">
<colgroup>
<col width="28%" />
<col width="48%" />
<col width="24%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Atomic Operation</th>
<th class="head">New Value at address</th>
<th class="head">Return value</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>ATOMIC_AND</td>
<td>old_dst &amp; src0</td>
<td>old_dst</td>
</tr>
<tr class="row-odd"><td>ATOMIC_OR</td>
<td>old_dst | src0</td>
<td>old_dst</td>
</tr>
<tr class="row-even"><td>ATOMIC_XOR</td>
<td>old_dst ^ src0</td>
<td>old_dst</td>
</tr>
<tr class="row-odd"><td>ATOMIC_XCHG</td>
<td>src0</td>
<td>old_dst</td>
</tr>
<tr class="row-even"><td>ATOMIC_INC</td>
<td>old_dst + 1</td>
<td>old_dst</td>
</tr>
<tr class="row-odd"><td>ATOMIC_DEC</td>
<td>old_dst - 1</td>
<td>old_dst</td>
</tr>
<tr class="row-even"><td>ATOMIC_ADD</td>
<td>old_dst + src0</td>
<td>old_dst</td>
</tr>
<tr class="row-odd"><td>ATOMIC_SUB</td>
<td>old_dst - src0</td>
<td>old_dst</td>
</tr>
<tr class="row-even"><td>ATOMIC_REVSUB</td>
<td>src0 - old_dst</td>
<td>old_dst</td>
</tr>
<tr class="row-odd"><td>ATOMIC_MAXSINT</td>
<td>imax(old_dst, src0)</td>
<td>old_dst</td>
</tr>
<tr class="row-even"><td>ATOMIC_MINSINT</td>
<td>imin(old_dst, src0)</td>
<td>old_dst</td>
</tr>
<tr class="row-odd"><td>ATOMIC_MAX</td>
<td>umax(old_dst, src0)</td>
<td>old_dst</td>
</tr>
<tr class="row-even"><td>ATOMIC_MIN</td>
<td>umin(old_dst, src0)</td>
<td>old_dst</td>
</tr>
<tr class="row-odd"><td>ATOMIC_CMPXCHG</td>
<td>(src1 == old_dst) ? src0 : old_dst</td>
<td>old_dst</td>
</tr>
<tr class="row-even"><td>ATOMIC_PREDEC</td>
<td>old_dst - 1</td>
<td>new_dst</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="dataport-interface">
<h3><a class="toc-backref" href="#id53">4.5 Dataport Interface</a><a class="headerlink" href="#dataport-interface" title="Permalink to this headline">¶</a></h3>
<div class="section" id="media-block-read-write">
<h4>Media Block Read/Write<a class="headerlink" href="#media-block-read-write" title="Permalink to this headline">¶</a></h4>
<p>CM provides several qualifiers that can be applied to the surface index:</p>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Qualifier</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>TOP_FIELD</td>
<td>indicates only the top field surface data are needed.</td>
</tr>
<tr class="row-odd"><td>BOTTOM_FIELD</td>
<td>indicates only the bottom field surface data are needed.
This may not be used together with TOP_FIELD.</td>
</tr>
</tbody>
</table>
<p>For out-of-bounds read, the address is clamped to the nearest edge of the
surface, and the pixel in that position is returned.  Out-of-bound writes are
dropped.  Out-of-bound behavior is undefined, however, if the surface width is
not DWord-aligned.</p>
<p>The valid combination of block width and height is described in the following table.</p>
<table border="1" class="docutils">
<colgroup>
<col width="46%" />
<col width="54%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Block Width (bytes)</th>
<th class="head">Maximum Block Height (rows)</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>1-4</td>
<td>64</td>
</tr>
<tr class="row-odd"><td>5-8</td>
<td>32</td>
</tr>
<tr class="row-even"><td>9-16</td>
<td>16</td>
</tr>
<tr class="row-odd"><td>17-32</td>
<td>8</td>
</tr>
<tr class="row-even"><td>33-64 {BDW+}</td>
<td>4</td>
</tr>
</tbody>
</table>
<p>Supported Surfaces:</p>
<table border="1" class="docutils">
<colgroup>
<col width="8%" />
<col width="8%" />
<col width="83%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Format</th>
<th class="head">Type</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Any</td>
<td>2D</td>
<td><ul class="first last simple">
<li>Block width and offset should be pixel-aligned for read.</li>
<li>For CM_SURFACE_FORMAT_YUY2,  Block width and offset should
be pixel pair aligned</li>
<li>For Block width &gt; 32 read or write, the surface must be linear or x-
tiled.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="section" id="read">
<h5>read<a class="headerlink" href="#read" title="Permalink to this headline">¶</a></h5>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">read</span> <span class="p">(</span><span class="n">SurfaceIndex</span> <span class="n">IND</span><span class="p">,</span> <span class="kt">int</span> <span class="n">X</span><span class="p">,</span> <span class="kt">int</span> <span class="n">Y</span><span class="p">,</span> <span class="n">matrix_ref</span><span class="o">&lt;</span><span class="n">TYPE</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">m</span><span class="p">);</span>
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>IND</td>
<td>surface index, which must correspond to a 2D type surface
(optionally qualified as specified above)</td>
</tr>
<tr class="row-odd"><td>X</td>
<td><p class="first">zero based X-coordinate of the left upper rectangle corner in
BYTES;</p>
<p>For regular surfaces, the X-offset must be pixel aligned.</p>
<p class="last">For surfaces with compact format (e.g., YUY2), this must be
DWord (i.e. 4 bytes) aligned.</p>
</td>
</tr>
<tr class="row-even"><td>Y</td>
<td>zero based Y-coordinate of the left upper rectangle corner in
ROWS.</td>
</tr>
<tr class="row-odd"><td>m</td>
<td>the data location to be read / written:
the width of matrix m must be pixel aligned.</td>
</tr>
</tbody>
</table>
<p>Usage example:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">read</span> <span class="p">(</span><span class="n">TOP_FIELD</span><span class="p">(</span><span class="n">ind</span><span class="p">),</span> <span class="p">...)</span>  <span class="c1">// only reads top field surface data</span>
</pre></div>
</div>
</div>
<div class="section" id="write">
<h5>write<a class="headerlink" href="#write" title="Permalink to this headline">¶</a></h5>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">write</span><span class="p">(</span><span class="n">SurfaceIndex</span> <span class="n">IND</span><span class="p">,</span> <span class="kt">int</span> <span class="n">X</span><span class="p">,</span> <span class="kt">int</span> <span class="n">Y</span><span class="p">,</span> <span class="k">const</span> <span class="n">matrix</span> <span class="n">m</span><span class="p">);</span>
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="18%" />
<col width="82%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>IND</td>
<td>surface index, which must correspond to a 2D type surface
(optionally qualified as specified above)</td>
</tr>
<tr class="row-odd"><td>X</td>
<td>zero based X-coordinate of the left upper rectangle corner in BYTES;
must be DWord (i.e. 4 bytes) aligned.</td>
</tr>
<tr class="row-even"><td>Y</td>
<td>zero based Y-coordinate of the left upper rectangle corner in ROWS.</td>
</tr>
<tr class="row-odd"><td>m</td>
<td>the data location to be read / written:
the width of matrix m must be DWord (i.e. 4 bytes) aligned.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="media-block-read-write-for-planar-surface">
<h4>Media Block Read/Write for Planar Surface<a class="headerlink" href="#media-block-read-write-for-planar-surface" title="Permalink to this headline">¶</a></h4>
<p>CM provides several qualifiers that can be applied to the surface index:</p>
<table border="1" class="docutils">
<colgroup>
<col width="17%" />
<col width="83%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Qualifier</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>TOP_FIELD</td>
<td>indicates only the top field surface data are needed.</td>
</tr>
<tr class="row-odd"><td>BOTTOM_FIELD</td>
<td>indicates only the bottom field surface data are needed.  This may not be
used together with TOP_FIELD.</td>
</tr>
</tbody>
</table>
<p>The planar media block read and write have the same restrictions on the block
width and height as the regular media read/write.</p>
<p>Supported Surfaces:</p>
<table border="1" class="docutils">
<colgroup>
<col width="28%" />
<col width="8%" />
<col width="64%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Format</th>
<th class="head">Type</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>CM_SURFACE_FORMAT_NV12</td>
<td>2D</td>
<td><ul class="first last simple">
<li>Block width and offset should be pixel-aligned for read.</li>
<li>Only Y and UV plane are available.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="section" id="read-plane">
<h5>read_plane<a class="headerlink" href="#read-plane" title="Permalink to this headline">¶</a></h5>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">read_plane</span><span class="p">(</span><span class="n">SurfaceIndex</span> <span class="n">IND</span><span class="p">,</span> <span class="n">CmSurfacePlaneIndex</span> <span class="n">plane_index</span><span class="p">,</span> <span class="kt">int</span> <span class="n">X</span><span class="p">,</span> <span class="kt">int</span> <span class="n">Y</span><span class="p">,</span> <span class="n">matrix_ref</span> <span class="n">m</span><span class="p">);</span>
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="18%" />
<col width="82%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>IND</td>
<td>surface index, which must correspond to a 2D type surface with
planar format (optionally qualified as specified above)</td>
</tr>
<tr class="row-odd"><td>plane_index</td>
<td><p class="first">the index to the plane. CmSurfacePlaneIndex is an enumerator
type with 4 possible values, as listed below. This must be a
compile time constant.</p>
<ul class="last simple">
<li>GENX_SURFACE_Y_PLANE</li>
<li>GENX_SURFACE_U_PLANE</li>
<li>GENX_SURFACE_UV_PLANE</li>
<li>GENX_SURFACE_V_PLANE</li>
</ul>
</td>
</tr>
<tr class="row-even"><td>X</td>
<td><p class="first">zero based X-coordinate of the left upper rectangle corner in BYTES;</p>
<p class="last">The alignment rule applies to each sub-plane surface
separately.  For example, for NV12 format, the Y-plane is Byte
aligned, while the UV plane is Word aligned.</p>
</td>
</tr>
<tr class="row-odd"><td>Y</td>
<td>zero based Y-coordinate of the left upper rectangle corner in ROWS.</td>
</tr>
<tr class="row-even"><td>m</td>
<td>the data location to be read / written:
the width of matrix m must be pixel aligned.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="write-plane">
<h5>write_plane<a class="headerlink" href="#write-plane" title="Permalink to this headline">¶</a></h5>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">write_plane</span><span class="p">(</span><span class="n">SurfaceIndex</span> <span class="n">IND</span><span class="p">,</span> <span class="kt">int</span> <span class="n">plane_index</span><span class="p">,</span> <span class="kt">int</span> <span class="n">X</span><span class="p">,</span> <span class="kt">int</span> <span class="n">Y</span><span class="p">,</span> <span class="k">const</span> <span class="n">matrix</span> <span class="n">m</span><span class="p">);</span>
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="18%" />
<col width="82%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>IND</td>
<td>surface index, which must correspond to a 2D type surface with
planar format (optionally qualified as specified above)</td>
</tr>
<tr class="row-odd"><td>plane_index</td>
<td><p class="first">the index to the plane. CmSurfacePlaneIndex is an enumerator
type with 4 possible values, as listed below. This must be a
compile time constant.</p>
<ul class="last simple">
<li>GENX_SURFACE_Y_PLANE</li>
<li>GENX_SURFACE_U_PLANE</li>
<li>GENX_SURFACE_UV_PLANE</li>
<li>GENX_SURFACE_V_PLANE</li>
</ul>
</td>
</tr>
<tr class="row-even"><td>X</td>
<td>zero based X-coordinate of the left upper rectangle corner in BYTES;
must be DWord (i.e. 4 bytes) aligned.</td>
</tr>
<tr class="row-odd"><td>Y</td>
<td>zero based Y-coordinate of the left upper rectangle corner in ROWS.</td>
</tr>
<tr class="row-even"><td>m</td>
<td>the data location to be read / written:
the width of matrix m must be DWord (i.e. 4 bytes) aligned.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="oword-block-read-write">
<h4>OWord Block Read/Write<a class="headerlink" href="#oword-block-read-write" title="Permalink to this headline">¶</a></h4>
<p>CM provides the following qualifiers for specifying the input usage options:</p>
<table border="1" class="docutils">
<colgroup>
<col width="23%" />
<col width="77%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Qualifier</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>DWALIGNED</td>
<td>indicates that the offset is DWord aligned.</td>
</tr>
<tr class="row-odd"><td>MODIFIED_DWALIGNED</td>
<td>deprecated: same as DWALIGNED, as there is no modified bit in
current hardware.</td>
</tr>
</tbody>
</table>
<p>Out-of-bound reads return zero, while out-of-bound writes are dropped.</p>
<p>Note: CM currently only supports read/write operations of OWord Block data with
size &lt;= 128 bytes.</p>
<p>Supported Surfaces:</p>
<table border="1" class="docutils">
<colgroup>
<col width="29%" />
<col width="8%" />
<col width="63%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Format</th>
<th class="head">Type</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>N/A</td>
<td>Buffer</td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<div class="section" id="id2">
<h5>read<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h5>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">read</span><span class="p">(</span><span class="n">SurfaceIndex</span> <span class="n">IND</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="n">vector_ref</span> <span class="n">v</span><span class="p">);</span>
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="19%" />
<col width="81%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>IND</td>
<td>surface index, which must correspond to a buffer
(optionally qualified as specified above)</td>
</tr>
<tr class="row-odd"><td>offset</td>
<td>zero based offset of the input buffer in <em>bytes</em>.  Must be
OWord (i.e. 16 bytes) aligned, but need be only DWord (i.e. 4
bytes) aligned if the DWALIGNED or MODIFIED_DWALIGNED modifier
is present.</td>
</tr>
<tr class="row-even"><td>v</td>
<td>the data location to be read / written:
the width of vector v must be OWord (i.e. 16 bytes) aligned.</td>
</tr>
</tbody>
</table>
<p>Usage example:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">read</span> <span class="p">(</span><span class="n">DWALIGNED</span><span class="p">(</span><span class="n">ind</span><span class="p">),</span> <span class="p">...)</span>  <span class="c1">// the offset ind is DWord aligned</span>
<span class="n">read</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="p">...)</span>              <span class="c1">// the offset ind is OWord aligned</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h5>write<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h5>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">write</span><span class="p">(</span><span class="n">SurfaceIndex</span> <span class="n">IND</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span> <span class="n">v</span><span class="p">);</span>
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="19%" />
<col width="81%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>IND</td>
<td>surface index, which must correspond to a buffer
(optionally qualified as specified above)</td>
</tr>
<tr class="row-odd"><td>offset</td>
<td>zero based offset of the input buffer in <em>bytes</em>;
must be OWord (i.e. 16 bytes) aligned.</td>
</tr>
<tr class="row-even"><td>v</td>
<td>the data location to be read / written:
the width of vector v can be only 1, 2, 4 or 8 OWords.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="scattered-read-write">
<h4>Scattered Read/Write<a class="headerlink" href="#scattered-read-write" title="Permalink to this headline">¶</a></h4>
<p>Out-of-bound reads return zero, while out-of-bound writes are dropped.</p>
<p>Scattered read/write may appear in SIMD control flow blocks, as long as it size matches
that of the controlling SIMD expression.</p>
<p>Supported Surfaces:</p>
<table border="1" class="docutils">
<colgroup>
<col width="29%" />
<col width="8%" />
<col width="63%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Format</th>
<th class="head">Type</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>N/A</td>
<td>Buffer</td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<div class="section" id="id4">
<h5>read<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h5>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">read</span><span class="p">(</span><span class="n">SurfaceIndex</span> <span class="n">IND</span><span class="p">,</span> <span class="n">uint</span> <span class="n">global_offset</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">uint</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">element_offset</span><span class="p">,</span> <span class="n">vector_ref</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">);</span>
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="19%" />
<col width="81%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>IND</td>
<td>surface index, which must correspond to a buffer</td>
</tr>
<tr class="row-odd"><td>global_offset</td>
<td>zero based global offset of a set of sattered elements
to be read from the surface. This offset is in units of the
size of the elements.</td>
</tr>
<tr class="row-even"><td>element_offset</td>
<td>zero based offset of each element (relative to the global
offset) to be read; N must be a power of 2 and no more than 16.
This offset is in units of the size of the elements.</td>
</tr>
<tr class="row-odd"><td>v</td>
<td>the data location to store the return result.
N must be equal to the length of element_offset.
T can be either char, uchar, short, ushort, int, uint or float.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id5">
<h5>write<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h5>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">write</span><span class="p">(</span><span class="n">SurfaceIndex</span> <span class="n">IND</span><span class="p">,</span> <span class="n">uint</span> <span class="n">global_offset</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">uint</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">element_offset</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">);</span>

<span class="n">or</span>

<span class="kt">void</span> <span class="nf">write</span><span class="p">(</span><span class="n">SurfaceIndex</span> <span class="n">IND</span><span class="p">,</span> <span class="n">uint</span> <span class="n">global_offset</span><span class="p">,</span> <span class="n">uint</span> <span class="n">element_offset</span><span class="p">,</span> <span class="n">T</span> <span class="n">val</span><span class="p">);</span>
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="16%" />
<col width="84%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>IND</td>
<td>surface index, which must correspond to a buffer.</td>
</tr>
<tr class="row-odd"><td>global_offset</td>
<td>zero based global offset of a set of scattered elements
to be written to the surface. This offset is in units of the
size of the elements.</td>
</tr>
<tr class="row-even"><td>element_offset</td>
<td>zero based offset of each element (relative to the global
offset) to be written; N must be a power of 2 and no more than 16, or a scalar.
This offset is in units of the size of the elements.</td>
</tr>
<tr class="row-odd"><td>v</td>
<td>data location that contains the data to be written.
N must be equal to the length of element_offset or else a scalar.
T can be either char, uchar, short, ushort, int, uint or float.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="scaled-scattered-read-write">
<h4>Scaled Scattered Read/Write<a class="headerlink" href="#scaled-scattered-read-write" title="Permalink to this headline">¶</a></h4>
<p>Scaled scattered read/write are similar to scattered read/write.
The only difference is that the scaled version takes byte offsets and
there is no alignment restrictions on either offsets.</p>
<div class="section" id="read-scaled">
<h5>read_scaled<a class="headerlink" href="#read-scaled" title="Permalink to this headline">¶</a></h5>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">read_scaled</span><span class="p">(</span><span class="n">SurfaceIndex</span> <span class="n">IND</span><span class="p">,</span> <span class="n">uint</span> <span class="n">global_offset</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">uint</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">element_offset</span><span class="p">,</span> <span class="n">vector_ref</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">);</span>
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="19%" />
<col width="81%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>IND</td>
<td>surface index, which must correspond to a buffer</td>
</tr>
<tr class="row-odd"><td>global_offset</td>
<td>zero based global offset of a set of sattered elements
to be read from the surface. This offset is in bytes.</td>
</tr>
<tr class="row-even"><td>element_offset</td>
<td>zero based offset of each element (relative to the global
offset) to be read; N must be a power of 2 and no more than 16.
This offset is in bytes.</td>
</tr>
<tr class="row-odd"><td>v</td>
<td>the data location to store the return result.
N must be equal to the length of element_offset.
T can be either char, uchar, short, ushort, int, uint or float.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="write-scaled">
<h5>write_scaled<a class="headerlink" href="#write-scaled" title="Permalink to this headline">¶</a></h5>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">write_scaled</span><span class="p">(</span><span class="n">SurfaceIndex</span> <span class="n">IND</span><span class="p">,</span> <span class="n">uint</span> <span class="n">global_offset</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">uint</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">element_offset</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">);</span>
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="16%" />
<col width="84%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>IND</td>
<td>surface index, which must correspond to a buffer.</td>
</tr>
<tr class="row-odd"><td>global_offset</td>
<td>zero based global offset of a set of scattered elements
to be written to the surface. This offset is in bytes.</td>
</tr>
<tr class="row-even"><td>element_offset</td>
<td>zero based offset of each element (relative to the global
offset) to be written; N must be a power of 2 and no more than 16, or a scalar.
This offset is in bytes.</td>
</tr>
<tr class="row-odd"><td>v</td>
<td>data location that contains the data to be written.
N must be equal to the length of element_offset.
T can be either char, uchar, short, ushort, int, uint or float.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="dword-atomic-write">
<h4>DWord Atomic Write<a class="headerlink" href="#dword-atomic-write" title="Permalink to this headline">¶</a></h4>
<p>Performs atomic read-modify-write operations on the N element offsets
specified, where N can be 1, 2, 4, 8 or 16.</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="n">CmAtomicOpType</span> <span class="n">Op</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="n">write_atomic</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ushort</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">mask</span><span class="p">,</span> <span class="n">SurfaceIndex</span> <span class="n">index</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">uint</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">element_offset</span><span class="p">,</span>
             <span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">src0</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">src1</span><span class="p">,</span> <span class="n">vector_ref</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">);</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="n">CmAtomicOpType</span> <span class="n">Op</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="n">write_atomic</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ushort</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">mask</span><span class="p">,</span> <span class="n">SurfaceIndex</span> <span class="n">index</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">uint</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">element_offset</span><span class="p">,</span>
             <span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">src0</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">src1</span><span class="p">);</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="n">CmAtomicOpType</span> <span class="n">Op</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="n">write_atomic</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ushort</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">mask</span><span class="p">,</span> <span class="n">SurfaceIndex</span> <span class="n">index</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">uint</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">element_offset</span><span class="p">,</span>
             <span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">src0</span><span class="p">,</span> <span class="n">vector_ref</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">);</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="n">CmAtomicOpType</span> <span class="n">Op</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="n">write_atomic</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ushort</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">mask</span><span class="p">,</span> <span class="n">SurfaceIndex</span> <span class="n">index</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">uint</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">element_offset</span><span class="p">,</span>
             <span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">src0</span><span class="p">);</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="n">CmAtomicOpType</span> <span class="n">Op</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="n">write_atomic</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ushort</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">mask</span><span class="p">,</span> <span class="n">SurfaceIndex</span> <span class="n">index</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">uint</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">element_offset</span><span class="p">,</span>
             <span class="n">vector_ref</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">);</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="n">CmAtomicOpType</span> <span class="n">Op</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="n">write_atomic</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ushort</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">mask</span><span class="p">,</span> <span class="n">SurfaceIndex</span> <span class="n">index</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">uint</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">element_offset</span><span class="p">);</span>
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="14%" />
<col width="86%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>op</td>
<td>the atomic operation kind</td>
</tr>
<tr class="row-odd"><td>mask</td>
<td>(optional) predicate to specify enabled channels.</td>
</tr>
<tr class="row-even"><td>index</td>
<td>surface index, which must correspond to a buffer.</td>
</tr>
<tr class="row-odd"><td>element_offset</td>
<td>zero based offset of each DWord to be written. This is in units of DWords.</td>
</tr>
<tr class="row-even"><td>src0</td>
<td>the first source operand for the specified atomic operation.</td>
</tr>
<tr class="row-odd"><td>src1</td>
<td>the second source operand for the specified atomic operation.</td>
</tr>
<tr class="row-even"><td>v</td>
<td>the data location to store the returned result, which corresponds to the old surface data value.</td>
</tr>
</tbody>
</table>
<p>Out-of-bound reads return zero, while out-of-bound writes are dropped.</p>
<p>Supported Surfaces:</p>
<table border="1" class="docutils">
<colgroup>
<col width="29%" />
<col width="8%" />
<col width="63%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Format</th>
<th class="head">Type</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>N/A</td>
<td>Buffer</td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">write</span><span class="p">(</span><span class="n">SurfaceIndex</span> <span class="n">IND</span><span class="p">,</span> <span class="n">CmAtomicOpType</span> <span class="n">op</span><span class="p">,</span> <span class="n">uint</span> <span class="n">global_offset</span><span class="p">,</span>
  <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">uint</span><span class="p">,</span> <span class="mi">8</span><span class="o">&gt;</span> <span class="n">element_offset</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span> <span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">src</span><span class="p">,</span>
  <span class="n">vector_ref</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">8</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">)</span>
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="19%" />
<col width="81%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>IND</td>
<td>surface index, which must correspond to a buffer</td>
</tr>
<tr class="row-odd"><td>op</td>
<td>the atomic operation type.  It must be a compile time constant.</td>
</tr>
<tr class="row-even"><td>global_offset</td>
<td>zero based global offset of a set of 8 scattered DWords to be
written to the surface.  This offset is in units of DWords.</td>
</tr>
<tr class="row-odd"><td>element_offset</td>
<td>zero based offset of each DWord (relative to the global offset)
to be written.  This offset is in units of DWords.</td>
</tr>
<tr class="row-even"><td>src</td>
<td><p class="first">the data location that contains the source operands for the
specified atomic operation.</p>
<p>For ATOMIC_CMPXCHG, N must be 16.</p>
<p>For ATOMIC_INC / ATOMIC_DEC, src is ignored.</p>
<p class="last">For all other cases, N must be 8.</p>
</td>
</tr>
<tr class="row-odd"><td>v</td>
<td>the data location to store the return result, which correspond
to the old surface data value.  T can be either int or uint.
This can also be NULL which indicates that no return value
should be used.</td>
</tr>
</tbody>
</table>
<p>Out-of-bound reads return zero, while out-of-bound writes are dropped.</p>
<p>Supported Surfaces:</p>
<table border="1" class="docutils">
<colgroup>
<col width="29%" />
<col width="8%" />
<col width="63%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Format</th>
<th class="head">Type</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>N/A</td>
<td>Buffer</td>
<td>&#160;</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="transpose-read-gen8">
<h4>Transpose Read {Gen8+}<a class="headerlink" href="#transpose-read-gen8" title="Permalink to this headline">¶</a></h4>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">read_transpose</span><span class="p">(</span><span class="n">SurfaceIndex</span> <span class="n">IND</span><span class="p">,</span> <span class="n">CM_READ_SIZE</span> <span class="n">height</span><span class="p">,</span> <span class="n">CM_READ_SIZE</span> <span class="n">width</span><span class="p">,</span>
  <span class="kt">int</span> <span class="n">X</span><span class="p">,</span> <span class="kt">int</span> <span class="n">Y</span><span class="p">,</span> <span class="n">matrix_ref</span> <span class="n">m</span><span class="p">);</span>
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="19%" />
<col width="81%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>IND</td>
<td>surface index, which must correspond to a 2D type surface</td>
</tr>
<tr class="row-odd"><td>height</td>
<td><p class="first">The block height. Valid values:</p>
<ul class="last simple">
<li>CM_READ_1 (1 row)</li>
<li>CM_READ_2 (2 row)</li>
<li>CM_READ_4 (4 row)</li>
<li>CM_READ_8 (8 row)</li>
</ul>
</td>
</tr>
<tr class="row-even"><td>width</td>
<td><p class="first">The block width. Valid values:</p>
<ul class="last simple">
<li>CM_READ_1 (1 DWord)</li>
<li>CM_READ_2 (2 DWord)</li>
<li>CM_READ_4 (4 DWord)</li>
<li>CM_READ_8 (8 DWord)</li>
</ul>
</td>
</tr>
<tr class="row-odd"><td>X</td>
<td>zero based X-coordinate in unit of block width.</td>
</tr>
<tr class="row-even"><td>Y</td>
<td>zero based Y-coordinate in unit of block height.</td>
</tr>
<tr class="row-odd"><td>m</td>
<td>the data location to be read.  The width and height of the
matrix must be the transpose of the width and height
parameters.  Width in bytes of the matrix must be equal to the
number of dwords read after transpose.</td>
</tr>
</tbody>
</table>
<p>If the address is out-of-bound, it is clamped to the nearest edge of the surface, and the pixel in that
position is returned.</p>
<p>Supported Surfaces:</p>
<table border="1" class="docutils">
<colgroup>
<col width="29%" />
<col width="8%" />
<col width="63%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Format</th>
<th class="head">Type</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Any</td>
<td>2D</td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<p>Usage example:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">matrix</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">m</span><span class="p">;</span>
<span class="n">read_transpose</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="n">CM_READ_2</span><span class="p">,</span> <span class="n">CM_READ_8</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>  <span class="c1">//x offset = 16 bytes, y offset = 2 rows</span>
</pre></div>
</div>
</div>
<div class="section" id="untyped-surface-read-write-gen7">
<h4>Untyped Surface Read/Write {Gen7+}<a class="headerlink" href="#untyped-surface-read-write-gen7" title="Permalink to this headline">¶</a></h4>
<p>Out-of-bound reads return zero, while out-of-bound writes are dropped.</p>
<p>Supported Surfaces:</p>
<table border="1" class="docutils">
<colgroup>
<col width="29%" />
<col width="8%" />
<col width="63%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Format</th>
<th class="head">Type</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>N/A</td>
<td>Buffer</td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<div class="section" id="read-untyped">
<h5>read_untyped<a class="headerlink" href="#read-untyped" title="Permalink to this headline">¶</a></h5>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">read_untyped</span><span class="p">(</span><span class="n">SurfaceIndex</span> <span class="n">IND</span><span class="p">,</span> <span class="n">ChannelMaskType</span> <span class="n">channelMask</span><span class="p">,</span>
  <span class="n">matrix_ref</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N1</span><span class="p">,</span> <span class="n">N2</span><span class="o">&gt;</span> <span class="n">m</span><span class="p">,</span>  <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">uint</span><span class="p">,</span> <span class="n">N2</span><span class="o">&gt;</span> <span class="n">u</span><span class="p">);</span>
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="18%" />
<col width="82%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>IND</td>
<td>surface index, which must correspond to a buffer</td>
</tr>
<tr class="row-odd"><td>channelMask</td>
<td>enabled channels.  It must be a compile time constant.</td>
</tr>
<tr class="row-even"><td>m</td>
<td><p class="first">the matrix to store the return results. The type T must be of
size of DWord (i.e., int, uint, or float).</p>
<p class="last">The size N1 is at least the number of enabled channels and N2
must be either 8 or 16.</p>
</td>
</tr>
<tr class="row-odd"><td>u</td>
<td>the offsets of the data elements to be read from surface,
which must be in unit of DWords. The size N2 must be either 8 or 16.</td>
</tr>
</tbody>
</table>
<p>The compiler generates code for GenX hardware to perform scattered read from
offsets given by u.  The results are returned in m with each enabled channel
returned in the next row of m.  The enabled channels are returned in R, G, B, A
order with no gap in m for disabled channels.</p>
</div>
<div class="section" id="write-untyped">
<h5>write_untyped<a class="headerlink" href="#write-untyped" title="Permalink to this headline">¶</a></h5>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">write_untyped</span><span class="p">(</span><span class="n">SurfaceIndex</span> <span class="n">IND</span><span class="p">,</span> <span class="n">ChannelMaskType</span> <span class="n">channelMask</span><span class="p">,</span>
  <span class="n">matrix_ref</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N1</span><span class="p">,</span> <span class="n">N2</span><span class="o">&gt;</span> <span class="n">m</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">uint</span><span class="p">,</span> <span class="n">N2</span><span class="o">&gt;</span> <span class="n">u</span><span class="p">);</span>
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="19%" />
<col width="81%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>IND</td>
<td>surface index, which must correspond to a buffer</td>
</tr>
<tr class="row-odd"><td>channelMask</td>
<td>enabled channels. It must be a compile time constant.</td>
</tr>
<tr class="row-even"><td>m</td>
<td><p class="first">the matrix that stores the data to be written. The type T
must be of size of DWord (i.e., int, uint, or float).</p>
<p class="last">The size N1 is at least the number of enabled channels and N2
must be either 8 or 16.</p>
</td>
</tr>
<tr class="row-odd"><td>u</td>
<td>the offsets of the data elements to written surface, which
must be in unit of DWords. The size N2 must be either 8 or 16.</td>
</tr>
</tbody>
</table>
<p>The compiler generates code for GenX hardware to perform scattered write to
offsets given by u. Only enabled channels are written to the surface.</p>
</div>
</div>
<div class="section" id="typed-surface-read-write-gen7">
<h4>Typed Surface Read/Write {Gen7+}<a class="headerlink" href="#typed-surface-read-write-gen7" title="Permalink to this headline">¶</a></h4>
<p>Out-of-bound reads return zero, while out-of-bound writes are dropped.</p>
<p>Supported Surfaces:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="8%" />
<col width="4%" />
<col width="4%" />
<col width="4%" />
<col width="4%" />
<col width="47%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Format</th>
<th class="head">Type</th>
<th class="head">R</th>
<th class="head">G</th>
<th class="head">B</th>
<th class="head">A</th>
<th class="head">Message Data Type</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>CM_SURFACE_FORMAT_R32F</td>
<td>2D/3D</td>
<td>R</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td>float</td>
</tr>
</tbody>
</table>
<div class="section" id="read-typed">
<h5>read_typed<a class="headerlink" href="#read-typed" title="Permalink to this headline">¶</a></h5>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">read_typed</span><span class="p">(</span><span class="n">SurfaceIndex</span> <span class="n">IND</span><span class="p">,</span> <span class="n">ChannelMaskType</span> <span class="n">channelMask</span><span class="p">,</span>
  <span class="n">matrix_ref</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N1</span><span class="p">,</span> <span class="n">N2</span><span class="o">&gt;</span> <span class="n">m</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">uint</span><span class="p">,</span> <span class="n">N2</span><span class="o">&gt;</span> <span class="n">u</span><span class="p">,</span>
  <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">uint</span><span class="p">,</span> <span class="n">N2</span><span class="o">&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">uint</span><span class="p">,</span> <span class="n">N2</span><span class="o">&gt;</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>IND</td>
<td>surface index, which must correspond to a 1D, 2D or 3D
surface</td>
</tr>
<tr class="row-odd"><td>channelMask</td>
<td>enabled channels.  It must be a compile time constant.</td>
</tr>
<tr class="row-even"><td>m</td>
<td><p class="first">the matrix to store the return results. The type T must be of
size of DWord (i.e., int, uint, or float).</p>
<p class="last">The size N1 is at least the number of enabled channels and N2
must be either 8 or 16.</p>
</td>
</tr>
<tr class="row-odd"><td>u</td>
<td>the x coordinates of the data elements to be read from
surface, which must be in unit of pixels. The size N2 must
be either 8 or 16.</td>
</tr>
<tr class="row-even"><td>v</td>
<td>(optional, default = 0) the y coordinates of the data
elements to be read from non-1D surface types; ignored
otherwise.</td>
</tr>
<tr class="row-odd"><td>r</td>
<td>(optional, default = 0) the z coordinates of the data
elements to be read from 3D surface types; ignored
otherwise.</td>
</tr>
</tbody>
</table>
<p>The compiler generates code for GenX hardware to perform scattered read from
the given offsets.  The results are returned in m with each enabled channel
returned in the next row of m.  The enabled channels are returned in R, G, B, A
order with no gap in m for disabled channels.</p>
</div>
<div class="section" id="write-typed">
<h5>write_typed<a class="headerlink" href="#write-typed" title="Permalink to this headline">¶</a></h5>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">write_typed</span><span class="p">(</span><span class="n">SurfaceIndex</span> <span class="n">IND</span><span class="p">,</span> <span class="n">ChannelMaskType</span> <span class="n">channelMask</span><span class="p">,</span>
  <span class="n">matrix_ref</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N1</span><span class="p">,</span> <span class="n">N2</span><span class="o">&gt;</span> <span class="n">m</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">uint</span><span class="p">,</span> <span class="n">N2</span><span class="o">&gt;</span> <span class="n">u</span><span class="p">,</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="n">uint</span><span class="p">,</span> <span class="n">N2</span><span class="o">&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">uint</span><span class="p">,</span> <span class="n">N2</span><span class="o">&gt;</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="19%" />
<col width="81%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>IND</td>
<td>surface index, which must correspond to a 1D, 2D or 3D surface</td>
</tr>
<tr class="row-odd"><td>channelMask</td>
<td>enabled channels.  It must be a compile time constant.</td>
</tr>
<tr class="row-even"><td>m</td>
<td>the matrix that stores the data to be written. The type T must
be of size of DWord (i.e., int, uint, or float). The size N1 is
at least the number of enabled channels and N2 must be either 8
or 16.</td>
</tr>
<tr class="row-odd"><td>u</td>
<td>the x coordinates of the data elements to be written to
surface, which must be in unit of pixels. The size N2 must be
either 8 or 16.</td>
</tr>
<tr class="row-even"><td>v</td>
<td>(optional, default = 0) the y coordinates of the data elements
to be written to non-1D surface types; ignored otherwise.</td>
</tr>
<tr class="row-odd"><td>r</td>
<td>(optional, default = 0) the z coordinates of the data elements
to be written to 3D surface types; ignored otherwise.</td>
</tr>
</tbody>
</table>
<p>The compiler generates code for GenX hardware to perform scattered write to the
given offsets. Only enabled channels are written to the surface.</p>
</div>
</div>
<div class="section" id="typed-surface-atomic-write-gen9">
<h4>Typed Surface Atomic Write {Gen9+}<a class="headerlink" href="#typed-surface-atomic-write-gen9" title="Permalink to this headline">¶</a></h4>
<p>{Only for new cm-llvm compiler cmc - not supported for legacy cm-icl compiler - icl}</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">write_typed_atomic</span><span class="o">&lt;</span><span class="n">ATOMIC_OP</span><span class="o">&gt;</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ushort</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">mask</span><span class="p">,</span> <span class="n">SurfaceIndex</span> <span class="n">IND</span><span class="p">,</span>
  <span class="n">vector_ref</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">ret</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">src0</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">src1</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">uint</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">u</span><span class="p">,</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="n">uint</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">uint</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">r</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">uint</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">LOD</span><span class="p">);</span>
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>ATOMIC_OP</td>
<td>atomic operation to perform. These are the same enums as the
other atomic operations.  Please refer to these for details.</td>
</tr>
<tr class="row-odd"><td>mask</td>
<td>(optional) predicate to specify enabled channels.</td>
</tr>
<tr class="row-even"><td>IND</td>
<td>surface index, which must correspond to a 1D, 2D or 3D
surface [6].</td>
</tr>
<tr class="row-odd"><td>ret</td>
<td>the vector that stores the data returned. This contains the
values in the surface before the atomic operation was
performed. The type T must be of size of DWord and must be
unsigned except for the ATOMIC_IMIN and ATOMIC_IMAX variants
where it can be signed. The size N can be 1, 2, 4 or 8.</td>
</tr>
<tr class="row-even"><td>Src0</td>
<td>the vector containing src0 data for the operation. Not
required for INC and DEC operations. Must be unsigned int.</td>
</tr>
<tr class="row-odd"><td>Src1</td>
<td>the vector containing src1 data for the operation. Only
required for CMPXCHG operations. Must be unsigned int.</td>
</tr>
<tr class="row-even"><td>u</td>
<td>the x coordinates of the data elements to be written to
surface, which must be in unit of pixels.</td>
</tr>
<tr class="row-odd"><td>v</td>
<td>(optional) the y coordinates of the data elements to be
written to non-1D surface types; ignored otherwise.</td>
</tr>
<tr class="row-even"><td>r</td>
<td>(optional) the z coordinates of the data elements to be
written to 3D surface types; ignored otherwise.</td>
</tr>
<tr class="row-odd"><td>LOD</td>
<td>(optional) the w coordinates of the data elements to be
written to 3D surface types; ignored otherwise.</td>
</tr>
</tbody>
</table>
<p>The compiler generates code for GenX hardware to perform scattered write to the
given offsets with the associated atomic operation. Out-of-bound writes are
dropped.</p>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="20%" />
<col width="20%" />
<col width="20%" />
<col width="20%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Surface Type</th>
<th class="head">U</th>
<th class="head">V</th>
<th class="head">R</th>
<th class="head">LOD</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>1D</td>
<td>X pixel address</td>
<td>N/A</td>
<td>N/A</td>
<td>LOD</td>
</tr>
<tr class="row-odd"><td>1D_array</td>
<td>X pixel address</td>
<td>Array index</td>
<td>N/A</td>
<td>LOD</td>
</tr>
<tr class="row-even"><td>2D</td>
<td>X pixel address</td>
<td>Y pixel address</td>
<td>N/A</td>
<td>LOD</td>
</tr>
<tr class="row-odd"><td>2D_array</td>
<td>X pixel address</td>
<td>Y pixel address</td>
<td>Array index</td>
<td>LOD</td>
</tr>
<tr class="row-even"><td>3D</td>
<td>X pixel address</td>
<td>Y pixel address</td>
<td>Z pixel address</td>
<td>LOD</td>
</tr>
</tbody>
</table>
<p>Supported Surfaces:</p>
<table border="1" class="docutils">
<colgroup>
<col width="36%" />
<col width="28%" />
<col width="4%" />
<col width="4%" />
<col width="4%" />
<col width="4%" />
<col width="20%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Format</th>
<th class="head">Type</th>
<th class="head">R</th>
<th class="head">G</th>
<th class="head">B</th>
<th class="head">A</th>
<th class="head">Message Data
Type</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>CM_SURFACE_FORMAT_R32_UINT</td>
<td>1D/2D/3D/CUBE/BUFFER</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td>Integer</td>
</tr>
<tr class="row-odd"><td>CM_SURFACE_FORMAT_R32_SINT</td>
<td>1D/2D/3D/CUBE/BUFFER</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td>Integer</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="shared-local-memory-slm-and-groups-interface-gen7">
<h3><a class="toc-backref" href="#id54">4.6 Shared Local Memory (SLM) and Groups Interface {Gen7+}</a><a class="headerlink" href="#shared-local-memory-slm-and-groups-interface-gen7" title="Permalink to this headline">¶</a></h3>
<p>The shared local memory (SLM) is a high bandwidth memory that is not backed up by system memory.  It
is only supported for Gen7+. Its contents are uninitialized after creation, and its contents disappear when
de-allocated.</p>
<p>The host program needs to organize all the threads into groups (collection of threads) by specifying the
group-space and the thread-space within each group. This group and thread space information can be
subsequently used to execute a kernel in that space. Formal description of the host API functions can be
found in ‘CM runtime API Specification’ [6].</p>
<p>A kernel needs to specify which data would be allocated in the SLM (cm_slm_alloc). All the declared SLM
buffers are allocated once for each group generated and are accessible only from the threads within that
group. Runtime and hardware will keep track of each group’s SLM data separately.</p>
<p>In the current SLM support in CM, SLM values are not first-class operands which mean they cannot be
used directly in CM operations. They need to be read to GRF registers (cm_slm_read) before being used.
After their use, they could be written back to SLM if needed (cm_slm_write). However, if data written to
SLM by one thread needs to be read by other threads in the group, a barrier (cm_barrier) needs to be
inserted to make the writes visible to the reads. If the SLM writes needed are only for loading data from
global memory to SLM, then the kernel can simply use cm_slm_load to load data from memory to SLM –
cm_slm_load would transparently distribute the work, of reading data from memory and writing to SLM,
amongst the available threads in the current group and insert the necessary barrier needed to make the
loaded data visible to all threads. The kernel could also perform atomic operations on data residing in the
SLM (cm_slm_atomic).</p>
<p>In order to distinguish data and operations between threads in a group, the kernel can get the thread IDs
through cm_local_id and thread counts in a group through cm_local_size. For data distinction across
groups, kernel can call cm_group_id and cm_group_count to get the group IDs and group dimensions
respectively in the group space. For programming convenience, some useful functions are provided to get
the linearized IDs and sizes in one dimensional group and thread spaces.</p>
<p>Note on EMU-mode Support: Currently EMU mode is not supported if the kernel uses cm_barrier().
However, if the only purpose of the barrier is to load data from memory to SLM, the kernel can use
cm_slm_load() which is supported in EMU mode with one restriction – only one SLM buffer is used, i.e.,
there is a single call to cm_slm_alloc().</p>
<p>Note on Performance: Use cm_slm_read4() and cm_slm_write4() instead of cm_slm_read() and
cm_slm_write() whenever possible, as read4 and write4 versions provide much higher read/write
bandwidth (an order of magnitude higher) on Gen7. Read4 and write4 versions can read/write 4 dwords
per address – even if all 4 dwords per address are not needed, use read4/write4 (with appropriate mask
argument) for higher performance. Also note that, data read or written using read4/write4 intrinsics are
transposed by the hardware – the application should try to take advantage of this; otherwise, it would
incur the overhead of transposing the data back to the desired layout.</p>
<p>In this section, we describe the kernel APIs needed to explicitly control and use the SLM.</p>
<div class="section" id="id-and-size-api-functions">
<h4>ID and Size API Functions<a class="headerlink" href="#id-and-size-api-functions" title="Permalink to this headline">¶</a></h4>
<div class="section" id="cm-local-id">
<h5>cm_local_id<a class="headerlink" href="#cm-local-id" title="Permalink to this headline">¶</a></h5>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">uint</span> <span class="nf">cm_local_id</span> <span class="p">(</span><span class="n">uint</span> <span class="n">dim</span><span class="p">);</span>
</pre></div>
</div>
<p>Get the thread ID of this thread in the 2D thread-space of its
group along dimension ‘dim’.</p>
</div>
<div class="section" id="cm-local-size">
<h5>cm_local_size<a class="headerlink" href="#cm-local-size" title="Permalink to this headline">¶</a></h5>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">uint</span> <span class="nf">cm_local_size</span> <span class="p">(</span><span class="n">uint</span> <span class="n">dim</span><span class="p">);</span>
</pre></div>
</div>
<p>Get the number of threads along dimension ‘dim’ in the 2D
thread-space of the current group.</p>
</div>
<div class="section" id="cm-group-id">
<h5>cm_group_id<a class="headerlink" href="#cm-group-id" title="Permalink to this headline">¶</a></h5>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">uint</span> <span class="nf">cm_group_id</span> <span class="p">(</span><span class="n">uint</span> <span class="n">dim</span><span class="p">);</span>
</pre></div>
</div>
<p>Get the group ID of the group this thread belongs to, in the 2D
group-space, along the dimension ‘dim’.</p>
</div>
<div class="section" id="cm-group-count">
<h5>cm_group_count<a class="headerlink" href="#cm-group-count" title="Permalink to this headline">¶</a></h5>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">uint</span> <span class="nf">cm_group_count</span> <span class="p">(</span><span class="n">uint</span> <span class="n">dim</span><span class="p">);</span>
</pre></div>
</div>
<p>Get the number of groups in the 2D group-space along the
dimension ‘dim’.</p>
</div>
<div class="section" id="cm-linear-local-id">
<h5>cm_linear_local_id<a class="headerlink" href="#cm-linear-local-id" title="Permalink to this headline">¶</a></h5>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">uint</span> <span class="nf">cm_linear_local_id</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>
</pre></div>
</div>
<p>Get the linear thread ID of this thread in its group.</p>
</div>
<div class="section" id="cm-linear-global-id">
<h5>cm_linear_global_id<a class="headerlink" href="#cm-linear-global-id" title="Permalink to this headline">¶</a></h5>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">uint</span> <span class="nf">cm_linear_global_id</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>
</pre></div>
</div>
<p>Get the linear global ID of this thread.</p>
</div>
<div class="section" id="cm-linear-local-size">
<h5>cm_linear_local_size<a class="headerlink" href="#cm-linear-local-size" title="Permalink to this headline">¶</a></h5>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">uint</span> <span class="nf">cm_linear_local_size</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>
</pre></div>
</div>
<p>Get the total number of threads in a group.</p>
</div>
<div class="section" id="cm-linear-group-id">
<h5>cm_linear_group_id<a class="headerlink" href="#cm-linear-group-id" title="Permalink to this headline">¶</a></h5>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">uint</span> <span class="nf">cm_linear_group_id</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>
</pre></div>
</div>
<p>Get the linear group ID of this group.</p>
</div>
<div class="section" id="cm-linear-group-count">
<h5>cm_linear_group_count<a class="headerlink" href="#cm-linear-group-count" title="Permalink to this headline">¶</a></h5>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">uint</span> <span class="nf">cm_linear_group_count</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>
</pre></div>
</div>
<p>Get the total number of groups.</p>
</div>
<div class="section" id="cm-linear-global-size">
<h5>cm_linear_global_size<a class="headerlink" href="#cm-linear-global-size" title="Permalink to this headline">¶</a></h5>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">uint</span> <span class="nf">cm_linear_global_size</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>
</pre></div>
</div>
<p>Get the total number of threads.</p>
</div>
</div>
<div class="section" id="slm-functions">
<h4>SLM Functions<a class="headerlink" href="#slm-functions" title="Permalink to this headline">¶</a></h4>
<div class="section" id="cm-slm-init">
<h5>cm_slm_init<a class="headerlink" href="#cm-slm-init" title="Permalink to this headline">¶</a></h5>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">cm_slm_init</span> <span class="p">(</span><span class="n">uint</span> <span class="n">slmSize</span><span class="p">);</span>
</pre></div>
</div>
<p>Initializes SLM for the kernel. SLM size (in Bytes) needed per
group has to be specified in ‘slmSize’. Maximum SLM size per
group that can be specified here is 64 KB on Gen7.</p>
</div>
<div class="section" id="cm-slm-alloc">
<h5>cm_slm_alloc<a class="headerlink" href="#cm-slm-alloc" title="Permalink to this headline">¶</a></h5>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">uint</span> <span class="nf">cm_slm_alloc</span> <span class="p">(</span><span class="n">uint</span> <span class="n">bufferSize</span><span class="p">);</span>
</pre></div>
</div>
<p>Allocate a SLM buffer of size ‘bufferSize’ in current-group’s SLM
– this is allocated once per group; Maximum of all SLM
allocations is 64KB and is always rounded up to next multiple of
4KB. Currently, this function would return an integer identifier
of the SLM buffer allocated – this is the byte-offset of this
buffer in SLM. In the first implementation, there would be no
support of freeing SLM buffer and reusing it – can be supported
later.</p>
</div>
<div class="section" id="cm-slm-write">
<h5>cm_slm_write<a class="headerlink" href="#cm-slm-write" title="Permalink to this headline">¶</a></h5>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">cm_slm_write</span> <span class="p">(</span><span class="n">uint</span> <span class="n">slmBuffer</span><span class="p">,</span>
           <span class="n">vector_ref</span><span class="o">&lt;</span><span class="n">ushort</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">v_Addr</span><span class="p">,</span>
           <span class="n">vector_ref</span><span class="o">&lt;</span><span class="n">TYPE</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">v_Src</span><span class="p">);</span>
</pre></div>
</div>
<p>Where:</p>
<ul class="simple">
<li>N = 8 or 16;</li>
<li>TYPE could be of size byte, word or dword.</li>
</ul>
<p>Write 8 or 16 data elements (byte, word, or dword) given in the
vector ‘v_Src’ into the SLM buffer ‘slmBuffer’ at the element-
offsets specified in ‘v_Addr’. Note that the addresses are in
units of element size.</p>
<p>A variant of this API ‘cm_slm_write_scaled” is provided with
the same parameters, except the addresses are in units of bytes.</p>
<p>Note: Writes to overlapping addresses will have undefined
write ordering.</p>
</div>
<div class="section" id="cm-slm-write4">
<h5>cm_slm_write4<a class="headerlink" href="#cm-slm-write4" title="Permalink to this headline">¶</a></h5>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">cm_slm_write4</span> <span class="p">(</span><span class="n">uint</span> <span class="n">slmBuffer</span><span class="p">,</span>
           <span class="n">vector_ref</span><span class="o">&lt;</span><span class="n">ushort</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">v_Addr</span><span class="p">,</span>
           <span class="n">vector_ref</span><span class="o">&lt;</span><span class="n">TYPE</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="n">v_Src</span><span class="p">,</span>
           <span class="n">SLM_ChannelMaskType</span> <span class="n">mask</span><span class="p">);</span>
</pre></div>
</div>
<p>Where:</p>
<ul class="simple">
<li>N = 8 or 16;</li>
<li>M is at least N*C where C is the
number of channels enabled in
‘mask’.</li>
<li>TYPE must be of size dword (so, could be int, uint, or float).</li>
<li>‘mask’ specifies the channels that
are enabled – it has to be a compile-time constant of the enum type
SLM_ChannelMaskType that can have the following 15 values:<ul>
<li>SLM_R_ENABLE</li>
<li>SLM_G_ENABLE</li>
<li>SLM_GR_ENABLE</li>
<li>SLM_B_ENABLE</li>
<li>SLM_BR_ENABLE</li>
<li>SLM_BG_ENABLE</li>
<li>SLM_BGR_ENABLE</li>
<li>SLM_A_ENABLE</li>
<li>SLM_AR_ENABLE</li>
<li>SLM_AG_ENABLE</li>
<li>SLM_AGR_ENABLE</li>
<li>SLM_AB_ENABLE</li>
<li>SLM_ABR_ENABLE</li>
<li>SLM_ABG_ENABLE</li>
<li>SLM_ABGR_ENABLE</li>
</ul>
</li>
</ul>
<p>Write 8 or 16 4-element vectors, say {R,G,B,A}, where each
element is of size dword and is also referred to as a channel.</p>
<p>The elements to be written must be in the vector ‘v_Src’ and
organized channel-wise, i.e. all R’s followed by all G’s, and so
on. Address of each 4-element vector inside the SLM buffer
‘slmBuffer’ must be specified in ‘v_Addr’. Note that the
addresses are in units of element size. One or more channels in
the 4-element vector could be masked, and v_Src must contain
only the unmasked or enabled elements.  The argument ‘mask’
specifies the channels that are enabled. Only the enabled
channels are written to SLM.
e.g. if mask = SLM_BR_ENABLE (i.e. only R and B channels
enabled), and v_Src is B7B6B5B4B3B2B1B0 R7R6R5R4R3R2R1R0,
8 vectors written to SLM are as (x B7 x R7), (x B6 x R6), … (x B0 x
R0) -  where ‘x’ means the value is not written.</p>
<p>Note: cm_slm_write4() provides an order of magnitude more
bandwidth than cm_slm_write() on Gen7 hardware. Whenever
possible, cm_slm_write4() should be used instead of
cm_slm_write() to achieve higher performance.</p>
<p>Note: Writes to overlapping addresses will have undefined
write ordering.</p>
<p>A variant of this API ‘cm_slm_write4_scaled” is provided with
the same parameters, except the addresses are in units of bytes.</p>
</div>
<div class="section" id="cm-slm-read">
<h5>cm_slm_read<a class="headerlink" href="#cm-slm-read" title="Permalink to this headline">¶</a></h5>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">cm_slm_read</span><span class="p">(</span><span class="n">uint</span> <span class="n">slmBuffer</span><span class="p">,</span>
                 <span class="n">vector_ref</span><span class="o">&lt;</span><span class="n">ushort</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">v_Addr</span><span class="p">,</span>
                 <span class="n">vector_ref</span><span class="o">&lt;</span><span class="n">TYPE</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">v_Dst</span><span class="p">);</span>
</pre></div>
</div>
<p>Where:</p>
<ul class="simple">
<li>N = 8 or 16;</li>
<li>TYPE could be of size byte, word or dword.</li>
</ul>
<p>Read 8 or 16 data elements (byte, word, or dword) from the
SLM buffer ‘slmBuffer’ at the element-offsets specified in
‘v_Addr’, and write back into the vector ‘v_Dst’. Note that the
addresses are in units of element size.</p>
<p>A variant of this API ‘cm_slm_read_scaled” is provided with
the same parameters, except the addresses are in units of bytes.</p>
</div>
<div class="section" id="cm-slm-read4">
<h5>cm_slm_read4<a class="headerlink" href="#cm-slm-read4" title="Permalink to this headline">¶</a></h5>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">cm_slm_read4</span><span class="p">(</span><span class="n">uint</span> <span class="n">slmBuffer</span><span class="p">,</span>
                  <span class="n">vector_ref</span><span class="o">&lt;</span><span class="n">uint</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">v_Addr</span><span class="p">,</span>
                  <span class="n">vector_ref</span><span class="o">&lt;</span><span class="n">TYPE</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="n">v_Dst</span><span class="p">,</span>
                  <span class="n">SLM_ChannelMaskType</span> <span class="n">mask</span><span class="p">);</span>
</pre></div>
</div>
<p>Where:</p>
<ul class="simple">
<li>N = 8 or 16;</li>
<li>M is at least N*C where C is the number of channels enabled in ‘mask’;</li>
<li>TYPE must be of size dword (so, could be int, uint, or float);</li>
<li>‘mask’ specifies the channels that are enabled – it has to be a compile-time
constant of the enum type SLM_ChannelMaskType that can have the following 15 values:<ul>
<li>SLM_R_ENABLE</li>
<li>SLM_G_ENABLE</li>
<li>SLM_GR_ENABLE</li>
<li>SLM_B_ENABLE</li>
<li>SLM_BR_ENABLE</li>
<li>SLM_BG_ENABLE</li>
<li>SLM_BGR_ENABLE</li>
<li>SLM_A_ENABLE</li>
<li>SLM_AR_ENABLE</li>
<li>SLM_AG_ENABLE</li>
<li>SLM_AGR_ENABLE</li>
<li>SLM_AB_ENABLE</li>
<li>SLM_ABR_ENABLE</li>
<li>SLM_ABG_ENABLE</li>
<li>SLM_ABGR_ENABLE</li>
</ul>
</li>
</ul>
<p>Read 8 or 16 4-element vectors, say {R,G,B,A}, where each
element is of size dword and is also referred to as a channel.</p>
<p>The elements read from SLM are written back to the vector
‘v_Dst’ and organized channel-wise, i.e. all R’s followed by all
G’s, and so on. Address of each 4-element vector inside the
SLM buffer ‘slmBuffer’ must be specified in ‘v_Addr’. Note that
the addresses are in units of element size. One or more
channels in the 4-element vector could be masked, and v_Dst
contains only the unmasked elements. Only the lower 4 bits of
‘mask’ specify the elements masked. A ‘1’ implies that the
corresponding element of each vector will not be read from
SLM.
e.g. if mask = SLM_BR_ENABLE, ‘v_Dst’ would contain
B7B6B5B4B3B2B1B0 R7R6R5R4R3R2R1R0, where the data elements
correspond to the 8 vectors (x B7 x R7), (x B6 x R6), … (x B0 x R0)
read from SLM at the addresses specified in v_Addr, where ‘x’
means the value is not read.</p>
<p>Note: This provides much more (order of magnitude) read
bandwidth than cm_slm_read() on Gen7 hardware. Whenever
possible, cm_slm_read4() should be used instead of
cm_slm_read() to achieve higher performance.</p>
<p>A variant of this API ‘cm_slm_read4_scaled” is provided with
the same parameters, except the addresses are in units of bytes.</p>
</div>
<div class="section" id="cm-slm-fence">
<h5>cm_slm_fence<a class="headerlink" href="#cm-slm-fence" title="Permalink to this headline">¶</a></h5>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">cm_slm_fence</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">mask</span><span class="p">);</span>
</pre></div>
</div>
<p>For Gen10+, cm_slm_fence(CM_GLOBAL_COHERENT_FENCE) must be
added before a barrier to enforce read/write ordering.</p>
</div>
<div class="section" id="cm-barrier">
<h5>cm_barrier<a class="headerlink" href="#cm-barrier" title="Permalink to this headline">¶</a></h5>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">cm_barrier</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>
</pre></div>
</div>
<p>Inserts a barrier to ensure all writes to SLM before this point
would be henceforth visible to other threads in the same
group.</p>
</div>
<div class="section" id="cm-sbarrier">
<h5>cm_sbarrier<a class="headerlink" href="#cm-sbarrier" title="Permalink to this headline">¶</a></h5>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">cm_sbarrier</span> <span class="p">(</span><span class="n">uint</span> <span class="n">flag</span><span class="p">);</span>
</pre></div>
</div>
<p>Split a barrier into two separate events: 1) signal: cm_sbarrier(1);
2) wait: cm_sbarrier(0). The input parameter flag must be a compile-time constant.</p>
</div>
<div class="section" id="cm-slm-load">
<h5>cm_slm_load<a class="headerlink" href="#cm-slm-load" title="Permalink to this headline">¶</a></h5>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">cm_slm_load</span><span class="p">(</span><span class="n">uint</span> <span class="n">slmBuffer</span><span class="p">,</span>
                 <span class="n">SurfaceIndex</span> <span class="n">memSurfIndex</span><span class="p">,</span>
                 <span class="n">uint</span> <span class="n">memOffset</span><span class="p">,</span>
                 <span class="n">uint</span> <span class="n">loadSize</span><span class="p">);</span>
</pre></div>
</div>
<p>Load ‘loadSize’ bytes from memory surface ‘memSurfIndex’
starting at ‘memOffset’ to the SLM buffer ‘slmBuffer’.
‘loadSize’ must be a multiple of 256.</p>
</div>
<div class="section" id="cm-slm-atomic">
<h5>cm_slm_atomic<a class="headerlink" href="#cm-slm-atomic" title="Permalink to this headline">¶</a></h5>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">cm_slm_atomic</span><span class="p">(</span><span class="n">uint</span> <span class="n">slmBuffer</span><span class="p">,</span>
                   <span class="n">CmAtomicOpType</span> <span class="n">aop</span><span class="p">,</span>
                   <span class="n">T</span>  <span class="n">v_Addr</span><span class="p">,</span>
                   <span class="n">T1</span> <span class="n">v_Dst</span><span class="p">,</span>
                   <span class="n">T2</span> <span class="n">v_Src0</span><span class="p">,</span>
                   <span class="n">T3</span> <span class="n">v_Src1</span><span class="p">);</span>
</pre></div>
</div>
<p>Where:</p>
<ul class="simple">
<li>v_Src0 and v_Src1 are optional and are needed based on
the atomic operation ‘aop’;</li>
<li>Type T is vector_ref&lt;ushort, N&gt;, where N is 8 or 16.</li>
<li>The types T1, T2, T3 are either
vector_ref&lt;TYPE, N&gt;, where TYPE could be int or uint, and N is 8 or 16.</li>
<li>v_Src0 and v_Src1 both are needed
when ‘aop’ is ATOMIC_CMPXCHG.
No sources needed when ‘aop’ is
ATOMIC_INC, ATOMIC_DEC, AND
ATOMIC_PREDEC.
For all other atomic operations, only
one source v_Src0 is needed.</li>
<li>v_Dst can optionally be NULL which
indicates no return value is to be
used.</li>
<li>‘aop’ specifies the atomic operation.
It has to be a compile-time constant.</li>
</ul>
<p>This causes atomic read-modify-write operations on the
destination locations addressed.</p>
<p>The destination locations are given in ‘v_Addr’ and the desired
atomic operation is specified as ‘aop’. The value returned in
‘v_Dst’ depends on the atomic operation. Whether the two
optional sources, ‘v_Src0’ and ‘v_Src1’, are needed also
depends on the atomic operation.</p>
</div>
</div>
<div class="section" id="slm-block-read-write">
<h4>SLM Block Read/Write<a class="headerlink" href="#slm-block-read-write" title="Permalink to this headline">¶</a></h4>
<p>CM provides the following qualifiers for specifying the input usage options:</p>
<table border="1" class="docutils">
<colgroup>
<col width="23%" />
<col width="77%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Qualifier</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>DWALIGNED</td>
<td>indicates that the offset is DWord aligned.</td>
</tr>
<tr class="row-odd"><td>MODIFIED_DWALIGNED</td>
<td>deprecated: same as DWALIGNED, as there is no modified bit in
current hardware.</td>
</tr>
</tbody>
</table>
<p>Out-of-bound reads return zero, while out-of-bound writes are dropped.</p>
<p>Note: CM currently only supports read/write operations of SLM Block data with
size &lt;= 128 bytes.</p>
<div class="section" id="cm-slm-block-read">
<h5>cm_slm_block_read<a class="headerlink" href="#cm-slm-block-read" title="Permalink to this headline">¶</a></h5>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">cm_slm_block_read</span><span class="p">(</span><span class="n">uint</span> <span class="n">slmBuffer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="n">vector_ref</span> <span class="n">v</span><span class="p">);</span>
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="19%" />
<col width="81%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>slmBuffer</td>
<td>must correspond to a SLM-buffer
(optionally qualified as specified above)</td>
</tr>
<tr class="row-odd"><td>offset</td>
<td>zero based offset of the input buffer in <em>bytes</em>.  Must be
OWord (i.e. 16 bytes) aligned, but need be only DWord (i.e. 4
bytes) aligned if the DWALIGNED or MODIFIED_DWALIGNED modifier
is present.</td>
</tr>
<tr class="row-even"><td>v</td>
<td>the data location to be read / written:
the width of vector v must be OWord (i.e. 16 bytes) aligned.</td>
</tr>
</tbody>
</table>
<p>Usage example:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">read</span> <span class="p">(</span><span class="n">DWALIGNED</span><span class="p">(</span><span class="n">slmBuffer</span><span class="p">),</span> <span class="p">...)</span>  <span class="c1">// the offset ind is DWord aligned</span>
<span class="n">read</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="p">...)</span>                    <span class="c1">// the offset ind is OWord aligned</span>
</pre></div>
</div>
</div>
<div class="section" id="cm-slm-block-write">
<h5>cm_slm_block_write<a class="headerlink" href="#cm-slm-block-write" title="Permalink to this headline">¶</a></h5>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">cm_slm_block_write</span><span class="p">(</span><span class="n">uint</span> <span class="n">slmBuffer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span> <span class="n">v</span><span class="p">);</span>
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="19%" />
<col width="81%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>slmBuffer</td>
<td>must correspond to a SLM-buffer
(optionally qualified as specified above)</td>
</tr>
<tr class="row-odd"><td>offset</td>
<td>zero based offset of the input buffer in <em>bytes</em>;
must be OWord (i.e. 16 bytes) aligned.</td>
</tr>
<tr class="row-even"><td>v</td>
<td>the data location to be read / written:
the width of vector v can be only 1, 2, 4 or 8 OWords.</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="section" id="sampler-interface">
<h3><a class="toc-backref" href="#id55">4.7 Sampler Interface</a><a class="headerlink" href="#sampler-interface" title="Permalink to this headline">¶</a></h3>
<p>CM provides the user with the following sampler function support:</p>
<div class="section" id="sample16">
<h4>sample16<a class="headerlink" href="#sample16" title="Permalink to this headline">¶</a></h4>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">sample16</span><span class="p">(</span><span class="n">matrix_ref</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="mi">16</span><span class="o">&gt;</span> <span class="n">m</span><span class="p">,</span> <span class="n">ChannelMaskType</span> <span class="n">channelMask</span><span class="p">,</span>
  <span class="n">SurfaceIndex</span> <span class="n">surfIndex</span><span class="p">,</span> <span class="n">SamplerIndex</span> <span class="n">sampIndex</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">16</span><span class="o">&gt;</span> <span class="n">u</span><span class="p">,</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">16</span><span class="o">&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">16</span><span class="o">&gt;</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>m</td>
<td>the matrix to store the return results, where N is at least
the number of enabled channels. The element type T can be
one of float, int, or unsigned int based on the format of
the surface being sampled.</td>
</tr>
<tr class="row-odd"><td>channelMask</td>
<td>enabled channels.  It must be a compile time constant.</td>
</tr>
<tr class="row-even"><td>surfIndex</td>
<td>surface index. This is an abstract handle that represents
the surface created by CM host runtime [6] and must be
passed through kernel function parameters. CM does not allow
the explicit use of local/global variable or modification of
such abstract data types in kernel functions, except used as
function call argument.</td>
</tr>
<tr class="row-odd"><td>sampIndex</td>
<td>the index into the sampler state table. This is an abstract
handle that represents the sampler state created by CM host
runtime [6] and must be passed through kernel function
parameters. CM does not allow the explicit use of
local/global variable or modification of such abstract data
types in kernel functions, except used as function call
argument.</td>
</tr>
<tr class="row-even"><td>u</td>
<td>the normalized x coordinates of the texels to be sampled.</td>
</tr>
<tr class="row-odd"><td>v</td>
<td>(optional, default = 0) the normalized y coordinates for
non-1D surface types; ignored otherwise.</td>
</tr>
<tr class="row-even"><td>r</td>
<td>(optional, default = 0) the normalized z coordinates for any
3D surface types; ignored otherwise.</td>
</tr>
</tbody>
</table>
<p>The compiler generates code for GenX hardware to sample 16 texels given by u,
v, and r.  The results are returned in m with each enabled channel returned in
the next row of m.  The enabled channels are returned in R, G, B, A order with
no gap in m for disabled channels.</p>
<p>Supported Surfaces:</p>
<table border="1" class="docutils">
<colgroup>
<col width="36%" />
<col width="8%" />
<col width="3%" />
<col width="3%" />
<col width="3%" />
<col width="3%" />
<col width="43%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Format</th>
<th class="head">Type</th>
<th class="head">R</th>
<th class="head">G</th>
<th class="head">B</th>
<th class="head">A</th>
<th class="head">Return Type</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>CM_SURFACE_FORMAT_A8R8G8B8</td>
<td>2D/3D</td>
<td>R</td>
<td>G</td>
<td>B</td>
<td>A</td>
<td>float</td>
</tr>
<tr class="row-odd"><td>CM_SURFACE_FORMAT_A8</td>
<td>2D/3D</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td>A</td>
<td>float</td>
</tr>
<tr class="row-even"><td>CM_SURFACE_FORMAT_YUY2</td>
<td>2D</td>
<td>V</td>
<td>Y</td>
<td>U</td>
<td>&#160;</td>
<td>float</td>
</tr>
<tr class="row-odd"><td>CM_SURFACE_FORMAT_NV12 {Gen7_5+}</td>
<td>2D</td>
<td>Cr</td>
<td>Y</td>
<td>Cb</td>
<td>&#160;</td>
<td>float</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="load16">
<h4>load16<a class="headerlink" href="#load16" title="Permalink to this headline">¶</a></h4>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">load16</span><span class="p">(</span><span class="n">matrix_ref</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="mi">16</span><span class="o">&gt;</span> <span class="n">m</span><span class="p">,</span> <span class="n">ChannelMaskType</span> <span class="n">channelMask</span><span class="p">,</span>
  <span class="n">SurfaceIndex</span> <span class="n">surfIndex</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">uint</span><span class="p">,</span> <span class="mi">16</span><span class="o">&gt;</span> <span class="n">u</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">uint</span><span class="p">,</span> <span class="mi">16</span><span class="o">&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="n">uint</span><span class="p">,</span> <span class="mi">16</span><span class="o">&gt;</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="19%" />
<col width="81%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>m</td>
<td>the matrix to store the return results, where N is at least the
number of enabled channels.</td>
</tr>
<tr class="row-odd"><td>channelMask</td>
<td>enabled channels.  It must be a compile time constant.</td>
</tr>
<tr class="row-even"><td>surfIndex</td>
<td>surface index. This is an abstract handle that represents the
surface created by CM host runtime [6] and must be passed
through kernel function parameters. CM does not allow the
explicit use of local/global variable or modification of such
abstract data types in kernel functions, except used as
function call argument.</td>
</tr>
<tr class="row-odd"><td>u</td>
<td>the unnormalized x coordinates of the texels to be sampled.</td>
</tr>
<tr class="row-even"><td>v</td>
<td>(optional, default = 0) the unnormalized y coordinates for
non-1D surface types; ignored otherwise.</td>
</tr>
<tr class="row-odd"><td>r</td>
<td>(optional, default = 0) the unnormalized z coordinates for any
3D surface types; ignored otherwise.</td>
</tr>
</tbody>
</table>
<p>The compiler generates a sampler “ld” message, which samples the surface using
the default sampler state.  The u, v, and r parameters represent integer texel
addresses.  The results, in normalized floating point values of range [0, 1],
are returned in m with each enabled channel returned in the next row of m.  The
enabled channels are returned in R, G, B, A order with no gap in m for disabled
channels.</p>
<p>Supported Surfaces:</p>
<table border="1" class="docutils">
<colgroup>
<col width="36%" />
<col width="8%" />
<col width="3%" />
<col width="3%" />
<col width="3%" />
<col width="3%" />
<col width="43%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Format</th>
<th class="head">Type</th>
<th class="head">R</th>
<th class="head">G</th>
<th class="head">B</th>
<th class="head">A</th>
<th class="head">Return Type</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>CM_SURFACE_FORMAT_A8R8G8B8</td>
<td>2D/3D</td>
<td>R</td>
<td>G</td>
<td>B</td>
<td>A</td>
<td>float</td>
</tr>
<tr class="row-odd"><td>CM_SURFACE_FORMAT_A8</td>
<td>2D/3D</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td>A</td>
<td>float</td>
</tr>
<tr class="row-even"><td>CM_SURFACE_FORMAT_YUY2</td>
<td>2D</td>
<td>V</td>
<td>Y</td>
<td>U</td>
<td>&#160;</td>
<td>float</td>
</tr>
<tr class="row-odd"><td>CM_SURFACE_FORMAT_NV12 {Gen7_5+}</td>
<td>2D</td>
<td>Cr</td>
<td>Y</td>
<td>Cb</td>
<td>&#160;</td>
<td>float</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="cm-3d-sample">
<h4>cm_3d_sample<a class="headerlink" href="#cm-3d-sample" title="Permalink to this headline">¶</a></h4>
<p>{Only for new cm-llvm compiler cmc on SKL+ - not supported for legacy cm-icl compiler - icl}</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="n">CM3DSampleOp</span> <span class="n">Op</span><span class="p">,</span> <span class="n">ChannelMaskType</span> <span class="n">Ch</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="p">,</span>
          <span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">cm_3d_sample</span><span class="p">(</span><span class="n">vector_ref</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">dst</span><span class="p">,</span> <span class="n">ushort</span> <span class="n">Aoffimmi</span><span class="p">,</span>
                  <span class="n">SamplerIndex</span> <span class="n">sampIndex</span><span class="p">,</span> <span class="n">SurfaceIndex</span> <span class="n">surfIndex</span><span class="p">,</span>
                  <span class="n">Args</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span>
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="17%" />
<col width="83%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Op</td>
<td>sample operation. Please refer to the table below to see what
operations are available</td>
</tr>
<tr class="row-odd"><td>Ch</td>
<td>channel mask selection. See section 4.4 for the permitted
values.</td>
</tr>
<tr class="row-even"><td>args</td>
<td><p class="first">between 1 and 15 variadic arguments, each of which must be
a same type and be a vector or matrix of type float (half is
permitted on CNL+). The number of elements in this type
determines if the operation is performed in SIMD8 or SIMD16
mode. If the number of less than 16, only the first 8
elements are significant and the operation is performed in
SIMD8 mode. If there are 16 or more elements, the first 16
only are significant and the operation is performed in SIMD16
mode. There must be at least 8 elements in this type.</p>
<p class="last">The precise number of arguments depends on the sample operation being
performed, see the table below for details of what needs to be
supplied.</p>
</td>
</tr>
<tr class="row-odd"><td>dst</td>
<td><p class="first">a reference to the destination vector, where the results of
the sample are stored. This is a vector of type  half, float,
ushort, short, int or uint.</p>
<p>For 32-bit return types (float, int, uint):</p>
<p>For each enabled channel in Ch up to 8 or 16 values are returned
starting from R, dependent on the SIMD width. Disabled channels
are skipped in the results, with only enabled channels being
written.</p>
<p>For 16-bit return types (half, short and ushort):</p>
<p>For each enabled channel in Ch 16 elements are written to the
destination starting from R. Disabled channels are skipped
in the results, with only the enabled pixels being written.
In SIMD8 mode the upper 8 elements for each returned channel
are undefined.</p>
<p>For LOD operations the R channel contains the clamped LOD
values while the G channel contains the unclamped LOD values. The
B and A channels have undefined values and should be masked out.</p>
<p class="last">For all operations, if CM_3D_SAMPLE_NULL_MASK_ENABLE is enabled
in Op then an additional GRF’s worth of data is written after
the sampler data, with 8 or 16 bits (dependent on the SIMD width)
of the first ushort containing pixel null mask values: all bits
contain 1 except for those where a null page was source for at
least one texel.</p>
</td>
</tr>
<tr class="row-even"><td>Aofimmi</td>
<td><p class="first">a ushort value containing the Aofimmi modifier, where:</p>
<ul class="simple">
<li>Bit 0-3: The R offset</li>
<li>Bit 4-7: The V offset</li>
<li>Bit 8-11: The U offset</li>
</ul>
<p class="last">These offsets must be in the range [-8,7]. Bit 12-15 are reserved
and must be zero.</p>
</td>
</tr>
<tr class="row-odd"><td>sampIndex</td>
<td>the sampler index</td>
</tr>
<tr class="row-even"><td>surfIndex</td>
<td>the surface index</td>
</tr>
</tbody>
</table>
<p>This samples “surfIndex” using the sampler state “sampIndex”. LOD, bias, ref,
and gradients are computed differently based on the sampler operation.</p>
<p>The type CM3DSampleOp defines what sample operations are supported and
how any variadic arguments supplied are interpreted according to each
specific operation. For any of the variadic arguments it is
possible to give 0 to indicate a default, all zeros argument, and
any missing trailing variadic arguments will be defaulted to 0 anyway.</p>
<p>The table below lists the operations available and the arguments expected,
in the order they are expected.</p>
<table border="1" class="docutils">
<colgroup>
<col width="27%" />
<col width="73%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">3D Sample Operation</th>
<th class="head">Variadic Arguments</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>CM_3D_SAMPLE</td>
<td>u, v, r, ai</td>
</tr>
<tr class="row-odd"><td>CM_3D_SAMPLE_B</td>
<td>bias, u, v, r, ai</td>
</tr>
<tr class="row-even"><td>CM_3D_SAMPLE_L</td>
<td>lod, u, v, r, ai</td>
</tr>
<tr class="row-odd"><td>CM_3D_SAMPLE_C</td>
<td>ref, u, v, r, ai</td>
</tr>
<tr class="row-even"><td>CM_3D_SAMPLE_D</td>
<td>u, dudx, duxy, v, dvdx, dvdy, r, drdx, drdy, ai</td>
</tr>
<tr class="row-odd"><td>CM_3D_SAMPLE_B_C</td>
<td>ref, bias, u, v, r, ai</td>
</tr>
<tr class="row-even"><td>CM_3D_SAMPLE_L_C</td>
<td>ref, lod, u, v, r, ai</td>
</tr>
<tr class="row-odd"><td>CM_3D_LOD</td>
<td>u, v, r, ai</td>
</tr>
<tr class="row-even"><td>CM_3D_SAMPLE_D_C</td>
<td>ref, u, dudx, duxy, v, dvdx, dvdy, r, drdx, drdy, ai</td>
</tr>
<tr class="row-odd"><td>CM_3D_SAMPLE_LZ</td>
<td>u, v, r, ai</td>
</tr>
<tr class="row-even"><td>CM_3D_SAMPLE_C_LZ</td>
<td>ref, u, v, r, ai</td>
</tr>
</tbody>
</table>
<p>Each of the values above can be composed with CM_3D_SAMPLE_NULLMASK_ENABLE
using the | operation to enable a variant of the operation that also
returns pixel null mask information.</p>
<p>The following table lists surface types supported for each operation:</p>
<table border="1" class="docutils">
<colgroup>
<col width="47%" />
<col width="53%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">3D Sample Operation</th>
<th class="head">Surface Types</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>CM_3D_SAMPLE</td>
<td>1D, 2D, 3D, CUBE</td>
</tr>
<tr class="row-odd"><td>CM_3D_SAMPLE_B</td>
<td>1D, 2D, 3D, CUBE</td>
</tr>
<tr class="row-even"><td>CM_3D_SAMPLE_L</td>
<td>1D, 2D, 3D, CUBE</td>
</tr>
<tr class="row-odd"><td>CM_3D_SAMPLE_C</td>
<td>1D, 2D, CUBE</td>
</tr>
<tr class="row-even"><td>CM_3D_SAMPLE_D</td>
<td>1D, 2D, 3D, CUBE</td>
</tr>
<tr class="row-odd"><td>CM_3D_SAMPLE_B_C</td>
<td>1D, 2D, CUBE</td>
</tr>
<tr class="row-even"><td>CM_3D_SAMPLE_L_C</td>
<td>1D, 2D, 3D, CUBE</td>
</tr>
<tr class="row-odd"><td>CM_3D_SAMPLE_D_C</td>
<td>1D, 2D, CUBE</td>
</tr>
<tr class="row-even"><td>CM_3D_SAMPLE_LZ</td>
<td>1D, 2D, 3D, CUBE</td>
</tr>
<tr class="row-odd"><td>CM_3D_SAMPLE_C_LZ</td>
<td>1D, 2D, CUBE</td>
</tr>
</tbody>
</table>
<p>The following table lists how the common “u”, “v”, “r”, and “ai” arguments are interpreted
against different surface types:</p>
<table border="1" class="docutils">
<colgroup>
<col width="12%" />
<col width="20%" />
<col width="22%" />
<col width="22%" />
<col width="23%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Surface Type</th>
<th class="head">u</th>
<th class="head">v</th>
<th class="head">r</th>
<th class="head">ai</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>1D</td>
<td>Normalized x coordinate</td>
<td>Unnormalized array index</td>
<td>ignored</td>
<td>ignored</td>
</tr>
<tr class="row-odd"><td>2D</td>
<td>Normalized x coordinate</td>
<td>Normalized y coordinate</td>
<td>Unnormalized array index</td>
<td>ignored</td>
</tr>
<tr class="row-even"><td>3D</td>
<td>Normalized x coordinate</td>
<td>Normalized y coordinate</td>
<td>Normalized z coordinate</td>
<td>ignored</td>
</tr>
<tr class="row-odd"><td>CUBE</td>
<td>Normalized x coordinate</td>
<td>Normalized y coordinate</td>
<td>Normalized z coordinate</td>
<td>Unnormalized array index</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="cm-3d-load">
<h4>cm_3d_load<a class="headerlink" href="#cm-3d-load" title="Permalink to this headline">¶</a></h4>
<p>{Only for new cm-llvm compiler cmc on SKL+ - not supported for legacy cm-icl compiler - icl}</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="n">CM3DLoadOp</span> <span class="n">Op</span><span class="p">,</span> <span class="n">ChannelMaskType</span> <span class="n">Ch</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="p">,</span>
          <span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">cm_3d_load</span><span class="p">(</span><span class="n">vector_ref</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">dst</span><span class="p">,</span> <span class="n">ushort</span> <span class="n">Aofimmi</span><span class="p">,</span> <span class="n">SurfaceIndex</span> <span class="n">surfIndex</span><span class="p">,</span>
                <span class="n">Args</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span>
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="17%" />
<col width="83%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Op</td>
<td>load operation. Please refer to the table below to see what
operations are available</td>
</tr>
<tr class="row-odd"><td>Ch</td>
<td>channel mask selection. See section 4.4 for the permitted
values.</td>
</tr>
<tr class="row-even"><td>args</td>
<td><p class="first">between 1 and 15 variadic arguments, each of which must be
a same type and be a vector or matrix of type uint or ushort
The number of elements in this type determines if the operation
is performed in SIMD8 or SIMD16 mode. If the number of less than
16, only the first 8 elements are significant and the operation
is performed in SIMD8 mode. If there are 16 or more elements, the
first 16 only are significant and the operation is performed in
SIMD16 mode. There must be at least 8 elements in this type.</p>
<p class="last">The precise number of arguments depends on the load operation being
performed, see the table below for details of what needs to be
supplied.</p>
</td>
</tr>
<tr class="row-odd"><td>dst</td>
<td><p class="first">a reference to the destination vector, where the results of
the load are stored. This is a vector of type half, float, ushort,
short, int or uint.</p>
<p>For 32-bit return types (float, int, uint):</p>
<p>For each enabled channel in Ch up to 8 or 16 values are returned
starting from R, dependent on the SIMD width. Disabled channels
are skipped in the results, with only enabled channels being
written.</p>
<p>For 16-bit return types (half, short and ushort):</p>
<p>For each enabled channel in Ch 16 elements are written to the
destination starting from R. Disabled channels are skipped
in the results, with only the enabled pixels being written.
In SIMD8 mode the upper 8 elements for each returned channel
are undefined.</p>
<p class="last">For all operations, if CM_3D_LOAD_NULL_MASK_ENABLE is enabled
in Op then an additional GRF’s worth of data is written after
the sampler data, with 8 or 16 bits (dependent on the SIMD width)
of the first ushort containing pixel null mask values: all bits
contain 1 except for those where a null page was source for at
least one texel.</p>
</td>
</tr>
<tr class="row-even"><td>Aofimmi</td>
<td><p class="first">a ushort value containing the Aofimmi modifier, where:</p>
<ul class="simple">
<li>Bit 0-3: The R offset</li>
<li>Bit 4-7: The V offset</li>
<li>Bit 8-11: The U offset</li>
</ul>
<p class="last">These offsets must be in the range [-8,7]. Bit 12-15 are reserved
and must be zero.</p>
</td>
</tr>
<tr class="row-odd"><td>surfIndex</td>
<td>the surface index</td>
</tr>
</tbody>
</table>
<p>This loads data from “surfIndex” at the given integer texel addresses</p>
<p>The type CM3DLoadOp defines what load operations are supported and
how any variadic arguments supplied are interpreted according to each
specific operation. For any of the variadic arguments it is
possible to give 0 to indicate a default, all zeros argument, and
any missing trailing variadic arguments will defaulted to 0 anyway.</p>
<p>The table below lists the operations available and the arguments expected,
in the order they are expected.</p>
<table border="1" class="docutils">
<colgroup>
<col width="44%" />
<col width="56%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">3D Load Operation</th>
<th class="head">Variadic Arguments</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>CM_3D_LOAD</td>
<td>u, v, lod, r</td>
</tr>
<tr class="row-odd"><td>CM_3D_LOAD_LZ</td>
<td>u, v, r</td>
</tr>
<tr class="row-even"><td>CM_3D_LOAD_2DMS_W (type uint)</td>
<td>si, mcsl, mcsh, u, v, r, lod</td>
</tr>
<tr class="row-odd"><td>CM_3D_LOAD_2DMS_W (type ushort) {ICL+}</td>
<td>si, mcs0, mcs1, mcs2, mcs3, u, v, r, lod</td>
</tr>
<tr class="row-even"><td>CM_3D_LOAD_MCS</td>
<td>u, v, r, lod</td>
</tr>
</tbody>
</table>
<p>Each of the values above can be composed with CM_3D_LOAD_NULLMASK_ENABLE
using the | operation to enable a variant of the operation that also
returns pixel null mask information.</p>
<p>The following table lists surface types supported for each operation:</p>
<table border="1" class="docutils">
<colgroup>
<col width="47%" />
<col width="53%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">3D Load Operation</th>
<th class="head">Surface Types</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>CM_3D_LOAD</td>
<td>1D, 2D, 3D, BUFFER</td>
</tr>
<tr class="row-odd"><td>CM_3D_LOAD_LZ</td>
<td>1D, 2D, 3D, BUFFER</td>
</tr>
<tr class="row-even"><td>CM_3D_LOAD_2DMS_W</td>
<td>2D</td>
</tr>
<tr class="row-odd"><td>CM_3D_LOAD_MCS</td>
<td>2D</td>
</tr>
</tbody>
</table>
<p>The following table lists how the common “u”, “v”, “r”, and “ai” arguments are interpreted
against different surface types:</p>
<table border="1" class="docutils">
<colgroup>
<col width="16%" />
<col width="26%" />
<col width="29%" />
<col width="29%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Surface Type</th>
<th class="head">u</th>
<th class="head">v</th>
<th class="head">r</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>1D</td>
<td>Unnormalized x coordinate</td>
<td>Unnormalized array index</td>
<td>ignored</td>
</tr>
<tr class="row-odd"><td>2D</td>
<td>Unnormalized x coordinate</td>
<td>Unnormalized y coordinate</td>
<td>Unnormalized array index</td>
</tr>
<tr class="row-even"><td>3D</td>
<td>Unnormalized x coordinate</td>
<td>Unnormalized y coordinate</td>
<td>Unnormalized z coordinate</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="adaptive-video-scaling">
<h3><a class="toc-backref" href="#id56">4.8 Adaptive Video Scaling</a><a class="headerlink" href="#adaptive-video-scaling" title="Permalink to this headline">¶</a></h3>
<div class="section" id="cm-avs-sampler">
<h4>cm_avs_sampler<a class="headerlink" href="#cm-avs-sampler" title="Permalink to this headline">¶</a></h4>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">cm_avs_sampler</span><span class="p">(</span><span class="n">matrix_ref</span> <span class="n">m</span><span class="p">,</span> <span class="n">ChannelMaskType</span> <span class="n">channelMask</span><span class="p">,</span>
  <span class="n">SurfaceIndex</span> <span class="n">surfIndex</span><span class="p">,</span> <span class="n">SamplerIndex</span> <span class="n">sampIndex</span><span class="p">,</span> <span class="kt">float</span> <span class="n">u</span><span class="p">,</span> <span class="kt">float</span> <span class="n">v</span><span class="p">,</span>
  <span class="kt">float</span> <span class="n">deltaU</span><span class="p">,</span> <span class="kt">float</span> <span class="n">deltaV</span><span class="p">,</span> <span class="kt">float</span> <span class="n">u2d</span><span class="p">,</span> <span class="kt">int</span> <span class="n">GroupID</span> <span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
  <span class="kt">short</span> <span class="n">VertBlockNumber</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">OutputFormatControl</span> <span class="n">cntrl</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
  <span class="kt">float</span> <span class="n">v2d</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">AVSExecMode</span> <span class="n">execMode</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">IEFBypass</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span>
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>m</td>
<td>matrix to store the return results. See below for details.</td>
</tr>
<tr class="row-odd"><td>channelMask</td>
<td>enabled channels.  It must be a compile time constant.</td>
</tr>
<tr class="row-even"><td>surfIndex</td>
<td>surface index, which must correspond to a 2D type surface
that has a format  with &lt;= 10 bits  per channel.</td>
</tr>
<tr class="row-odd"><td>sampIndex</td>
<td>the index into the sampler state table.</td>
</tr>
<tr class="row-even"><td>u</td>
<td>the normalized x coordinat of pixel 0.</td>
</tr>
<tr class="row-odd"><td>v</td>
<td>the normalized y coordinat of pixel 0.</td>
</tr>
<tr class="row-even"><td>deltaU</td>
<td>the difference in coordinates for adjacent pixels in the X
direction.</td>
</tr>
<tr class="row-odd"><td>deltaV</td>
<td>the difference in coordinates for adjacent pixels in the Y
direction.</td>
</tr>
<tr class="row-even"><td>u2d</td>
<td>Defines the change in the delta U for adjacent pixels in the
X direction</td>
</tr>
<tr class="row-odd"><td>GroupID</td>
<td>This field is valid and must be set for Gen7+, for all
previous platforms this field is ignored.  This parameter
will be used to group messages for reorder for sample_8x8
messages.  For all messages with the same Group ID they must
have the following in common: Surface state, Sampler State,
GRFID, M0, and M1 except for Block number.</td>
</tr>
<tr class="row-even"><td>VertBlockNumber</td>
<td><p class="first">This field is valid and must be set for Gen7+, for all
previous platforms this field is ignored. This field will
specify the vertical block offset being sent for this
sample_8x8 messages.  This will be equal to the vertical
pixel offset from the given address divided by 4.</p>
<p class="last">e.g.  A 16x16 macro-block can be processed with 4 16x4
blocks.  They can share one Group ID, Pix0U, and Pix0V for
the group.  Top block has VBN=0, the next below has VBN=1,
and so on.  Here Pix0U, and Pix0V are address for the pixel
at the top left of the group, not the block origin.</p>
</td>
</tr>
<tr class="row-odd"><td>cntrl</td>
<td><p class="first">An enumeration constant that specifies the output format for
each pixel.</p>
<ul class="last simple">
<li>CM_16_FULL: two bytes will be returned for each pixel
channel, and TYPE of m must be short or unsigned short.</li>
<li>CM_16_DOWN_SAMPLE {Gen7.5+}: like previous, except that
only the even pixels in R and B channels are returned.</li>
<li>CM_8_FULL {Gen7.5+}: one byte will be returned for each
pixel channel, and TYPE of m must be char or unsigned
char.</li>
<li>CM_8_DOWN_SAMPLE {Gen7.5+}: like previous, except that
only the even pixels in R and B channels are returned.</li>
</ul>
</td>
</tr>
<tr class="row-even"><td>v2d</td>
<td>Defines the change in the delta V for adjacent pixels in the
Y direction. This parameter is for Gen8+ only, ignored for
previous architectures.</td>
</tr>
<tr class="row-odd"><td>execMode</td>
<td><p class="first">an enumeration constant that determines the number of pixels
to be returned.</p>
<ul class="last simple">
<li>CM_AVS_16x4</li>
<li>CM_AVS_16x8 {Gen8+}</li>
<li>CM_AVS_8x4 {Gen9+} output shuffle must be set</li>
<li>CM_AVS_4x4 {Gen9+} output shuffle must be set</li>
</ul>
</td>
</tr>
<tr class="row-even"><td>IEFBypass</td>
<td>Gen8 only, this field enables EIF pass. Default is 0.</td>
</tr>
</tbody>
</table>
<p>The results are returned
in matrix m with each enabled channel stored in the next row.  The
actual data returned is determined by a combination of
channelMask, cntrl, execMode, as well as whether output
shuffle is enabled in the sampler state.</p>
<ul>
<li><p class="first">If output shuffle is off:</p>
<table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="25%" />
<col width="25%" />
<col width="25%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>R[0:N]</td>
<td>G[0:N]</td>
<td>B[0:N]</td>
<td>A[0:N]</td>
</tr>
<tr class="row-even"><td>R[64:127]</td>
<td>G[64:127]</td>
<td>B[64:127]</td>
<td>A[64:127]</td>
</tr>
</tbody>
</table>
<p>Where R[0] corresponds to the first element in m.  N is
equal to the number of pixels specified by the execMode
except for CM_AVS_16x8, for which N is 63.  For
CM_AVS_16x8 mode, an additional 64 pixels will be
delivered.  The disabled channels will be skipped with no
gap in m.  The cntrl field determines the pixel channel
size as well as whether the odd pixels will be skipped for
the R and B channels.</p>
</li>
<li><p class="first">If output shuffle is on {Gen9+}:</p>
<p>The format of CM_AVS_16x4 mode becomes</p>
<table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="25%" />
<col width="25%" />
<col width="25%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>R[0:7][16:23][32:39][48:55]</td>
<td>G[0:7][16:23][32:39][48:55]</td>
<td>B[0:7][16:23][32:39][48:55]</td>
<td>A[0:7][16:23][32:39][48:55]</td>
</tr>
<tr class="row-even"><td>R[8:15][24:31][40:47][56:63]</td>
<td>G[8:15][24:31][40:47][56:63]</td>
<td>B[8:15][24:31][40:47][56:63]</td>
<td>A[8:15][24:31][40:47][56:63]</td>
</tr>
</tbody>
</table>
<p>The disabled channels will be skipped with no gap in m.  The
cntrl field determines the pixel channel size as well as
whether the odd pixels will be skipped for the R and B
channels.</p>
<p>The format of CM_AVS_8x4 and CM_AVS_4x4 is the same as
before, while CM_AVS_16x8 is not supported.</p>
<p>For CM_8_DOWN_SAMPLE control mode, if either R or B channel
(but not both) are disabled, the two channels will not be
skipped in m, but the disabled channel is not written to m.
If both R and B channels are disabled they will still be
skipped.</p>
</li>
</ul>
<p>Supported Surfaces:</p>
<table border="1" class="docutils">
<colgroup>
<col width="36%" />
<col width="8%" />
<col width="3%" />
<col width="3%" />
<col width="3%" />
<col width="3%" />
<col width="43%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Format</th>
<th class="head">Type</th>
<th class="head">R</th>
<th class="head">G</th>
<th class="head">B</th>
<th class="head">A</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>CM_SURFACE_FORMAT_UYVY</td>
<td>2D</td>
<td>Cr</td>
<td>Y</td>
<td>Cb</td>
<td>&#160;</td>
<td>Swappy</td>
</tr>
<tr class="row-odd"><td>CM_SURFACE_FORMAT_YUY2</td>
<td>2D</td>
<td>Cr</td>
<td>Y</td>
<td>Cb</td>
<td>&#160;</td>
<td>Normal</td>
</tr>
<tr class="row-even"><td>CM_SURFACE_FORMAT_A8</td>
<td>2D</td>
<td>R</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>CM_SURFACE_FORMAT_NV12</td>
<td>2D</td>
<td>Cr</td>
<td>Y</td>
<td>Cb</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="video-analytics-functions-gen8">
<h3><a class="toc-backref" href="#id57">4.9 Video Analytics Functions (Gen8+)</a><a class="headerlink" href="#video-analytics-functions-gen8" title="Permalink to this headline">¶</a></h3>
<div class="section" id="d-convolve">
<h4>4.9.1 2d Convolve<a class="headerlink" href="#d-convolve" title="Permalink to this headline">¶</a></h4>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">cm_va_2d_convolve</span><span class="p">(</span><span class="n">matrix_ref</span><span class="o">&lt;</span><span class="kt">short</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">16</span><span class="o">&gt;</span> <span class="n">m</span><span class="p">,</span> <span class="n">SurfaceIndex</span> <span class="n">surfIndex</span><span class="p">,</span>
  <span class="n">SamplerIndex</span> <span class="n">sampIndex</span><span class="p">,</span> <span class="kt">float</span> <span class="n">u</span><span class="p">,</span> <span class="kt">float</span> <span class="n">v</span><span class="p">,</span> <span class="n">CONVExecMode</span> <span class="n">execMode</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
  <span class="kt">bool</span> <span class="n">big_kernel</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>m</td>
<td><p class="first">the matrix to store the return results. Output format is
16bit SINT.</p>
<ul class="last simple">
<li>16x4 mode: matrix&lt;short, 4,16&gt;. Data is laid out in pixel
sequential order.</li>
<li>16x1 mode: matrix&lt;short, 1,16&gt;. Data is laid out in pixel
sequential order.</li>
</ul>
</td>
</tr>
<tr class="row-odd"><td>surfIndex</td>
<td>surface index, which must correspond to a 2D type surface
that has either 8-bit or 16bit format.</td>
</tr>
<tr class="row-even"><td>sampIndex</td>
<td>the index into the sampler state table.</td>
</tr>
<tr class="row-odd"><td>u</td>
<td>the normalized x coordinate of pixel 0.</td>
</tr>
<tr class="row-even"><td>v</td>
<td>the normalized y coordinate of pixel 0.</td>
</tr>
<tr class="row-odd"><td>execMode</td>
<td><p class="first">Two modes are supported: 16x4, 16x1. The return matrix
varies depending on mode set.  The default mode is 16x4.</p>
<ul class="last simple">
<li>CM_CONV_16x4</li>
<li>CM_CONV_16x1</li>
</ul>
</td>
</tr>
<tr class="row-even"><td>big_kernel</td>
<td>Gen9+ functionality. For Gen8 this value is ignored. Set to
true when size of the kernel is larger then  15x15.</td>
</tr>
</tbody>
</table>
<p>In addition, the sampler state setup in the host must satisfy the following constraints:</p>
<ul class="simple">
<li>Surface Type must be 2D</li>
<li>Surface Format must be 8-bit or 16-bit format</li>
<li>Mode supported 16x4, 16x1</li>
</ul>
<p>Supported Surfaces</p>
<table border="1" class="docutils">
<colgroup>
<col width="41%" />
<col width="9%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Format</th>
<th class="head">Type</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>CM_SURFACE_FORMAT_V8U8</td>
<td>2D</td>
<td>Signed planar</td>
</tr>
<tr class="row-odd"><td>CM_SURFACE_FORMAT_A8</td>
<td>2D</td>
<td>Planar</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="min-max-filter">
<h4>4.9.2 Min Max Filter<a class="headerlink" href="#min-max-filter" title="Permalink to this headline">¶</a></h4>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">cm_va_min_max_filter</span><span class="p">(</span><span class="n">matrix_ref</span><span class="o">&lt;</span><span class="n">TYPE</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="n">m</span><span class="p">,</span> <span class="n">SurfaceIndex</span> <span class="n">surfIndex</span><span class="p">,</span>
  <span class="n">SamplerIndex</span> <span class="n">sampIndex</span><span class="p">,</span> <span class="kt">float</span> <span class="n">u</span><span class="p">,</span> <span class="kt">float</span> <span class="n">v</span><span class="p">,</span> <span class="n">OutputFormatControl</span> <span class="n">cntrl</span><span class="p">,</span>
  <span class="n">MMFExecMode</span> <span class="n">execMode</span><span class="p">,</span> <span class="n">MMFEnableMode</span> <span class="n">mmfMode</span><span class="p">);</span>
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>m</td>
<td><p class="first">the matrix to store the return results. Number of pixels per
row depends on the Surface format.  It is up to the user to
make sure matrix of the correct size is passed in, based on
surface input format. A Min or Max can be disabled,
corresponding values are invalid.</p>
<ul class="last simple">
<li>16 bit surface 16x4 mode: matrix&lt;short, 4,32&gt;. Data is
laid out in pixel sequential order, with min max for each
pixel.</li>
<li>8-bit surface 16x4 mode: matrix&lt;uchar,4,32&gt; Data is laid
out in pixel sequential order, with min max interleaved
for each pixel: pixel0 min, pixel1 min, pixel0 max, pixel1
max.</li>
<li>16-bit surface 16x1 mode: matrix&lt;short, 1,32&gt;. Data is
laid out in pixel sequential order, with min max for each
pixel.</li>
<li>8-bit surface 16x1 mode: matrix&lt;uchar,1,32&gt; Data is laid
out in pixel sequential order, with min max interleaved
for each pixel: pixel0 min, pixel1 min, pixel0 max, pixel1
max.</li>
<li>16-bit surface 1x1 mode: matrix&lt;short, 1,2&gt;. Data is laid
out in pixel sequential order, with min max for each
pixel.</li>
<li>8-bit surface 1x1 mode: matrix&lt;uchar,1,4&gt; Data is laid out
in pixel sequential order, with min max interleaved for
each pixel: pixel0 min, pixel1 min, pixel0 max, pixel1
max.</li>
</ul>
</td>
</tr>
<tr class="row-odd"><td>surfIndex</td>
<td>surface index, which must correspond to a 2D type surface
that has either 8-bit or 16 bit format.</td>
</tr>
<tr class="row-even"><td>sampIndex</td>
<td>the index into the sampler state table.</td>
</tr>
<tr class="row-odd"><td>u</td>
<td>the normalized x coordinate of pixel 0.</td>
</tr>
<tr class="row-even"><td>v</td>
<td>the normalized y coordinate of pixel 0.</td>
</tr>
<tr class="row-odd"><td>cntrl</td>
<td><p class="first">Specifies output format, the size of the return matrix will
vary depending on mode. Modes are:</p>
<ul class="last simple">
<li>CM_16_FULL</li>
<li>CM_8_FULL</li>
</ul>
</td>
</tr>
<tr class="row-even"><td>execMode</td>
<td><p class="first">Three modes are supported: 16x4, 16x1, and 1x1. The return
matrix varies depending on mode set. The default mode is
16x4.</p>
<ul class="last simple">
<li>CM_MMF_16x4</li>
<li>CM_MMF_16x1</li>
<li>CM_MMF_1x1</li>
</ul>
</td>
</tr>
<tr class="row-odd"><td>mmfMode</td>
<td><p class="first">Used to enable MinMax functionality.</p>
<ul class="last simple">
<li>CM_MINMAX_ENABLE</li>
<li>CM_MAX_ENABLE</li>
<li>CM_MIN_ENABLE</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>In addition, the sampler state setup in the host must satisfy the following constraints:</p>
<ul class="simple">
<li>Surface Type must be 2D</li>
<li>Surface Format must be 8-bit or 16 bit.</li>
</ul>
<p>Supported Surfaces:</p>
<table border="1" class="docutils">
<colgroup>
<col width="41%" />
<col width="9%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Format</th>
<th class="head">Type</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>CM_SURFACE_FORMAT_V8U8</td>
<td>2D</td>
<td>Signed planar</td>
</tr>
<tr class="row-odd"><td>CM_SURFACE_FORMAT_A8</td>
<td>2D</td>
<td>Planar</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="min-max">
<h4>4.9.3 Min Max<a class="headerlink" href="#min-max" title="Permalink to this headline">¶</a></h4>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">cm_va_min_max</span><span class="p">(</span><span class="n">vector_ref</span><span class="o">&lt;</span><span class="n">TYPE</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">vect</span><span class="p">,</span> <span class="n">SurfaceIndex</span> <span class="n">surfIndex</span><span class="p">,</span>
  <span class="kt">float</span> <span class="n">u</span><span class="p">,</span> <span class="kt">float</span> <span class="n">v</span><span class="p">,</span> <span class="n">MMFEnableMode</span> <span class="n">mmfMode</span><span class="p">)</span>
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>vect</td>
<td><p class="first">the vector to store the return results. Pixel 0 Max and Min
are stored in vect[1], vect[0] respectively. The type,
uchar, or ushort, of matrix needs to correspond to the input
format: 8- bit, 16-bit.</p>
<ul class="last simple">
<li>vector_ref&lt;uchar, 32&gt; - for 8-bit input format</li>
<li>vector_ref&lt;ushort, 16&gt; - for 16-bit input format</li>
</ul>
</td>
</tr>
<tr class="row-odd"><td>surfIndex</td>
<td>surface index, which must correspond to a 2D type surface
that has either 8-bit or 16-bit format.  This is an abstract
handle that represents the surface created by CM host
runtime [6] and must be passed through kernel function
parameters. CM does not allow the explicit use of
local/global variable or modification of such abstract data
types in kernel functions, except used as function call
argument.</td>
</tr>
<tr class="row-even"><td>u</td>
<td>the normalized x coordinate of pixel 0.</td>
</tr>
<tr class="row-odd"><td>v</td>
<td>the normalized y coordinate of pixel 0.</td>
</tr>
<tr class="row-even"><td>mmfMode</td>
<td><p class="first">Used to enable MinMax functionality. By default both are
enabled. Modes are:</p>
<ul class="last simple">
<li>CM_MINMAX_ENABLE</li>
<li>CM_MAX_ENABLE</li>
<li>CM_MIN_ENABLE</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>In addition, the sampler state setup in the host must satisfy the following
constraints:</p>
<ul class="simple">
<li>Surface Type must be 2D</li>
</ul>
<p>Supported Surfaces:</p>
<table border="1" class="docutils">
<colgroup>
<col width="41%" />
<col width="9%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Format</th>
<th class="head">Type</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>CM_SURFACE_FORMAT_V8U8</td>
<td>2D</td>
<td>Signed planar</td>
</tr>
<tr class="row-odd"><td>CM_SURFACE_FORMAT_A8</td>
<td>2D</td>
<td>Planar</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="erode">
<h4>4.9.4 Erode<a class="headerlink" href="#erode" title="Permalink to this headline">¶</a></h4>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">cm_va_erode</span><span class="p">(</span><span class="n">vector_ref</span><span class="o">&lt;</span><span class="n">uint</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">vect</span><span class="p">,</span> <span class="n">SurfaceIndex</span> <span class="n">surfIndex</span><span class="p">,</span>
  <span class="n">SamplerIndex</span> <span class="n">sampIndex</span><span class="p">,</span> <span class="kt">float</span> <span class="n">u</span><span class="p">,</span> <span class="kt">float</span> <span class="n">v</span><span class="p">,</span> <span class="n">EDExecMode</span> <span class="n">execMode</span><span class="p">);</span>
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>vect</td>
<td><p class="first">the vector to store the return results.</p>
<ul class="last simple">
<li>In 64x4 mode each value in the vector contains 32 values,
N is 8.</li>
<li>In 64x1 mode each value in the vector contains 32 values,
N is 2.</li>
<li>In 32x4 mode each even value [0,6] in the vector contains
32 values, N is 8.</li>
<li>In 32x1 mode each value in the vector contains 32 values,
N is 1.</li>
</ul>
</td>
</tr>
<tr class="row-odd"><td>surfIndex</td>
<td>surface index, which must correspond to a 2D type surface
that has 32-bit format.</td>
</tr>
<tr class="row-even"><td>sampIndex</td>
<td>the index into the sampler state table.</td>
</tr>
<tr class="row-odd"><td>u</td>
<td>the normalized x coordinate of pixel 0.</td>
</tr>
<tr class="row-even"><td>v</td>
<td>the normalized y coordinate of pixel 0.</td>
</tr>
<tr class="row-odd"><td>execMode</td>
<td><p class="first">There are four modes: 16x4, 16x1, 32x4, and 32x1. It is up
to the user to make sure the return matrix has appropriate
number of pixels and rows. The default mode is: 16x4.</p>
<ul class="last simple">
<li>CM_ED_64x4</li>
<li>CM_ED_32x4</li>
<li>CM_ED_64x1</li>
<li>CM_ED_32x1</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>In addition, the sampler state setup in the host must satisfy the following constraints:</p>
<ul class="simple">
<li>Surface Type must be 2D</li>
<li>Surface Format is 1 bit per pixel.</li>
</ul>
<p>Supported Surfaces:</p>
<table border="1" class="docutils">
<colgroup>
<col width="44%" />
<col width="8%" />
<col width="48%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Format</th>
<th class="head">Type</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>CM_SURFACE_FORMAT_A8R8G8B8</td>
<td>2D</td>
<td>Planar 1 bit per pixel format</td>
</tr>
<tr class="row-odd"><td>CM_SURFACE_FORMAT_X8R8G8B8</td>
<td>2D</td>
<td>Planar 1 bit per pixel format</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="dilate">
<h4>4.9.5 Dilate<a class="headerlink" href="#dilate" title="Permalink to this headline">¶</a></h4>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">cm_va_dilate</span><span class="p">(</span><span class="n">vector_ref</span><span class="o">&lt;</span><span class="n">uint</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">vect</span><span class="p">,</span> <span class="n">SurfaceIndex</span> <span class="n">surfIndex</span><span class="p">,</span>
  <span class="n">SamplerIndex</span> <span class="n">sampIndex</span><span class="p">,</span> <span class="kt">float</span> <span class="n">u</span><span class="p">,</span> <span class="kt">float</span> <span class="n">v</span><span class="p">,</span> <span class="n">EDExecMode</span> <span class="n">execMode</span><span class="p">);</span>
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>vect</td>
<td><p class="first">the vector to store the return results.</p>
<ul class="last simple">
<li>In 64x4 mode each value in the vector contains 32 values,
N is 8.</li>
<li>In 64x1 mode each value in the vector contains 32 values,
N is 2.</li>
<li>In 32x4 mode each even value [0,6] in the vector contains
32 values, N is 8.</li>
<li>In 32x1 mode each value in the vector contains 32 values,
N is 1.</li>
</ul>
</td>
</tr>
<tr class="row-odd"><td>surfIndex</td>
<td>surface index, which must correspond to a 2D type surface
that has 32-bit format.</td>
</tr>
<tr class="row-even"><td>sampIndex</td>
<td>the index into the sampler state table.</td>
</tr>
<tr class="row-odd"><td>u</td>
<td>the normalized x coordinate of pixel 0.</td>
</tr>
<tr class="row-even"><td>v</td>
<td>the normalized y coordinate of pixel 0.</td>
</tr>
<tr class="row-odd"><td>execMode</td>
<td><p class="first">There are four modes: 16x4, 16x1, 32x4, and 32x1. It is up
to the user to make sure the return matrix has appropriate
number of pixels and rows. The default mode is: 16x4.</p>
<ul class="last simple">
<li>CM_ED_64x4</li>
<li>CM_ED_32x4</li>
<li>CM_ED_64x1</li>
<li>CM_ED_32x1</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>In addition, the sampler state setup in the host must satisfy the following constraints:</p>
<ul class="simple">
<li>Surface Type must be 2D</li>
<li>Surface Format is 1 bit per pixel.</li>
</ul>
<p>Supported Surfaces:</p>
<table border="1" class="docutils">
<colgroup>
<col width="44%" />
<col width="8%" />
<col width="48%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Format</th>
<th class="head">Type</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>CM_SURFACE_FORMAT_A8R8G8B8</td>
<td>2D</td>
<td>Planar 1 bit per pixel format</td>
</tr>
<tr class="row-odd"><td>CM_SURFACE_FORMAT_X8R8G8B8</td>
<td>2D</td>
<td>Planar 1 bit per pixel format</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="centroid">
<h4>4.9.6 Centroid<a class="headerlink" href="#centroid" title="Permalink to this headline">¶</a></h4>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">cm_va_centroid</span><span class="p">(</span><span class="n">matrix_ref</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="o">&gt;</span> <span class="n">m</span><span class="p">,</span> <span class="n">SurfaceIndex</span> <span class="n">surfIndex</span><span class="p">,</span> <span class="kt">float</span> <span class="n">u</span><span class="p">,</span> <span class="kt">float</span> <span class="n">v</span><span class="p">,</span> <span class="n">uchar</span> <span class="n">vSize</span><span class="p">)</span>
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>m</td>
<td>the matrix to store the return results. Values are returned
in order [jSum, Division/Sum, ..] starting with  column 0,
to column 15 inclusive.</td>
</tr>
<tr class="row-odd"><td>surfIndex</td>
<td>surface index, which must correspond to a 2D type surface
that has either 8-bit or 16-bit format.</td>
</tr>
<tr class="row-even"><td>u</td>
<td>the normalized x coordinate of pixel 0.</td>
</tr>
<tr class="row-odd"><td>v</td>
<td>the normalized y coordinate of pixel 0.</td>
</tr>
<tr class="row-even"><td>vSize</td>
<td>To control the size of the centroid in vertical direction if
less than 8 is required. Valid range is [0-7]. Default value
of 0 means size is 8.</td>
</tr>
</tbody>
</table>
<p>In addition, the sampler state setup in the host must satisfy the following constraints:</p>
<ul class="simple">
<li>Surface Type must be 2D</li>
<li>Surface Format must be 8-bit</li>
</ul>
<p>Supported Surfaces:</p>
<table border="1" class="docutils">
<colgroup>
<col width="41%" />
<col width="9%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Format</th>
<th class="head">Type</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>CM_SURFACE_FORMAT_V8U8</td>
<td>2D</td>
<td>Signed planar</td>
</tr>
<tr class="row-odd"><td>CM_SURFACE_FORMAT_A8</td>
<td>2D</td>
<td>Planar</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="boolean-centroid">
<h4>4.9.7 Boolean Centroid<a class="headerlink" href="#boolean-centroid" title="Permalink to this headline">¶</a></h4>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">cm_va_boolean_centroid</span><span class="p">(</span><span class="n">matrix_ref</span><span class="o">&lt;</span><span class="n">uint</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="o">&gt;</span> <span class="n">m</span><span class="p">,</span> <span class="n">SurfaceIndex</span> <span class="n">surfIndex</span><span class="p">,</span> <span class="kt">float</span> <span class="n">u</span><span class="p">,</span> <span class="kt">float</span> <span class="n">v</span><span class="p">,</span>
  <span class="n">uchar</span> <span class="n">vSize</span><span class="p">,</span> <span class="n">uchar</span> <span class="n">hSize</span><span class="p">)</span>
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>m</td>
<td>the matrix to store the return results. Values are returned
are iSum, jSum, Sum, column 0 is in row0, etc. The return
value of Sum from the Sampler8x8 is a signed value.</td>
</tr>
<tr class="row-odd"><td>surfIndex</td>
<td>surface index, which must correspond to a 2D type surface.</td>
</tr>
<tr class="row-even"><td>u</td>
<td>the normalized x coordinate of pixel 0.</td>
</tr>
<tr class="row-odd"><td>v</td>
<td>the normalized y coordinate of pixel 0.</td>
</tr>
<tr class="row-even"><td>hSize</td>
<td>To control the size of the BoolCentroid in horizontal
direction if less than 64 is required.</td>
</tr>
<tr class="row-odd"><td>vSize</td>
<td>To control the size of the BoolCentroid in vertical
direction if less than 4 is required. Valid range is [0-3].
Default value of 0 means size is 4.</td>
</tr>
</tbody>
</table>
<p>In addition, the sampler state setup in the host must satisfy the following constraints:</p>
<ul class="simple">
<li>Surface Type must be 2D</li>
<li>Surface Format must be 1-bit. On the host side and driver side CM uses D3D formats.</li>
</ul>
<p>Supported Surfaces:</p>
<table border="1" class="docutils">
<colgroup>
<col width="44%" />
<col width="8%" />
<col width="48%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Format</th>
<th class="head">Type</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>CM_SURFACE_FORMAT_A8R8G8B8</td>
<td>2D</td>
<td>Planar 1 bit per pixel format</td>
</tr>
<tr class="row-odd"><td>CM_SURFACE_FORMAT_X8R8G8B8</td>
<td>2D</td>
<td>Planar 1 bit per pixel format</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="video-analytics-functions-gen9">
<h3><a class="toc-backref" href="#id58">4.10 Video Analytics Functions (Gen9+)</a><a class="headerlink" href="#video-analytics-functions-gen9" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id6">
<h4>4.10.1 1d Convolve<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h4>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">cm_va_1d_convolution</span><span class="p">(</span><span class="n">matrix_ref</span><span class="o">&lt;</span><span class="kt">short</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="mi">16</span><span class="o">&gt;</span> <span class="n">m</span><span class="p">,</span>
  <span class="n">SurfaceIndex</span> <span class="n">surfIndex</span><span class="p">,</span> <span class="n">SamplerIndex</span> <span class="n">sampIndex</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">isHdirection</span><span class="p">,</span>
  <span class="kt">float</span> <span class="n">u</span><span class="p">,</span> <span class="kt">float</span> <span class="n">v</span><span class="p">,</span> <span class="n">CONVExecMode</span> <span class="n">execMode</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span>
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>m</td>
<td><p class="first">the vector  to store the return results. Output format is
16bit SINT.</p>
<ul class="last simple">
<li>16x4 mode: matrix&lt;short, 4,16&gt;. Data is layed out in pixel
sequential order.</li>
<li>16x1 mode: matrix&lt;short, 1,16&gt;. Data is layed out in pixel
sequential order.</li>
</ul>
</td>
</tr>
<tr class="row-odd"><td>surfIndex</td>
<td>surface index, which must correspond to a 2D type surface
that has either 8-bit or 16bit format.</td>
</tr>
<tr class="row-even"><td>sampIndex</td>
<td>the index into the sampler state table.</td>
</tr>
<tr class="row-odd"><td>isHdirection</td>
<td><ul class="first last simple">
<li>TRUE : horizontal 1DConvolve</li>
<li>FALSE: vertical 1dConvolve</li>
</ul>
</td>
</tr>
<tr class="row-even"><td>u</td>
<td>the normalized x coordinat of pixel 0.</td>
</tr>
<tr class="row-odd"><td>v</td>
<td>the normalized y coordinat of pixel 0.</td>
</tr>
<tr class="row-even"><td>execMode</td>
<td><p class="first">Two modes are supported: 16x4, 16x1. The return matrix
varies depending on mode set. The default mode is 16x4.</p>
<ul class="last simple">
<li>CM_CONV_16x4</li>
<li>CM_CONV_16x1</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>In addition, the sampler state setup in the host must satisfy the following constraints:</p>
<ul class="simple">
<li>Surface Type must be 2D</li>
<li>Surface Format must be 8-bit or 16-bit format</li>
<li>Mode supported 16x4, 16x1</li>
</ul>
<p>Supported Surfaces:</p>
<table border="1" class="docutils">
<colgroup>
<col width="41%" />
<col width="9%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Format</th>
<th class="head">Type</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>CM_SURFACE_FORMAT_V8U8</td>
<td>2D</td>
<td>Signed planar</td>
</tr>
<tr class="row-odd"><td>CM_SURFACE_FORMAT_A8</td>
<td>2D</td>
<td>Planar</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="pixel-convolve">
<h4>4.10.2 1Pixel Convolve<a class="headerlink" href="#pixel-convolve" title="Permalink to this headline">¶</a></h4>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">cm_va_1pixel_convolve</span><span class="p">(</span><span class="n">matrix_ref</span><span class="o">&lt;</span><span class="kt">short</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="n">m</span><span class="p">,</span> <span class="n">SurfaceIndex</span> <span class="n">surfIndex</span><span class="p">,</span>
  <span class="n">SamplerIndex</span> <span class="n">sampIndex</span><span class="p">,</span> <span class="kt">float</span> <span class="n">u</span><span class="p">,</span> <span class="kt">float</span> <span class="n">v</span><span class="p">,</span> <span class="n">CONVExecMode</span> <span class="n">execMode</span><span class="p">,</span>
  <span class="n">matrix</span><span class="o">&lt;</span><span class="kt">short</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="n">offsets</span><span class="p">);</span>
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="19%" />
<col width="81%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>m</td>
<td><p class="first">the matrix to store the return results. Output format is
16bit SINT.</p>
<ul class="last simple">
<li>16x1 mode: matrix_ref&lt;short, 1,16&gt;. Data is layed out in pixel
sequential order.</li>
<li>1x1 mode: matrix_ref&lt;short, 1,1&gt;</li>
</ul>
</td>
</tr>
<tr class="row-odd"><td>surfIndex</td>
<td>surface index, which must correspond to a 2D type surface
that has either 8-bit or 16bit format.</td>
</tr>
<tr class="row-even"><td>sampIndex</td>
<td>the index into the sampler state table.</td>
</tr>
<tr class="row-odd"><td>u</td>
<td>the normalized x coordinat of pixel 0.</td>
</tr>
<tr class="row-even"><td>v</td>
<td>the normalized y coordinat of pixel 0.</td>
</tr>
<tr class="row-odd"><td>execMode</td>
<td><p class="first">Three modes are supported: 16x1 and 1x1. The return matrix
varies depending on mode set.</p>
<ul class="last simple">
<li>CM_CONV_16x1</li>
<li>CM_CONV_1x1</li>
</ul>
</td>
</tr>
<tr class="row-even"><td>Offsets</td>
<td>offsets of pixels from U,V address. A row contains 15 pairs
of x,y. For 1x1 mode offset is not applicable and should be
omitted.</td>
</tr>
</tbody>
</table>
<p>In addition, the sampler state setup in the host must satisfy the following constraints:</p>
<ul class="simple">
<li>Surface Type must be 2D</li>
<li>Surface Format must be 8-bit or 16-bit format</li>
<li>Mode supported 16x1, 1x1</li>
</ul>
<p>Supported Surfaces:</p>
<table border="1" class="docutils">
<colgroup>
<col width="41%" />
<col width="9%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Format</th>
<th class="head">Type</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>CM_SURFACE_FORMAT_V8U8</td>
<td>2D</td>
<td>Signed planar</td>
</tr>
<tr class="row-odd"><td>CM_SURFACE_FORMAT_A8</td>
<td>2D</td>
<td>Unsigned planar</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="lbp-creation">
<h4>4.10.3 LBP Creation<a class="headerlink" href="#lbp-creation" title="Permalink to this headline">¶</a></h4>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">cm_va_lbp_creation</span><span class="p">(</span><span class="n">matrix_ref</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="mi">16</span><span class="o">&gt;</span> <span class="n">m</span><span class="p">,</span> <span class="n">SurfaceIndex</span> <span class="n">surfIndex</span><span class="p">,</span>
  <span class="kt">float</span> <span class="n">u</span><span class="p">,</span> <span class="kt">float</span> <span class="n">v</span><span class="p">,</span> <span class="n">LBPCreationExecMode</span> <span class="n">execMode</span><span class="p">);</span>
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="19%" />
<col width="81%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>m</td>
<td><p class="first">the matrix to store the return results. Output format is
16bit SINT.</p>
<ul class="last simple">
<li>5x5 mode: matrix_ref&lt;uchar, 4,16&gt;. Data is laid out in pixel
sequential order.</li>
<li>3x3  mode: matrix_ref&lt;uchar, 4,16&gt;. Data is laid out in pixel
sequential order.</li>
<li>3x3 and 5x5 modes: matrix_ref&lt;uchar, 8, 16&gt; First 4 rows will
be results of 3x3 operation, the next 4 rows will be
results of 5x5 operation.</li>
</ul>
</td>
</tr>
<tr class="row-odd"><td>surfIndex</td>
<td>surface index, which must correspond to a 2D type surface
that has either 8-bit or 16bit format.</td>
</tr>
<tr class="row-even"><td>u</td>
<td>the normalized x coordinat of pixel 0.</td>
</tr>
<tr class="row-odd"><td>v</td>
<td>the normalized y coordinat of pixel 0.</td>
</tr>
<tr class="row-even"><td>execMode</td>
<td><p class="first">Three modes are supported: 5x5, 3x3, and BOTH. The return
matrix varies depending on mode set. The default mode is
16x4.</p>
<ul class="last simple">
<li>CM_LBP_CREATION_5x5</li>
<li>CM_LBP_CREATION_3x3</li>
<li>CM_LBP_CREATION_BOTH</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Supported Surfaces:</p>
<table border="1" class="docutils">
<colgroup>
<col width="41%" />
<col width="9%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Format</th>
<th class="head">Type</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>CM_SURFACE_FORMAT_V8U8</td>
<td>2D</td>
<td>Signed planar</td>
</tr>
<tr class="row-odd"><td>CM_SURFACE_FORMAT_A8</td>
<td>2D</td>
<td>Unsigned planar</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="lbp-correlation">
<h4>4.10.4 LBP Correlation<a class="headerlink" href="#lbp-correlation" title="Permalink to this headline">¶</a></h4>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">cm_va_lbp_correlation</span><span class="p">(</span><span class="n">matrix_ref</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="mi">16</span><span class="o">&gt;</span> <span class="n">m</span><span class="p">,</span>
  <span class="n">SurfaceIndex</span> <span class="n">surfIndex</span><span class="p">,</span> <span class="kt">float</span> <span class="n">u</span><span class="p">,</span> <span class="kt">float</span> <span class="n">v</span><span class="p">,</span> <span class="kt">short</span> <span class="n">xoff_disparity</span><span class="p">);</span>
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="19%" />
<col width="81%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>m</td>
<td><p class="first">the matrix to store the return results. Output format is
16bit SINT.</p>
<ul class="last simple">
<li>matrix_ref&lt;uchar, 4,16&gt;. Data is layed out in pixel sequential
order.</li>
</ul>
</td>
</tr>
<tr class="row-odd"><td>surfIndex</td>
<td>surface index, which must correspond to a 2D type surface
that has either 8-bit or 16bit format.</td>
</tr>
<tr class="row-even"><td>u</td>
<td>the normalized x coordinat of pixel 0.</td>
</tr>
<tr class="row-odd"><td>v</td>
<td>the normalized y coordinat of pixel 0.</td>
</tr>
<tr class="row-even"><td>xoff_disparity</td>
<td>16bit signed x-offset for right image with respect to left
image</td>
</tr>
</tbody>
</table>
<p>Supported Surfaces:</p>
<table border="1" class="docutils">
<colgroup>
<col width="41%" />
<col width="9%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Format</th>
<th class="head">Type</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>CM_SURFACE_FORMAT_A8</td>
<td>2D</td>
<td>Unsigned planar</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="flood-fill">
<h4>4.10.5 Flood Fill<a class="headerlink" href="#flood-fill" title="Permalink to this headline">¶</a></h4>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">cm_va_flood_fill</span><span class="p">(</span><span class="n">vector_ref</span><span class="o">&lt;</span><span class="n">ushort</span><span class="p">,</span> <span class="mi">8</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">is8Connect</span><span class="p">,</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="n">ushort</span><span class="p">,</span> <span class="mi">10</span><span class="o">&gt;</span> <span class="n">pxMaskHDir</span><span class="p">,</span> <span class="n">ushort</span> <span class="n">pxMaskVDirLeft</span><span class="p">,</span>
  <span class="n">ushort</span> <span class="n">pxMaskVDirRight</span><span class="p">,</span> <span class="n">uchar</span> <span class="n">loopCount</span><span class="p">);</span>
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>v</td>
<td><p class="first">the vector to store the return results. Output format is
1bpp.</p>
<ul class="last simple">
<li>16x8 mode: vector_ref&lt;ushort, 8&gt;. Data is laid out in pixel
sequential order.</li>
</ul>
</td>
</tr>
<tr class="row-odd"><td>Is8Connect</td>
<td><ul class="first last simple">
<li>TRUE: 8 connect is used for floodfill</li>
<li>FALSE: 4 connect is used for floodfill</li>
</ul>
</td>
</tr>
<tr class="row-even"><td>pxMaskHDir</td>
<td>Pixel Mask of the bottom adjacent pixels in horizontal
direction. Index [0,7] are for rows [0,7], Index 8 is for
row: -1, Index 9 is for row 8.</td>
</tr>
<tr class="row-odd"><td>pxMaskVDirLeft</td>
<td>Pixel mask of the adjacent pixels in vertical direction. The
mask is 10 bits per entry. All MSB bits passed 10 bits must
be 0.</td>
</tr>
<tr class="row-even"><td>pxMaskVDirRight</td>
<td>Pixel mask of the adjacent pixels in vertical direction. The
mask is 10 bits per entry. All MSB bits passed 10 bits must
be 0.</td>
</tr>
<tr class="row-odd"><td>loopCount</td>
<td>Number of times FloodFill will be repeated on HW. Valid
range is [1,16]</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="correlation-search">
<h4>4.10.6 Correlation Search<a class="headerlink" href="#correlation-search" title="Permalink to this headline">¶</a></h4>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">cm_va_correlation_search</span><span class="p">(</span><span class="n">matrix_ref</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="n">m</span><span class="p">,</span> <span class="n">SurfaceIndex</span> <span class="n">surfIndex</span><span class="p">,</span>
  <span class="kt">float</span> <span class="n">u</span><span class="p">,</span> <span class="kt">float</span> <span class="n">v</span><span class="p">,</span> <span class="kt">float</span> <span class="n">vertOrigin</span><span class="p">,</span> <span class="kt">float</span> <span class="n">horizOrigin</span><span class="p">,</span>
  <span class="n">uchar</span> <span class="n">xDirectionSize</span><span class="p">,</span> <span class="n">uchar</span> <span class="n">yDirectionSize</span><span class="p">,</span> <span class="n">uchar</span> <span class="n">xDirSearchSize</span><span class="p">,</span>
  <span class="n">uchar</span> <span class="n">yDirSearchSize</span><span class="p">);</span>
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="19%" />
<col width="81%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>m</td>
<td><p class="first">the matrix to store the return results. Output format is
32bit SINT.</p>
<ul class="last simple">
<li>width less then 8: matrix_ref&lt;int, N,8&gt;. Data is layed out in
sequential order. Rows depend on height of search region.
Only valid rows are returned.</li>
<li>width greater then 8: matrix_ref&lt;int, N,16&gt;. Data is layed out
in sequential order. Rows depend on height of search
region. Only valid rows are returned.</li>
</ul>
</td>
</tr>
<tr class="row-odd"><td>surfIndex</td>
<td>surface index, which must correspond to a 2D type surface
that has either 8-bit or 16bit format.</td>
</tr>
<tr class="row-even"><td>u</td>
<td>the normalized x coordinate of pixel 0.</td>
</tr>
<tr class="row-odd"><td>v</td>
<td>the normalized y coordinate of pixel 0.</td>
</tr>
<tr class="row-even"><td>vertOrigin</td>
<td>Normalized vertical origin of the reference image.</td>
</tr>
<tr class="row-odd"><td>horizOrigin</td>
<td>Normalized horizontal origin of the reference image.</td>
</tr>
<tr class="row-even"><td>xDirectionSize</td>
<td>X Direction size of the Source Correlation. Valid range
[1,8]</td>
</tr>
<tr class="row-odd"><td>yDirectionSize</td>
<td>Y direction size of the Source Correlation. Valid range
[1,8]</td>
</tr>
<tr class="row-even"><td>xDirSearchSize</td>
<td>X direction Search Size. Valid range [3,16]</td>
</tr>
<tr class="row-odd"><td>yDirSearchsize</td>
<td>Y direction Search Size. Valid range [3,16]</td>
</tr>
</tbody>
</table>
<p>Supported Surfaces:</p>
<table border="1" class="docutils">
<colgroup>
<col width="41%" />
<col width="9%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Format</th>
<th class="head">Type</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>CM_SURFACE_FORMAT_V8U8</td>
<td>2D</td>
<td>Signed planar</td>
</tr>
<tr class="row-odd"><td>CM_SURFACE_FORMAT_A8</td>
<td>2D</td>
<td>Unsigned planar</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="video-analytics-functions-hdc-write-gen9">
<h3><a class="toc-backref" href="#id59">4.11 Video Analytics Functions HDC Write {Gen9+}</a><a class="headerlink" href="#video-analytics-functions-hdc-write-gen9" title="Permalink to this headline">¶</a></h3>
<p>These variants of VA functions write their output to another surface directly instead of GRF.  The output
surface must have the same dimension (width*height in pixels) as the input surface.</p>
<div class="section" id="id7">
<h4>4.11.1 2d Convolve<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h4>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">cm_va_2d_convolve_hdc</span><span class="p">(</span><span class="n">SurfaceIndex</span> <span class="n">surfIndex</span><span class="p">,</span> <span class="n">SamplerIndex</span> <span class="n">sampIndex</span><span class="p">,</span>
  <span class="kt">float</span> <span class="n">u</span><span class="p">,</span> <span class="kt">float</span> <span class="n">v</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">big_kernel</span><span class="p">,</span> <span class="n">CM_FORMAT_SIZE</span> <span class="n">size</span><span class="p">,</span>
  <span class="n">SurfaceIndex</span> <span class="n">destIndex</span><span class="p">,</span> <span class="n">ushort</span> <span class="n">x_offset</span><span class="p">,</span> <span class="n">ushort</span> <span class="n">y_offset</span><span class="p">);</span>
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>surfIndex</td>
<td>surface index, which must correspond to a 2D type surface
that has either 8-bit or 16bit format.</td>
</tr>
<tr class="row-odd"><td>sampIndex</td>
<td>the index into the sampler state table.</td>
</tr>
<tr class="row-even"><td>u</td>
<td>the normalized x coordinate of pixel 0.</td>
</tr>
<tr class="row-odd"><td>v</td>
<td>the normalized y coordinate of pixel 0.</td>
</tr>
<tr class="row-even"><td>big_kernel</td>
<td>Set to true when size of the kernel is larger then  15x15.</td>
</tr>
<tr class="row-odd"><td>size</td>
<td><p class="first">Specifies the format of the output surface. Two formats are
supported:</p>
<ul class="last simple">
<li>CM_HDC_FORMAT_16S</li>
<li>CM_HDC_FORMAT_8U</li>
</ul>
</td>
</tr>
<tr class="row-even"><td>destIndex</td>
<td>surface index of the 2D surface where data will be written.</td>
</tr>
<tr class="row-odd"><td>x_offset</td>
<td>A byte offset in to the output surface.</td>
</tr>
<tr class="row-even"><td>y_offset</td>
<td>A row offset in to the output surface</td>
</tr>
</tbody>
</table>
<p>16x4 pixels will be written to the output surface.  Each pixel is clamped to unsigned char for 8-bit
output surfaces.</p>
<p>Supported Surfaces:</p>
<table border="1" class="docutils">
<colgroup>
<col width="41%" />
<col width="9%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Format</th>
<th class="head">Type</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>CM_SURFACE_FORMAT_V8U8</td>
<td>2D</td>
<td>Signed planar</td>
</tr>
<tr class="row-odd"><td>CM_SURFACE_FORMAT_A8</td>
<td>2D</td>
<td>Planar</td>
</tr>
</tbody>
</table>
<p>Supported Output Surfaces:</p>
<table border="1" class="docutils">
<colgroup>
<col width="45%" />
<col width="8%" />
<col width="47%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Format</th>
<th class="head">Type</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>CM_SURFACE_FORMAT_R16_SINT</td>
<td>2D</td>
<td>Signed</td>
</tr>
<tr class="row-odd"><td>CM_SURFACE_FORMAT_R8_UINT</td>
<td>2D</td>
<td>Unsigned</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id8">
<h4>4.11.2 Min Max Filter<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h4>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">cm_va_min_max_filter_hdc</span><span class="p">(</span><span class="n">SurfaceIndex</span> <span class="n">surfIndex</span><span class="p">,</span>
  <span class="n">SamplerIndex</span> <span class="n">sampIndex</span><span class="p">,</span> <span class="kt">float</span> <span class="n">u</span><span class="p">,</span> <span class="kt">float</span> <span class="n">v</span><span class="p">,</span> <span class="n">MMFEnableMode</span> <span class="n">mmfMode</span><span class="p">,</span>
  <span class="n">CM_FORMAT_SIZE</span> <span class="n">size</span><span class="p">,</span> <span class="n">SurfaceIndex</span> <span class="n">destIndex</span><span class="p">,</span> <span class="n">ushort</span> <span class="n">x_offset</span><span class="p">,</span>
  <span class="n">ushort</span> <span class="n">y_offset</span><span class="p">);</span>
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>surfIndex</td>
<td>surface index, which must correspond to a 2D type surface
that has either 8-bit or 16 bit format.</td>
</tr>
<tr class="row-odd"><td>sampIndex</td>
<td>the index into the sampler state table.</td>
</tr>
<tr class="row-even"><td>u</td>
<td>the normalized x coordinate of pixel 0.</td>
</tr>
<tr class="row-odd"><td>v</td>
<td>the normalized y coordinate of pixel 0.</td>
</tr>
<tr class="row-even"><td>mmfMode</td>
<td><p class="first">Used to enable MinMax functionality.</p>
<ul class="last simple">
<li>CM_MAX_ENABLE</li>
<li>CM_MIN_ENABLE</li>
</ul>
</td>
</tr>
<tr class="row-odd"><td>size</td>
<td><p class="first">Specifies the format used for the output. Two formats are
supported:</p>
<ul class="last simple">
<li>CM_HDC_FORMAT_16S</li>
<li>CM_HDC_FORMAT_8U</li>
</ul>
</td>
</tr>
<tr class="row-even"><td>destIndex</td>
<td>surface index of the 2D surface where data will be written.</td>
</tr>
<tr class="row-odd"><td>x_offset</td>
<td>A byte offset in to the output surface.</td>
</tr>
<tr class="row-even"><td>y_offset</td>
<td>A row offset in to the output surface.</td>
</tr>
</tbody>
</table>
<p>16x4 pixels will be written to the output surface.  Each pixel is clamped to unsigned char for 8-bit
output surfaces.</p>
<p>Supported Surfaces:</p>
<table border="1" class="docutils">
<colgroup>
<col width="41%" />
<col width="9%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Format</th>
<th class="head">Type</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>CM_SURFACE_FORMAT_V8U8</td>
<td>2D</td>
<td>Signed planar</td>
</tr>
<tr class="row-odd"><td>CM_SURFACE_FORMAT_A8</td>
<td>2D</td>
<td>Planar</td>
</tr>
</tbody>
</table>
<p>Supported Output Surfaces:</p>
<table border="1" class="docutils">
<colgroup>
<col width="45%" />
<col width="8%" />
<col width="47%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Format</th>
<th class="head">Type</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>CM_SURFACE_FORMAT_R16_SINT</td>
<td>2D</td>
<td>Signed</td>
</tr>
<tr class="row-odd"><td>CM_SURFACE_FORMAT_R8_UINT</td>
<td>2D</td>
<td>Unsigned</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id9">
<h4>4.11.3 Erode<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h4>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">cm_va_erode_hdc</span><span class="p">(</span><span class="n">SurfaceIndex</span> <span class="n">surfIndex</span><span class="p">,</span> <span class="n">SamplerIndex</span> <span class="n">sampIndex</span><span class="p">,</span>
  <span class="kt">float</span> <span class="n">u</span><span class="p">,</span> <span class="kt">float</span> <span class="n">v</span><span class="p">,</span> <span class="n">SurfaceIndex</span> <span class="n">destIndex</span><span class="p">,</span> <span class="n">ushort</span> <span class="n">x_offset</span><span class="p">,</span>
  <span class="n">ushort</span> <span class="n">y_offset</span><span class="p">);</span>
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>surfIndex</td>
<td>surface index, which must correspond to a 2D type surface
that has 32-bit format.</td>
</tr>
<tr class="row-odd"><td>sampIndex</td>
<td>the index into the sampler state table.</td>
</tr>
<tr class="row-even"><td>u</td>
<td>the normalized x coordinate of pixel 0.</td>
</tr>
<tr class="row-odd"><td>v</td>
<td>the normalized y coordinate of pixel 0.</td>
</tr>
<tr class="row-even"><td>destIndex</td>
<td>surface index of the 2D surface where data will be written.</td>
</tr>
<tr class="row-odd"><td>x_offset</td>
<td>A byte offset in to the output surface.</td>
</tr>
<tr class="row-even"><td>y_offset</td>
<td>A row offset in to the output surface</td>
</tr>
</tbody>
</table>
<p>64x4 pixels with one-bit per pixel will be written to the output surface.</p>
<p>Supported Surfaces:</p>
<table border="1" class="docutils">
<colgroup>
<col width="44%" />
<col width="8%" />
<col width="48%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Format</th>
<th class="head">Type</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>CM_SURFACE_FORMAT_A8R8G8B8</td>
<td>2D</td>
<td>Planar 1 bit per pixel format</td>
</tr>
<tr class="row-odd"><td>CM_SURFACE_FORMAT_X8R8G8B8</td>
<td>2D</td>
<td>Planar 1 bit per pixel format</td>
</tr>
</tbody>
</table>
<p>Supported Output Surfaces:</p>
<table border="1" class="docutils">
<colgroup>
<col width="45%" />
<col width="8%" />
<col width="47%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Format</th>
<th class="head">Type</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>CM_SURFACE_FORMAT_R8_UINT</td>
<td>2D</td>
<td>Unsigned</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id10">
<h4>4.11.4 Dilate<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h4>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">cm_va_dilate_hdc</span><span class="p">(</span><span class="n">SurfaceIndex</span> <span class="n">surfIndex</span><span class="p">,</span> <span class="n">SamplerIndex</span> <span class="n">sampIndex</span><span class="p">,</span>
  <span class="kt">float</span> <span class="n">u</span><span class="p">,</span> <span class="kt">float</span> <span class="n">v</span><span class="p">,</span> <span class="n">SurfaceIndex</span> <span class="n">destIndex</span><span class="p">,</span> <span class="n">ushort</span> <span class="n">x_offset</span><span class="p">,</span>
  <span class="n">ushort</span> <span class="n">y_offset</span><span class="p">);</span>
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>surfIndex</td>
<td>surface index, which must correspond to a 2D type surface
that has 32-bit format.</td>
</tr>
<tr class="row-odd"><td>sampIndex</td>
<td>the index into the sampler state table.</td>
</tr>
<tr class="row-even"><td>u</td>
<td>the normalized x coordinate of pixel 0.</td>
</tr>
<tr class="row-odd"><td>v</td>
<td>the normalized y coordinate of pixel 0.</td>
</tr>
<tr class="row-even"><td>destIndex</td>
<td>surface index of the 2D surface where data will be written.</td>
</tr>
<tr class="row-odd"><td>x_offset</td>
<td>A byte offset in to the output surface.</td>
</tr>
<tr class="row-even"><td>y_offset</td>
<td>A row offset in to the output surface</td>
</tr>
</tbody>
</table>
<p>64x4 pixels with one-bit per pixel will be written to the output surface.</p>
<p>Supported Surfaces:</p>
<table border="1" class="docutils">
<colgroup>
<col width="44%" />
<col width="8%" />
<col width="48%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Format</th>
<th class="head">Type</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>CM_SURFACE_FORMAT_A8R8G8B8</td>
<td>2D</td>
<td>Planar 1 bit per pixel format</td>
</tr>
<tr class="row-odd"><td>CM_SURFACE_FORMAT_X8R8G8B8</td>
<td>2D</td>
<td>Planar 1 bit per pixel format</td>
</tr>
</tbody>
</table>
<p>Supported Output Surfaces:</p>
<table border="1" class="docutils">
<colgroup>
<col width="45%" />
<col width="8%" />
<col width="47%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Format</th>
<th class="head">Type</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>CM_SURFACE_FORMAT_R8_UINT</td>
<td>2D</td>
<td>Unsigned</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id11">
<h4>4.11.5 1d Convolve<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h4>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">cm_va_1d_convolution_hdc</span><span class="p">(</span><span class="n">SurfaceIndex</span> <span class="n">surfIndex</span><span class="p">,</span>
  <span class="n">SamplerIndex</span> <span class="n">sampIndex</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">isHdirection</span><span class="p">,</span> <span class="kt">float</span> <span class="n">u</span><span class="p">,</span> <span class="kt">float</span> <span class="n">v</span><span class="p">,</span>
  <span class="n">CM_FORMAT_SIZE</span> <span class="n">size</span><span class="p">,</span> <span class="n">SurfaceIndex</span> <span class="n">destIndex</span><span class="p">,</span> <span class="n">ushort</span> <span class="n">x_offset</span><span class="p">,</span>
  <span class="n">ushort</span> <span class="n">y_offset</span><span class="p">);</span>
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>surfIndex</td>
<td>surface index, which must correspond to a 2D type surface
that has either 8-bit or 16bit format.</td>
</tr>
<tr class="row-odd"><td>sampIndex</td>
<td>the index into the sampler state table.</td>
</tr>
<tr class="row-even"><td>isHdirection</td>
<td><ul class="first last simple">
<li>TRUE : horizontal 1DConvolve</li>
<li>FALSE: vertical 1dConvolve</li>
</ul>
</td>
</tr>
<tr class="row-odd"><td>u</td>
<td>the normalized x coordinate of pixel 0.</td>
</tr>
<tr class="row-even"><td>v</td>
<td>the normalized y coordinate of pixel 0.</td>
</tr>
<tr class="row-odd"><td>size</td>
<td><p class="first">Specifies the format used for the output. Two formats are
supported:</p>
<blockquote class="last">
<div><ul class="simple">
<li>CM_HDC_FORMAT_16S</li>
<li>CM_HDC_FORMAT_8U</li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="row-even"><td>destIndex</td>
<td>surface index of the 2D surface where data will be written.</td>
</tr>
<tr class="row-odd"><td>x_offset</td>
<td>A byte offset in to the output surface.</td>
</tr>
<tr class="row-even"><td>y_offset</td>
<td>A row offset in to the output surface.</td>
</tr>
</tbody>
</table>
<p>For vertical convolve, 16x4 pixels will be written to the output surface.  For horizontal convolve, 4x16
pixels will be written to the output surface.  Each pixel is clamped to unsigned char for 8-bit output
surfaces.</p>
<p>Supported Surfaces:</p>
<table border="1" class="docutils">
<colgroup>
<col width="41%" />
<col width="9%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Format</th>
<th class="head">Type</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>CM_SURFACE_FORMAT_V8U8</td>
<td>2D</td>
<td>Signed planar</td>
</tr>
<tr class="row-odd"><td>CM_SURFACE_FORMAT_A8</td>
<td>2D</td>
<td>Planar</td>
</tr>
</tbody>
</table>
<p>Supported Output Surfaces:</p>
<table border="1" class="docutils">
<colgroup>
<col width="45%" />
<col width="8%" />
<col width="47%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Format</th>
<th class="head">Type</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>CM_SURFACE_FORMAT_R16_SINT</td>
<td>2D</td>
<td>Signed</td>
</tr>
<tr class="row-odd"><td>CM_SURFACE_FORMAT_R8_UINT</td>
<td>2D</td>
<td>Unsigned</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id12">
<h4>4.11.6 1Pixel Convolve<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h4>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">cm_va_1pixel_convolve_hdc</span><span class="p">(</span><span class="n">SurfaceIndex</span> <span class="n">surfIndex</span><span class="p">,</span>
  <span class="n">SamplerIndex</span> <span class="n">sampIndex</span><span class="p">,</span> <span class="kt">float</span> <span class="n">u</span><span class="p">,</span> <span class="kt">float</span> <span class="n">v</span><span class="p">,</span> <span class="n">matrix</span><span class="o">&lt;</span><span class="kt">short</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="n">offsets</span><span class="p">,</span>
  <span class="n">CM_FORMAT_SIZE</span> <span class="n">size</span><span class="p">,</span> <span class="n">SurfaceIndex</span> <span class="n">destIndex</span><span class="p">,</span> <span class="n">ushort</span> <span class="n">x_offset</span><span class="p">,</span>
  <span class="n">ushort</span> <span class="n">y_offset</span> <span class="p">);</span>
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>surfIndex</td>
<td>surface index, which must correspond to a 2D type surface
that has either 8-bit or 16bit format.</td>
</tr>
<tr class="row-odd"><td>sampIndex</td>
<td>the index into the sampler state table.</td>
</tr>
<tr class="row-even"><td>u</td>
<td>the normalized x coordinat of pixel 0.</td>
</tr>
<tr class="row-odd"><td>v</td>
<td>the normalized y coordinat of pixel 0.</td>
</tr>
<tr class="row-even"><td>offsets</td>
<td>offsets of pixels from U,V address.</td>
</tr>
<tr class="row-odd"><td>size</td>
<td><p class="first">Specifies the format used for the output. Two formats are
supported:</p>
<ul class="last simple">
<li>CM_HDC_FORMAT_16S</li>
<li>CM_HDC_FORMAT_8U</li>
</ul>
</td>
</tr>
<tr class="row-even"><td>destIndex</td>
<td>surface index of the 2D surface where data will be written.</td>
</tr>
<tr class="row-odd"><td>x_offset</td>
<td>A byte offset in to the output surface.</td>
</tr>
<tr class="row-even"><td>y_offset</td>
<td>A row offset in to the output surface</td>
</tr>
</tbody>
</table>
<p>16x1 pixels will be written to the output surface.  Each pixel is clamped to unsigned char for 8-bit output
surfaces.</p>
<p>Supported Surfaces:</p>
<table border="1" class="docutils">
<colgroup>
<col width="41%" />
<col width="9%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Format</th>
<th class="head">Type</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>CM_SURFACE_FORMAT_V8U8</td>
<td>2D</td>
<td>Signed planar</td>
</tr>
<tr class="row-odd"><td>CM_SURFACE_FORMAT_A8</td>
<td>2D</td>
<td>Planar</td>
</tr>
</tbody>
</table>
<p>Supported Output Surfaces:</p>
<table border="1" class="docutils">
<colgroup>
<col width="45%" />
<col width="8%" />
<col width="47%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Format</th>
<th class="head">Type</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>CM_SURFACE_FORMAT_R16_SINT</td>
<td>2D</td>
<td>Signed</td>
</tr>
<tr class="row-odd"><td>CM_SURFACE_FORMAT_R8_UINT</td>
<td>2D</td>
<td>Unsigned</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id13">
<h4>4.11.7 LBP Creation<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h4>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">cm_va_lbp_creation_hdc</span><span class="p">(</span><span class="n">SurfaceIndex</span> <span class="n">surfIndex</span><span class="p">,</span> <span class="kt">float</span> <span class="n">u</span><span class="p">,</span> <span class="kt">float</span> <span class="n">v</span><span class="p">,</span>
  <span class="n">LBPCreationExecMode</span> <span class="n">execMode</span><span class="p">,</span> <span class="n">SurfaceIndex</span> <span class="n">destIndex</span><span class="p">,</span> <span class="n">ushort</span> <span class="n">x_offset</span><span class="p">,</span>
  <span class="n">ushort</span> <span class="n">y_offset</span><span class="p">);</span>
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>surfIndex</td>
<td>surface index, which must correspond to a 2D type surface
that has either 8-bit or 16bit format.</td>
</tr>
<tr class="row-odd"><td>u</td>
<td>the normalized x coordinate of pixel 0.</td>
</tr>
<tr class="row-even"><td>v</td>
<td>the normalized y coordinate of pixel 0.</td>
</tr>
<tr class="row-odd"><td>execMode</td>
<td><p class="first">valid values are:</p>
<ul class="last simple">
<li>CM_LBP_CREATION_5x5</li>
<li>CM_LBP_CREATION_3x3</li>
</ul>
</td>
</tr>
<tr class="row-even"><td>destIndex</td>
<td>surface index of the 2D surface where data will be written.</td>
</tr>
<tr class="row-odd"><td>x_offset</td>
<td>A byte offset in to the output surface.</td>
</tr>
<tr class="row-even"><td>y_offset</td>
<td>A row offset in to the output surface.</td>
</tr>
</tbody>
</table>
<p>16x4 pixels will be written to the output surface.</p>
<p>Supported Surfaces:</p>
<table border="1" class="docutils">
<colgroup>
<col width="41%" />
<col width="9%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Format</th>
<th class="head">Type</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>CM_SURFACE_FORMAT_V8U8</td>
<td>2D</td>
<td>Signed planar</td>
</tr>
<tr class="row-odd"><td>CM_SURFACE_FORMAT_A8</td>
<td>2D</td>
<td>Planar</td>
</tr>
</tbody>
</table>
<p>Supported Output Surfaces:</p>
<table border="1" class="docutils">
<colgroup>
<col width="45%" />
<col width="8%" />
<col width="47%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Format</th>
<th class="head">Type</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>CM_SURFACE_FORMAT_R16_SINT</td>
<td>2D</td>
<td>Signed</td>
</tr>
<tr class="row-odd"><td>CM_SURFACE_FORMAT_R8_UINT</td>
<td>2D</td>
<td>Unsigned</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id14">
<h4>4.11.8 LBP Correlation<a class="headerlink" href="#id14" title="Permalink to this headline">¶</a></h4>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">cm_va_lbp_correlation_hdc</span><span class="p">(</span><span class="n">SurfaceIndex</span> <span class="n">surfIndex</span><span class="p">,</span> <span class="kt">float</span> <span class="n">u</span><span class="p">,</span> <span class="kt">float</span> <span class="n">v</span><span class="p">,</span>
  <span class="kt">short</span> <span class="n">xoff_disparity</span><span class="p">,</span> <span class="n">SurfaceIndex</span> <span class="n">destIndex</span><span class="p">,</span> <span class="n">ushort</span> <span class="n">x_offset</span><span class="p">,</span>
  <span class="n">ushort</span> <span class="n">y_offset</span><span class="p">);</span>
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>surfIndex</td>
<td>surface index, which must correspond to a 2D type surface
that has either 8-bit or 16bit format.</td>
</tr>
<tr class="row-odd"><td>u</td>
<td>the normalized x coordinat of pixel 0.</td>
</tr>
<tr class="row-even"><td>v</td>
<td>the normalized y coordinat of pixel 0.</td>
</tr>
<tr class="row-odd"><td>xoff_disparity</td>
<td>16bit signed x-offset for right image with respect to left
image</td>
</tr>
<tr class="row-even"><td>destIndex</td>
<td>surface index of the 2D surface where data will be written.</td>
</tr>
<tr class="row-odd"><td>x_offset</td>
<td>A byte offset in to the output surface.</td>
</tr>
<tr class="row-even"><td>y_offset</td>
<td>A row offset in to the output surface</td>
</tr>
</tbody>
</table>
<p>16x4 pixels will be written to the output surface.</p>
<p>Supported Surfaces:</p>
<table border="1" class="docutils">
<colgroup>
<col width="41%" />
<col width="9%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Format</th>
<th class="head">Type</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>CM_SURFACE_FORMAT_A8</td>
<td>2D</td>
<td>Planar</td>
</tr>
</tbody>
</table>
<p>Supported Output Surfaces:</p>
<table border="1" class="docutils">
<colgroup>
<col width="45%" />
<col width="8%" />
<col width="47%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Format</th>
<th class="head">Type</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>CM_SURFACE_FORMAT_R8_UINT</td>
<td>2D</td>
<td>Unsigned</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="vme-interface">
<h3><a class="toc-backref" href="#id60">4.12 VME Interface</a><a class="headerlink" href="#vme-interface" title="Permalink to this headline">¶</a></h3>
<div class="section" id="gen6-vme-interface">
<h4>4.12.1 Gen6 VME Interface<a class="headerlink" href="#gen6-vme-interface" title="Permalink to this headline">¶</a></h4>
<p>CM provides the user with the following Video Motion Estimation (VME) function support for Gen6
architecture. More detailed information on the VME functionality is provided in reference [4].</p>
<p>The formal parameters for all three functions below are described here:</p>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>mInput</td>
<td>the matrix that stores the VME payload data.  For detailed
description of the payload content, please refer to [4]. The
input matrix type “vme_InputMrfType” is defined as
matrix&lt;unsigned char, 4, 32&gt;.</td>
</tr>
<tr class="row-odd"><td>surfIndex</td>
<td>surface index. This is an abstract handle that represents
the surface created by CM host runtime [6] and must be
passed through kernel function parameters. CM does not allow
the explicit use of local/global variable or modification of
such abstract data types in kernel functions, except used as
function call argument.</td>
</tr>
<tr class="row-even"><td>SPIndex</td>
<td>search path LUT index. This is an abstract handle that
represents the VME state created by CM host runtime [6] and
must be passed through kernel function parameters. CM does
not allow the explicit use of local/global variable or
modification of such abstract data types in kernel
functions, except used as function call argument.</td>
</tr>
<tr class="row-odd"><td>lutSubIndex</td>
<td>the index into the RDLUT state table, with a range of [0-3].</td>
</tr>
<tr class="row-even"><td>srcMB</td>
<td>The position of the left-top integer corner of the source
macroblock or block located in the surface (in unit of
pixels, relative to the surface origin).</td>
</tr>
<tr class="row-odd"><td>ref0</td>
<td>The position of the left-top integer corner of the first
reference window located in the first reference surface (in
unit of pixels, relative to the surface origin).</td>
</tr>
<tr class="row-even"><td>ref1</td>
<td>The position of the left-top integer corner of the second
reference window located in the second reference surface (in
unit of pixels, relative to the surface origin; ignored in
single reference mode).</td>
</tr>
<tr class="row-odd"><td>topMinus8Pels</td>
<td>The positions of the top neighborhood pixels. Please refer
to reference [4] for more detailed description of the data
members.</td>
</tr>
<tr class="row-even"><td>leftPels</td>
<td>The positions of the left neighborhood pixels. Please refer
to [4] for more detailed description of the data members.</td>
</tr>
<tr class="row-odd"><td>mOutput</td>
<td>the matrix that stores the VME output data.  For detailed
description of the output content, refer to [4]. For
“run_vme_intra”, the output matrix type
vme_OutputGrfShortType” is defined as
matrix&lt;unsigned char, 1, 32&gt;. For “run_vme_inter” and
“run_vme_all”, the output matrix type vme_OutputGrfType” is
defined as matrix&lt;unsigned char, 4, 32&gt;.</td>
</tr>
</tbody>
</table>
<div class="section" id="run-vme-intra">
<h5>run_vme_intra<a class="headerlink" href="#run-vme-intra" title="Permalink to this headline">¶</a></h5>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">run_vme_intra</span><span class="p">(</span><span class="n">vme_InputMrfType</span> <span class="n">mInput</span><span class="p">,</span> <span class="n">SurfaceIndex</span> <span class="n">surfIndex</span><span class="p">,</span> <span class="n">VmeIndex</span> <span class="n">SPIndex</span><span class="p">,</span>
  <span class="n">uint</span> <span class="n">lutSubIndex</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">ushort</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">srcMB</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">ushort</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">ref0</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">ushort</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">ref1</span><span class="p">,</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="n">topMinus8Pels</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">16</span><span class="o">&gt;</span> <span class="n">leftPels</span><span class="p">,</span> <span class="n">vme_OutputGrfShortType</span> <span class="n">mOutput</span><span class="p">);</span>
</pre></div>
</div>
<p>The compiler generates code for GenX hardware to perform VME function in intra-search only mode.</p>
</div>
<div class="section" id="run-vme-inter">
<h5>run_vme_inter<a class="headerlink" href="#run-vme-inter" title="Permalink to this headline">¶</a></h5>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">run_vme_inter</span><span class="p">(</span><span class="n">vme_InputMrfType</span> <span class="n">mInput</span><span class="p">,</span> <span class="n">SurfaceIndex</span> <span class="n">surfIndex</span><span class="p">,</span> <span class="n">VmeIndex</span> <span class="n">SPIndex</span><span class="p">,</span>
  <span class="n">uint</span> <span class="n">lutSubIndex</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">ushort</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">srcMB</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">ushort</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">ref0</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">ushort</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">ref1</span><span class="p">,</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="n">topMinus8Pels</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">16</span><span class="o">&gt;</span> <span class="n">leftPels</span><span class="p">,</span> <span class="n">vme_OutputGrfType</span> <span class="n">mOutput</span><span class="p">);</span>
</pre></div>
</div>
<p>The compiler generates code for GenX hardware to perform VME function in inter-search only mode.</p>
</div>
<div class="section" id="run-vme-all">
<h5>run_vme_all<a class="headerlink" href="#run-vme-all" title="Permalink to this headline">¶</a></h5>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">run_vme_all</span><span class="p">(</span><span class="n">vme_InputMrfType</span> <span class="n">mInput</span><span class="p">,</span> <span class="n">SurfaceIndex</span> <span class="n">surfIndex</span><span class="p">,</span> <span class="n">VmeIndex</span> <span class="n">SPIndex</span><span class="p">,</span>
  <span class="n">uint</span> <span class="n">lutSubIndex</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">ushort</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">srcMB</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">ushort</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">ref0</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">ushort</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">ref1</span><span class="p">,</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="n">topMinus8Pels</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">16</span><span class="o">&gt;</span> <span class="n">leftPels</span><span class="p">,</span> <span class="n">vme_OutputGrfType</span> <span class="n">mOutput</span><span class="p">);</span>
</pre></div>
</div>
<p>The compiler generates code for GenX hardware to perform VME functions in both inter- and intra-search
enabled mode.</p>
</div>
</div>
<div class="section" id="gen7-vme-interface">
<h4>4.12.2 Gen7 VME Interface<a class="headerlink" href="#gen7-vme-interface" title="Permalink to this headline">¶</a></h4>
<p>CM provides the user with the following Video Motion Estimation (VME) function support for Gen7
architecture.</p>
<div class="section" id="id15">
<h5>run_vme_intra<a class="headerlink" href="#id15" title="Permalink to this headline">¶</a></h5>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">run_vme_intra</span><span class="p">(</span><span class="n">matrix</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="n">mInput</span><span class="p">,</span> <span class="n">VMEStreamMode</span> <span class="n">streamMode</span><span class="p">,</span>
  <span class="n">VMESearchCtrl</span> <span class="n">searchCtrl</span><span class="p">,</span> <span class="n">SurfaceIndex</span> <span class="n">surfIndex</span><span class="p">,</span> <span class="n">VmeIndex</span> <span class="n">SPIndex</span><span class="p">,</span> <span class="n">uint</span> <span class="n">lutSubIndex</span><span class="p">,</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="n">ushort</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">srcMB</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">ushort</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">ref0</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">ushort</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">ref1</span><span class="p">,</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="n">topMinus8Pels</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">16</span><span class="o">&gt;</span> <span class="n">leftPels</span><span class="p">,</span> <span class="n">matrix_ref</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="n">mOutput</span><span class="p">);</span>
</pre></div>
</div>
<p>The compiler generates code for GenX hardware to perform VME function in intra-search only mode.</p>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>mInput</td>
<td>the matrix that stores the VME payload data.</td>
</tr>
<tr class="row-odd"><td>streamMode</td>
<td>VME stream mode, which must be set to VME_STREAM_DISABLE for
run_vme_intra function.</td>
</tr>
<tr class="row-even"><td>searchCtrl</td>
<td>VME search control, which must be set to
VME_SEARCH_SINGLE_REF_SINGLE_REC_SINGLE_START for
run_vme_intra function.</td>
</tr>
<tr class="row-odd"><td>surfIndex</td>
<td>surface index. This is an abstract handle that represents
the surface created by CM host runtime [6] and must be
passed through kernel function parameters. CM does not allow
the explicit use of local/global variable or modification of
such abstract data types in kernel functions, except used as
function call argument.</td>
</tr>
<tr class="row-even"><td>SPIndex</td>
<td>search path LUT index. This is an abstract handle that
represents the VME state created by CM host runtime [6] and
must be passed through kernel function parameters. CM does
not allow the explicit use of local/global variable or
modification of such abstract data types in kernel
functions, except used as function call argument.</td>
</tr>
<tr class="row-odd"><td>lutSubIndex</td>
<td>the index into the RDLUT state table, with a range of [0-3].</td>
</tr>
<tr class="row-even"><td>srcMB</td>
<td>The position of the left-top integer corner of the source
macroblock or block located in the surface (in unit of
pixels, relative to the picture origin).</td>
</tr>
<tr class="row-odd"><td>ref0</td>
<td>The position of the left-top integer corner of the first
reference window located in the first reference surface (in
unit of pixels, relative to source MB location).</td>
</tr>
<tr class="row-even"><td>ref1</td>
<td>The position of the left-top integer corner of the second
reference window located in the second reference surface (in
unit of pixels, relative to source MB location; ignored in
single reference mode).</td>
</tr>
<tr class="row-odd"><td>topMinus8Pels</td>
<td>The positions of the top neighborhood pixels.</td>
</tr>
<tr class="row-even"><td>leftPels</td>
<td>The positions of the left neighborhood pixels.</td>
</tr>
<tr class="row-odd"><td>mOutput</td>
<td>the matrix that stores the VME output data.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id16">
<h5>run_vme_inter<a class="headerlink" href="#id16" title="Permalink to this headline">¶</a></h5>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">run_vme_inter</span><span class="p">(</span><span class="n">matrix</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="n">N1</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="n">mInput</span><span class="p">,</span> <span class="n">VMEStreamMode</span> <span class="n">streamMode</span><span class="p">,</span>
  <span class="n">VMESearchCtrl</span> <span class="n">searchCtrl</span><span class="p">,</span> <span class="n">SurfaceIndex</span> <span class="n">surfIndex</span><span class="p">,</span> <span class="n">VmeIndex</span> <span class="n">SPIndex</span><span class="p">,</span> <span class="n">uint</span> <span class="n">lutSubIndex</span><span class="p">,</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="n">ushort</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">srcMB</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">ushort</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">ref0</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">ushort</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">ref1</span><span class="p">,</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="n">topMinus8Pels</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">16</span><span class="o">&gt;</span> <span class="n">leftPels</span><span class="p">,</span> <span class="n">matrix_ref</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="n">N2</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="n">mOutput</span><span class="p">);</span>
</pre></div>
</div>
<p>The compiler generates code for GenX hardware to perform VME function in inter-search only mode.</p>
</div>
<div class="section" id="id17">
<h5>run_vme_all<a class="headerlink" href="#id17" title="Permalink to this headline">¶</a></h5>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">run_vme_all</span><span class="p">(</span><span class="n">matrix</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="n">N1</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="n">mInput</span><span class="p">,</span> <span class="n">VMEStreamMode</span> <span class="n">streamMode</span><span class="p">,</span>
  <span class="n">VMESearchCtrl</span> <span class="n">searchCtrl</span><span class="p">,</span> <span class="n">SurfaceIndex</span> <span class="n">surfIndex</span><span class="p">,</span> <span class="n">VmeIndex</span> <span class="n">SPIndex</span><span class="p">,</span> <span class="n">uint</span> <span class="n">lutSubIndex</span><span class="p">,</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="n">ushort</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">srcMB</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">ushort</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">ref0</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">ushort</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">ref1</span><span class="p">,</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="n">topMinus8Pels</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">16</span><span class="o">&gt;</span> <span class="n">leftPels</span><span class="p">,</span> <span class="n">matrix_ref</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="n">N2</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="n">mOutput</span><span class="p">);</span>
</pre></div>
</div>
<p>The compiler generates code for GenX hardware to perform VME functions in both inter- and intra-search
enabled mode.</p>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>mInput</td>
<td><p class="first">the matrix that stores the VME payload data, where N1 can be
the following values:</p>
<ul class="last simple">
<li>N1 = 5 if stream-in is disabled.</li>
<li>N1 = 9 if stream-in is enabled and search ctrl is set to
dual-record and dual-reference.</li>
<li>N1 = 7 if stream-in is enabled and search ctrl is set to
other type.</li>
</ul>
</td>
</tr>
<tr class="row-odd"><td>streamMode</td>
<td><p class="first">VME stream mode, which is an enumeration type with 4
possible values, as listed below.  It must be a compile time
constant.</p>
<ul class="last simple">
<li>VME_STREAM_DISABLE</li>
<li>VME_STREAM_OUT</li>
<li>VME_STREAM_IN</li>
<li>VME_STREAM_IN_OUT</li>
</ul>
</td>
</tr>
<tr class="row-even"><td>searchCtrl</td>
<td><p class="first">VME search control, which is an enumeration type with 4
possible values, as listed below. It must be a compile time
constant.</p>
<ul class="last simple">
<li>VME_SEARCH_SINGLE_REF_SINGLE_REC_SINGLE_START</li>
<li>VME_SEARCH_SINGLE_REF_SINGLE_REC_DUAL_START</li>
<li>VME_SEARCH_SINGLE_REF_DUAL_REC</li>
<li>VME_SEARCH_DUAL_REF_DUAL_REC</li>
</ul>
</td>
</tr>
<tr class="row-odd"><td>surfIndex</td>
<td>surface index. This is an abstract handle that represents
the surface created by CM host runtime [6] and must be
passed through kernel function parameters. CM does not allow
the explicit use of local/global variable or modification of
such abstract data types in kernel functions, except used as
function call argument.</td>
</tr>
<tr class="row-even"><td>SPIndex</td>
<td>search path LUT index. This is an abstract handle that
represents the VME state created by CM host runtime [6] and
must be passed through kernel function parameters. CM does
not allow the explicit use of local/global variable or
modification of such abstract data types in kernel
functions, except used as function call argument.</td>
</tr>
<tr class="row-odd"><td>lutSubIndex</td>
<td>the index into the RDLUT state table, with a range of [0-3].</td>
</tr>
<tr class="row-even"><td>srcMB</td>
<td>The position of the left-top integer corner of the source
macroblock or block located in the surface (in unit of
pixels, relative to the picture origin).</td>
</tr>
<tr class="row-odd"><td>ref0</td>
<td>The position of the left-top integer corner of the first
reference window located in the first reference surface (in
unit of pixels, relative to source MB location).</td>
</tr>
<tr class="row-even"><td>ref1</td>
<td>The position of the left-top integer corner of the second
reference window located in the second reference surface (in
unit of pixels, relative to source MB location; ignored in
single reference mode).</td>
</tr>
<tr class="row-odd"><td>topMinus8Pels</td>
<td>The positions of the top neighborhood pixels.</td>
</tr>
<tr class="row-even"><td>leftPels</td>
<td>The positions of the left neighborhood pixels.</td>
</tr>
<tr class="row-odd"><td>mOutput</td>
<td><p class="first">the matrix that stores the VME output data, where N2 can be
the following values:</p>
<ul class="last simple">
<li>N2 = 6 if stream-out is disabled.</li>
<li>N2 = 10 if stream-out is enabled and search ctrl is set to
dual-record and dual-reference.</li>
<li>N2 = 8 if stream-out is enabled and search ctrl is set to
other type.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="gen7-5-vme-interface">
<h4>4.12.3 Gen7_5 VME Interface<a class="headerlink" href="#gen7-5-vme-interface" title="Permalink to this headline">¶</a></h4>
<p>CM provides the following Video Motion Estimation (VME) APIs for Gen7_5 architecture.</p>
<div class="section" id="run-vme-ime">
<h5>run_vme_ime<a class="headerlink" href="#run-vme-ime" title="Permalink to this headline">¶</a></h5>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">run_vme_ime</span><span class="p">(</span><span class="n">matrix</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="n">UNIInput</span><span class="p">,</span> <span class="n">matrix</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="n">N1</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="n">IMEInput</span><span class="p">,</span>
  <span class="n">VMEStreamMode</span> <span class="n">streamMode</span><span class="p">,</span> <span class="n">VMESearchCtrl</span> <span class="n">searchCtrl</span><span class="p">,</span> <span class="n">SurfaceIndex</span> <span class="n">curSurfIndex</span><span class="p">,</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">short</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">ref0</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">short</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">ref1</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">ushort</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">costCenter</span><span class="p">,</span>
  <span class="n">matrix_ref</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="n">N2</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="n">IMEOutput</span><span class="p">);</span>
</pre></div>
</div>
<p>The compiler generates code for GenX hardware to perform Integer Motion Estimation (IME). The formal
parameters are described below:</p>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>UNIInput</td>
<td>the matrix that stores the universal VME payload data.</td>
</tr>
<tr class="row-odd"><td>IMEInput</td>
<td><p class="first">the matrix that stores the IME specific payload data, where
N1 can be the following values:</p>
<ul class="last simple">
<li>N1 = 2 if stream-in is disabled.</li>
<li>N1 = 6 if stream-in is enabled and search ctrl is set to
dual-record and dual-reference.</li>
<li>N1 = 4 if stream-in is enabled and search ctrl is set to
other type.</li>
</ul>
</td>
</tr>
<tr class="row-even"><td>streamMode</td>
<td><p class="first">VME stream mode, which is an enumeration type with 4
possible values, as listed below.  It must be a compile time
constant.</p>
<ul class="last simple">
<li>VME_STREAM_DISABLE</li>
<li>VME_STREAM_OUT</li>
<li>VME_STREAM_IN</li>
<li>VME_STREAM_IN_OUT</li>
</ul>
</td>
</tr>
<tr class="row-odd"><td>searchCtrl</td>
<td><p class="first">VME search control, which is an enumeration type with 4
possible values, as listed below. It must be a compile time
constant.</p>
<ul class="last simple">
<li>VME_SEARCH_SINGLE_REF_SINGLE_REC_SINGLE_START</li>
<li>VME_SEARCH_SINGLE_REF_SINGLE_REC_DUAL_START</li>
<li>VME_SEARCH_SINGLE_REF_DUAL_REC</li>
<li>VME_SEARCH_DUAL_REF_DUAL_REC</li>
</ul>
</td>
</tr>
<tr class="row-even"><td>curSurfIndex</td>
<td>surface index. This is an abstract handle that represents
the surface created by CM host runtime [6] and must be
passed through kernel function parameters. CM does not allow
the explicit use of local/global variable or modification of
such abstract data types in kernel functions, except used as
function call argument.</td>
</tr>
<tr class="row-odd"><td>ref0</td>
<td>The position of the left-top integer corner of the first
reference window located in the first reference surface (in
unit of pixels, relative to the source MB).</td>
</tr>
<tr class="row-even"><td>ref1</td>
<td>The position of the left-top integer corner of the second
reference window located in the second reference surface (in
unit of pixels, relative to the source MB; ignored in single
reference mode).</td>
</tr>
<tr class="row-odd"><td>costCenter</td>
<td>The coordinates for the cost centers relative to the picture
source MB. The coordinates are specified in the following
order: {CostCenter0X, CostCenter0Y, CostCenter1X,
CostCenter1Y}.</td>
</tr>
<tr class="row-even"><td>IMEOutput</td>
<td><p class="first">the matrix that stores the IME output data, where N2 can be
the following values:</p>
<ul class="last simple">
<li>N2 = 7 if stream-out is disabled.</li>
<li>N2 = 11 if stream-out is enabled and search ctrl is set to
dual-record and dual-reference.</li>
<li>N2 = 9 if stream-out is enabled and search ctrl is set to
other type.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="run-vme-sic">
<h5>run_vme_sic<a class="headerlink" href="#run-vme-sic" title="Permalink to this headline">¶</a></h5>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">run_vme_sic</span><span class="p">(</span><span class="n">matrix</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="n">UNIInput</span><span class="p">,</span> <span class="n">matrix</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="n">SICInput</span><span class="p">,</span>
  <span class="n">SurfaceIndex</span> <span class="n">curSurfIndex</span><span class="p">,</span> <span class="n">matrix_ref</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="n">UNIOutput</span><span class="p">);</span>
</pre></div>
</div>
<p>The compiler generates code for GenX hardware to perform Skip and Intra Check (SIC). The formal
parameters are described below:</p>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>UNIInput</td>
<td>the matrix that stores the universal VME payload data.</td>
</tr>
<tr class="row-odd"><td>SICInput</td>
<td>the matrix that stores the SIC specific payload data.</td>
</tr>
<tr class="row-even"><td>curSurfIndex</td>
<td>surface index. This is an abstract handle that represents
the surface created by CM host runtime [6] and must be
passed through kernel function parameters. CM does not allow
the explicit use of local/global variable or modification of
such abstract data types in kernel functions, except used as
function call argument.</td>
</tr>
<tr class="row-odd"><td>UNIOutput</td>
<td>the matrix that stores the SIC output data (same structure
as universal VME output data).</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="run-vme-fbr">
<h5>run_vme_fbr<a class="headerlink" href="#run-vme-fbr" title="Permalink to this headline">¶</a></h5>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">run_vme_fbr</span><span class="p">(</span><span class="n">matrix</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="n">UNIInput</span><span class="p">,</span> <span class="n">matrix</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="n">FBRInput</span><span class="p">,</span>
  <span class="n">SurfaceIndex</span> <span class="n">curSurfIndex</span><span class="p">,</span> <span class="n">uchar</span> <span class="n">FBRMbMode</span><span class="p">,</span> <span class="n">uchar</span> <span class="n">FBRSubMbShape</span><span class="p">,</span> <span class="n">uchar</span> <span class="n">FBRSubPredMode</span><span class="p">,</span>
  <span class="n">matrix_ref</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="n">UNIOutput</span><span class="p">);</span>
</pre></div>
</div>
<p>The compiler generates code for GenX hardware to perform Fractional and Bidirectional Refinement (FBR).
The formal parameters are described below:</p>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>UNIInput</td>
<td>the matrix that stores the universal VME payload data.</td>
</tr>
<tr class="row-odd"><td>FBRInput</td>
<td>the matrix that stores the FBR specific payload data.</td>
</tr>
<tr class="row-even"><td>curSurfIndex</td>
<td>surface index. This is an abstract handle that represents
the surface created by CM host runtime [6] and must be
passed through kernel function parameters. CM does not allow
the explicit use of local/global variable or modification of
such abstract data types in kernel functions, except used as
function call argument.</td>
</tr>
<tr class="row-odd"><td>FBRMbMode</td>
<td><p class="first">the inter macroblock type, which can be the following 2-bit
values:</p>
<ul class="last simple">
<li>00: 16x16</li>
<li>01: 16x8</li>
<li>10: 8x16</li>
<li>11: 8x8</li>
</ul>
</td>
</tr>
<tr class="row-even"><td>FBRSubMbShape</td>
<td><p class="first">the subshape per block for fractional and bidirectional
refinement, which can be the following combination of 8-bit
values:</p>
<ul class="simple">
<li>Bits [1:0]: SubMbShape[0]</li>
<li>Bits [3:2]: SubMbShape[1]</li>
<li>Bits [5:4]: SubMbShape[2]</li>
<li>Bits [7:6]: SubMbShape[3]</li>
</ul>
<p>where each 2-bit correspond to the following shapes:</p>
<ul class="last simple">
<li>00: 8x8</li>
<li>01: 8x4</li>
<li>10: 4x8</li>
<li>11: 4x4</li>
</ul>
</td>
</tr>
<tr class="row-odd"><td>FBRSubPredMode</td>
<td><p class="first">the selection of shapes from the input message for
performing FME, which can be the following combination of
8-bit values:</p>
<ul class="simple">
<li>Bits [1:0]: SubMbPredMode[0]</li>
<li>Bits [3:2]: SubMbPredMode[1]</li>
<li>Bits [5:4]: SubMbPredMode[2]</li>
<li>Bits [7:6]: SubMbPredMode[3]</li>
</ul>
<p>where each 2-bit correspond to the following selections:</p>
<ul class="last simple">
<li>00: Forward</li>
<li>01: Backward</li>
<li>10: Bidirectional</li>
<li>11: Illegal</li>
</ul>
</td>
</tr>
<tr class="row-even"><td>UNIOutput</td>
<td>the matrix that stores the FBR output data (same structure
as universal VME output data).</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="gen8-vme-interface">
<h4>4.12.4 Gen8 VME Interface<a class="headerlink" href="#gen8-vme-interface" title="Permalink to this headline">¶</a></h4>
<p>CM provides the following Video Motion Estimation (VME) APIs for Gen8 architecture.</p>
<div class="section" id="id18">
<h5>run_vme_ime<a class="headerlink" href="#id18" title="Permalink to this headline">¶</a></h5>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">run_vme_ime</span><span class="p">(</span><span class="n">matrix</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="n">UNIInput</span><span class="p">,</span> <span class="n">matrix</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="n">N1</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="n">IMEInput</span><span class="p">,</span>
  <span class="n">VMEStreamMode</span> <span class="n">streamMode</span><span class="p">,</span> <span class="n">VMESearchCtrl</span> <span class="n">searchCtrl</span><span class="p">,</span> <span class="n">SurfaceIndex</span> <span class="n">curSurfIndex</span><span class="p">,</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">short</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">ref0</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">short</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">ref1</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">ushort</span><span class="p">,</span> <span class="mi">16</span><span class="o">&gt;</span> <span class="n">costCenter</span><span class="p">,</span>
  <span class="n">matrix_ref</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="n">N2</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="n">IMEOutput</span><span class="p">);</span>
</pre></div>
</div>
<p>The compiler generates code for GenX hardware to perform Integer Motion Estimation (IME). The formal
parameters are described below:</p>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>UNIInput</td>
<td>the matrix that stores the universal VME payload data.</td>
</tr>
<tr class="row-odd"><td>IMEInput</td>
<td><p class="first">the matrix that stores the IME specific payload data, where
N1 can be the following values:</p>
<ul class="last simple">
<li>N1 = 2 if stream-in is disabled.</li>
<li>N1 = 6 if stream-in is enabled and search ctrl is set to
dual-record and dual-reference.</li>
<li>N1 = 4 if stream-in is enabled and search ctrl is set to
other type.</li>
</ul>
</td>
</tr>
<tr class="row-even"><td>streamMode</td>
<td><p class="first">VME stream mode, which is an enumeration type with 4
possible values, as listed below.  It must be a compile time
constant.</p>
<ul class="last simple">
<li>VME_STREAM_DISABLE</li>
<li>VME_STREAM_OUT</li>
<li>VME_STREAM_IN</li>
<li>VME_STREAM_IN_OUT</li>
</ul>
</td>
</tr>
<tr class="row-odd"><td>searchCtrl</td>
<td><p class="first">VME search control, which is an enumeration type with 4
possible values, as listed below. It must be a compile time
constant.</p>
<ul class="last simple">
<li>VME_SEARCH_SINGLE_REF_SINGLE_REC_SINGLE_START</li>
<li>VME_SEARCH_SINGLE_REF_SINGLE_REC_DUAL_START</li>
<li>VME_SEARCH_SINGLE_REF_DUAL_REC</li>
<li>VME_SEARCH_DUAL_REF_DUAL_REC</li>
</ul>
</td>
</tr>
<tr class="row-even"><td>curSurfIndex</td>
<td>surface index. This is an abstract handle that represents
the surface created by CM host runtime [6] and must be
passed through kernel function parameters. CM does not allow
the explicit use of local/global variable or modification of
such abstract data types in kernel functions, except used as
function call argument.</td>
</tr>
<tr class="row-odd"><td>ref0</td>
<td>The position of the left-top integer corner of the first
reference window located in the first reference surface (in
unit of pixels, relative to the source MB).</td>
</tr>
<tr class="row-even"><td>ref1</td>
<td>The position of the left-top integer corner of the second
reference window located in the second reference surface (in
unit of pixels, relative to the source MB; ignored in single
reference mode).</td>
</tr>
<tr class="row-odd"><td>costCenter</td>
<td>The coordinates for the cost centers relative to the picture
source MB. The coordinates are specified in the following
order: {FWDCostCenter0X, FWDCostCenter0Y, BWDCostCenter0X,
BWDCostCenter0Y, FWDCostCenter1X, FWDCostCenter1Y,
BWDCostCenter1X, BWDCostCenter1Y, FWDCostCenter2X,
FWDCostCenter2Y, BWDCostCenter2X, BWDCostCenter2Y,
FWDCostCenter3X, FWDCostCenter3Y, BWDCostCenter3X,
BWDCostCenter3Y}</td>
</tr>
<tr class="row-even"><td>IMEOutput</td>
<td><p class="first">the matrix that stores the IME output data, where N2 can be
the following values:</p>
<ul class="last simple">
<li>N2 = 7 if stream-out is disabled.</li>
<li>N2 = 11 if stream-out is enabled and search ctrl is set to
dual-record and dual-reference.</li>
<li>N2 = 9 if stream-out is enabled and search ctrl is set to
other type.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id19">
<h5>run_vme_sic<a class="headerlink" href="#id19" title="Permalink to this headline">¶</a></h5>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">run_vme_sic</span><span class="p">(</span><span class="n">matrix</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="n">UNIInput</span><span class="p">,</span> <span class="n">matrix</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="n">SICInput</span><span class="p">,</span>
  <span class="n">SurfaceIndex</span> <span class="n">curSurfIndex</span><span class="p">,</span> <span class="n">matrix_ref</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="n">UNIOutput</span><span class="p">);</span>
</pre></div>
</div>
<p>The compiler generates code for GenX hardware to perform Skip and Intra Check (SIC). The formal
parameters are described below:</p>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>UNIInput</td>
<td>the matrix that stores the universal VME payload data.</td>
</tr>
<tr class="row-odd"><td>SICInput</td>
<td>the matrix that stores the SIC specific payload data.</td>
</tr>
<tr class="row-even"><td>curSurfIndex</td>
<td>surface index. This is an abstract handle that represents
the surface created by CM host runtime [6] and must be
passed through kernel function parameters. CM does not allow
the explicit use of local/global variable or modification of
such abstract data types in kernel functions, except used as
function call argument.</td>
</tr>
<tr class="row-odd"><td>UNIOutput</td>
<td>the matrix that stores the SIC output data (same structure
as universal VME output data).</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id20">
<h5>run_vme_fbr<a class="headerlink" href="#id20" title="Permalink to this headline">¶</a></h5>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">run_vme_fbr</span><span class="p">(</span><span class="n">matrix</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="n">UNIInput</span><span class="p">,</span> <span class="n">matrix</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="n">FBRInput</span><span class="p">,</span>
  <span class="n">SurfaceIndex</span> <span class="n">curSurfIndex</span><span class="p">,</span> <span class="n">uchar</span> <span class="n">FBRMbMode</span><span class="p">,</span> <span class="n">uchar</span> <span class="n">FBRSubMbShape</span><span class="p">,</span> <span class="n">uchar</span> <span class="n">FBRSubPredMode</span><span class="p">,</span>
  <span class="n">matrix_ref</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="n">UNIOutput</span><span class="p">);</span>
</pre></div>
</div>
<p>The compiler generates code for GenX hardware to perform Fractional and Bidirectional Refinement (FBR).
The formal parameters are described below:</p>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>UNIInput</td>
<td>the matrix that stores the universal VME payload data.</td>
</tr>
<tr class="row-odd"><td>FBRInput</td>
<td>the matrix that stores the FBR specific payload data.</td>
</tr>
<tr class="row-even"><td>curSurfIndex</td>
<td>surface index. This is an abstract handle that represents
the surface created by CM host runtime [6] and must be
passed through kernel function parameters. CM does not allow
the explicit use of local/global variable or modification of
such abstract data types in kernel functions, except used as
function call argument.</td>
</tr>
<tr class="row-odd"><td>FBRMbMode</td>
<td><p class="first">the inter macroblock type, which can be the following 2-bit
values:</p>
<ul class="last simple">
<li>00: 16x16</li>
<li>01: 16x8</li>
<li>10: 8x16</li>
<li>11: 8x8</li>
</ul>
</td>
</tr>
<tr class="row-even"><td>FBRSubMbShape</td>
<td><p class="first">the subshape per block for fractional and bidirectional
refinement, which can be the following combination of 8-bit
values:</p>
<ul class="simple">
<li>Bits [1:0]: SubMbShape[0]</li>
<li>Bits [3:2]: SubMbShape[1]</li>
<li>Bits [5:4]: SubMbShape[2]</li>
<li>Bits [7:6]: SubMbShape[3]</li>
</ul>
<p>where each 2-bit correspond to the following shapes:</p>
<ul class="last simple">
<li>00: 8x8</li>
<li>01: 8x4</li>
<li>10: 4x8</li>
<li>11: 4x4</li>
</ul>
</td>
</tr>
<tr class="row-odd"><td>FBRSubPredMode</td>
<td><p class="first">the selection of shapes from the input message for
performing FME, which can be the following combination of
8-bit values:</p>
<ul class="simple">
<li>Bits [1:0]: SubMbPredMode[0]</li>
<li>Bits [3:2]: SubMbPredMode[1]</li>
<li>Bits [5:4]: SubMbPredMode[2]</li>
<li>Bits [7:6]: SubMbPredMode[3]</li>
</ul>
<p>where each 2-bit correspond to the following selections:</p>
<ul class="last simple">
<li>00: Forward</li>
<li>01: Backward</li>
<li>10: Bidirectional</li>
<li>11: Illegal</li>
</ul>
</td>
</tr>
<tr class="row-even"><td>UNIOutput</td>
<td>the matrix that stores the FBR output data (same structure
as universal VME output data).</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="run-vme-idm">
<h5>run_vme_idm<a class="headerlink" href="#run-vme-idm" title="Permalink to this headline">¶</a></h5>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">run_vme_idm</span><span class="p">(</span><span class="n">matrix</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="n">UNIInput</span><span class="p">,</span> <span class="n">matrix</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="n">IDMInput</span><span class="p">,</span>
  <span class="n">SurfaceIndex</span> <span class="n">curSurfIndex</span><span class="p">,</span> <span class="n">matrix_ref</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="n">IDMOutput</span><span class="p">);</span>
</pre></div>
</div>
<p>The compiler generates code for GenX hardware to generate distortion mesh output (IDM). The formal
parameters are described below:</p>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>UNIInput</td>
<td>the matrix that stores the universal VME payload data.</td>
</tr>
<tr class="row-odd"><td>IDMInput</td>
<td>the matrix that stores the IDM specific payload data.</td>
</tr>
<tr class="row-even"><td>curSurfIndex</td>
<td>surface index. This is an abstract handle that represents
the surface created by CM host runtime [6] and must be
passed through kernel function parameters. CM does not allow
the explicit use of local/global variable or modification of
such abstract data types in kernel functions, except used as
function call argument.</td>
</tr>
<tr class="row-odd"><td>IDMOutput</td>
<td>the matrix that stores the IDM output data.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="gen10-hevc-vme-interface">
<h4>4.12.5 Gen10 HEVC VME Interface<a class="headerlink" href="#gen10-hevc-vme-interface" title="Permalink to this headline">¶</a></h4>
<p>CM provides the following HEVC-specific Video Motion Estimation (VME) APIs for the Gen10 architecture</p>
<div class="section" id="cm-vme-hevc-ime">
<h5>cm_vme_hevc_ime<a class="headerlink" href="#cm-vme-hevc-ime" title="Permalink to this headline">¶</a></h5>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">cm_vme_hevc_ime</span> <span class="p">(</span><span class="n">matrix</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="n">IMEInput</span><span class="p">,</span> <span class="n">matrix</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="n">StreamInput</span><span class="p">,</span>
  <span class="kt">int</span> <span class="n">LenStreamInput</span><span class="p">,</span> <span class="n">SurfaceIndex</span> <span class="n">curSurfIndex</span><span class="p">,</span> <span class="n">matrix_ref</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="n">IMEOutput</span><span class="p">);</span>
</pre></div>
</div>
<p>These generate code to perform an HEVC Integer Motion Estimation (IME) operation in GenX hardware.</p>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>IMEInput</td>
<td>this holds the universal VME and search path (IME) input
payloads.</td>
</tr>
<tr class="row-odd"><td>LenStreamInput</td>
<td>the length of Stream Input, it could be either 0 (for an
IME-F operation) or 10 (for an IME-S operation) .</td>
</tr>
<tr class="row-even"><td>StreamInput</td>
<td>this holds the stream-in major shape motion-vector and
distortion (SISO)  input payload.  Unused if
LengthStreamInput is 0.</td>
</tr>
<tr class="row-odd"><td>curSurfIndex</td>
<td>the surface index.</td>
</tr>
<tr class="row-even"><td>IMEOutput</td>
<td>this holds the output payload, comprising the universal VME
return data and the stream out motion-vector and distortion
data (SISO).</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="cm-vme-hevc-sic-cm-vme-hevc-sc">
<h5>cm_vme_hevc_sic, cm_vme_hevc_sc<a class="headerlink" href="#cm-vme-hevc-sic-cm-vme-hevc-sc" title="Permalink to this headline">¶</a></h5>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">cm_vme_hevc_sic</span><span class="p">(</span><span class="n">matrix_ref</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="n">SICInput</span><span class="p">,</span> <span class="n">matrix_ref</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="n">NPInput</span><span class="p">,</span>
  <span class="kt">int</span> <span class="n">LengthNP</span><span class="p">,</span> <span class="n">SurfaceIndex</span> <span class="n">curSurfIndex</span><span class="p">,</span> <span class="n">matrix_ref</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="n">SICOutput</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">cm_vme_hevc_sc</span><span class="p">(</span><span class="n">matrix_ref</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="n">SICInput</span><span class="p">,</span> <span class="n">SurfaceIndex</span> <span class="n">curSurfIndex</span><span class="p">,</span>
  <span class="n">matrix_ref</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="n">SICOutput</span><span class="p">);</span>
</pre></div>
</div>
<p>These generate code to perform an HEVC Skip and/or Intra Check (SIC, IC, SC) operation in GenX
hardware.</p>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>SICInput</td>
<td>this hold the universal VME and SIC input payloads.</td>
</tr>
<tr class="row-odd"><td>NPInput</td>
<td>this holds the neighbor pixel (NP) input payload. Not used
if LengthNP is 0.</td>
</tr>
<tr class="row-even"><td>LengthNP</td>
<td>the size of Neighbor Pixel payload, 8 for SIC or IC
operations, 0 for SC operations.  curSurfIndex -  the
surface index.</td>
</tr>
<tr class="row-odd"><td>SICOutput</td>
<td>this stores the SIC output payload, comprising the universal
VME return data followed the intra steam-in steam-out data
(SSRA) and Coding Unit (CU) data (these latter two data
groups are only meaningful if an Intra Check was performed).</td>
</tr>
</tbody>
</table>
<p>cm_vme_hevc_sc() should be used in situations where it is always the case that there will be no need for
an Intra Check. This avoids having to create NPInput matrix just to satisfy the parameter requirements for
cm_vme_hevc_sic() even though it will be unused, and to avoid having SICOutput be unnecessarily large.</p>
</div>
<div class="section" id="cm-vme-hevc-hpm-u">
<h5>cm_vme_hevc_hpm_u<a class="headerlink" href="#cm-vme-hevc-hpm-u" title="Permalink to this headline">¶</a></h5>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">cm_vme_hevc_hpm_u</span> <span class="p">(</span><span class="n">matrix_ref</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="n">HPMInput</span><span class="p">,</span> <span class="n">matrix_ref</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="n">StreamInpInter</span><span class="p">,</span>
  <span class="n">SurfaceIndex</span> <span class="n">curSurfIndex</span><span class="p">,</span>  <span class="n">matrix_ref</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="n">HPMOutput</span><span class="p">);</span>
</pre></div>
</div>
<p>These generate code to perform an HEVC Partitioning Message (HPM) with single-directional inter
prediction in GenX hardware.</p>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>HPMInput</td>
<td>this holds the universal VME, Skip Intra Check (SIC),
IntraPred and distortion (SSRA) and Neighbor Motion Vector
(NMV) input payloads.</td>
</tr>
<tr class="row-odd"><td>StreamInpInter</td>
<td>this holds the stream-in major shape motion vector and
distortion data (SISO).</td>
</tr>
<tr class="row-even"><td>curSurfIndex</td>
<td>the surface index.</td>
</tr>
<tr class="row-odd"><td>HPMOutput</td>
<td>the matrix that hold the output payload, comprising the
universal VME return data and major shape stream out data
(CU).</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="cm-vme-hevc-hpm-b">
<h5>cm_vme_hevc_hpm_b<a class="headerlink" href="#cm-vme-hevc-hpm-b" title="Permalink to this headline">¶</a></h5>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">cm_vme_hevc_hpm_b</span> <span class="p">(</span><span class="n">matrix</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="n">HPMInput</span><span class="p">,</span> <span class="n">matrix</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="n">StreamInpInter</span><span class="p">,</span>
  <span class="kt">int</span> <span class="n">LenStrmInpInter</span><span class="p">,</span> <span class="n">SurfaceIndex</span> <span class="n">curSurfIndex</span><span class="p">,</span>  <span class="n">matrix_ref</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="n">HPMOutput</span><span class="p">);</span>
</pre></div>
</div>
<p>These generate code to perform HEVC Partitioning Message (HPM) with single- or bi-directional Inter
Prediction in GenX hardware.</p>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>HPMInput</td>
<td>this holds the universal VME, Skip Intra Check (SIC),
IntraPred and distortion (SSRA) and Neighbor Motion Vector
(NMV) input payloads.</td>
</tr>
<tr class="row-odd"><td>StreamInpInter</td>
<td>this holds the stream-in major shape motion vector and
distortion data (SISO).</td>
</tr>
<tr class="row-even"><td>LenStrmInpInter</td>
<td>the size of StreamInputInter payload, 10 for
single-directional, 20 for bi-directional.</td>
</tr>
<tr class="row-odd"><td>curSurfIndex</td>
<td>the surface index</td>
</tr>
<tr class="row-even"><td>HPMOutput</td>
<td>this  holds the output payload, comprising the universal VME
return data and major shape stream out data (CU).</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="cm-vme-hevc-fbr">
<h5>cm_vme_hevc_fbr<a class="headerlink" href="#cm-vme-hevc-fbr" title="Permalink to this headline">¶</a></h5>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">cm_vme_hevc_fbr</span><span class="p">(</span><span class="n">matrix</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="n">UNIInput</span><span class="p">,</span> <span class="n">matrix</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="n">CUInput</span><span class="p">,</span>
  <span class="kt">int</span> <span class="n">ValidCULength</span><span class="p">,</span> <span class="n">SurfaceIndex</span> <span class="n">curSurfIndex</span><span class="p">,</span> <span class="n">matrix_ref</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="n">FBROutput</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">cm_vme_hevc_fbr</span><span class="p">(</span><span class="n">matrix_ref</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="n">UNIInput</span><span class="p">,</span> <span class="n">matrix_ref</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="n">CUInput</span><span class="p">,</span>
  <span class="kt">int</span> <span class="n">ValidCULength</span><span class="p">,</span> <span class="n">SurfaceIndex</span> <span class="n">curSurfIndex</span><span class="p">,</span> <span class="n">matrix_ref</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="n">FBROutput</span><span class="p">);</span>
</pre></div>
</div>
<p>These generate code to perform a Fractional and Bidirectional Refinement (FBR) operation in GenX
hardware.</p>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>UNIInput</td>
<td>this holds the universal VME input payload.</td>
</tr>
<tr class="row-odd"><td>CUInput</td>
<td>this holds the Coding Unit (CU) input payload.</td>
</tr>
<tr class="row-even"><td>ValidCULength</td>
<td>the size of CUInput. Legal value are: 1, 2, 4, 5, 6, 7, 8,
9, 10, 11, 12, 13, 14, or 16.</td>
</tr>
<tr class="row-odd"><td>curSurfIndex</td>
<td>the surface index.</td>
</tr>
<tr class="row-even"><td>FBROutput</td>
<td>this holds the FBR output payload, comprising the universal
VME return data and the FBR applied Coding Unit data (CU).</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="cm-vme-hevc-rpm">
<h5>cm_vme_hevc_rpm<a class="headerlink" href="#cm-vme-hevc-rpm" title="Permalink to this headline">¶</a></h5>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">cm_vme_hevc_rpm</span><span class="p">(</span><span class="n">matrix</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="n">UNIInput</span><span class="p">,</span> <span class="n">matrix</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="n">CUInput</span><span class="p">,</span>
  <span class="kt">int</span> <span class="n">ValidCULength</span><span class="p">,</span> <span class="n">SurfaceIndex</span> <span class="n">curSurfIndex</span><span class="p">,</span> <span class="n">matrix_ref</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="n">RPMOutput</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">cm_vme_hevc_rpm</span><span class="p">(</span><span class="n">matrix_ref</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="n">UNIInput</span><span class="p">,</span> <span class="n">matrix_ref</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="n">CUInput</span><span class="p">,</span>
  <span class="kt">int</span> <span class="n">ValidCULength</span><span class="p">,</span> <span class="n">SurfaceIndex</span> <span class="n">curSurfIndex</span><span class="p">,</span> <span class="n">matrix_ref</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="n">RPMOutput</span><span class="p">);</span>
</pre></div>
</div>
<p>These generate code to perform a Residual Prediction Message (RPM) operation in GenX.</p>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>RPMInput</td>
<td>this holds the universal VME and Spatial Neighbor Pixel (NP)
input payloads.</td>
</tr>
<tr class="row-odd"><td>CUInput</td>
<td>this holds the Coding Unit input payload.</td>
</tr>
<tr class="row-even"><td>ValidCULength</td>
<td>the size of CUInput. Legal values are: 1, 4, 7, 10, 13, or
16.</td>
</tr>
<tr class="row-odd"><td>curSurfIndex</td>
<td>the surface index.</td>
</tr>
<tr class="row-even"><td>RPMOutput</td>
<td>this stores the 4x4 z-order based approximate predicted
residual value or approximate predicted pixel for 32x32 data
area (RPM).</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="cm-vme-hevc-srm">
<h5>cm_vme_hevc_srm<a class="headerlink" href="#cm-vme-hevc-srm" title="Permalink to this headline">¶</a></h5>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">cm_vme_hevc_srm</span><span class="p">(</span><span class="n">matrix</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="n">SRMInput</span><span class="p">,</span> <span class="n">matrix</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="n">CUInput</span><span class="p">,</span>
  <span class="kt">int</span> <span class="n">ValidCULength</span><span class="p">,</span> <span class="n">SurfaceIndex</span> <span class="n">curSurfIndex</span><span class="p">,</span> <span class="n">matrix_ref</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="n">SRMOutput</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">cm_vme_hevc_srm</span><span class="p">(</span><span class="n">matrix_ref</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="n">SRMInput</span><span class="p">,</span> <span class="n">matrix_ref</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="n">CUInput</span><span class="p">,</span>
  <span class="kt">int</span> <span class="n">ValidCULength</span><span class="p">,</span> <span class="n">SurfaceIndex</span> <span class="n">curSurfIndex</span><span class="p">,</span> <span class="n">matrix_ref</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="n">SRMOutput</span><span class="p">);</span>
</pre></div>
</div>
<p>These generate code to perform a Skip Replacement Message (SRM) operation in GenX hardware.</p>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>SRMInput</td>
<td>this holds the universal VME and Neighbor Motion Vector
input payloads.</td>
</tr>
<tr class="row-odd"><td>CUInput</td>
<td>this holds the Coding Unit input payload.</td>
</tr>
<tr class="row-even"><td>ValidCULength</td>
<td>the size of CUInput, the legal value as follows: 1, 4, 7,
10, 13, or 16.</td>
</tr>
<tr class="row-odd"><td>curSurfIndex</td>
<td>the surface index.</td>
</tr>
<tr class="row-even"><td>SRMOutput</td>
<td>this holds the SRM output payload, comprising the universal
VME return data and SRM applied Coding Unit data (CU).</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="section" id="media-walker-interface">
<h3><a class="toc-backref" href="#id61">4.13 Media Walker Interface</a><a class="headerlink" href="#media-walker-interface" title="Permalink to this headline">¶</a></h3>
<p>To support the Media Walker functionality, CM provides the following intrinsic functions for a kernel to
query the thread position in the thread space. Please refer to CM runtime specification on the definition
of thread space and usage models of Media Walker [6].  The kernel can use these functions to obtain the
per-thread X/Y origin and color values set by the CM runtime host.</p>
<div class="section" id="get-thread-origin-x">
<h4>get_thread_origin_x<a class="headerlink" href="#get-thread-origin-x" title="Permalink to this headline">¶</a></h4>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">unsigned</span> <span class="kt">short</span> <span class="nf">get_thread_origin_x</span><span class="p">();</span>
</pre></div>
</div>
<p>This function returns the X value of the thread origin in the thread space. The return value is from 0 to
predefined thread space width - 1.</p>
</div>
<div class="section" id="get-thread-origin-y">
<h4>get_thread_origin_y<a class="headerlink" href="#get-thread-origin-y" title="Permalink to this headline">¶</a></h4>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">unsigned</span> <span class="kt">short</span> <span class="nf">get_thread_origin_y</span><span class="p">();</span>
</pre></div>
</div>
<p>This function returns the Y value of the thread origin in the thread space. The return value is from 0 to
predefined thread space height - 1.</p>
</div>
<div class="section" id="get-color">
<h4>get_color<a class="headerlink" href="#get-color" title="Permalink to this headline">¶</a></h4>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">unsigned</span> <span class="kt">short</span> <span class="nf">get_color</span><span class="p">();</span>
</pre></div>
</div>
<p>This function returns the color value of the thread origin in the thread space. The return value is from 0 to
predefined thread space color value - 1.</p>
<p>If thread space is not defined by CM runtime host, the default thread space width is fixed at 511.</p>
</div>
</div>
<div class="section" id="synchronization-functions">
<h3><a class="toc-backref" href="#id62">4.14 Synchronization Functions</a><a class="headerlink" href="#synchronization-functions" title="Permalink to this headline">¶</a></h3>
<p>CM provides the following intrinsic functions for synchronization:</p>
<div class="section" id="cm-wait">
<h4>cm_wait<a class="headerlink" href="#cm-wait" title="Permalink to this headline">¶</a></h4>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">cm_wait</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
</pre></div>
</div>
<p>If a thread dependency pattern is specified during the creation of the kernel’s thread space, this function
causes the thread to wait until all of its dependency threads have terminated before resuming execution.
Refer to [6] for more information on how to create thread dependencies during kernel launch.</p>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>mask</td>
<td>the thread dependency clear mask. Each bit corresponds to
one of the eight threads this thread may depend on; if set,
the dependency is cleared, and this thread will not wait for
the corresponding thread’s termination.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="cm-fence">
<h4>cm_fence<a class="headerlink" href="#cm-fence" title="Permalink to this headline">¶</a></h4>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">cm_fence</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">mask</span><span class="p">);</span>
</pre></div>
</div>
<p>This function causes thread execution to block until all previous reads and writes issued by the thread
have been globally observed.</p>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>mask</td>
<td><p class="first">{Gen8+} a bit mask that controls additional cache flush or
fence behavior. Valid masks are:</p>
<ul class="simple">
<li>CM_GLOBAL_COHERENT_FENCE: enables commit enable setting</li>
<li>CM_L3_FLUSH_INSTRUCTIONS: flushes the instruction cache</li>
<li>CM_L3_FLUSH_TEXTURE_DATA: flushes the sampler cache</li>
<li>CM_L3_FLUSH_CONSTANT_DATA: flushes the constant cache</li>
<li>CM_L3_FLUSH_RW_DATA: flushes the read-write cache</li>
<li>CM_LOCAL_BARRIER: enables local memory barrier</li>
<li>CM_L1_FLUASH_RO_DATA: flushes L1 read-only cache</li>
<li>CM_SW_BARRIER: enables software scheduling barrier</li>
</ul>
<p>The masks may be combined if more than one cache is to be
flushed.</p>
<p class="last">{pre-Gen8}  The field is ignored and the cache will not be
flushed.</p>
</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="cm-pause">
<h4>cm_pause<a class="headerlink" href="#cm-pause" title="Permalink to this headline">¶</a></h4>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">cm_pause</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">length</span><span class="p">);</span>
</pre></div>
</div>
<p>This function causes thread to pause for a length of time specified by
“length”. The value is decremented by the hardware thread control every 32 EU
cycles. Note that the EU clock frequency is variable so the pause is at best an
approximate pause. Generally it will be longer than the value written. For
architectures that don’t support (pre Gen10) the call will have no effect.</p>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>length</td>
<td>number of 32 cycle chunks to pause for</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="raw-send-functions">
<h3><a class="toc-backref" href="#id63">4.15 Raw Send Functions</a><a class="headerlink" href="#raw-send-functions" title="Permalink to this headline">¶</a></h3>
<p>CM provides the following APIs for issuing raw send messages to GenX shared functions.</p>
<div class="section" id="cm-send">
<h4>cm_send<a class="headerlink" href="#cm-send" title="Permalink to this headline">¶</a></h4>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">cm_send</span><span class="p">(</span><span class="n">matrix_ref</span><span class="o">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">N1</span><span class="p">,</span> <span class="n">N2</span><span class="o">&gt;</span> <span class="n">rspVar</span><span class="p">,</span>
             <span class="n">matrix</span><span class="o">&lt;</span><span class="n">T2</span><span class="p">,</span> <span class="n">N3</span><span class="p">,</span> <span class="n">N4</span><span class="o">&gt;</span> <span class="n">msgVar</span><span class="p">,</span>
             <span class="n">uint</span> <span class="n">exDesc</span><span class="p">,</span> <span class="n">uint</span> <span class="n">msgDesc</span><span class="p">,</span> <span class="n">uint</span> <span class="n">sendc</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="cm-sends-gen9">
<h4>cm_sends {Gen9+}<a class="headerlink" href="#cm-sends-gen9" title="Permalink to this headline">¶</a></h4>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">cm_sends</span><span class="p">(</span><span class="n">matrix_ref</span><span class="o">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">N1</span><span class="p">,</span> <span class="n">N2</span><span class="o">&gt;</span> <span class="n">rspVar</span><span class="p">,</span>
              <span class="n">matrix</span><span class="o">&lt;</span><span class="n">T2</span><span class="p">,</span> <span class="n">N3</span><span class="p">,</span> <span class="n">N4</span><span class="o">&gt;</span> <span class="n">msgVar</span><span class="p">,</span>
              <span class="n">matrix</span><span class="o">&lt;</span><span class="n">T3</span><span class="p">,</span> <span class="n">N5</span><span class="p">,</span> <span class="n">N6</span><span class="o">&gt;</span> <span class="n">msg2Var</span><span class="p">,</span>
              <span class="n">uint</span> <span class="n">exDesc</span><span class="p">,</span> <span class="n">uint</span> <span class="n">msgDesc</span><span class="p">,</span> <span class="n">uint</span> <span class="n">sendc</span><span class="p">);</span>
</pre></div>
</div>
<p>The formal parameters are described below:</p>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>rspVar</td>
<td>the matrix that stores the message response data.</td>
</tr>
<tr class="row-odd"><td>msgVar</td>
<td>the matrix that stores the message payload data.</td>
</tr>
<tr class="row-even"><td>msg2Var</td>
<td>the matrix that stores the second part of the message
payload data in a split send (Gen9+)</td>
</tr>
<tr class="row-odd"><td>exDesc</td>
<td>the extended message descriptor, which must be a compile
time constant.</td>
</tr>
<tr class="row-even"><td>msgDesc</td>
<td>the message descriptor for the send.</td>
</tr>
<tr class="row-odd"><td>sendc</td>
<td>the flag that indicates whether sendc should be used. It
must be a compile time constant (0 indicates send should be
used, while 1 means sendc)</td>
</tr>
</tbody>
</table>
<p>Note: When using raw send API, in general, it is the programmer’s responsibility to ensure that the input
parameters match the BSPEC requirement for a specific shared function message (e.g., payload
size, alignment, descriptor value, etc.). The response data and payload data are 32-bytes aligned.
When the destination is not present, the first parameter can be specified as “NULL”.</p>
<p><strong>Cm-icl compiler only:</strong></p>
<p>The SIMD width of the resulting <code class="docutils literal"><span class="pre">send</span></code> or <code class="docutils literal"><span class="pre">sends</span></code> instruction is always SIMD16.
The <code class="docutils literal"><span class="pre">cm_send</span></code> or <code class="docutils literal"><span class="pre">cm_sends</span></code> call cannot be inside SIMD control flow.</p>
<p><strong>Cmc compiler only:</strong></p>
<p>The SIMD width of the resulting <code class="docutils literal"><span class="pre">send</span></code> or <code class="docutils literal"><span class="pre">sends</span></code> instruction defaults to SIMD16.
However, if the <code class="docutils literal"><span class="pre">cm_send</span></code> or <code class="docutils literal"><span class="pre">cm_sends</span></code> is inside SIMD control flow, the
SIMD width of the <code class="docutils literal"><span class="pre">send</span></code> or <code class="docutils literal"><span class="pre">sends</span></code> instruction is adjusted to match the SIMD
control flow. The effect of the SIMD condition on the <code class="docutils literal"><span class="pre">send</span></code> or <code class="docutils literal"><span class="pre">sends</span></code> depends
on how the shared function unit interprets the execution mask.</p>
<p>If the <code class="docutils literal"><span class="pre">SIMD_IF_BEGIN</span></code> has a vector condition that evaluates
to all channels true, then the SIMD control flow code is optimized away but the
SIMD width of the <code class="docutils literal"><span class="pre">send</span></code> or <code class="docutils literal"><span class="pre">sends</span></code> instruction is adjusted anyway.</p>
</div>
<div class="section" id="cm-get-value">
<h4>cm_get_value<a class="headerlink" href="#cm-get-value" title="Permalink to this headline">¶</a></h4>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">cm_get_value</span><span class="p">(</span><span class="n">T</span> <span class="n">index</span><span class="p">);</span>
</pre></div>
</div>
<p>This intrinsic can be used to assemble the message descriptor, since CM does not allow direct
manipulation of abstract handles such as SurfaceIndex. The input parameter must be one of the
abstract data types (SurfaceIndex, SamplerIndex or VmeIndex). The return data is the encapsulated
index value.</p>
</div>
<div class="section" id="cm-get-r0">
<h4>cm_get_r0<a class="headerlink" href="#cm-get-r0" title="Permalink to this headline">¶</a></h4>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">vector</span><span class="o">&lt;</span><span class="n">uint</span><span class="p">,</span> <span class="mi">8</span><span class="o">&gt;</span> <span class="n">cm_get_r0</span><span class="p">();</span>
</pre></div>
</div>
<p>This intrinsic can be used to access the thread payload register R0, needed to assemble the raw
send message’s payload.</p>
</div>
</div>
<div class="section" id="cm-label-function">
<h3><a class="toc-backref" href="#id64">4.16 CM label function</a><a class="headerlink" href="#cm-label-function" title="Permalink to this headline">¶</a></h3>
<p>The cm_label function is deprecated in cmc. For backwards compatibility it is ignored if used.</p>
</div>
<div class="section" id="formatted-output">
<h3><a class="toc-backref" href="#id65">4.17 Formatted Output</a><a class="headerlink" href="#formatted-output" title="Permalink to this headline">¶</a></h3>
<div class="section" id="printf">
<h4>4.17.1 printf<a class="headerlink" href="#printf" title="Permalink to this headline">¶</a></h4>
<p>Starting with version 3.0, CM includes support for calling printf in-kernel: it prints formatted output
from a CM kernel to stdout on the host. Printf is defined as:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">printf</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">format</span><span class="p">,</span> <span class="p">...);</span>
</pre></div>
</div>
<p>CM device printf works similar to printf in &lt;stdio.h&gt; with the following exceptions:</p>
<ul class="simple">
<li>Unlike standard printf, which returns the number of bytes of the formatted output written
to stdout, CM printf returns the total unformatted bytes written to the special surface that is
reserved to printf.</li>
<li>The format string for the CM printf must have fewer than 128 bytes.</li>
<li>There can be no more than 64 parameters passed to a CM printf call.</li>
<li>The following conversion specifiers are currently not supported:  p, n.</li>
</ul>
<p>To use printf there are certain changes required in the host code to allocate the printf surface,
read and format the data written, and then print the result to stdout after the kernel finishes
execution. Please refer to the CM Runtime API documentation for more information.</p>
<p>Example</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;cm/cm.h&gt;</span><span class="cp"></span>

<span class="n">_GENX_MAIN_</span> <span class="kt">void</span> <span class="nf">printf_demo_genx</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">tx</span> <span class="o">=</span> <span class="n">get_thread_origin_x</span><span class="p">();</span>
  <span class="kt">int</span> <span class="n">ty</span> <span class="o">=</span> <span class="n">get_thread_origin_y</span><span class="p">();</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Number of bytes returned: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Hello CM from %dx%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">tx</span><span class="p">,</span> <span class="n">ty</span><span class="p">));</span>

  <span class="kt">double</span> <span class="n">foo</span> <span class="o">=</span> <span class="mf">4.2</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Print a double: %f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">foo</span><span class="p">);</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Print a string: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="s">&quot;Hello&quot;</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">tx</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">ty</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// Only print on tid 0</span>
  <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Hello from tid 0 with tx/ty %d/%d </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">tx</span><span class="p">,</span> <span class="n">ty</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>For a kernel with four threads the following would print (not necessarily in the same order):</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>Number of bytes returned: 224
Number of bytes returned: 224
Number of bytes returned: 224
Number of bytes returned: 224
Print a double: 4.2
Print a double: 4.2
Print a double: 4.2
Print a double: 4.2
Print a string: Hello
Print a string: Hello
Print a string: Hello
Print a string: Hello
Hello from tid 0 with tx/ty: 0/0
</pre></div>
</div>
</div>
</div>
<div class="section" id="shared-virtual-memory-svm">
<span id="sharedvirtualmemory"></span><h3><a class="toc-backref" href="#id66">4.18 Shared Virtual Memory (SVM)</a><a class="headerlink" href="#shared-virtual-memory-svm" title="Permalink to this headline">¶</a></h3>
<p>Shared Virtual Memory allows the CM program and the host application to share complex pointer-
containing data structures such as trees and lists. A pointer to a location within SVM has the same pointer
value on the host and in the CM program.</p>
<p>In CM, the type svmptr_t represents a pointer. It can be used as a parameter in a kernel (corresponding to
an actual pointer passed from the host application), as the element type in a vector or matrix, and as a
field within a struct declared for use within a data structure in memory shared with the host application.</p>
<p>The svmptr_t type is in fact an integer type, carrying no information on what type it points to. Therefore
adding one makes the pointer point to the next byte in memory, not the next item in an array of whatever
it points to.</p>
<p>Currently offsetof cannot be used in a CM program, so the offset of a field within a struct must be
computed manually by summing sizeof() each field before, taking care to avoid errors from alignment
gaps.</p>
<p>The size of svmptr_t is determined by the /DCM_PTRSIZE=32 or /DCM_PTRSIZE=64 compiler options. If
svmptr_t is used as a kernel parameter or in a data structure shared between host application and CM
program, then the size of svmptr_t must agree with the host application pointer size (and thus the vISA
resulting from compilation is not portable between 32 bit and 64 bit host applications). A mismatch
between pointer size in the host application and in the CM program will cause undefined behavior.</p>
<div class="section" id="cm-svm-block-read">
<h4>cm_svm_block_read<a class="headerlink" href="#cm-svm-block-read" title="Permalink to this headline">¶</a></h4>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">cm_svm_block_read</span><span class="p">(</span><span class="n">svmptr_t</span> <span class="n">v_Addr</span><span class="p">,</span> <span class="n">vector_ref</span><span class="o">&lt;</span><span class="n">TYPE</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">v_Src</span><span class="p">);</span>
</pre></div>
</div>
<p>Read N data elements (byte, word, dword, qword, total data
size up to 128 bytes) into the vector ‘v_Src’ from a single block
starting at address ‘v_Addr’. The address must be oword (16-
byte) aligned. The total size of the vector must be 1, 2, 4 or 8
owords (16, 32, 64 or 128 bytes).</p>
</div>
<div class="section" id="cm-svm-block-read-unaligned">
<h4>cm_svm_block_read_unaligned<a class="headerlink" href="#cm-svm-block-read-unaligned" title="Permalink to this headline">¶</a></h4>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">cm_svm_block_read_unaligned</span><span class="p">(</span><span class="n">svmptr_t</span> <span class="n">v_Addr</span><span class="p">,</span> <span class="n">vector_ref</span><span class="o">&lt;</span><span class="n">TYPE</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">v_Src</span><span class="p">);</span>
</pre></div>
</div>
<p>Read N data elements (byte, word, dword, qword, total data
size up to 128 bytes) into the vector ‘v_Src’ from a single block
starting at address ‘v_Addr’. The address must be dword (4-
byte) aligned. The total size of the vector must be 1, 2, 4 or 8
owords (16, 32, 64 or 128 bytes).</p>
</div>
<div class="section" id="cm-svm-scatter-read">
<h4>cm_svm_scatter_read<a class="headerlink" href="#cm-svm-scatter-read" title="Permalink to this headline">¶</a></h4>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">cm_svm_scatter_read</span><span class="p">(</span><span class="n">vector_ref</span><span class="o">&lt;</span><span class="n">svmptr_t</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">v_Addr</span><span class="p">,</span> <span class="n">vector_ref</span><span class="o">&lt;</span><span class="n">TYPE</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">v_Src</span><span class="p">);</span>
</pre></div>
</div>
<p>(where N = 8):
Read 8 data elements (byte, dword, qword) into the vector
‘v_Src’ from the 8 addresses given in the vector ‘v_Addr’.</p>
</div>
<div class="section" id="cm-svm-block-write">
<h4>cm_svm_block_write<a class="headerlink" href="#cm-svm-block-write" title="Permalink to this headline">¶</a></h4>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">cm_svm_block_write</span><span class="p">(</span><span class="n">svmptr_t</span>  <span class="n">v_Addr</span><span class="p">,</span> <span class="n">vector_ref</span><span class="o">&lt;</span><span class="n">TYPE</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">v_Src</span><span class="p">);</span>
</pre></div>
</div>
<p>Write N data elements (byte, word, dword, qword, total data
size up to 128 bytes) given in the vector ‘v_Src’ as a single block
starting at address ‘v_Addr’. The address must be oword (16-
byte) aligned. The total size of the vector must be 1, 2, 4 or 8
owords (16, 32, 64 or 128 bytes).</p>
</div>
<div class="section" id="cm-svm-scatter-write">
<h4>cm_svm_scatter_write<a class="headerlink" href="#cm-svm-scatter-write" title="Permalink to this headline">¶</a></h4>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">cm_svm_scatter_write</span><span class="p">(</span><span class="n">vector_ref</span><span class="o">&lt;</span><span class="n">svmptr_t</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">v_Addr</span><span class="p">,</span> <span class="n">vector_ref</span><span class="o">&lt;</span><span class="n">TYPE</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">v_Src</span><span class="p">);</span>
</pre></div>
</div>
<p>(where N = 8):
Write 8 data elements (byte, dword, qword) given in the vector
‘v_Src’ to the 8 addresses given in the vector ‘v_Addr’.</p>
<p>Note: Writes to overlapping addresses will have undefined
write ordering.</p>
</div>
<div class="section" id="cm-svm-atomic">
<h4>cm_svm_atomic<a class="headerlink" href="#cm-svm-atomic" title="Permalink to this headline">¶</a></h4>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">cm_svm_atomic</span><span class="p">(</span>
    <span class="n">CmAtomicOpType</span> <span class="n">aop</span><span class="p">,</span>
    <span class="n">vector_ref</span><span class="o">&lt;</span><span class="n">svmptr_t</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">v_Addr</span><span class="p">,</span>
    <span class="n">vector_ref</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">v_Dst</span><span class="p">,</span>
    <span class="n">vector_ref</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">v_Src0</span><span class="p">,</span>
    <span class="n">vector_ref</span><span class="o">&lt;</span><span class="n">T</span><span class="p">.</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">v_Src1</span><span class="p">);</span>
</pre></div>
</div>
<p>Where:</p>
<ul class="simple">
<li>v_Src0 and v_Src1 are
optional and are needed based on
the atomic operation ‘aop’.</li>
<li>N is 8.</li>
<li>v_Src0 and v_Src1 both are needed
when ‘aop’ is ATOMIC_CMPXCHG.
No sources needed when ‘aop’ is
ATOMIC_INC, ATOMIC_DEC, AND
ATOMIC_PREDEC.
For all other atomic operations, only
one source v_Src0 is needed.</li>
<li>‘aop’ specifies the atomic operation.
It has to be a compile-time constant.</li>
</ul>
<p>This causes atomic read-modify-write operations on the
destination locations addressed.
The destination locations are given in ‘v_Addr’ and the desired
atomic operation is specified as ‘aop’. The value returned in
‘v_Dst’ depends on the atomic operation. Whether the two
optional sources, ‘v_Src0’ and ‘v_Src1’, are needed also
depends on the atomic operation.</p>
</div>
</div>
<div class="section" id="preprocessor-directives">
<h3><a class="toc-backref" href="#id67">4.19 Preprocessor Directives</a><a class="headerlink" href="#preprocessor-directives" title="Permalink to this headline">¶</a></h3>
<p>Currently CM supports the following preprocessor directives (pragmas):</p>
<div class="section" id="pragma-unroll-n">
<h4>#pragma unroll (n)<a class="headerlink" href="#pragma-unroll-n" title="Permalink to this headline">¶</a></h4>
<p>This pragma may be specified immediately before a loop to instruct the CM compiler to unroll a loop
for n times. The CM compiler may still not unroll the loop due to lack of resource.</p>
</div>
<div class="section" id="pragma-unroll">
<h4>#pragma unroll<a class="headerlink" href="#pragma-unroll" title="Permalink to this headline">¶</a></h4>
<p>This pragma may be specified immediately before a loop to instruct the CM compiler to completely
unroll a loop. The CM compiler may not unroll the loop due to lack of resources.</p>
</div>
<div class="section" id="pragma-cm-nonstrict">
<h4>#pragma cm_nonstrict<a class="headerlink" href="#pragma-cm-nonstrict" title="Permalink to this headline">¶</a></h4>
<p>Note that the <code class="docutils literal"><span class="pre">cm_nonstrict</span></code> pragma is deprecated by the cmc compiler, as when it is appropriate
cmc will implicitly use a narrower integer type whenever that is guaranteed not to change the result
of a computation.
For situations where a narrower integer type is not guaranteed to produce the correct answer but the
data values are known to be such that incorrect results won’t be generated, or where incorrect results
are acceptable, explicit casts can be added to force the desired integer width.</p>
<p>The following description therefore applies to cm-icl only.</p>
<p>This pragma may be applied to either an instruction or a block.  For the immediately following
statement or block, CM compiler behaves differently from the standard C/C++ language rules.  Instead of
following the rules of usual arithmetic conversions to find a common real type for the integer operands,
the intermediate results will take the type of the destination variable in the original CM statement.
Floating-point types are not affected by the pragma, and the standard rules of usual arithmetic
conversions will be followed if any of the operands have floating-point type.  Here is an example:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="cp">#define PAARM_LEVEL2 255</span>

  <span class="n">matrix</span><span class="o">&lt;</span><span class="kt">short</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">16</span><span class="o">&gt;</span> <span class="n">tempBuffer</span><span class="p">;</span>
  <span class="n">matrix</span><span class="o">&lt;</span><span class="kt">short</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">16</span><span class="o">&gt;</span> <span class="n">left</span><span class="p">;</span>
  <span class="n">matrix</span><span class="o">&lt;</span><span class="kt">short</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">16</span><span class="o">&gt;</span> <span class="n">right</span><span class="p">;</span>
  <span class="n">matrix</span><span class="o">&lt;</span><span class="kt">short</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">16</span><span class="o">&gt;</span> <span class="n">top</span><span class="p">;</span>
  <span class="n">matrix</span><span class="o">&lt;</span><span class="kt">short</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">16</span><span class="o">&gt;</span> <span class="n">bot</span><span class="p">;</span>
  <span class="c1">// ...</span>

  <span class="cp">#pragma cm_nonstrict</span>
  <span class="n">tempBuffer</span> <span class="o">=</span> <span class="p">(</span><span class="n">PAARM_LEVEL2</span> <span class="o">*</span> <span class="n">left</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">PAARM_LEVEL2</span> <span class="o">*</span> <span class="n">right</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">PAARM_LEVEL2</span> <span class="o">*</span> <span class="n">top</span><span class="p">)</span> <span class="o">+</span>
  <span class="p">(</span><span class="n">PAARM_LEVEL2</span> <span class="o">*</span> <span class="n">bot</span> <span class="p">);</span>
</pre></div>
</div>
<p>Without the <code class="docutils literal"><span class="pre">cm_nonstrict</span></code> pragma, the intermediate results (e.g., (PAARM_LEVEL2 * left)) will have “int” type
due to integer promotion; with the pragma, they will have “short” type, which is the type of the
tempBuffer variable.</p>
<p>The <code class="docutils literal"><span class="pre">cm_nonstrict</span></code> pragma typically produces better code as it allows the compiler to eliminate type conversion
moves and use a narrower integer type for computation.  It is the user’s responsibility, however, to
ensure that program is still correct when the pragma is applied.  For example:</p>
<ul>
<li><p class="first">Data size assumption:</p>
<div class="line-block">
<div class="line">matrix&lt;uchar, 4, 16&gt; fbitmap1;</div>
<div class="line">matrix&lt;uchar, 4, 16&gt; Lval;</div>
<div class="line">matrix&lt;short, 4, 16&gt; Hval;</div>
<div class="line">fbitmap1 = (Lval * (128 - opacity) +  Hval * opacity) &gt;&gt; 7;</div>
</div>
<p>There is an assumption that the intermediate result of (Lval * (128 - opacity) +  Hval * opacity) is
at least a short, such that we can get a char after the shift operation. In this case the user should add an
explicit intermediate result to preserve this short intermediate data type when applying the <code class="docutils literal"><span class="pre">cm_nonstrict</span></code>
pragma:</p>
</li>
</ul>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="cp">#pragma cm_nonstrict</span>
<span class="p">{</span>
  <span class="n">matrix</span><span class="o">&lt;</span><span class="kt">short</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">16</span><span class="o">&gt;</span> <span class="n">temp_matrix</span> <span class="o">=</span> <span class="p">(</span><span class="n">Lval</span> <span class="o">*</span> <span class="p">(</span><span class="mi">128</span> <span class="o">-</span> <span class="n">opacity</span><span class="p">)</span> <span class="o">+</span>  <span class="n">Hval</span> <span class="o">*</span> <span class="n">opacity</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">7</span><span class="p">;</span>
  <span class="n">fbitmap1</span> <span class="o">=</span> <span class="n">temp_matrix</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<ul>
<li><p class="first">Sign assumption:</p>
<div class="line-block">
<div class="line">char r;</div>
<div class="line">matrix&lt;unsigned char, 4, 8&gt; m1;</div>
<div class="line">r = cm_sum&lt;unsigned char&gt;(m1.select&lt;1, 1, 2, 1&gt;(2, 0)) &gt;&gt; 1;</div>
</div>
<p>Although the CM compiler can preserve the result data type of cm_sum to be
“unsigned char”, the first source operand used in the shift operation is
lowered to the data type of r, which is “char”. User should use a temporary
variable to preserve the data type of the first source of shift.</p>
</li>
</ul>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="cp">#pragma cm_nonstrict</span>
  <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">t</span> <span class="o">=</span> <span class="n">cm_sum</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m1</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
  <span class="n">r</span> <span class="o">=</span> <span class="n">t</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span> <span class="p">;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="rounding-mode-and-float-control-support">
<h3><a class="toc-backref" href="#id68">4.20 Rounding mode and float control support</a><a class="headerlink" href="#rounding-mode-and-float-control-support" title="Permalink to this headline">¶</a></h3>
<p>CM supports setting of floating point rounding mode and other floating point control on a per-kernel
basis. This is achieved by using the _GENX_FLOAT_CONTROL_ or _GENX_ROUNDING_MODE_ kernel
attributes. _GENX_FLOAT_CONTROL_ supports all control. _GENX_ROUNDING_MODE_ is a synonym for
_GENX_FLOAT_CONTROL_ and is retained for backward compatibility.</p>
<p>The values that the attribute can be set to are a subset of the following that can be OR’ed
together. The compiler will not enforce using mutually exclusive values (for instance 2 rounding
modes) and the results in this case may be undefined.</p>
<p>Valid values for the float control setting are as follows:</p>
<table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="75%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Attribute Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>CM_RTE</td>
<td>Set round to nearest even (default)</td>
</tr>
<tr class="row-odd"><td>CM_RTP</td>
<td>Set round towards +ve infinity</td>
</tr>
<tr class="row-even"><td>CM_RTN</td>
<td>Set round towards -ve infinity</td>
</tr>
<tr class="row-odd"><td>CM_RTZ</td>
<td>Set round towards zero</td>
</tr>
<tr class="row-even"><td>CM_DENORM_RTZ</td>
<td>Set all denorm setting to Flush To Zero (no denorms) (default)</td>
</tr>
<tr class="row-odd"><td>CM_DENORM_D_ALLOW</td>
<td>Set double to allow denorms</td>
</tr>
<tr class="row-even"><td>CM_DENORM_F_ALLOW</td>
<td>Set float to allow denorms</td>
</tr>
<tr class="row-odd"><td>CM_DENORM_HF_ALLOW</td>
<td>Set half to allow denorms</td>
</tr>
<tr class="row-even"><td>CM_DENORM_ALLOW</td>
<td>Set all float types (double, float, half) to allow denorms</td>
</tr>
<tr class="row-odd"><td>CM_FLOAT_MODE_IEEE</td>
<td>Set single float mode to IEEE (default)</td>
</tr>
<tr class="row-even"><td>CM_FLOAT_MODE_ALT</td>
<td>Set single float mode to ALT</td>
</tr>
</tbody>
</table>
<div class="section" id="round-to-even-rte-default">
<h4>Round to even (RTE) (default)<a class="headerlink" href="#round-to-even-rte-default" title="Permalink to this headline">¶</a></h4>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">_GENX_MAIN_</span> <span class="nf">_GENX_FLOAT_CONTROL_</span><span class="p">(</span><span class="n">CM_RTE</span><span class="p">)</span> <span class="kt">void</span> <span class="n">rte_kernel</span><span class="p">(</span><span class="n">SurfaceIndex</span> <span class="n">ExampleBuffer</span><span class="p">)</span> <span class="p">{</span>
<span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="round-to-positive-infinity-rtp">
<h4>Round to positive infinity (RTP)<a class="headerlink" href="#round-to-positive-infinity-rtp" title="Permalink to this headline">¶</a></h4>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">_GENX_MAIN_</span> <span class="nf">_GENX_FLOAT_CONTROL_</span><span class="p">(</span><span class="n">CM_RTP</span><span class="p">)</span> <span class="kt">void</span> <span class="n">rtp_kernel</span><span class="p">(</span><span class="n">SurfaceIndex</span> <span class="n">ExampleBuffer</span><span class="p">)</span> <span class="p">{</span>
<span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="round-to-negative-infinity-rtn">
<h4>Round to negative infinity (RTN)<a class="headerlink" href="#round-to-negative-infinity-rtn" title="Permalink to this headline">¶</a></h4>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">_GENX_MAIN_</span> <span class="nf">_GENX_FLOAT_CONTROL_</span><span class="p">(</span><span class="n">CM_RTN</span><span class="p">)</span> <span class="kt">void</span> <span class="n">rtn_kernel</span><span class="p">(</span><span class="n">SurfaceIndex</span> <span class="n">ExampleBuffer</span><span class="p">)</span> <span class="p">{</span>
<span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="round-to-zero-rtz">
<h4>Round to zero (RTZ)<a class="headerlink" href="#round-to-zero-rtz" title="Permalink to this headline">¶</a></h4>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">_GENX_MAIN_</span> <span class="nf">_GENX_FLOAT_CONTROL_</span><span class="p">(</span><span class="n">CM_RTZ</span><span class="p">)</span> <span class="kt">void</span> <span class="n">rtz_kernel</span><span class="p">(</span><span class="n">SurfaceIndex</span> <span class="n">ExampleBuffer</span><span class="p">)</span> <span class="p">{</span>
<span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="denorm-behaviour">
<h4>Denorm behaviour<a class="headerlink" href="#denorm-behaviour" title="Permalink to this headline">¶</a></h4>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">_GENX_MAIN_</span> <span class="nf">_GENX_FLOAT_CONTROL_</span><span class="p">(</span><span class="n">CM_DENORM_ALLOW</span><span class="p">)</span> <span class="kt">void</span> <span class="n">denorm_kernel</span><span class="p">(</span><span class="n">SurfaceIndex</span> <span class="n">ExampleBuffer</span><span class="p">)</span> <span class="p">{</span>
<span class="p">...</span>
<span class="p">}</span>
<span class="n">_GENX_MAIN_</span> <span class="nf">_GENX_FLOAT_CONTROL_</span><span class="p">(</span><span class="n">CM_DENORM_D_ALLOW</span> <span class="o">|</span> <span class="n">CM_DENORM_HF_ALLOW</span><span class="p">)</span> <span class="kt">void</span> <span class="n">denorm_d_hf_kernel</span><span class="p">(</span><span class="n">SurfaceIndex</span> <span class="n">ExampleBuffer</span><span class="p">)</span> <span class="p">{</span>
<span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="float-mode-behaviour">
<h4>Float mode behaviour<a class="headerlink" href="#float-mode-behaviour" title="Permalink to this headline">¶</a></h4>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">_GENX_MAIN_</span> <span class="nf">_GENX_FLOAT_CONTROL_</span><span class="p">(</span><span class="n">CM_FLOAT_MODE_IEEE</span><span class="p">)</span> <span class="kt">void</span> <span class="n">float_ieee_kernel</span><span class="p">(</span><span class="n">SurfaceIndex</span> <span class="n">ExampleBuffer</span><span class="p">)</span> <span class="p">{</span>
<span class="p">...</span>
<span class="p">}</span>
<span class="n">_GENX_MAIN_</span> <span class="nf">_GENX_FLOAT_CONTROL_</span><span class="p">(</span><span class="n">CM_FLOAT_MODE_ALT</span><span class="p">)</span> <span class="kt">void</span> <span class="n">float_alt_kernel</span><span class="p">(</span><span class="n">SurfaceIndex</span> <span class="n">ExampleBuffer</span><span class="p">)</span> <span class="p">{</span>
<span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="mixed-control-examples">
<h4>Mixed control examples<a class="headerlink" href="#mixed-control-examples" title="Permalink to this headline">¶</a></h4>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">_GENX_MAIN_</span> <span class="nf">_GENX_FLOAT_CONTROL_</span><span class="p">(</span><span class="n">CM_DENORM_F_ALLOW</span> <span class="o">|</span> <span class="n">CM_RTN</span><span class="p">)</span> <span class="kt">void</span> <span class="n">denorm_and_round_kernel</span><span class="p">(</span><span class="n">SurfaceIndex</span> <span class="n">ExampleBuffer</span><span class="p">)</span> <span class="p">{</span>
<span class="p">...</span>
<span class="p">}</span>
<span class="n">_GENX_MAIN_</span> <span class="nf">_GENX_FLOAT_CONTROL_</span><span class="p">(</span><span class="n">CM_DENORM_ALLOW</span> <span class="o">|</span> <span class="n">CM_RTN</span> <span class="o">|</span> <span class="n">CM_FLOAT_MODE_ALT</span><span class="p">)</span> <span class="kt">void</span> <span class="n">multiple_settings_kernel</span><span class="p">(</span><span class="n">SurfaceIndex</span> <span class="n">ExampleBuffer</span><span class="p">)</span> <span class="p">{</span>
<span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="miscellaneous-functions">
<h3><a class="toc-backref" href="#id69">4.21 Miscellaneous Functions</a><a class="headerlink" href="#miscellaneous-functions" title="Permalink to this headline">¶</a></h3>
<div class="section" id="cm-get-hwid">
<h4>cm_get_hwid<a class="headerlink" href="#cm-get-hwid" title="Permalink to this headline">¶</a></h4>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">uint</span> <span class="nf">cm_get_hwid</span><span class="p">();</span>
</pre></div>
</div>
<p>This intrinsic can be used to access the hardware thread id from register R0.</p>
</div>
</div>
</div>
<div class="section" id="cm-template-library">
<span id="cmtemplatelibrary"></span><h2><a class="toc-backref" href="#id70">5 CM Template Library</a><a class="headerlink" href="#cm-template-library" title="Permalink to this headline">¶</a></h2>
<p>The CM implementation also provides  a template library of functions.  Inclusion of the cm/cmtl.h header file
is required to make use of these functions.</p>
<p>The functions defined in cm/cmtl.h provide an implementation which has been defined to be as optimal as
possible for the CM language. In general, if a function exists in the CM Template Library it is advisable to
use it. To some extent this will also better enable code to cope with future variations and enhancements.</p>
<p>The CM Template Library uses a namespace to stop pollution of the global namespace as much as
possible. The namespace used for the CM Template Library is cmtl. Here is an example:</p>
<p>#include &lt;cm/cm.h&gt;
#include &lt;cm/cmtl.h&gt;</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">_GENX_MAIN_</span> <span class="kt">void</span> <span class="nf">my_func</span><span class="p">(</span><span class="n">SurfaceIndex</span> <span class="n">ibuf</span><span class="p">,</span> <span class="n">SurfaceIndex</span> <span class="n">obuf</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">matrix</span><span class="o">&lt;</span><span class="kt">short</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="o">&gt;</span> <span class="n">io</span><span class="p">;</span>
  <span class="n">cmtl</span><span class="o">::</span><span class="n">ReadBlock</span><span class="o">&lt;</span><span class="kt">short</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ibuf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">io</span><span class="p">);</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Some functions have not been fully integrated into the compiler regression suite and are marked as such
in the reference for each function with limited testing.</p>
<div class="section" id="i-o">
<h3><a class="toc-backref" href="#id71">5.1 I/O</a><a class="headerlink" href="#i-o" title="Permalink to this headline">¶</a></h3>
<p>A set of template functions to enhance the I/O routines.</p>
<div class="section" id="readblock">
<h4>5.1.1 ReadBlock<a class="headerlink" href="#readblock" title="Permalink to this headline">¶</a></h4>
<p>Read a pixel block.</p>
<p><strong>Description:</strong> Read a pixel block of size HEIGHT x WIDTH from a surface, all input are in pixel sizes. HEIGHT
and WIDTH can be any integer.</p>
<p>The function will deal with any border issues using border replication where necessary when the block
being read falls out of bounds of the input surface.</p>
<p><strong>Author:</strong> Dori Eldar, Noam Teomim (ReadBlock with border handling)</p>
<p><strong>Functions:</strong></p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">uint</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">uint</span> <span class="n">WIDTH</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">ReadBlock</span><span class="p">(</span><span class="n">SurfaceIndex</span> <span class="n">ibuf</span><span class="p">,</span>
                                                    <span class="kt">int</span> <span class="n">h_pix_pos</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v_pix_pos</span><span class="p">,</span>
                                                    <span class="n">matrix_ref</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="o">&gt;</span> <span class="n">block</span><span class="p">,</span>
                                                    <span class="n">uint</span> <span class="n">surfaceWidth</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">uint</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">uint</span> <span class="n">WIDTH</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">ReadBlock</span><span class="p">(</span><span class="n">SurfaceIndex</span> <span class="n">ibuf</span><span class="p">,</span>
                                                    <span class="n">CmBufferAttrib</span> <span class="n">buf_attrib</span><span class="p">,</span>
                                                    <span class="kt">int</span> <span class="n">h_pix_pos</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v_pix_pos</span><span class="p">,</span>
                                                    <span class="n">matrix_ref</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="o">&gt;</span> <span class="n">block</span><span class="p">,</span>
                                                    <span class="n">uint</span> <span class="n">surfaceWidth</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>T</td>
<td><p class="first">A type whose size is the same as the size of a single
surface pixel.</p>
<p>Example surface types and T values:</p>
<ul class="last simple">
<li>CM_SURFACE_FORMAT_A8, char</li>
<li>CM_SURFACE_FORMAT_V8U8, short</li>
<li>CM_SURFACE_FORMAT_A8R8G8B8, int</li>
</ul>
</td>
</tr>
<tr class="row-odd"><td>HEIGHT</td>
<td>Number of rows for the matrix</td>
</tr>
<tr class="row-even"><td>WIDTH</td>
<td>Number of columns</td>
</tr>
<tr class="row-odd"><td>ibuf</td>
<td>Surface index for input buffer</td>
</tr>
<tr class="row-even"><td>h_pix_pos</td>
<td>Horizontal offset in pixels</td>
</tr>
<tr class="row-odd"><td>v_pix_pos</td>
<td>Vertical offset in pixels</td>
</tr>
<tr class="row-even"><td>block</td>
<td>Ref to output matrix (matrix_ref only)</td>
</tr>
<tr class="row-odd"><td>surfaceWidth</td>
<td>Surface width in pixels. When set ReadBlock will properly
replicate pixels across the right hand side boundary for
non-dword aligned surfaces.</td>
</tr>
</tbody>
</table>
<p><strong>Example:</strong></p>
<div class="highlight-c++"><div class="highlight"><pre><span></span>  <span class="c1">// SurfaceIndex ibuf passed in as parameter</span>
  <span class="c1">// WIDTH and HEIGHT previously defined</span>
  <span class="c1">// surfWidth previously defined or passed as parameter</span>
  <span class="n">matrix</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="o">&gt;</span> <span class="n">block</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">get_thread_origin_x</span><span class="p">()</span> <span class="o">*</span> <span class="n">WIDTH</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">get_thread_origin_y</span><span class="p">()</span> <span class="o">*</span> <span class="n">HEIGHT</span><span class="p">;</span>

  <span class="c1">// Read without considering non-dword aligned surface and replication</span>
  <span class="n">cmtl</span><span class="o">::</span><span class="n">ReadBlock</span><span class="p">(</span><span class="n">ibuf</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">block</span><span class="p">.</span><span class="n">select_all</span><span class="p">());</span>

  <span class="c1">// Read taking into consideration non-dword aligned surfaces</span>
  <span class="n">cmtl</span><span class="o">::</span><span class="n">ReadBlock</span><span class="p">(</span><span class="n">ibuf</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">block</span><span class="p">.</span><span class="n">select_all</span><span class="p">(),</span> <span class="n">surfWidth</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="writeblock">
<h4>5.1.2 WriteBlock<a class="headerlink" href="#writeblock" title="Permalink to this headline">¶</a></h4>
<p>Write a pixel block.</p>
<p><strong>Description:</strong> Write a pixel block of size HEIGHT x WIDTH to a surface, all input are in pixel sizes. HEIGHT
and WIDTH can be any integer.</p>
<p>The function will deal correctly with any border issues</p>
<p><strong>Author:</strong> Dori Eldar</p>
<p><strong>Functions:</strong></p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">uint</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">uint</span> <span class="n">WIDTH</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">WriteBlock</span><span class="p">(</span><span class="n">SurfaceIndex</span> <span class="n">obuf</span><span class="p">,</span>
                                                     <span class="kt">int</span> <span class="n">h_pix_pos</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v_pix_pos</span><span class="p">,</span>
                                                     <span class="n">matrix_ref</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="o">&gt;</span> <span class="n">block</span><span class="p">);</span>
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>T</td>
<td><p class="first">A type whose size is the same as the size of a single
surface pixel.</p>
<p>Example surface types and T values:</p>
<ul class="last simple">
<li>CM_SURFACE_FORMAT_A8, char</li>
<li>CM_SURFACE_FORMAT_V8U8, short</li>
<li>CM_SURFACE_FORMAT_A8R8G8B8, int</li>
</ul>
</td>
</tr>
<tr class="row-odd"><td>HEIGHT</td>
<td>Number of rows for the matrix</td>
</tr>
<tr class="row-even"><td>WIDTH</td>
<td>Number of columns</td>
</tr>
<tr class="row-odd"><td>obuf</td>
<td>Surface index for output buffer</td>
</tr>
<tr class="row-even"><td>h_pix_pos</td>
<td>Horizontal offset in pixels</td>
</tr>
<tr class="row-odd"><td>v_pix_pos</td>
<td>Vertical offset in pixels</td>
</tr>
<tr class="row-even"><td>block</td>
<td>Ref to matrix to write out to surface (matrix_ref only)</td>
</tr>
</tbody>
</table>
<p><strong>Example:</strong></p>
<div class="highlight-c++"><div class="highlight"><pre><span></span>  <span class="c1">// SurfaceIndex obuf passed in as parameter</span>
  <span class="c1">// WIDTH and HEIGHT previously defined</span>
 
  <span class="n">matrix</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="o">&gt;</span> <span class="n">block</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">get_thread_origin_x</span><span class="p">()</span> <span class="o">*</span> <span class="n">WIDTH</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">get_thread_origin_y</span><span class="p">()</span> <span class="o">*</span> <span class="n">HEIGHT</span><span class="p">;</span>

  <span class="c1">// Some work to put some relevant values into block</span>
  <span class="c1">// ...</span>

  <span class="c1">// Write block to output surface</span>
  <span class="n">cmtl</span><span class="o">::</span><span class="n">WriteBlock</span><span class="p">(</span><span class="n">obuf</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">block</span><span class="p">.</span><span class="n">select_all</span><span class="p">());</span>
</pre></div>
</div>
</div>
<div class="section" id="readlinear">
<h4>5.1.3 ReadLinear<a class="headerlink" href="#readlinear" title="Permalink to this headline">¶</a></h4>
<p>Read a vector from a linear buffer.</p>
<p><strong>Description:</strong> Read a pixel vector of size WIDTH from a linear buffer. WIDTH can be any integer.</p>
<p><strong>Author:</strong> Dori Eldar</p>
<p><strong>Functions:</strong></p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">uint</span> <span class="n">WIDTH</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">ReadLinear</span><span class="p">(</span><span class="n">SurfaceIndex</span> <span class="n">ibuf</span><span class="p">,</span>
                                        <span class="kt">int</span> <span class="n">pix_pos</span><span class="p">,</span>
                                        <span class="n">vector_ref</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">WIDTH</span><span class="o">&gt;</span> <span class="n">block</span><span class="p">);</span>
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>T</td>
<td><p class="first">A type whose size is the same as the size of a single
surface pixel.</p>
<p class="last">Example surface types and T values:
* CM_SURFACE_FORMAT_A8, char
* CM_SURFACE_FORMAT_V8U8, short
* CM_SURFACE_FORMAT_A8R8G8B8, int</p>
</td>
</tr>
<tr class="row-odd"><td>WIDTH</td>
<td>Number of elements</td>
</tr>
<tr class="row-even"><td>Ibuf</td>
<td>Surface index for input buffer</td>
</tr>
<tr class="row-odd"><td>pix_pos</td>
<td>Offset in pixels</td>
</tr>
<tr class="row-even"><td>Block</td>
<td>Ref to vector to read from surface (vector_ref only)</td>
</tr>
</tbody>
</table>
<p><strong>Example:</strong></p>
<div class="highlight-c++"><div class="highlight"><pre><span></span>  <span class="c1">// SurfaceIndex ibuf passed in as parameter</span>
  <span class="c1">// WIDTH previously defined</span>

  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">WIDTH</span><span class="o">&gt;</span> <span class="n">block</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">get_thread_origin_x</span><span class="p">()</span> <span class="o">*</span> <span class="n">WIDTH</span><span class="p">;</span>

  <span class="c1">// Read block from input surface</span>
  <span class="n">cmtl</span><span class="o">::</span><span class="n">ReadLinear</span><span class="p">(</span><span class="n">ibuf</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">block</span><span class="p">.</span><span class="n">select_all</span><span class="p">());</span>
</pre></div>
</div>
</div>
<div class="section" id="writelinear">
<h4>5.1.4 WriteLinear<a class="headerlink" href="#writelinear" title="Permalink to this headline">¶</a></h4>
<p>Write a vector to a linear buffer.</p>
<p><strong>Description:</strong> Write a pixel vector of size WIDTH to a linear buffer. WIDTH can be any integer.</p>
<p><strong>Author:</strong> Dori Eldar</p>
<p><strong>Functions:</strong></p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">uint</span> <span class="n">WIDTH</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">WriteLinear</span><span class="p">(</span><span class="n">SurfaceIndex</span> <span class="n">obuf</span><span class="p">,</span>
                                         <span class="kt">int</span> <span class="n">pix_pos</span><span class="p">,</span>
                                         <span class="n">vector_ref</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">WIDTH</span><span class="o">&gt;</span> <span class="n">block</span><span class="p">);</span>
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>T</td>
<td><p class="first">A type whose size is the same as the size of a single
surface pixel.</p>
<p>Example surface types and T values:</p>
<ul class="last simple">
<li>CM_SURFACE_FORMAT_A8, char</li>
<li>CM_SURFACE_FORMAT_V8U8, short</li>
<li>CM_SURFACE_FORMAT_A8R8G8B8, int</li>
</ul>
</td>
</tr>
<tr class="row-odd"><td>WIDTH</td>
<td>Number of elements</td>
</tr>
<tr class="row-even"><td>Obuf</td>
<td>Surface index for input buffer</td>
</tr>
<tr class="row-odd"><td>pix_pos</td>
<td>Offset in pixels</td>
</tr>
<tr class="row-even"><td>Block</td>
<td>Ref to vector to write to surface (vector_ref only)</td>
</tr>
</tbody>
</table>
<p><strong>Example:</strong></p>
<div class="highlight-c++"><div class="highlight"><pre><span></span>  <span class="c1">// SurfaceIndex obuf passed in as parameter</span>
  <span class="c1">// WIDTH previously defined</span>
 
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">WIDTH</span><span class="o">&gt;</span> <span class="n">block</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">get_thread_origin_x</span><span class="p">()</span> <span class="o">*</span> <span class="n">WIDTH</span><span class="p">;</span>

  <span class="c1">// Some work to put some relevant values into block</span>
  <span class="c1">// ...</span>

  <span class="c1">// Write block to output surface</span>
  <span class="n">cmtl</span><span class="o">::</span><span class="n">WriteLinear</span><span class="p">(</span><span class="n">obuf</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">block</span><span class="p">.</span><span class="n">select_all</span><span class="p">());</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="vectorization">
<h3><a class="toc-backref" href="#id72">5.2 Vectorization</a><a class="headerlink" href="#vectorization" title="Permalink to this headline">¶</a></h3>
<div class="section" id="vectorize2dkrnl">
<h4>5.2.1 Vectorize2DKRNL<a class="headerlink" href="#vectorize2dkrnl" title="Permalink to this headline">¶</a></h4>
</div>
<div class="section" id="dto1d">
<h4>5.2.2 _2Dto1D<a class="headerlink" href="#dto1d" title="Permalink to this headline">¶</a></h4>
</div>
</div>
<div class="section" id="slm">
<h3><a class="toc-backref" href="#id73">5.3 SLM</a><a class="headerlink" href="#slm" title="Permalink to this headline">¶</a></h3>
<p>NOTE: These routines are not ready for general use at the moment (but are documented here for future
inclusion)</p>
<div class="section" id="dumpslm">
<h4>5.3.1 DumpSLM<a class="headerlink" href="#dumpslm" title="Permalink to this headline">¶</a></h4>
<p>Limited testing</p>
<p>Dump content of SLM to memory</p>
<p><strong>Description:</strong> Dump the contents of SLM to memory. This is primarily intended as a debugging tool. Note:
this routine is not ready for general use at the moment.</p>
<p><strong>Author:</strong> Aharon Robbins, Liron Atedgi</p>
<p><strong>Functions:</strong></p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">DumpSLM</span><span class="p">(</span><span class="n">uint</span> <span class="n">slmX</span><span class="p">,</span> <span class="n">SurfaceIndex</span> <span class="n">slmDebugSurface</span><span class="p">,</span> <span class="n">uint</span> <span class="n">size</span><span class="p">);</span>
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>slmX</td>
<td>SLM handle</td>
</tr>
<tr class="row-odd"><td>slmDebugSurface</td>
<td>Linear surface in which to dump contents of SLM</td>
</tr>
<tr class="row-even"><td>Size</td>
<td>Number of bytes to dump</td>
</tr>
</tbody>
</table>
<p><strong>Example:</strong></p>
<div class="highlight-c++"><div class="highlight"><pre><span></span>  <span class="c1">// SurfaceIndex slmDebugSurface passed in as parameter</span>
  <span class="c1">// slmX handle is allocated here assuming cm_slm_init etc already done</span>
  <span class="c1">// elsewhere</span>
  <span class="c1">// SLM_BUFFER_SIZE defined elsewhere</span>

  <span class="n">uint</span> <span class="n">slmX</span> <span class="o">=</span> <span class="n">cm_slm_alloc</span><span class="p">(</span><span class="n">SLM_BUFFER_SIZE</span><span class="p">);</span>

  <span class="c1">// Some work to put some relevant values into SLM</span>
  <span class="c1">// ...</span>

  <span class="c1">// Dump SLM to memory</span>
  <span class="c1">// In this case we&#39;re dumping the whole of the allocated buffer</span>
  <span class="n">cmtl</span><span class="o">::</span><span class="n">DumpSLM</span><span class="p">(</span><span class="n">slmX</span><span class="p">,</span> <span class="n">slmDebugSurface</span><span class="p">,</span> <span class="n">SLM_BUFFER_SIZE</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="transposefromslm">
<h4>5.3.2 TransposeFromSLM<a class="headerlink" href="#transposefromslm" title="Permalink to this headline">¶</a></h4>
<p>Limited testing</p>
<p>Transpose from SLM</p>
<p><strong>Description:</strong> Transpose from SLM. Note: this routine is not ready for general use at the moment.</p>
<p><strong>Author:</strong> Aharon Robbins, Liron Atedgi</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="n">uint</span> <span class="n">N</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">TransposeFromSLM</span><span class="p">(</span><span class="n">vector_ref</span><span class="o">&lt;</span><span class="n">uint</span><span class="p">,</span> <span class="n">N</span><span class="o">*</span><span class="mi">4</span><span class="o">&gt;</span> <span class="n">dst</span><span class="p">,</span>
                                        <span class="n">vector_ref</span><span class="o">&lt;</span><span class="n">uint</span><span class="p">,</span> <span class="n">N</span><span class="o">*</span><span class="mi">4</span><span class="o">&gt;</span> <span class="n">src</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="transposetoslm">
<h4>5.3.3 TransposeToSLM<a class="headerlink" href="#transposetoslm" title="Permalink to this headline">¶</a></h4>
<p>Limited testing</p>
<p>Transpose to SLM</p>
<p><strong>Description:</strong> Transpose to SLM. Note: this routine is not ready for general use at the moment.</p>
<p><strong>Author:</strong> Aharon Robbins, Liron Atedgi</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="n">uint</span> <span class="n">N</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">TransposeToSLM</span><span class="p">(</span><span class="n">vector_ref</span><span class="o">&lt;</span><span class="n">uint</span><span class="p">,</span> <span class="n">N</span><span class="o">*</span><span class="mi">4</span><span class="o">&gt;</span> <span class="n">dst</span><span class="p">,</span>
                                      <span class="n">vector_ref</span><span class="o">&lt;</span><span class="n">uint</span><span class="p">,</span> <span class="n">N</span><span class="o">*</span><span class="mi">4</span><span class="o">&gt;</span> <span class="n">src</span><span class="p">);</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="iselect">
<h3><a class="toc-backref" href="#id74">5.4 Iselect</a><a class="headerlink" href="#iselect" title="Permalink to this headline">¶</a></h3>
<p>The following templates can be used to pack two small data elements into a single larger data element.
This is useful when one needs  to simultaneously update multiple matrices through iselect. As iselect is a
SIMD-1 for left hand side assignment.</p>
<div class="section" id="pack">
<h4>5.4.1 Pack<a class="headerlink" href="#pack" title="Permalink to this headline">¶</a></h4>
<p>Limited testing</p>
<p>Pack 2 “small” elements into a single double sized element</p>
<p><strong>Description:</strong>  Use this as part of iselect optimization, see example for more info. Typically packing would
be:</p>
<ul class="simple">
<li>uchar/char -&gt; ushort</li>
<li>short/ushort -&gt; uint</li>
<li>int/uint -&gt; double</li>
</ul>
<p>Pack into double is supported on HSW+</p>
<p><strong>Author:</strong> Dori Eldar</p>
<p><strong>Functions:</strong></p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="n">Tpackd</span><span class="p">,</span> <span class="n">Tcompst</span><span class="p">,</span> <span class="n">uint</span> <span class="n">WD</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">Pack</span><span class="p">(</span><span class="n">vector_ref</span><span class="o">&lt;</span><span class="n">Tpackd</span><span class="p">,</span> <span class="n">WD</span><span class="o">&gt;</span> <span class="n">src1</span><span class="p">,</span> <span class="n">vector_ref</span><span class="o">&lt;</span><span class="n">Tpackd</span><span class="p">,</span> <span class="n">WD</span><span class="o">&gt;</span> <span class="n">src2</span><span class="p">,</span>
          <span class="n">vector_ref</span><span class="o">&lt;</span><span class="n">Tcompst</span><span class="p">,</span> <span class="n">WD</span><span class="o">&gt;</span> <span class="n">dst</span><span class="p">);</span>
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Parameters</td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Tpackd</dt>
<dd>Data type of the 2 sources</dd>
<dt>Tcompst</dt>
<dd>Data  type of output sizeof(Tcompst) = 2sizeof(Tpackd)</dd>
<dt>WD</dt>
<dd>WIDTH of data vectors</dd>
<dt>src1</dt>
<dd>First source vector</dd>
<dt>src2</dt>
<dd>Second source vector</dd>
<dt>Dst</dt>
<dd>Destination composite vector</dd>
</dl>
</div>
<div class="section" id="unpack">
<h4>5.4.2 Unpack<a class="headerlink" href="#unpack" title="Permalink to this headline">¶</a></h4>
<p>Limited testing
UnPack a compisite element previously generated through Pack(), into 2 elements</p>
<p><strong>Description:</strong>  Use this as part of iselect optimization. Typically packing would be:</p>
<ul class="simple">
<li>uchar/char -&gt; ushort</li>
<li>short/ushort -&gt; uint</li>
<li>int/uint -&gt; double</li>
</ul>
<p>Pack into double is supported on HSW+</p>
<p><strong>Author:</strong> Dori Eldar</p>
<p><strong>Functions:</strong></p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="n">Tpackd</span><span class="p">,</span> <span class="n">Tcompst</span><span class="p">,</span> <span class="n">uint</span> <span class="n">WD</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">UnPack</span><span class="p">(</span><span class="n">vector_ref</span><span class="o">&lt;</span><span class="n">Tpackd</span><span class="p">,</span> <span class="n">WD</span><span class="o">&gt;</span> <span class="n">dst1</span><span class="p">,</span> <span class="n">vector_ref</span><span class="o">&lt;</span><span class="n">Tpackd</span><span class="p">,</span> <span class="n">WD</span><span class="o">&gt;</span> <span class="n">dst2</span><span class="p">,</span>
            <span class="n">vector_ref</span><span class="o">&lt;</span><span class="n">Tcompst</span><span class="p">,</span> <span class="n">WD</span><span class="o">&gt;</span> <span class="n">src</span><span class="p">);</span>
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tpackd</td>
<td>Data type of the 2 sources</td>
</tr>
<tr class="row-odd"><td>Tcompst</td>
<td>Data  type of output sizeof(Tcompst) = 2sizeof(Tpackd)</td>
</tr>
<tr class="row-even"><td>WD</td>
<td>WIDTH of data vectors</td>
</tr>
<tr class="row-odd"><td>src</td>
<td>Source Composite vector</td>
</tr>
<tr class="row-even"><td>dst1</td>
<td>First destination vector,  corresponding  to first source
provided to Pack()</td>
</tr>
<tr class="row-odd"><td>dst2</td>
<td>Second destination vector, corresponding  to second source
provided to Pack()</td>
</tr>
</tbody>
</table>
<p>Example:
See the example for Pack</p>
</div>
<div class="section" id="unpacksingle">
<h4>5.4.3 UnpackSingle<a class="headerlink" href="#unpacksingle" title="Permalink to this headline">¶</a></h4>
<p>Limited testing</p>
<p>UnPack a composite element previously generated through Pack(), return only 1 of the 2 elements</p>
<p><strong>Description:</strong>  Use this as part of iselect optimization, Use this API, instead of Unpack, when only 1 element
is required. Typically packing would be:</p>
<ul class="simple">
<li>uchar/char -&gt; ushort</li>
<li>short/ushort -&gt; uint</li>
<li>int/uint -&gt; double</li>
</ul>
<p>Pack into double is supported on HSW+</p>
<p><strong>Author:</strong> Dori Eldar</p>
<p><strong>Functions:</strong></p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="cp">#define CMRT_LOC_FIRST 0</span>
<span class="cp">#define CMRT_LOC_SECOND 1</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="n">Tpackd</span><span class="p">,</span> <span class="n">Tcompst</span><span class="p">,</span> <span class="n">uint</span> <span class="n">WD</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">UnpackSingle</span><span class="p">(</span><span class="n">vector_ref</span><span class="o">&lt;</span><span class="n">Tpackd</span><span class="p">,</span> <span class="n">WD</span><span class="o">&gt;</span> <span class="n">dst</span><span class="p">,</span> <span class="kt">int</span> <span class="n">location</span><span class="p">,</span> <span class="n">vector_ref</span><span class="o">&lt;</span><span class="n">Tcompst</span><span class="p">,</span> <span class="n">WD</span><span class="o">&gt;</span> <span class="n">src</span><span class="p">);</span>
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Tpackd</td>
<td>Data type of the 2 sources</td>
</tr>
<tr class="row-odd"><td>Tcompst</td>
<td>Data  type of output sizeof(Tcompst) = 2sizeof(Tpackd)</td>
</tr>
<tr class="row-even"><td>WD</td>
<td>WIDTH of data vectors</td>
</tr>
<tr class="row-odd"><td>Src</td>
<td>Source Composite vector</td>
</tr>
<tr class="row-even"><td>Dst</td>
<td>destination packed element vector</td>
</tr>
<tr class="row-odd"><td>Location</td>
<td><p class="first">Indicates which packed vector to retrieve, either
CMRT_LOC_FIRST or CMRT_LOC_SECOND should be returned.</p>
<p class="last">The order of vectors is based on the order provided to Pack
from left to right,
e.g.
| Pack(src1,src,2,dst)
| UnpackSingle(dst, src, CMRT_LOC_FIRST)
| Will set src  with values from src1</p>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="cachedstack">
<h3><a class="toc-backref" href="#id75">5.5 CachedStack</a><a class="headerlink" href="#cachedstack" title="Permalink to this headline">¶</a></h3>
<p>A Cached Stack object represents Multi-Channel (SIMD) Stacks, (optionally) stored in a host memory
buffer, with the elements of the stack cached in GRF. The fundamental functionality provided by a Stack
object are:</p>
<ul class="simple">
<li>Push() – add an element to top of stack</li>
<li>Pop()  - extract top element from Stack</li>
<li>Top()  - read the top element  without extracting it.</li>
</ul>
<div class="section" id="cachedstackinit">
<h4>5.5.1 CachedStackInit<a class="headerlink" href="#cachedstackinit" title="Permalink to this headline">¶</a></h4>
<p>Limited testing</p>
<p><strong>Description:</strong>
Initializes a CachedStack Object</p>
<p><strong>Author:</strong> Dori Eldar</p>
<p><strong>Functions:</strong></p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">uint</span> <span class="n">W</span><span class="p">,</span> <span class="n">uint</span> <span class="n">CACHESIZE</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">CachedStackInit</span><span class="p">(</span><span class="n">matrix_ref</span><span class="o">&lt;</span><span class="kt">short</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">W</span><span class="o">*</span><span class="n">STACKCOUNT</span><span class="o">&gt;</span> <span class="n">context</span><span class="p">,</span>
                     <span class="n">matrix_ref</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">W</span><span class="o">&gt;</span> <span class="n">context_ii</span><span class="p">,</span>
                     <span class="n">uint</span> <span class="n">MaxSize</span><span class="p">);</span>
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>CACHESIZE</td>
<td>Pixel Size of Stack cache stored in GRF, currently MUST be:
CACHESIZE *sizeof(T) % 128 == 0 (preferable for optimal IO)</td>
</tr>
<tr class="row-odd"><td>T</td>
<td>Type of elements stored in stack</td>
</tr>
<tr class="row-even"><td>W</td>
<td>Number of channels (SIMD) for an element on stack context,
Internally used by CachedStack to maintain cache pointers,
caller must not modify this parameter.</td>
</tr>
<tr class="row-odd"><td>context_ii</td>
<td>Internally used by CachedStack to maintain cache pointers,
caller must not modify this parameter.</td>
</tr>
<tr class="row-even"><td>MaxSize</td>
<td><p class="first">Maximum number of elements on stack for a single channel.
Caller must allocate the linear surface with:</p>
<p>size &gt;= MaxSize*NumThreads*W*Sizeof(T)</p>
<p class="last">Optimization note: MaxSize should be aligned to:
(CACHELINE / sizeof(T))  (CACHELINE = 64 bytes)</p>
</td>
</tr>
</tbody>
</table>
<p><strong>Example:</strong></p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;cm/cm.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cm/cmtl.h&gt;</span><span class="cp"></span>

<span class="cp">#define ALIGN_CACHELINE_SHORT(x) (((x) + 64 - 1) &amp; (~ (64 - 1)))</span>

<span class="n">_GENX_MAIN_</span> <span class="kt">void</span>
<span class="nf">CachedStackExample</span><span class="p">(</span><span class="n">SurfaceIndex</span> <span class="n">stack_surf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ImageHeight</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">ushort</span> <span class="n">x_pos</span> <span class="o">=</span> <span class="n">get_thread_origin_x</span><span class="p">()</span> <span class="o">*</span> <span class="n">SZ</span><span class="p">;</span>

    <span class="n">vector</span><span class="o">&lt;</span><span class="n">ushort</span><span class="p">,</span> <span class="mi">16</span><span class="o">&gt;</span> <span class="n">element</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">ushort</span><span class="p">,</span> <span class="mi">16</span><span class="o">&gt;</span> <span class="n">mask</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">aligned_image_hight</span> <span class="o">=</span> <span class="n">ALIGN_CACHELINE_SHORT</span><span class="p">(</span><span class="n">ImageHeight</span><span class="p">);</span>

    <span class="n">CachedStackInit</span><span class="o">&lt;</span><span class="n">uint</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="n">CACHESIZE</span><span class="o">&gt;</span><span class="p">(</span><span class="n">stack_context</span><span class="p">,</span>
                                         <span class="n">stack_context_ii</span><span class="p">,</span>
                                         <span class="n">aligned_image_height</span><span class="p">);</span>
    <span class="n">CachedStackPush</span><span class="o">&lt;</span><span class="n">uint</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="n">CACHESIZE</span><span class="o">&gt;</span><span class="p">(</span><span class="n">stack_surf</span><span class="p">,</span>
                                         <span class="n">stack_context</span><span class="p">,</span>
                                         <span class="n">stack_context_ii</span><span class="p">,</span>
                                         <span class="n">stack</span><span class="p">,</span> <span class="n">element</span><span class="p">);</span>

    <span class="n">CachedStackPop</span><span class="o">&lt;</span><span class="n">uint</span><span class="p">,</span> <span class="n">SIMD_SZ</span><span class="p">,</span> <span class="n">CACHESIZE</span><span class="o">&gt;</span><span class="p">(</span><span class="n">stack_surf</span><span class="p">,</span>
                                             <span class="n">stack_context</span><span class="p">,</span>
                                             <span class="n">stack_context_ii</span><span class="p">,</span> <span class="n">stack</span><span class="p">,</span>
                                             <span class="n">element</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="cachedstacktop">
<span id="id22"></span><h4>5.5.2 CachedStackTop<a class="headerlink" href="#cachedstacktop" title="Permalink to this headline">¶</a></h4>
<p>Limited testing</p>
<p><strong>Description:</strong>
Returns a vector containing top elements in the stack</p>
<p><strong>Author:</strong> Dori Eldar</p>
<p><strong>Functions:</strong></p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">uint</span> <span class="n">W</span><span class="p">,</span> <span class="n">uint</span> <span class="n">CACHESIZE</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">CachedStackTop</span><span class="p">(</span><span class="n">SurfaceIndex</span> <span class="n">surf</span><span class="p">,</span> <span class="n">matrix_ref</span><span class="o">&lt;</span><span class="kt">short</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">W</span><span class="o">&gt;</span> <span class="n">context</span><span class="p">,</span>
                    <span class="n">matrix_ref</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">W</span><span class="o">&gt;</span> <span class="n">context_ii</span><span class="p">,</span>
                    <span class="n">matrix_ref</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">CACHESIZE</span><span class="o">&gt;</span> <span class="n">stack</span><span class="p">,</span>
                    <span class="n">vector_ref</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="n">W</span><span class="o">&gt;</span> <span class="n">element</span><span class="p">);</span>
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>CACHESIZE</td>
<td>Pixel Size of Stack cache stored in GRF, currently MUST be:
CACHESIZE *sizeof(T) % 128 == 0 (preferable for optimal IO)</td>
</tr>
<tr class="row-odd"><td>T</td>
<td>Type of elements stored in stack</td>
</tr>
<tr class="row-even"><td>W</td>
<td>Number of channels (SIMD) for an element on stack</td>
</tr>
<tr class="row-odd"><td>Surf</td>
<td>Pointer to linear surface used for stack</td>
</tr>
<tr class="row-even"><td>Context</td>
<td>Internally used by CachedStack to maintain cache pointers,
caller must not modify this parameter.</td>
</tr>
<tr class="row-odd"><td>context_ii</td>
<td>Internally used by CachedStack to maintain cache pointers,
caller must not modify this parameter.</td>
</tr>
<tr class="row-even"><td>stack</td>
<td>User allocated stack cache</td>
</tr>
<tr class="row-odd"><td>Element</td>
<td>Returned top element vector</td>
</tr>
</tbody>
</table>
<p><strong>Example:</strong>
See example for CachedStackInit</p>
</div>
<div class="section" id="cachedstackpop">
<h4>5.5.3 CachedStackPop<a class="headerlink" href="#cachedstackpop" title="Permalink to this headline">¶</a></h4>
<p>Limited testing</p>
<p><strong>Description:</strong>
Conditionaly pop top elements from stack based on mask, for channels with a 0 mask pixel element is
returned to caller but not popped (see <a class="reference internal" href="#cachedstacktop"><span class="std std-ref">5.5.2 CachedStackTop</span></a>). Note: Caller must avoid Pop() over empty stack
channels. See example for details of how to avoid this.</p>
<p><strong>Author:</strong> Dori Eldar</p>
<p><strong>Functions:</strong></p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">uint</span> <span class="n">W</span><span class="p">,</span> <span class="n">uint</span> <span class="n">CACHESIZE</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">CachedStackPop</span><span class="p">(</span><span class="n">SurfaceIndex</span> <span class="n">surf</span><span class="p">,</span> <span class="n">matrix_ref</span><span class="o">&lt;</span><span class="kt">short</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">W</span><span class="o">&gt;</span> <span class="n">context</span><span class="p">,</span>
                    <span class="n">matrix_ref</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">W</span><span class="o">&gt;</span> <span class="n">context_ii</span><span class="p">,</span>
                    <span class="n">matrix_ref</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="n">W</span><span class="p">,</span> <span class="n">CACHESIZE</span><span class="o">&gt;</span> <span class="n">stack</span><span class="p">,</span>
                    <span class="n">vector_ref</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="n">W</span><span class="o">&gt;</span> <span class="n">element</span><span class="p">,</span>
                    <span class="n">vector_ref</span><span class="o">&lt;</span><span class="kt">short</span><span class="p">,</span><span class="n">W</span><span class="o">&gt;</span> <span class="n">mask</span><span class="p">);</span>
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="19%" />
<col width="81%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>CACHESIZE</td>
<td>Pixel Size of Stack cache stored in GRF, currently MUST be:
| CACHESIZE *sizeof(T) % 128 == 0 (preferable for optimal IO)</td>
</tr>
<tr class="row-odd"><td>T</td>
<td>Type of elements stored in stack</td>
</tr>
<tr class="row-even"><td>W</td>
<td>Number of channels (SIMD) for an element on stack</td>
</tr>
<tr class="row-odd"><td>Surf</td>
<td>Pointer to linear surface used for stack</td>
</tr>
<tr class="row-even"><td>Context</td>
<td>Internally used by CachedStack to maintain cache pointers,
caller must not modify this parameter.</td>
</tr>
<tr class="row-odd"><td>context_ii</td>
<td>Internally used by CachedStack to maintain cache pointers,
caller must not modify this parameter.</td>
</tr>
<tr class="row-even"><td>Stack</td>
<td>User allocated stack cache</td>
</tr>
<tr class="row-odd"><td>Element</td>
<td>Returned top element vector</td>
</tr>
<tr class="row-even"><td>Mask</td>
<td>A 0-1 mask indicating top elements to Pop() (mask = 1) vs
elements to Top() (mask = 0).  Note: currently only a 0,1
mask is supported, if mask contains other values behavior
will be undefined</td>
</tr>
</tbody>
</table>
<p><strong>Example:</strong></p>
<p>Note: Caller must avoid Pop() over empty stack channels. Caller can use CacheStackEmpty() to set a mask
to avoid this condition:</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>vector&lt;short, W&gt; isEmpty;
vector&lt;short, W&gt; appMask; CallerSetMask(mask);
CachedStackEmpty&lt;...&gt;(..., isEmpty);
mask |= (1-isEmpty);
CachedStackPop&lt;..&gt;(..., mask);
</pre></div>
</div>
</div>
<div class="section" id="cachedstackpush">
<h4>5.5.4 CachedStackPush<a class="headerlink" href="#cachedstackpush" title="Permalink to this headline">¶</a></h4>
<p>Limited testing</p>
<p><strong>Description:</strong>
Push a vector element to top of stack. Note: Caller must not push() over a full stack (top element at
MaxSize – 1)</p>
<p><strong>Author:</strong> Dori Eldar</p>
<p>Function:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">W</span><span class="p">,</span> <span class="kt">int</span> <span class="n">CACHESIZE</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">CachedStackPush</span><span class="p">(</span><span class="n">SurfaceIndex</span> <span class="n">surf</span><span class="p">,</span> <span class="n">matrix_ref</span><span class="o">&lt;</span><span class="kt">short</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">W</span><span class="o">&gt;</span> <span class="n">context</span><span class="p">,</span>
                     <span class="n">matrix_ref</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">W</span><span class="o">&gt;</span> <span class="n">context_ii</span>
                     <span class="n">matrix_ref</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">CACHESIZE</span><span class="o">&gt;</span> <span class="n">stack</span><span class="p">,</span>
                     <span class="n">vector_ref</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">W</span><span class="o">&gt;</span> <span class="n">element</span><span class="p">);</span>
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="19%" />
<col width="81%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>CACHESIZE</td>
<td>Pixel Size of Stack cache stored in GRF, currently MUST be:
| CACHESIZE *sizeof(T) % 128 == 0 (preferable for optimal IO)</td>
</tr>
<tr class="row-odd"><td>T</td>
<td>Type of elements stored in stack</td>
</tr>
<tr class="row-even"><td>W</td>
<td>Number of channels (SIMD) for an element on stack</td>
</tr>
<tr class="row-odd"><td>surf</td>
<td>Pointer to linear surface used for stack</td>
</tr>
<tr class="row-even"><td>context</td>
<td>Internally used by CachedStack to maintain cache pointers,
caller must not modify this parameter.</td>
</tr>
<tr class="row-odd"><td>context_ii</td>
<td>Internally used by CachedStack to maintain cache pointers,
caller must not modify this parameter.</td>
</tr>
<tr class="row-even"><td>stack</td>
<td>User allocated stack cache</td>
</tr>
<tr class="row-odd"><td>element</td>
<td>Returned top elements vector</td>
</tr>
</tbody>
</table>
<p><strong>Example:</strong>
See example for CachedStackInit</p>
</div>
<div class="section" id="cachedstackempty">
<h4>5.5.5 CachedStackEmpty<a class="headerlink" href="#cachedstackempty" title="Permalink to this headline">¶</a></h4>
<p>Limited testing</p>
<p><strong>Description:</strong>
Returns a per element mask if Stack is empty or not</p>
<p><strong>Author:</strong> Dori Eldar</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="n">uint</span> <span class="n">W</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">CachedStackEmpty</span><span class="p">(</span><span class="n">matrix_ref</span><span class="o">&lt;</span><span class="kt">short</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">W</span><span class="o">&gt;</span> <span class="n">context</span><span class="p">,</span>
                                       <span class="n">matrix_ref</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">W</span><span class="o">&gt;</span> <span class="n">context_ii</span><span class="p">,</span>
                                       <span class="n">vector_ref</span><span class="o">&lt;</span><span class="kt">short</span><span class="p">,</span> <span class="n">W</span><span class="o">&gt;</span> <span class="n">isEmpty</span><span class="p">);</span>
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>W</td>
<td>Number of channels (SIMD) for an element on stack</td>
</tr>
<tr class="row-odd"><td>context</td>
<td>Internally used by CachedStack to maintain cache pointers,
caller must not modify this parameter.</td>
</tr>
<tr class="row-even"><td>context_ii</td>
<td>Internally used by CachedStack to maintain cache pointers,
caller must not modify this parameter.</td>
</tr>
<tr class="row-odd"><td>isEmpty</td>
<td>0-1 mask,  1 Stack Empty 0 - Otherwise</td>
</tr>
</tbody>
</table>
<p><strong>Example:</strong>
See example for CachedStackPop</p>
</div>
</div>
<div class="section" id="matrix-transform">
<h3><a class="toc-backref" href="#id76">5.6 Matrix transform</a><a class="headerlink" href="#matrix-transform" title="Permalink to this headline">¶</a></h3>
<p>A series of functions (mainly for 16x16 matrices) to perform various rotation and mirror operations on
matrix_ref matrices.</p>
<div class="section" id="mirrorvertical">
<h4>5.6.1 MirrorVertical<a class="headerlink" href="#mirrorvertical" title="Permalink to this headline">¶</a></h4>
<p>Limited testing</p>
<p>Vertical mirror matrix transform</p>
<p><strong>Description:</strong> Perform a vertical mirror transformation on a matrix, transforming it to a different output
* - matrix</p>
<p><strong>Author:</strong> Danny Barash, Chaim Rand</p>
<p><strong>Functions:</strong></p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">uint</span> <span class="n">H</span><span class="p">,</span> <span class="n">uint</span> <span class="n">W</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">MirrorVertical</span><span class="p">(</span><span class="n">matrix_ref</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="n">H</span><span class="p">,</span><span class="n">W</span><span class="o">&gt;</span> <span class="n">in</span><span class="p">,</span> <span class="n">matrix_ref</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="n">H</span><span class="p">,</span><span class="n">W</span><span class="o">&gt;</span> <span class="n">out</span><span class="p">);</span>
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>T</td>
<td>The type of the matrix elements</td>
</tr>
<tr class="row-odd"><td>H</td>
<td>Height of the matrix (number of rows)</td>
</tr>
<tr class="row-even"><td>W</td>
<td>Width of the matrix (number of columns)</td>
</tr>
<tr class="row-odd"><td>in</td>
<td>The input matrix (matrix_ref&lt;T,H,W&gt;)</td>
</tr>
<tr class="row-even"><td>out</td>
<td>The output matrix (matrix_ref&lt;T,H,W&gt;)</td>
</tr>
</tbody>
</table>
<p><strong>Example:</strong></p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">matrix</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">16</span><span class="o">&gt;</span> <span class="n">test_matrix</span><span class="p">;</span>
<span class="c1">// Set up the values in test matrix in some way</span>
<span class="n">matrix</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">16</span><span class="o">&gt;</span> <span class="n">mirrored_test_matrix</span><span class="p">;</span>
<span class="n">cmtl</span><span class="o">::</span><span class="n">MirrorVertical</span><span class="p">(</span><span class="n">test_matrix</span><span class="p">.</span><span class="n">select_all</span><span class="p">(),</span> <span class="n">mirrored_test_matrix</span><span class="p">.</span><span class="n">select_all</span><span class="p">());</span>
</pre></div>
</div>
</div>
<div class="section" id="mirrorhorizontal-16x16">
<h4>5.6.2 MirrorHorizontal_16x16<a class="headerlink" href="#mirrorhorizontal-16x16" title="Permalink to this headline">¶</a></h4>
<p>Limited testing</p>
<p>Horizontal mirror for 16x16 matrix transform</p>
<p><strong>Description:</strong> Perform a horizontal mirror transformation on a 16x16 matrix, transforming it to a different
output matrix</p>
<p><strong>Author:</strong> Danny Barash, Chaim Rand</p>
<p><strong>Functions:</strong></p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">MirrorVertical</span><span class="p">(</span><span class="n">matrix_ref</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">16</span><span class="o">&gt;</span> <span class="n">in</span><span class="p">,</span> <span class="n">matrix_ref</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">16</span><span class="o">&gt;</span> <span class="n">out</span><span class="p">);</span>
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>T</td>
<td>The type of the matrix elements</td>
</tr>
<tr class="row-odd"><td>in</td>
<td>The input matrix (matrix_ref&lt;T,16,16&gt;)</td>
</tr>
<tr class="row-even"><td>out</td>
<td>The output matrix (matrix_ref&lt;T,16,16&gt;)</td>
</tr>
</tbody>
</table>
<p><strong>Example:</strong></p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">matrix</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="o">&gt;</span> <span class="n">test_matrix</span><span class="p">;</span>
<span class="c1">// Set up the values in test matrix in some way</span>
<span class="n">matrix</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="o">&gt;</span> <span class="n">mirrored_test_matrix</span><span class="p">;</span>
<span class="n">cmtl</span><span class="o">::</span><span class="n">MirrorHorizontal_16x16</span><span class="p">(</span><span class="n">test_matrix</span><span class="p">.</span><span class="n">select_all</span><span class="p">(),</span> <span class="n">mirrored_test_matrix</span><span class="p">.</span><span class="n">select_all</span><span class="p">());</span>
</pre></div>
</div>
</div>
<div class="section" id="rotate90-16x16">
<h4>5.6.3 Rotate90_16x16<a class="headerlink" href="#rotate90-16x16" title="Permalink to this headline">¶</a></h4>
<p>Limited testing</p>
<p>Rotate 90 clockwise for 16x16 matrix transform</p>
<p><strong>Description:</strong> Perform a 90 degree clockwise rotation transformation on a 16x16 matrix, transforming it to
a different output matrix</p>
<p><strong>Author:</strong> Danny Barash, Chaim Rand</p>
<p><strong>Functions:</strong></p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">Rotate90_16x16</span><span class="p">(</span><span class="n">matrix_ref</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">16</span><span class="o">&gt;</span> <span class="n">in</span><span class="p">,</span> <span class="n">matrix_ref</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">16</span><span class="o">&gt;</span> <span class="n">out</span><span class="p">);</span>
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>T</td>
<td>The type of the matrix elements</td>
</tr>
<tr class="row-odd"><td>in</td>
<td>The input matrix (matrix_ref&lt;T,16,16&gt;)</td>
</tr>
<tr class="row-even"><td>out</td>
<td>The output matrix (matrix_ref&lt;T,16,16&gt;)</td>
</tr>
</tbody>
</table>
<p><strong>Example:</strong></p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">matrix</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="o">&gt;</span> <span class="n">test_matrix</span><span class="p">;</span>
<span class="c1">// Set up the values in test matrix in some way</span>
<span class="n">matrix</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="o">&gt;</span> <span class="n">rotated_test_matrix</span><span class="p">;</span>
<span class="n">cmtl</span><span class="o">::</span><span class="n">Rotate90_16x16</span><span class="p">(</span><span class="n">test_matrix</span><span class="p">.</span><span class="n">select_all</span><span class="p">(),</span> <span class="n">rotated_test_matrix</span><span class="p">.</span><span class="n">select_all</span><span class="p">());</span>
</pre></div>
</div>
</div>
<div class="section" id="rotate270-16x16">
<h4>5.6.4 Rotate270_16x16<a class="headerlink" href="#rotate270-16x16" title="Permalink to this headline">¶</a></h4>
<p>Limited testing
Rotate 270 clockwise for 16x16 matrix transform</p>
<p><strong>Description:</strong> Perform a 270 degree clockwise rotation transformation on a 16x16 matrix, transforming it
to a different output matrix</p>
<p><strong>Author:</strong> Danny Barash, Chaim Rand</p>
<p><strong>Functions:</strong></p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">Rotate270_16x16</span><span class="p">(</span><span class="n">matrix_ref</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">16</span><span class="o">&gt;</span> <span class="n">in</span><span class="p">,</span> <span class="n">matrix_ref</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">16</span><span class="o">&gt;</span> <span class="n">out</span><span class="p">);</span>
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>T</td>
<td>The type of the matrix elements</td>
</tr>
<tr class="row-odd"><td>in</td>
<td>The input matrix (matrix_ref&lt;T,16,16&gt;)</td>
</tr>
<tr class="row-even"><td>out</td>
<td>The output matrix (matrix_ref&lt;T,16,16&gt;)</td>
</tr>
</tbody>
</table>
<p><strong>Example:</strong></p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">matrix</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="o">&gt;</span> <span class="n">test_matrix</span><span class="p">;</span>
<span class="c1">// Set up the values in test matrix in some way</span>
<span class="n">matrix</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="o">&gt;</span> <span class="n">rotated_test_matrix</span><span class="p">;</span>
<span class="n">cmtl</span><span class="o">::</span><span class="n">Rotate270_16x16</span><span class="p">(</span><span class="n">test_matrix</span><span class="p">.</span><span class="n">select_all</span><span class="p">(),</span> <span class="n">rotated_test_matrix</span><span class="p">.</span><span class="n">select_all</span><span class="p">());</span>
</pre></div>
</div>
</div>
<div class="section" id="rotate180-16x16">
<h4>5.6.5 Rotate180_16x16<a class="headerlink" href="#rotate180-16x16" title="Permalink to this headline">¶</a></h4>
<p>Limited testing</p>
<p>Rotate 180 for 16x16 matrix transform</p>
<p><strong>Description:</strong> Perform a 180 degree rotation transformation on a 16x16 matrix, transforming it to a
different output matrix</p>
<p><strong>Author:</strong> Danny Barash, Chaim Rand</p>
<p><strong>Functions:</strong></p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">Rotate180_16x16</span><span class="p">(</span><span class="n">matrix_ref</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">16</span><span class="o">&gt;</span> <span class="n">in</span><span class="p">,</span> <span class="n">matrix_ref</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">16</span><span class="o">&gt;</span> <span class="n">out</span><span class="p">);</span>
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>T</td>
<td>The type of the matrix elements</td>
</tr>
<tr class="row-odd"><td>in</td>
<td>The input matrix (matrix_ref&lt;T,16,16&gt;)</td>
</tr>
<tr class="row-even"><td>out</td>
<td>The output matrix (matrix_ref&lt;T,16,16&gt;)</td>
</tr>
</tbody>
</table>
<p><strong>Example:</strong></p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">matrix</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="o">&gt;</span> <span class="n">test_matrix</span><span class="p">;</span>
<span class="c1">// Set up the values in test matrix in some way</span>
<span class="n">matrix</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="o">&gt;</span> <span class="n">rotated_test_matrix</span><span class="p">;</span>
<span class="n">cmtl</span><span class="o">::</span><span class="n">Rotate180_16x16</span><span class="p">(</span><span class="n">test_matrix</span><span class="p">.</span><span class="n">select_all</span><span class="p">(),</span> <span class="n">rotated_test_matrix</span><span class="p">.</span><span class="n">select_all</span><span class="p">());</span>
</pre></div>
</div>
</div>
<div class="section" id="transpose-16x16">
<h4>5.6.6 Transpose_16x16<a class="headerlink" href="#transpose-16x16" title="Permalink to this headline">¶</a></h4>
<p>Limited testing</p>
<p>Transpose for 16x16 matrix</p>
<p><strong>Description:</strong> Perform a transpose on a 16x16 matrix, transforming it to a different output matrix</p>
<p><strong>Author:</strong> Danny Barash, Chaim Rand</p>
<p><strong>Functions:</strong></p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">Transpose_16x16</span><span class="p">(</span><span class="n">matrix_ref</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">16</span><span class="o">&gt;</span> <span class="n">in</span><span class="p">,</span> <span class="n">matrix_ref</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">16</span><span class="o">&gt;</span> <span class="n">out</span><span class="p">);</span>
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>T</td>
<td>The type of the matrix elements</td>
</tr>
<tr class="row-odd"><td>in</td>
<td>The input matrix (matrix_ref&lt;T,16,16&gt;)</td>
</tr>
<tr class="row-even"><td>out</td>
<td>The output matrix (matrix_ref&lt;T,16,16&gt;)</td>
</tr>
</tbody>
</table>
<p><strong>Example:</strong></p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">matrix</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="o">&gt;</span> <span class="n">test_matrix</span><span class="p">;</span>
<span class="c1">// Set up the values in test matrix in some way</span>
<span class="n">matrix</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="o">&gt;</span> <span class="n">transpose_test_matrix</span><span class="p">;</span>
<span class="n">cmtl</span><span class="o">::</span><span class="n">Transpose_16x16</span><span class="p">(</span><span class="n">test_matrix</span><span class="p">.</span><span class="n">select_all</span><span class="p">(),</span> <span class="n">transpose_test_matrix</span><span class="p">.</span><span class="n">select_all</span><span class="p">());</span>
</pre></div>
</div>
</div>
<div class="section" id="reversetranspose16x16">
<h4>5.6.7 ReverseTranspose16x16<a class="headerlink" href="#reversetranspose16x16" title="Permalink to this headline">¶</a></h4>
<p>Limited testing</p>
<p>Reverse transpose for 16x16 matrix</p>
<p><strong>Description:</strong> Perform a reverse transpose on a 16x16 matrix, transforming it to a different output matrix.
Note: reverse transpose is not an inverse transpose (which is the same as a transpose), but instead a
transpose about the other diagonal than the normal transpose.</p>
<p><strong>Author:</strong> Danny Barash, Chaim Rand</p>
<p><strong>Functions:</strong></p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">ReverseTranspose_16x16</span><span class="p">(</span><span class="n">matrix_ref</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">16</span><span class="o">&gt;</span> <span class="n">in</span><span class="p">,</span>
                                        <span class="n">matrix_ref</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">16</span><span class="o">&gt;</span> <span class="n">out</span><span class="p">);</span>
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>T</td>
<td>The type of the matrix elements</td>
</tr>
<tr class="row-odd"><td>in</td>
<td>The input matrix (matrix_ref&lt;T,16,16&gt;)</td>
</tr>
<tr class="row-even"><td>out</td>
<td>The output matrix (matrix_ref&lt;T,16,16&gt;)</td>
</tr>
</tbody>
</table>
<p><strong>Example:</strong></p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">matrix</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="o">&gt;</span> <span class="n">test_matrix</span><span class="p">;</span>
<span class="c1">// Set up the values in test matrix in some way</span>
<span class="n">matrix</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="o">&gt;</span> <span class="n">reverse_transp_test_matrix</span><span class="p">;</span>
<span class="n">cmtl</span><span class="o">::</span><span class="n">ReverseTranspose_16x16</span><span class="p">(</span><span class="n">test_matrix</span><span class="p">.</span><span class="n">select_all</span><span class="p">(),</span>
                             <span class="n">reverse_transp_test_matrix</span><span class="p">.</span><span class="n">select_all</span><span class="p">());</span>
</pre></div>
</div>
</div>
<div class="section" id="transpose-8x8">
<h4>5.6.8 Transpose_8x8<a class="headerlink" href="#transpose-8x8" title="Permalink to this headline">¶</a></h4>
<p>Limited testing</p>
<p>Transpose for 8x8 matrix</p>
<p><strong>Description:</strong> Perform a transpose on an 8x8 matrix, transforming it to a different output matrix</p>
<p><strong>Author:</strong> Michele Casula</p>
<p><strong>Functions:</strong></p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">Transpose_8x8</span><span class="p">(</span><span class="n">matrix_ref</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="o">&gt;</span> <span class="n">in</span><span class="p">,</span>
                               <span class="n">matrix_ref</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="o">&gt;</span> <span class="n">out</span><span class="p">);</span>
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>T</td>
<td>The type of the matrix elements</td>
</tr>
<tr class="row-odd"><td>In</td>
<td>The input matrix (matrix_ref&lt;T,8,8&gt;)</td>
</tr>
<tr class="row-even"><td>Out</td>
<td>The output matrix (matrix_ref&lt;T,8,8&gt;)</td>
</tr>
</tbody>
</table>
<p><strong>Example:</strong></p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">matrix</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="o">&gt;</span> <span class="n">test_matrix</span><span class="p">;</span>
<span class="c1">// Set up the values in test matrix in some way</span>
<span class="n">matrix</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="o">&gt;</span> <span class="n">transpose_test_matrix</span><span class="p">;</span>
<span class="n">cmtl</span><span class="o">::</span><span class="n">Transpose_8x8</span><span class="p">(</span><span class="n">test_matrix</span><span class="p">.</span><span class="n">select_all</span><span class="p">(),</span>
                    <span class="n">transpose_test_matrix</span><span class="p">.</span><span class="n">select_all</span><span class="p">());</span>
</pre></div>
</div>
</div>
<div class="section" id="map">
<h4>5.6.9 map<a class="headerlink" href="#map" title="Permalink to this headline">¶</a></h4>
<p>Limited testing</p>
<p>Generic square matrix mapping</p>
<p><strong>Description:</strong> A generic square matrix mapping function. A mapping vector provides the source for
mapping each element. For function T(x) -&gt; T(mapping(x)) = x
e.g. mapping for 2x2 90 deg clockwise turn: mapping = { 2, 0, 3, 1 }</p>
<p><strong>Author:</strong> Danny Barash, Chaim Rand</p>
<p><strong>Functions:</strong></p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">uint</span> <span class="n">W</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">map</span><span class="p">(</span><span class="n">matrix_ref</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span><span class="n">W</span><span class="o">&gt;</span> <span class="n">in</span><span class="p">,</span>
                             <span class="n">matrix_ref</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span><span class="n">W</span><span class="o">&gt;</span> <span class="n">out</span><span class="p">,</span>
                             <span class="n">vector_ref</span><span class="o">&lt;</span><span class="n">ushort</span><span class="p">,</span> <span class="n">W</span><span class="o">*</span><span class="n">W</span><span class="o">&gt;</span> <span class="n">mapping</span><span class="p">);</span>
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>T</td>
<td>The type of the matrix elements</td>
</tr>
<tr class="row-odd"><td>W</td>
<td>The width and height (rows and columns) for the square matrix</td>
</tr>
<tr class="row-even"><td>In</td>
<td>The input matrix (matrix_ref)</td>
</tr>
<tr class="row-odd"><td>Out</td>
<td>The output matrix (matrix_ref)</td>
</tr>
<tr class="row-even"><td>mapping</td>
<td>The mapping vector (vector_ref). Elements proceed in row
order (e.g. row 0 is defined, then row 1 etc)</td>
</tr>
</tbody>
</table>
<p><strong>Example:</strong></p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">matrix</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">test_matrix</span><span class="p">;</span>

<span class="c1">// Set up the values in test matrix in some way</span>
<span class="n">matrix</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">map_test_matrix</span><span class="p">;</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">ushort</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">idx</span><span class="p">;</span>
<span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="n">idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">idx</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="n">idx</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="n">cmtl</span><span class="o">::</span><span class="n">map</span><span class="p">(</span><span class="n">test_matrix</span><span class="p">.</span><span class="n">select_all</span><span class="p">(),</span> <span class="n">map_test_matrix</span><span class="p">.</span><span class="n">select_all</span><span class="p">(),</span> <span class="n">idx</span><span class="p">.</span><span class="n">select_all</span><span class="p">());</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="init-and-assignment">
<h3><a class="toc-backref" href="#id77">5.7 Init and assignment</a><a class="headerlink" href="#init-and-assignment" title="Permalink to this headline">¶</a></h3>
<div class="section" id="cm-vector-assign">
<h4>5.7.1 cm_vector_assign<a class="headerlink" href="#cm-vector-assign" title="Permalink to this headline">¶</a></h4>
<p>Initialise a vector with some simple rules</p>
<p><strong>Description:</strong>
Initialise a vector with a sequence of values defined using an initial value and a step.</p>
<p><strong>Functions:</strong></p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">uint</span> <span class="n">Size</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">cm_vector_assign</span><span class="p">(</span><span class="n">vector_ref</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="n">Size</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">,</span>
                                             <span class="kt">int</span> <span class="n">InitValue</span><span class="p">,</span> <span class="kt">int</span> <span class="n">Step</span><span class="p">);</span>
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>T</td>
<td>The type of the vector elements</td>
</tr>
<tr class="row-odd"><td>Size</td>
<td>The size of the vector</td>
</tr>
<tr class="row-even"><td>InitValue</td>
<td>The value to assign to the first element in the vector</td>
</tr>
<tr class="row-odd"><td>Step</td>
<td>The amount to increase by for each subsequent element
assigned</td>
</tr>
</tbody>
</table>
<p><strong>Example:</strong></p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">100</span><span class="o">&gt;</span> <span class="n">test_vector</span><span class="p">;</span>
<span class="n">cmtl</span><span class="o">::</span><span class="n">cm_vector_assign</span><span class="p">(</span><span class="n">test_vector</span><span class="p">.</span><span class="n">select_all</span><span class="p">(),</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
<span class="c1">// Assigns vector values 20, 30, 40, ... 1000, 1010</span>
</pre></div>
</div>
</div>
<div class="section" id="cm-matrix">
<h4>5.7.2 cm_matrix<a class="headerlink" href="#cm-matrix" title="Permalink to this headline">¶</a></h4>
<p>Macro to create and initialize a matrix</p>
<p><strong>Description:</strong>
Create and initialize a new matrix and initialize with some simple values in an optimal way.</p>
<p><strong>Functions:</strong></p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="cp">#define cm_matrix(M, T, R, C, I, S)</span>
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>M</td>
<td>Name of the matrix to be created</td>
</tr>
<tr class="row-odd"><td>T</td>
<td>Type of the matrix to be created</td>
</tr>
<tr class="row-even"><td>R</td>
<td>Number of rows in the new matrix</td>
</tr>
<tr class="row-odd"><td>C</td>
<td>Number of columns in the new matrix</td>
</tr>
<tr class="row-even"><td>I</td>
<td>Initial value for the new matrix</td>
</tr>
<tr class="row-odd"><td>S</td>
<td>Step value between each element</td>
</tr>
</tbody>
</table>
<p><strong>Example:</strong></p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">cm_matrix</span><span class="p">(</span><span class="n">test_matrix</span><span class="p">,</span> <span class="kt">short</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="c1">// Assigns a matrix with values 1, 3, 5 etc. (starting row 0, col 0,</span>
<span class="c1">// row 0, col 1 and so on</span>
</pre></div>
</div>
</div>
<div class="section" id="cm-vector">
<h4>5.7.3 cm_vector<a class="headerlink" href="#cm-vector" title="Permalink to this headline">¶</a></h4>
<p>Macro to create and initialize a vector</p>
<p><strong>Description:</strong>
Create and initialize a new vector and initialize with some simple values in an optimal way.</p>
<p><strong>Functions:</strong></p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="cp">#define cm_vector(M, T, N, I, S)</span>
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>M</td>
<td>Name of the vector to be created</td>
</tr>
<tr class="row-odd"><td>T</td>
<td>Type of the vector  to be created</td>
</tr>
<tr class="row-even"><td>N</td>
<td>Number of elements in the new vector</td>
</tr>
<tr class="row-odd"><td>I</td>
<td>Initial value for the new vector</td>
</tr>
<tr class="row-even"><td>S</td>
<td>Step value between each element</td>
</tr>
</tbody>
</table>
<p><strong>Example:</strong></p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">cm_vector</span><span class="p">(</span><span class="n">test_vector</span><span class="p">,</span> <span class="kt">char</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="c1">// Assigns a vector with values 20, 19, 18 etc</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="extended-math">
<h3><a class="toc-backref" href="#id78">5.8 Extended math</a><a class="headerlink" href="#extended-math" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id23">
<h4>5.8.1 cm_atan2_fast<a class="headerlink" href="#id23" title="Permalink to this headline">¶</a></h4>
<p>Fast atan2</p>
<p><strong>Description:</strong>
Fast atan2 implementation for various input types (see functions for details). The results of this call are
generated more quickly but are less accurate than the standard atan2 function. It is only accurate up to
0.01, where cm_atan2 is precise up to 0.00001.
The flag parameter can be used to set the execution mode (e.g. SAT bit) in the same way as other intrinsic
functions.</p>
<p><strong>Functions:</strong></p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="n">uint</span> <span class="n">R</span><span class="p">,</span> <span class="n">uint</span> <span class="n">C</span><span class="o">&gt;</span> <span class="n">matrix</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span><span class="n">R</span><span class="p">,</span><span class="n">C</span><span class="o">&gt;</span> <span class="n">cm_atan2_fast</span><span class="p">(</span>
                            <span class="n">matrix</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span><span class="n">R</span><span class="p">,</span><span class="n">C</span><span class="o">&gt;</span> <span class="n">y</span><span class="p">,</span> <span class="n">matrix</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span><span class="n">R</span><span class="p">,</span><span class="n">C</span><span class="o">&gt;</span> <span class="n">x</span><span class="p">,</span>
                            <span class="k">const</span> <span class="n">uint</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="n">uint</span> <span class="n">R</span><span class="p">,</span> <span class="n">uint</span> <span class="n">C</span><span class="o">&gt;</span> <span class="n">matrix</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span><span class="n">R</span><span class="p">,</span><span class="n">C</span><span class="o">&gt;</span> <span class="n">cm_atan2_fast</span><span class="p">(</span>
                            <span class="n">matrix_ref</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span><span class="n">R</span><span class="p">,</span><span class="n">C</span><span class="o">&gt;</span> <span class="n">y</span><span class="p">,</span>
                            <span class="n">matrix_ref</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span><span class="n">R</span><span class="p">,</span><span class="n">C</span><span class="o">&gt;</span> <span class="n">x</span><span class="p">,</span>
                            <span class="k">const</span> <span class="n">uint</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="n">uint</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span><span class="n">N</span><span class="o">&gt;</span> <span class="n">cm_atan2_fast</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span><span class="n">N</span><span class="o">&gt;</span> <span class="n">y</span><span class="p">,</span>
                                                <span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span><span class="n">N</span><span class="o">&gt;</span> <span class="n">x</span><span class="p">,</span>
                                                <span class="k">const</span> <span class="n">uint</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="n">uint</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span><span class="n">N</span><span class="o">&gt;</span> <span class="n">cm_atan2_fast</span><span class="p">(</span><span class="n">vector_ref</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span><span class="n">N</span><span class="o">&gt;</span> <span class="n">y</span><span class="p">,</span>
                                                <span class="n">vector_ref</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span><span class="n">N</span><span class="o">&gt;</span> <span class="n">x</span><span class="p">,</span>
                                                <span class="k">const</span> <span class="n">uint</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">float</span> <span class="n">cm_atan2_fast</span><span class="p">(</span><span class="n">T</span> <span class="n">y</span><span class="p">,</span> <span class="n">T</span> <span class="n">x</span><span class="p">,</span>
                                          <span class="k">const</span> <span class="n">uint</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>R</td>
<td>Number of rows (matrix variant)</td>
</tr>
<tr class="row-odd"><td>C</td>
<td>Number of columns (matrix variant)</td>
</tr>
<tr class="row-even"><td>N</td>
<td>Number of elements (vector variant)</td>
</tr>
<tr class="row-odd"><td>T</td>
<td>Type for atan2 parameters (scalar variant)</td>
</tr>
<tr class="row-even"><td>y</td>
<td>y parameter for standard atan2(y,x) mathematical function</td>
</tr>
<tr class="row-odd"><td>x</td>
<td>x parameter for standard atan2(y,x) mathematical function</td>
</tr>
<tr class="row-even"><td>flags</td>
<td>Set the execution mode flags  (e.g. SAT bit). Defaults to 0</td>
</tr>
</tbody>
</table>
<p><strong>Example:</strong></p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">matrix</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="o">&gt;</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">;</span>
<span class="c1">// Set up the y and x values in some way ...</span>
<span class="n">Matrix</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">cmtl</span><span class="o">::</span><span class="n">cm_atan2_fast</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="id24">
<h4>5.8.2 cm_atan2<a class="headerlink" href="#id24" title="Permalink to this headline">¶</a></h4>
<p>Fast atan2</p>
<p><strong>Description:</strong>
Fast atan2 implementation for various input types (see functions for details). The results of this call are
generated less  quickly but are more accurate than the standard cm_atan2_fast function. It is accurate up
to 0.00001, where cm_atan2 _fast is only precise up to 0.01.
The flag parameter can be used to set the execution mode (e.g. SAT bit) in the same way as other intrinsic
functions.</p>
<p><strong>Functions:</strong></p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="n">uint</span> <span class="n">R</span><span class="p">,</span> <span class="n">uint</span> <span class="n">C</span><span class="o">&gt;</span> <span class="n">matrix</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span><span class="n">R</span><span class="p">,</span><span class="n">C</span><span class="o">&gt;</span> <span class="n">cm_atan2</span><span class="p">(</span>
                            <span class="n">matrix</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span><span class="n">R</span><span class="p">,</span><span class="n">C</span><span class="o">&gt;</span> <span class="n">y</span><span class="p">,</span> <span class="n">matrix</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span><span class="n">R</span><span class="p">,</span><span class="n">C</span><span class="o">&gt;</span> <span class="n">x</span><span class="p">,</span>
                            <span class="k">const</span> <span class="n">uint</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="n">uint</span> <span class="n">R</span><span class="p">,</span> <span class="n">uint</span> <span class="n">C</span><span class="o">&gt;</span> <span class="n">matrix</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span><span class="n">R</span><span class="p">,</span><span class="n">C</span><span class="o">&gt;</span> <span class="n">cm_atan2</span><span class="p">(</span>
                            <span class="n">matrix_ref</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span><span class="n">R</span><span class="p">,</span><span class="n">C</span><span class="o">&gt;</span> <span class="n">y</span><span class="p">,</span>
                            <span class="n">matrix_ref</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span><span class="n">R</span><span class="p">,</span><span class="n">C</span><span class="o">&gt;</span> <span class="n">x</span><span class="p">,</span>
                            <span class="k">const</span> <span class="n">uint</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="n">uint</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span><span class="n">N</span><span class="o">&gt;</span> <span class="n">cm_atan2</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span><span class="n">N</span><span class="o">&gt;</span> <span class="n">y</span><span class="p">,</span>
                                           <span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span><span class="n">N</span><span class="o">&gt;</span> <span class="n">x</span><span class="p">,</span>
                                           <span class="k">const</span> <span class="n">uint</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="n">uint</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span><span class="n">N</span><span class="o">&gt;</span> <span class="n">cm_atan2</span><span class="p">(</span><span class="n">vector_ref</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span><span class="n">N</span><span class="o">&gt;</span> <span class="n">y</span><span class="p">,</span>
                                           <span class="n">vector_ref</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span><span class="n">N</span><span class="o">&gt;</span> <span class="n">x</span><span class="p">,</span>
                                           <span class="k">const</span> <span class="n">uint</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">float</span> <span class="n">cm_atan2</span><span class="p">(</span><span class="n">T</span> <span class="n">y</span><span class="p">,</span> <span class="n">T</span> <span class="n">x</span><span class="p">,</span>
                                     <span class="k">const</span> <span class="n">uint</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>R</td>
<td>Number of rows (matrix variant)</td>
</tr>
<tr class="row-odd"><td>C</td>
<td>Number of columns (matrix variant)</td>
</tr>
<tr class="row-even"><td>N</td>
<td>Number of elements (vector variant)</td>
</tr>
<tr class="row-odd"><td>T</td>
<td>Type for atan2 parameters (scalar variant)</td>
</tr>
<tr class="row-even"><td>Y</td>
<td>y parameter for standard atan2(y,x) mathematical function</td>
</tr>
<tr class="row-odd"><td>X</td>
<td>x parameter for standard atan2(y,x) mathematical function</td>
</tr>
<tr class="row-even"><td>Flags</td>
<td>Set the execution mode flags  (e.g. SAT bit). Defaults to 0</td>
</tr>
</tbody>
</table>
<p><strong>Example:</strong></p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">matrix</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="o">&gt;</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">;</span>
<span class="c1">// Set up the y and x values in some way ...</span>
<span class="n">Matrix</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">cmtl</span><span class="o">::</span><span class="n">cm_atan2</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="cm-fmod">
<h4>5.8.3 cm_fmod<a class="headerlink" href="#cm-fmod" title="Permalink to this headline">¶</a></h4>
<p>Floating point remainder function</p>
<p><strong>Description:</strong>
Floating-point Remainder. This is the same as C standard function fmod(), namely:
cm_fmod(y,x)=r, if y = qx + r where q is an integer and r&lt;x.
The flag parameter can be used to set the execution mode (e.g. SAT bit) in the same way as other intrinsic
functions.</p>
<p><strong>Functions:</strong></p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="n">uint</span> <span class="n">R</span><span class="p">,</span> <span class="n">uint</span> <span class="n">C</span><span class="o">&gt;</span> <span class="n">matrix</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span><span class="n">R</span><span class="p">,</span><span class="n">C</span><span class="o">&gt;</span> <span class="n">cm_fmod</span> <span class="p">(</span>
                            <span class="n">matrix</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span><span class="n">R</span><span class="p">,</span><span class="n">C</span><span class="o">&gt;</span> <span class="n">y</span><span class="p">,</span> <span class="n">matrix</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span><span class="n">R</span><span class="p">,</span><span class="n">C</span><span class="o">&gt;</span> <span class="n">x</span><span class="p">,</span>
                            <span class="k">const</span> <span class="n">uint</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="n">uint</span> <span class="n">R</span><span class="p">,</span> <span class="n">uint</span> <span class="n">C</span><span class="o">&gt;</span> <span class="n">matrix</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span><span class="n">R</span><span class="p">,</span><span class="n">C</span><span class="o">&gt;</span> <span class="n">cm_fmod</span><span class="p">(</span>
                            <span class="n">matrix_ref</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span><span class="n">R</span><span class="p">,</span><span class="n">C</span><span class="o">&gt;</span> <span class="n">y</span><span class="p">,</span>
                            <span class="n">matrix_ref</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span><span class="n">R</span><span class="p">,</span><span class="n">C</span><span class="o">&gt;</span> <span class="n">x</span><span class="p">,</span>
                            <span class="k">const</span> <span class="n">uint</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="n">uint</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span><span class="n">N</span><span class="o">&gt;</span> <span class="n">cm_fmod</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span><span class="n">N</span><span class="o">&gt;</span> <span class="n">y</span><span class="p">,</span>
                                          <span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span><span class="n">N</span><span class="o">&gt;</span> <span class="n">x</span><span class="p">,</span>
                                          <span class="k">const</span> <span class="n">uint</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="n">uint</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span><span class="n">N</span><span class="o">&gt;</span> <span class="n">cm_fmod</span><span class="p">(</span><span class="n">vector_ref</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span><span class="n">N</span><span class="o">&gt;</span> <span class="n">y</span><span class="p">,</span>
                                          <span class="n">vector_ref</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span><span class="n">N</span><span class="o">&gt;</span> <span class="n">x</span><span class="p">,</span>
                                          <span class="k">const</span> <span class="n">uint</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">float</span> <span class="n">cm_fmod</span><span class="p">(</span><span class="n">T</span> <span class="n">y</span><span class="p">,</span> <span class="n">T</span> <span class="n">x</span><span class="p">,</span>
                                    <span class="k">const</span> <span class="n">uint</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>R</td>
<td>Number of rows (matrix variant)</td>
</tr>
<tr class="row-odd"><td>C</td>
<td>Number of columns (matrix variant)</td>
</tr>
<tr class="row-even"><td>N</td>
<td>Number of elements (vector variant)</td>
</tr>
<tr class="row-odd"><td>T</td>
<td>Type for fmod parameters (scalar variant)</td>
</tr>
<tr class="row-even"><td>Y</td>
<td>y parameter for standard fmod(y,x) mathematical function</td>
</tr>
<tr class="row-odd"><td>X</td>
<td>x parameter for standard fmod(y,x) mathematical function</td>
</tr>
<tr class="row-even"><td>Flags</td>
<td>Set the execution mode flags  (e.g. SAT bit). Defaults to 0</td>
</tr>
</tbody>
</table>
<p><strong>Example:</strong></p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">matrix</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="o">&gt;</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">;</span>
<span class="c1">// Set up the y and x values in some way ...</span>
<span class="n">Matrix</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">cmtl</span><span class="o">::</span><span class="n">cm_fmod</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="cm-floor">
<h4>5.8.4 cm_floor<a class="headerlink" href="#cm-floor" title="Permalink to this headline">¶</a></h4>
<p>Floating point floor function</p>
<p><strong>Description:</strong>
Produces the largest integer not greater than input operand (round down) – this is effectively the same
functionality as cm_rndd. This is the same as C standard function floorf().
The flag parameter can be used to set the execution mode (e.g. SAT bit) in the same way as other intrinsic
functions.</p>
<p><strong>Functions:</strong></p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">RT</span><span class="p">,</span> <span class="n">uint</span> <span class="n">R</span><span class="p">,</span> <span class="n">uint</span> <span class="n">C</span><span class="o">&gt;</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">RT</span><span class="p">,</span> <span class="n">R</span><span class="o">*</span><span class="n">C</span><span class="o">&gt;</span> <span class="n">cm_floor</span><span class="p">(</span>
                                       <span class="k">const</span> <span class="n">matrix</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span><span class="n">R</span><span class="p">,</span><span class="n">C</span><span class="o">&gt;</span> <span class="n">src</span><span class="p">,</span>
                                       <span class="k">const</span> <span class="n">uint</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">RT</span><span class="p">,</span> <span class="n">uint</span> <span class="n">SZ</span><span class="o">&gt;</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">RT</span><span class="p">,</span> <span class="n">SZ</span><span class="o">&gt;</span> <span class="n">cm_floor</span><span class="p">(</span>
                                       <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span><span class="n">SZ</span><span class="o">&gt;</span> <span class="n">src</span><span class="p">,</span>
                                       <span class="k">const</span> <span class="n">uint</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">RT</span><span class="o">&gt;</span> <span class="n">RT</span> <span class="n">cm_floor</span><span class="p">(</span><span class="k">const</span> <span class="kt">float</span> <span class="n">src</span><span class="p">,</span>
                                   <span class="k">const</span> <span class="n">uint</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>RT</td>
<td>Return type (elements of return object – scalar, vector or
matrix) – usually float</td>
</tr>
<tr class="row-odd"><td>R</td>
<td>Number of rows (matrix variant)</td>
</tr>
<tr class="row-even"><td>C</td>
<td>Number of columns (matrix variant)</td>
</tr>
<tr class="row-odd"><td>SZ</td>
<td>Number of elements (vector variant)</td>
</tr>
<tr class="row-even"><td>src</td>
<td>Input parameter which will be floor’ed</td>
</tr>
<tr class="row-odd"><td>flags</td>
<td>Set the execution mode flags  (e.g. SAT bit). Defaults to 0</td>
</tr>
</tbody>
</table>
<p><strong>Example:</strong></p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">matrix</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="o">&gt;</span> <span class="n">x</span><span class="p">;</span>
<span class="c1">// Set up the x values in some way ...</span>
<span class="n">matrix</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">cmtl</span><span class="o">::</span><span class="n">cm_floor</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="cm-ceil">
<h4>5.8.5 cm_ceil<a class="headerlink" href="#cm-ceil" title="Permalink to this headline">¶</a></h4>
<p>Floating point ceil function</p>
<p><strong>Description:</strong>
Produces the smallesT integer not less than input operand (round up) – this is effectively the same
functionality as cm_rndu. This is the same as C standard function ceilf().
The flag parameter can be used to set the execution mode (e.g. SAT bit) in the same way as other intrinsic
functions.</p>
<p><strong>Functions:</strong></p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">RT</span><span class="p">,</span> <span class="n">uint</span> <span class="n">R</span><span class="p">,</span> <span class="n">uint</span> <span class="n">C</span><span class="o">&gt;</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">RT</span><span class="p">,</span> <span class="n">R</span><span class="o">*</span><span class="n">C</span><span class="o">&gt;</span> <span class="n">cm_ceil</span><span class="p">(</span>
                                       <span class="k">const</span> <span class="n">matrix</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span><span class="n">R</span><span class="p">,</span><span class="n">C</span><span class="o">&gt;</span> <span class="n">src</span><span class="p">,</span>
                                       <span class="k">const</span> <span class="n">uint</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">RT</span><span class="p">,</span> <span class="n">uint</span> <span class="n">SZ</span><span class="o">&gt;</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">RT</span><span class="p">,</span> <span class="n">SZ</span><span class="o">&gt;</span> <span class="n">cm_ceil</span><span class="p">(</span>
                                       <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span><span class="n">SZ</span><span class="o">&gt;</span> <span class="n">src</span><span class="p">,</span>
                                       <span class="k">const</span> <span class="n">uint</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">RT</span><span class="o">&gt;</span> <span class="n">RT</span> <span class="n">cm_ceil</span><span class="p">(</span><span class="k">const</span> <span class="kt">float</span> <span class="n">src</span><span class="p">,</span>
                                  <span class="k">const</span> <span class="n">uint</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameters</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>RT</td>
<td>Return type (elements of return object – scalar, vector or
matrix) – usually float</td>
</tr>
<tr class="row-odd"><td>R</td>
<td>Number of rows (matrix variant)</td>
</tr>
<tr class="row-even"><td>C</td>
<td>Number of columns (matrix variant)</td>
</tr>
<tr class="row-odd"><td>SZ</td>
<td>Number of elements (vector variant)</td>
</tr>
<tr class="row-even"><td>src</td>
<td>Input parameter which will be ceil’ed</td>
</tr>
<tr class="row-odd"><td>flags</td>
<td>Set the execution mode flags  (e.g. SAT bit). Defaults to 0</td>
</tr>
</tbody>
</table>
<p><strong>Example:</strong></p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">matrix</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="o">&gt;</span> <span class="n">x</span><span class="p">;</span>
<span class="c1">// Set up the x values in some way ...</span>
<span class="n">matrix</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">cmtl</span><span class="o">::</span><span class="n">cm_ceil</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="appendix-a-media-kernel-example">
<h2><a class="toc-backref" href="#id79">Appendix A Media Kernel Example</a><a class="headerlink" href="#appendix-a-media-kernel-example" title="Permalink to this headline">¶</a></h2>
<div class="section" id="linear-filter-example">
<h3><a class="toc-backref" href="#id80">Linear Filter Example</a><a class="headerlink" href="#linear-filter-example" title="Permalink to this headline">¶</a></h3>
<div class="section" id="linear-filter-effect-illustration">
<h4>Linear filter effect illustration<a class="headerlink" href="#linear-filter-effect-illustration" title="Permalink to this headline">¶</a></h4>
<img alt="../_images/linear_in.png" src="../_images/linear_in.png" />
<p>==&gt; linear filter ==&gt;</p>
<img alt="../_images/linear_gold_hw.png" src="../_images/linear_gold_hw.png" />
</div>
<div class="section" id="pseudo-code">
<h4>Pseudo code<a class="headerlink" href="#pseudo-code" title="Permalink to this headline">¶</a></h4>
<img alt="../_images/linear_pseudocode.png" src="../_images/linear_pseudocode.png" />
</div>
<div class="section" id="cm-implementation">
<h4>CM implementation<a class="headerlink" href="#cm-implementation" title="Permalink to this headline">¶</a></h4>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">_GENX_MAIN_</span> <span class="kt">void</span>
<span class="nf">linear</span><span class="p">(</span><span class="n">SurfaceIndex</span> <span class="n">ibuf</span><span class="p">,</span> <span class="n">SurfaceIndex</span> <span class="n">obuf</span><span class="p">,</span> <span class="n">uint</span> <span class="n">h_pos</span><span class="p">,</span> <span class="n">uint</span> <span class="n">v_pos</span><span class="p">)</span>
<span class="p">{</span>
<span class="c1">// declare a 8x32 input matrix of uchar elements</span>
    <span class="n">matrix</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="n">in</span><span class="p">;</span>
<span class="c1">// declare a 6x24 output matrix of uchar elements</span>
    <span class="n">matrix</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">24</span><span class="o">&gt;</span> <span class="n">out</span><span class="p">;</span>
    <span class="n">matrix</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">24</span><span class="o">&gt;</span> <span class="n">m</span><span class="p">;</span>

<span class="c1">// CM intrinsic to read the input matrix via dataport</span>
    <span class="n">read</span><span class="p">(</span><span class="n">ibuf</span><span class="p">,</span> <span class="n">h_pos</span><span class="o">*</span><span class="mi">24</span><span class="p">,</span> <span class="n">v_pos</span><span class="o">*</span><span class="mi">6</span><span class="p">,</span> <span class="n">in</span><span class="p">);</span>

<span class="c1">// Compute the sums of neighbor elements</span>
    <span class="n">m</span>  <span class="o">=</span> <span class="n">in</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">6</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">24</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span>
    <span class="n">m</span> <span class="o">+=</span> <span class="n">in</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">6</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">24</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">m</span> <span class="o">+=</span> <span class="n">in</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">6</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">24</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span>
    <span class="n">m</span> <span class="o">+=</span> <span class="n">in</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">6</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">24</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">6</span><span class="p">);</span>
    <span class="n">m</span> <span class="o">+=</span> <span class="n">in</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">6</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">24</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">m</span> <span class="o">+=</span> <span class="n">in</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">6</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">24</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">);</span>
    <span class="n">m</span> <span class="o">+=</span> <span class="n">in</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">6</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">24</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">m</span> <span class="o">+=</span> <span class="n">in</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">6</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">24</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span>
    <span class="n">m</span> <span class="o">+=</span> <span class="n">in</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">6</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">24</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">);</span>

<span class="c1">// Compute the average</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">m</span> <span class="o">*</span> <span class="mf">0.111f</span><span class="p">;</span>

<span class="c1">// Write the result to dataport</span>
    <span class="n">write</span><span class="p">(</span><span class="n">obuf</span><span class="p">,</span> <span class="n">h_pos</span><span class="o">*</span><span class="mi">24</span><span class="p">,</span> <span class="n">v_pos</span><span class="o">*</span><span class="mi">6</span><span class="p">,</span> <span class="n">out</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="appendix-b-vme-interface-access-macros">
<h2><a class="toc-backref" href="#id81">Appendix B VME Interface Access Macros</a><a class="headerlink" href="#appendix-b-vme-interface-access-macros" title="Permalink to this headline">¶</a></h2>
<div class="section" id="vme-interface-access-macros-for-gen6">
<h3><a class="toc-backref" href="#id82">VME Interface Access Macros for Gen6</a><a class="headerlink" href="#vme-interface-access-macros-for-gen6" title="Permalink to this headline">¶</a></h3>
<p>To facilitate the use of VME interface, CM provides the following access macros for setting up the input
parameters, as well as retrieving the output results.</p>
<div class="section" id="list-of-input-access-macros">
<h4>List of Input Access Macros<a class="headerlink" href="#list-of-input-access-macros" title="Permalink to this headline">¶</a></h4>
<p>There are three formats for the input access macros:</p>
<ul>
<li><p class="first">VME_SET_DataFieldName(p, v):  set the specified data field in the input payload “p” to value “v”.</p>
<p>This macro may take multiple value fields, such as start center X and Y position. Note that in this case
the value should be set as unsigned hexadecimal and it is the programmer’s responsibility to interpret
the value properly.</p>
</li>
<li><p class="first">VME_SET_BitFieldName(p): set the specified input payload bit field to TRUE.</p>
</li>
<li><p class="first">VME_CLEAR_BitFieldName(p): set the specified input payload bit field to FALSE.</p>
</li>
</ul>
<p>The type of the input payload variable “p” is pre-defined as follows:</p>
<ul class="simple">
<li>typedef matrix&lt;unsigned char, 4, 32&gt; vme_InputMrfType;</li>
</ul>
<p>The expected value or type for the input value “v” is provided in the following list wherever appropriate.
For further information on the input payload content and the data field description, please refer to
reference [4].</p>
<div class="line-block">
<div class="line">ST_SRC_16X16 0</div>
<div class="line">ST_SRC_16X8  1</div>
<div class="line">ST_SRC_8X8   3</div>
<div class="line">VME_SET_SrcType_SrcBlockSize(p, v)</div>
<div class="line"><br /></div>
<div class="line">ST_SRC_FRAME 0x00</div>
<div class="line">ST_SRC_FIELD 0x40</div>
<div class="line">VME_SET_SrcType_SrcBlockStructure(p, v)</div>
<div class="line"><br /></div>
<div class="line">ST_REF_FRAME 0x00</div>
<div class="line">ST_REF_FIELD 0x80</div>
<div class="line">VME_SET_SrcType_RefWindowStructure(p, v)</div>
<div class="line"><br /></div>
<div class="line">VM_MODE_SSS 0</div>
<div class="line">VM_MODE_DSS 1</div>
<div class="line">VM_MODE_DDS 3</div>
<div class="line">VM_MODE_DDD 7</div>
<div class="line">VME_SET_VmeModes_RunningMode(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_VmeModes_DualSearchPathMode(p)</div>
<div class="line">VME_CLEAR_VmeModes_DualSearchPathMode(p)</div>
<div class="line"><br /></div>
<div class="line">VM_INTEGER_PEL 0</div>
<div class="line">VM_HALF_PEL 0x10</div>
<div class="line">VM_QUARTER_PEL 0x30</div>
<div class="line">VME_SET_VmeModes_SubPelMode(p, v)</div>
<div class="line"><br /></div>
<div class="line">DIST_INTRA_SAD 0</div>
<div class="line">DIST_INTRA_HAAR 0x80</div>
<div class="line">VME_SET_SadType_IntraDistMetric(p, v)</div>
<div class="line"><br /></div>
<div class="line">DIST_INTER_SAD 0</div>
<div class="line">DIST_INTER_HAAR 0x20</div>
<div class="line">VME_SET_SadType_InterDistMetric(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_SadType_SkipBoundaryCheckDis(p)</div>
<div class="line">VME_CLEAR_SadType_SkipBoundaryCheckDis(p)</div>
<div class="line"><br /></div>
<div class="line">// The value can be a combination of the following</div>
<div class="line">SHP_NO_16X16  0x01</div>
<div class="line">SHP_NO_16X8   0x02</div>
<div class="line">SHP_NO_8X16   0x04</div>
<div class="line">SHP_NO_8X8    0x08</div>
<div class="line">SHP_NO_8X4    0x10</div>
<div class="line">SHP_NO_4X8    0x20</div>
<div class="line">SHP_NO_4X4    0x40</div>
<div class="line">SHP_BIDIR_AVS 0x80</div>
<div class="line">VME_SET_ShapeMask(p, v)</div>
<div class="line"><br /></div>
<div class="line">// The value must be a multiple of 4. Range = [20, 64]</div>
<div class="line">VME_SET_RefW(p, v)</div>
<div class="line"><br /></div>
<div class="line">// The value must be a multiple of 4. Range = [20, 64]</div>
<div class="line">VME_SET_RefH(p, v)</div>
<div class="line"><br /></div>
<div class="line"><br /></div>
<div class="line">VME_SET_VmeFlags_SkipModeEn(p)</div>
<div class="line">VME_CLEAR_VmeFlags_SkipModeEn(p)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_VmeFlags_AdaptiveEn(p)</div>
<div class="line">VME_CLEAR_VmeFlags_AdaptiveEn(p)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_VmeFlags_BiMixDis(p)</div>
<div class="line">VME_CLEAR_VmeFlags_BiMixDis(p)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_VmeFlags_ExtraCandidateEn(p)</div>
<div class="line">VME_CLEAR_VmeFlags_ExtraCandidateEn(p)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_VmeFlags_EarlySuccessEn(p)</div>
<div class="line">VME_CLEAR_VmeFlags_EarlySuccessEn(p)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_VmeFlags_ImeSuccessEn(p)</div>
<div class="line">VME_CLEAR_VmeFlags_ImeSuccessEn(p)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_VmeFlags_QuitInterEn(p)</div>
<div class="line">VME_CLEAR_VmeFlags_QuitInterEn(p)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_VmeFlags_T8x8FlagForInterEn(p)</div>
<div class="line">VME_CLEAR_VmeFlags_T8x8FlagForInterEn(p)</div>
<div class="line"><br /></div>
<div class="line">// Value type = U4PAIR</div>
<div class="line">VME_SET_EarlySkipSuc(p, shift_count, shift_val)</div>
<div class="line">VME_SET_EarlyFmeExit(p, shift_count, shift_val)</div>
<div class="line">VME_SET_EarlyImeStop(p, shift_count, shift_val)</div>
<div class="line"><br /></div>
<div class="line">// Value type = U8; Range = [4, 32]</div>
<div class="line">VME_SET_MaxMvs(p, v) (VME_Input_S1(p, uint1, 1, 4) = v)</div>
<div class="line"><br /></div>
<div class="line">// Value type = U8; Range = [16, 21, 32, 43, 48]</div>
<div class="line">VME_SET_BiWeight(p, v) (VME_Input_S1(p, uint1, 1, 6) = v)</div>
<div class="line"><br /></div>
<div class="line">// The value can be a combination of the following</div>
<div class="line">BID_NO_16X16 0x01</div>
<div class="line">BID_NO_16X8_8X16 0x02</div>
<div class="line">BID_NO_16X8 0x02</div>
<div class="line">BID_NO_8X16 0x02</div>
<div class="line">BID_NO_8X8 0x04</div>
<div class="line">BID_NO_MINORS 0x08</div>
<div class="line">BID_NO_SubMbPartMaskALL 0x0F</div>
<div class="line">VME_SET_BiDirMask_BiSubMbPartMask(p, v)</div>
<div class="line">VME_CLEAR_BiDirMask_BiSubMbPartMask(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_BiDirMask_UniMixDisable(p)</div>
<div class="line">VME_CLEAR_BiDirMask_UniMixDisable(p)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_BiDirMask_ AdaptiveValidationControl (p)</div>
<div class="line">VME_CLEAR_BiDirMask_ AdaptiveValidationControl (p)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_BiDirMask_FBPrunEn(p)</div>
<div class="line">VME_CLEAR_BiDirMask_FBPrunEn(p)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_BiDirMask_ReshapeEnable(p)</div>
<div class="line">VME_CLEAR_BiDirMask_ReshapeEnable(p)</div>
<div class="line"><br /></div>
<div class="line">// Vaule type = U8</div>
<div class="line">VME_SET_MaxLenSP(p, v)</div>
<div class="line">VME_SET_MaxNumSU(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Value type = U4</div>
<div class="line">VME_SET_SPCenter0(p, X, Y)</div>
<div class="line">VME_SET_SPCenter1(p, X, Y)</div>
<div class="line"><br /></div>
<div class="line">// Value type = U4PAIR</div>
<div class="line">VME_SET_BPrunTolerance(p, shift_count, shift_val)</div>
<div class="line"><br /></div>
<div class="line">// Value type = U4PAIR</div>
<div class="line">VME_SET_ExtraTolerance(p, shift_count, shift_val)</div>
<div class="line"><br /></div>
<div class="line">// Value type = U4PAIR</div>
<div class="line">VME_SET_ImeTooBad(p, shift_count, shift_val)</div>
<div class="line"><br /></div>
<div class="line">// Value type = U4PAIR</div>
<div class="line">VME_SET_ImeTooGood(p, shift_count, shift_val)</div>
<div class="line"><br /></div>
<div class="line">// Value type = I16, Format = S7.2</div>
<div class="line">VME_SET_CostCenter0DeltaX(p, v)</div>
<div class="line">VME_SET_CostCenter0DeltaY(p, v)</div>
<div class="line">VME_SET_CostCenter1DeltaX(p, v)</div>
<div class="line">VME_SET_CostCenter1DeltaY(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Value type = U8, Format = U6.2</div>
<div class="line">VME_SET_SkipCenterDelta00X(p, v)</div>
<div class="line">VME_SET_SkipCenterDelta00Y(p, v)</div>
<div class="line">VME_SET_SkipCenterDelta01X(p, v)</div>
<div class="line">VME_SET_SkipCenterDelta01Y(p, v)</div>
<div class="line"><br /></div>
<div class="line">// The value can be a combination of the following</div>
<div class="line">INTRA_PARTITION_16X16 0x01</div>
<div class="line">INTRA_PARTITION_8X8 0x02</div>
<div class="line">INTRA_PARTITION_4X4 0x04</div>
<div class="line">INTRA_PARTITION_NONAVS8X8 0x08</div>
<div class="line">INTRA_PARTITION_NONAVS4X4 0x10</div>
<div class="line">INTRA_PARTITION_ALL 0x1F</div>
<div class="line">VME_SET_IntraFlags_IntraPartitionMaskDis(p, v)</div>
<div class="line">VME_CLEAR_IntraFlags_IntraPartitionMaskDis(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_IntraFlags_NonSkipZMVAdded(p)</div>
<div class="line">VME_CLEAR_IntraFlags_NonSkipZMVAdded(p)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_IntraFlags_NonSkipModeAdded(p)</div>
<div class="line">VME_CLEAR_IntraFlags_NonSkipModeAdded(p)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_IntraFlags_IntraCornerSwap(p)</div>
<div class="line">VME_CLEAR_IntraFlags_IntraCornerSwap(p)</div>
<div class="line"><br /></div>
<div class="line">INTRA_AVAIL_F 0x80</div>
<div class="line">INTRA_AVAIL_E 0x40</div>
<div class="line">INTRA_AVAIL_A 0x20</div>
<div class="line">INTRA_AVAIL_B 0x10</div>
<div class="line">INTRA_AVAIL_C 0x08</div>
<div class="line">INTRA_AVAIL_D 0x04</div>
<div class="line">VME_SET_IntraAvail(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Value type = U4</div>
<div class="line">VME_SET_LeftModes_IntraMxMPredModeA5(p, v)</div>
<div class="line">VME_SET_LeftModes_IntraMxMPredModeA7(p, v)</div>
<div class="line">VME_SET_LeftModes_IntraMxMPredModeA13(p, v)</div>
<div class="line">VME_SET_LeftModes_IntraMxMPredModeA15(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Value type = U4</div>
<div class="line">VME_SET_TopModes_IntraMxMPredModeB10(p, v)</div>
<div class="line">VME_SET_TopModes_IntraMxMPredModeB11(p, v)</div>
<div class="line">VME_SET_TopModes_IntraMxMPredModeB14(p, v)</div>
<div class="line">VME_SET_TopModes_IntraMxMPredModeB15(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Value type = U8, Format = U6.2</div>
<div class="line">VME_SET_SkipCenter1(p, Delta10X, Delta10Y, Delta11X, Delta11Y)</div>
<div class="line">VME_SET_SkipCenter2(p, Delta20X, Delta20Y, Delta21X, Delta21Y)</div>
<div class="line">VME_SET_SkipCenter3(p, Delta30X, Delta30Y, Delta31X, Delta31Y)</div>
</div>
</div>
<div class="section" id="list-of-output-access-macros">
<h4>List of Output Access Macros<a class="headerlink" href="#list-of-output-access-macros" title="Permalink to this headline">¶</a></h4>
<p>The output access macro is defined in the following format:</p>
<ul class="simple">
<li>VME_GET_DataFieldName(p, v):  retrieve the value of the specified filed in the output data matrix “p”
and assign it to the variable “v”.</li>
</ul>
<p>For “run_vme_inter” and “run_vme_all”, the type of the output data matrix “p” is defined as follows:</p>
<ul class="simple">
<li>typedef matrix&lt; unsigned char, 4, 32&gt; vme_OutputGrfType;</li>
</ul>
<p>For “run_vme_intra”, the type of the output data matrix “p” is defined as follows:</p>
<ul class="simple">
<li>typedef matrix&lt;unsigned char, 1, 32&gt; vme_OutputGrfShortType;</li>
</ul>
<p>The expected return value or type for “v” is provided in the following list wherever appropriate. For
further information on the output content and the data field description, please refer to reference [4].</p>
<div class="line-block">
<div class="line-block">
<div class="line">MODE_INTER_16X16 0x00</div>
<div class="line">MODE_INTER_16X8 0x01</div>
<div class="line">MODE_INTER_8X16 0x02</div>
<div class="line">MODE_INTER_8X8 0x03</div>
<div class="line">MODE_INTER_MINOR 0x03</div>
<div class="line">VME_GET_MbMode_InterMbMode(p, v)</div>
<div class="line"><br /></div>
<div class="line">MODE_SKIP_FLAG 0x04</div>
<div class="line">VME_GET_MbMode_MbSkipFlag(p, v)</div>
<div class="line"><br /></div>
<div class="line">MODE_INTRA_16X16 0x00</div>
<div class="line">MODE_INTRA_8X8 0x10</div>
<div class="line">MODE_INTRA_4X4 0x20</div>
<div class="line">MODE_INTRA_PCM 0x30</div>
<div class="line">VME_GET_MbMode_IntraMbMode(p, v)</div>
<div class="line"><br /></div>
<div class="line">MODE_FIELD_MB_POLARITY 0x80</div>
<div class="line">VME_GET_MbMode_FieldMbPolarityFlag(p, v)</div>
<div class="line"><br /></div>
<div class="line">TYPE_IS_INTRA 0x20</div>
<div class="line">TYPE_IS_FIELD 0x40</div>
<div class="line">TYPE_TRANSFORM8X8 0x80</div>
<div class="line">TYPE_INTRA_16X16 0x35</div>
<div class="line">TYPE_INTRA_16X16_021 0x35</div>
<div class="line">TYPE_INTRA_16X16_121 0x36</div>
<div class="line">TYPE_INTRA_16X16_221 0x37</div>
<div class="line">TYPE_INTRA_16X16_321 0x38</div>
<div class="line">TYPE_INTRA_8X8 0xA0</div>
<div class="line">TYPE_INTRA_4X4 0x20</div>
<div class="line">TYPE_INTER_16X16_0 0x01</div>
<div class="line">TYPE_INTER_16X16_1 0x02</div>
<div class="line">TYPE_INTER_16X16_2 0x03</div>
<div class="line">TYPE_INTER_16X8_00 0x04</div>
<div class="line">TYPE_INTER_16X8_11 0x06</div>
<div class="line">TYPE_INTER_16X8_01 0x08</div>
<div class="line">TYPE_INTER_16X8_10 0x0A</div>
<div class="line">TYPE_INTER_16X8_02 0x0C</div>
<div class="line">TYPE_INTER_16X8_12 0x0E</div>
<div class="line">TYPE_INTER_16X8_20 0x10</div>
<div class="line">TYPE_INTER_16X8_21 0x12</div>
<div class="line">TYPE_INTER_16X8_22 0x14</div>
<div class="line">TYPE_INTER_8X16_00 0x05</div>
<div class="line">TYPE_INTER_8X16_11 0x07</div>
<div class="line">TYPE_INTER_8X16_01 0x09</div>
<div class="line">TYPE_INTER_8X16_10 0x0B</div>
<div class="line">TYPE_INTER_8X16_02 0x0D</div>
<div class="line">TYPE_INTER_8X16_12 0x0F</div>
<div class="line">TYPE_INTER_8X16_20 0x11</div>
<div class="line">TYPE_INTER_8X16_21 0x13</div>
<div class="line">TYPE_INTER_8X16_22 0x15</div>
<div class="line">TYPE_INTER_8X8 0x16</div>
<div class="line">TYPE_INTER_OTHER 0x16</div>
<div class="line">VME_GET_MbType(p, v)</div>
<div class="line"><br /></div>
<div class="line">MVSZ_NULL 0x00</div>
<div class="line">MVSZ_8_MVS 0x40</div>
<div class="line">MVSZ_32_MVS 0x60</div>
<div class="line">VME_GET_MvSizeFlag(p, v)</div>
<div class="line"><br /></div>
</div>
<div class="line">// Value type = U8</div>
<div class="line-block">
<div class="line">VME_GET_MvQuantitye(p, v)</div>
<div class="line"><br /></div>
<div class="line">BORDER_REF0_LEFT 0x01</div>
<div class="line">BORDER_REF0_RIGHT 0x02</div>
<div class="line">BORDER_REF0_TOP 0x04</div>
<div class="line">BORDER_REF0_BOTTOM 0x08</div>
<div class="line">VME_GET_RefBorderMark_Ref0BorderReached(p, v)</div>
<div class="line"><br /></div>
<div class="line">BORDER_REF1_LEFT 0x10</div>
<div class="line">BORDER_REF1_RIGHT 0x20</div>
<div class="line">BORDER_REF1_TOP 0x40</div>
<div class="line">BORDER_REF1_BOTTOM 0x80</div>
<div class="line">VME_GET_RefBorderMark_Ref1BorderReached(p, v)</div>
<div class="line"><br /></div>
</div>
<div class="line">// Value type = U8</div>
<div class="line-block">
<div class="line">VME_GET_NumSUinIME(p, v)</div>
<div class="line"><br /></div>
</div>
<div class="line">// Vaule type = U14</div>
<div class="line-block">
<div class="line">VME_GET_MinDist(p, v)</div>
<div class="line">VME_GET_DistInter(p, v)</div>
<div class="line">VME_GET_DistIntra16_SkipRawDistortion(p, v)</div>
<div class="line"><br /></div>
</div>
<div class="line">// Value type = U1</div>
<div class="line-block">
<div class="line">VME_GET_DistIntra16_SkipRawDistortionInvalid(p, v)</div>
<div class="line"><br /></div>
</div>
<div class="line">// Vaule type = U14</div>
<div class="line-block">
<div class="line">VME_GET_DistIntra8or4(p, v)</div>
<div class="line"><br /></div>
</div>
<div class="line">// Vaule type = U8</div>
<div class="line-block">
<div class="line">BDirect8x8_0 0x10</div>
<div class="line">BDirect8x8_1 0x20</div>
<div class="line">BDirect8x8_2 0x40</div>
<div class="line">BDirect8x8_3 0x80</div>
<div class="line">VME_GET_D8x8Pattern(p, v)</div>
<div class="line"><br /></div>
</div>
<div class="line">// Value type = U16</div>
<div class="line-block">
<div class="line">VME_GET_IntraPredModes_LumaIntraPredModes0(p, v)</div>
<div class="line">VME_GET_IntraPredModes_LumaIntraPredModes1(p, v)</div>
<div class="line">VME_GET_IntraPredModes_LumaIntraPredModes2(p, v)</div>
<div class="line">VME_GET_IntraPredModes_LumaIntraPredModes3(p, v)</div>
<div class="line"><br /></div>
<div class="line">INTRA_AVAIL_F 0x80</div>
<div class="line">INTRA_AVAIL_E 0x40</div>
<div class="line">INTRA_AVAIL_A 0x20</div>
<div class="line">INTRA_AVAIL_B 0x10</div>
<div class="line">INTRA_AVAIL_C 0x08</div>
<div class="line">INTRA_AVAIL_D 0x04</div>
<div class="line">VME_GET_IntraAvail(p, v)</div>
<div class="line"><br /></div>
</div>
<div class="line">// Value type = U8</div>
<div class="line-block">
<div class="line">VME_GET_ClockCompute(p, v)</div>
<div class="line">VME_GET_ClockStalled(p, v)</div>
<div class="line">VME_GET_AltNumSUinIME(p, v)</div>
<div class="line"><br /></div>
</div>
<div class="line">// 4 2-bit tuple of the following value:</div>
<div class="line-block">
<div class="line">// SUBSHP_NO_SPLIT 0</div>
<div class="line">// SUBSHP_TWO_8X4 1</div>
<div class="line">// SUBSHP_TWO_4X8 2</div>
<div class="line">// SUBSHP_FOUR_4X4 3</div>
</div>
<div class="line">VME_GET_MbSubShape(p, v)</div>
<div class="line"><br /></div>
<div class="line">// 4 2-bit tuple of the following value:</div>
<div class="line">// SUBDIR_REF_0 0</div>
<div class="line">//  SUBDIR_REF_1 1</div>
<div class="line">// SUBDIR_BIDIR 2</div>
<div class="line">VME_GET_MbSubPredMode(p, v)</div>
<div class="line"><br /></div>
<div class="line-block">
<div class="line">PERFORM_SKIP 0x0001</div>
<div class="line">PERFORM_IME 0x0002</div>
<div class="line">PERFORM_1ST_FME 0x0004</div>
<div class="line">PERFORM_2ND_FME 0x0008</div>
<div class="line">PERFORM_1ST_BME 0x0010</div>
<div class="line">PERFORM_2ND_BME 0x0020</div>
<div class="line">PERFORM_INTRA 0x0040</div>
<div class="line">VME_GET_VmeDecisionLog_SubFuncs(p, v)</div>
<div class="line"><br /></div>
<div class="line">OCCURRED_EARLY_SKIP 0x0080</div>
<div class="line">OCCURRED_IME_STOP 0x0100</div>
<div class="line">OCCURRED_TOO_GOOD 0x0200</div>
<div class="line">OCCURRED_TOO_BAD 0x0400</div>
<div class="line">OCCURRED_EARLY_FME 0x0800</div>
<div class="line">VME_GET_VmeDecisionLog_EarlyExitCond(p, v)</div>
<div class="line"><br /></div>
<div class="line">IMPROVED_FME 0x1000</div>
<div class="line">IMPROVED_BME 0x2000</div>
<div class="line">IMPROVED_ALT 0x4000</div>
<div class="line">CAPPED_MAXMV 0x8000</div>
<div class="line">VME_GET_VmeDecisionLog_SubModules(p, v)</div>
<div class="line"><br /></div>
</div>
<div class="line">// Value type = matrix&lt;unsigned short, 2, 16&gt;</div>
<div class="line-block">
<div class="line">VME_GET_Mvs(p, v)</div>
<div class="line"><br /></div>
</div>
<div class="line">// Value type = vector&lt;unsigned short, 8&gt;</div>
<div class="line-block">
<div class="line">VME_GET_Mvs_MinorFlag8(p, v)</div>
<div class="line"><br /></div>
</div>
<div class="line">// Value type = vector&lt;unsigned short, 8&gt;</div>
<div class="line-block">
<div class="line">VME_GET_Distortion(p, v)</div>
<div class="line"><br /></div>
<div class="line"><br /></div>
</div>
<div class="line">VME Interface Access Macros for Gen7</div>
<div class="line"><br /></div>
<div class="line">The formats of input/output access macros are similar to those defined for Gen6. The types of</div>
<div class="line">input/output data variables are specified in Section 4.12.2.</div>
<div class="line"><br /></div>
<div class="line">List of Input Access Macros:</div>
<div class="line"><br /></div>
<div class="line">ST_SRC_16X16 0</div>
<div class="line">ST_SRC_16X8  1</div>
<div class="line">ST_SRC_8X8   3</div>
<div class="line">VME_SET_SrcType_SrcBlockSize(p, v)</div>
<div class="line"><br /></div>
<div class="line">ST_SRC_FRAME 0x00</div>
<div class="line">ST_SRC_FIELD 0x40</div>
<div class="line">VME_SET_SrcType_SrcBlockStructure(p, v)</div>
<div class="line"><br /></div>
<div class="line">ST_REF_FRAME 0x00</div>
<div class="line">ST_REF_FIELD 0x80</div>
<div class="line">VME_SET_SrcType_RefWindowStructure(p, v)</div>
<div class="line"><br /></div>
<div class="line">VM_MODE_SSS 0</div>
<div class="line">VM_MODE_DSS 1</div>
<div class="line">VM_MODE_DDS 3</div>
<div class="line">VM_MODE_DDD 7</div>
<div class="line">VME_SET_VmeModes_RunningMode(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_VmeModes_DualSearchPathMode(p)</div>
<div class="line">VME_CLEAR_VmeModes_DualSearchPathMode(p)</div>
<div class="line"><br /></div>
<div class="line">VM_INTEGER_PEL 0x00</div>
<div class="line">VM_HALF_PEL 0x10</div>
<div class="line">VM_QUARTER_PEL 0x30</div>
<div class="line">VME_SET_VmeModes_SubPelMode(p, v)</div>
<div class="line"><br /></div>
<div class="line">DIST_INTRA_SAD 0</div>
<div class="line">DIST_INTRA_HAAR 0x80</div>
<div class="line">VME_SET_SadType_IntraDistMetric(p, v)</div>
<div class="line"><br /></div>
<div class="line">DIST_INTER_SAD 0</div>
<div class="line">DIST_INTER_HAAR 0x20</div>
<div class="line">VME_SET_SadType_InterDistMetric(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_SadType_SkipBoundaryCheckDis(p)</div>
<div class="line">VME_CLEAR_SadType_SkipBoundaryCheckDis(p)</div>
<div class="line"><br /></div>
<div class="line">// v can be a combination of the following</div>
<div class="line">SHP_NO_16X16  0x01</div>
<div class="line">SHP_NO_16X8   0x02</div>
<div class="line">SHP_NO_8X16   0x04</div>
<div class="line">SHP_NO_8X8    0x08</div>
<div class="line">SHP_NO_8X4    0x10</div>
<div class="line">SHP_NO_4X8    0x20</div>
<div class="line">SHP_NO_4X4    0x40</div>
<div class="line">SHP_BIDIR_AVS 0x80  // only for AVS</div>
<div class="line">VME_SET_ShapeMask(p, v)</div>
<div class="line"><br /></div>
<div class="line">// The value must be a multiple of 4. Range = [20, 64]</div>
<div class="line">VME_SET_RefW(p, v)</div>
<div class="line"><br /></div>
<div class="line">// The value must be a multiple of 4. Range = [20, 64]</div>
<div class="line">VME_SET_RefH(p, v)</div>
<div class="line"><br /></div>
<div class="line">// VmeFlags</div>
<div class="line">VME_SET_VmeFlags_SkipModeEn(p)</div>
<div class="line">VME_CLEAR_VmeFlags_SkipModeEn(p)</div>
<div class="line">// VF_ADAPTIVE_ENABLE 0x02</div>
<div class="line">VME_SET_VmeFlags_AdaptiveEn(p)</div>
<div class="line">VME_CLEAR_VmeFlags_AdaptiveEn(p)</div>
<div class="line">// VF_BIMIX_DISABLE 0x04</div>
<div class="line">VME_SET_VmeFlags_BiMixDis(p)</div>
<div class="line">VME_CLEAR_VmeFlags_BiMixDis(p)</div>
<div class="line">// VF_EXTRA_CANDIDATE 0x08</div>
<div class="line">VME_SET_VmeFlags_ExtraCandidateEn(p)</div>
<div class="line">VME_CLEAR_VmeFlags_ExtraCandidateEn(p)</div>
<div class="line">// VF_EARLY_SUCCESS 0x10</div>
<div class="line">VME_SET_VmeFlags_EarlySuccessEn(p)</div>
<div class="line">VME_CLEAR_VmeFlags_EarlySuccessEn(p)</div>
<div class="line">// VF_IME_SUCCESS 0x20</div>
<div class="line">VME_SET_VmeFlags_ImeSuccessEn(p)</div>
<div class="line">VME_CLEAR_VmeFlags_ImeSuccessEn(p)</div>
<div class="line">// VF_QUITINTER_ENABLE 0x40</div>
<div class="line">VME_SET_VmeFlags_QuitInterEn(p)</div>
<div class="line">VME_CLEAR_VmeFlags_QuitInterEn(p)</div>
<div class="line">// VF_T8X8_FOR_INTER 0x80</div>
<div class="line">VME_SET_VmeFlags_T8x8FlagForInterEn(p)</div>
<div class="line">VME_CLEAR_VmeFlags_T8x8FlagForInterEn(p)</div>
<div class="line"><br /></div>
<div class="line">// Value type = U4PAIR</div>
<div class="line">VME_SET_EarlySkipSuc(p, shift_count, shift_val)</div>
<div class="line">VME_SET_EarlyFmeExit(p, shift_count, shift_val)</div>
<div class="line">VME_SET_EarlyImeStop(p, shift_count, shift_val)</div>
<div class="line"><br /></div>
<div class="line">// Number of bits = 6; Range = [4, 32]</div>
<div class="line">VME_SET_MaxMvs(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Number of bits =6; Range = [16, 21, 32, 43, 48]</div>
<div class="line">VME_SET_BiWeight(p, v)</div>
<div class="line"><br /></div>
<div class="line">// v can be a combination of the following</div>
<div class="line">BID_NO_16X16 0x01</div>
<div class="line">BID_NO_16X8_8X16 0x02</div>
<div class="line">BID_NO_16X8 0x02</div>
<div class="line">BID_NO_8X16 0x02</div>
<div class="line">BID_NO_8X8 0x04</div>
<div class="line">BID_NO_MINORS 0x08</div>
<div class="line">BID_NO_SubMbPartMaskALL 0x0F</div>
<div class="line">VME_SET_BiDirMask_BiSubMbPartMask(p, v)</div>
<div class="line">VME_CLEAR_BiDirMask_BiSubMbPartMask(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_BiDirMask_UniMixDisable(p)</div>
<div class="line">VME_CLEAR_BiDirMask_UniMixDisable(p)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_BiDirMask_AdaptiveValidationControl(p)</div>
<div class="line">VME_CLEAR_BiDirMask_AdaptiveValidationControl(p)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_BiDirMask_FBPrunEn(p)</div>
<div class="line">VME_CLEAR_BiDirMask_FBPrunEn(p)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_BiDirMask_ReshapeEnable(p)</div>
<div class="line">VME_CLEAR_BiDirMask_ReshapeEnable(p)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_MaxLenSP(p, v)</div>
<div class="line">VME_SET_MaxNumSU(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_SPCenter0(p, X, Y)</div>
<div class="line">VME_SET_SPCenter1(p, X, Y)</div>
<div class="line"><br /></div>
<div class="line">// Value type = U4PAIR</div>
<div class="line">VME_SET_BPrunTolerance(p, shift_count, shift_val)</div>
<div class="line"><br /></div>
<div class="line">// Value type = U4PAIR</div>
<div class="line">VME_SET_ExtraTolerance(p, shift_count, shift_val)</div>
<div class="line"><br /></div>
<div class="line">// Value type = U4PAIR</div>
<div class="line">VME_SET_ImeTooBad(p, shift_count, shift_val)</div>
<div class="line"><br /></div>
<div class="line">// Value type = U4PAIR</div>
<div class="line">VME_SET_ImeTooGood(p, shift_count, shift_val)</div>
<div class="line"><br /></div>
<div class="line">// Number of bits = 16, Value type = I16, Format = S13.2</div>
<div class="line">VME_SET_CostCenter0DeltaX(p, v)</div>
<div class="line">VME_SET_CostCenter0DeltaY(p, v)</div>
<div class="line">VME_SET_CostCenter1DeltaX(p, v)</div>
<div class="line">VME_SET_CostCenter1DeltaY(p, v)</div>
<div class="line"><br /></div>
<div class="line">// v can be a combination of the following</div>
<div class="line">INTRA_PARTITION_16X16 0x01</div>
<div class="line">INTRA_PARTITION_8X8 0x02</div>
<div class="line">INTRA_PARTITION_4X4 0x04</div>
<div class="line">INTRA_PARTITION_NONAVS8X8 0x08</div>
<div class="line">INTRA_PARTITION_NONAVS4X4 0x10</div>
<div class="line">INTRA_PARTITION_ALL 0x1F</div>
<div class="line">VME_SET_IntraFlags_IntraPartitionMaskDis(p, v)</div>
<div class="line">VME_CLEAR_IntraFlags_IntraPartitionMaskDis(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_IntraFlags_NonSkipZMVAdded(p)</div>
<div class="line">VME_CLEAR_IntraFlags_NonSkipZMVAdded(p)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_IntraFlags_NonSkipModeAdded(p)</div>
<div class="line">VME_CLEAR_IntraFlags_NonSkipModeAdded(p)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_IntraFlags_IntraCornerSwap(p)</div>
<div class="line">VME_CLEAR_IntraFlags_IntraCornerSwap(p)</div>
<div class="line"><br /></div>
<div class="line">INTRA_AVAIL_F 0x80</div>
<div class="line">INTRA_AVAIL_E 0x40</div>
<div class="line">INTRA_AVAIL_A 0x20</div>
<div class="line">INTRA_AVAIL_B 0x10</div>
<div class="line">INTRA_AVAIL_C 0x08</div>
<div class="line">INTRA_AVAIL_D 0x04</div>
<div class="line">VME_SET_IntraAvail(p, v)</div>
<div class="line"><br /></div>
<div class="line">MVCostScaleFactor_QPEL  0x00</div>
<div class="line">MVCostScaleFactor_HQPEL 0x01</div>
<div class="line">MVCostScaleFactor_PEL   0x02</div>
<div class="line">MVCostScaleFactor_2PEL  0x03</div>
<div class="line">VME_SET_MVCostScaleFactor(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_SrcFieldPolarity(p)</div>
<div class="line">VME_CLEAR_SrcFieldPolarity(p)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_Ref0FieldPolarity(p)</div>
<div class="line">VME_CLEAR_Ref0FieldPolarity(p)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_Ref1FieldPolarity(p)</div>
<div class="line">VME_CLEAR_Ref1FieldPolarity(p)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_SkipCenterMask(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Number of bits = 4</div>
<div class="line">VME_SET_LeftModes_IntraMxMPredModeA5(p, v)</div>
<div class="line">VME_SET_LeftModes_IntraMxMPredModeA7(p, v)</div>
<div class="line">VME_SET_LeftModes_IntraMxMPredModeA13(p, v)</div>
<div class="line">VME_SET_LeftModes_IntraMxMPredModeA15(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Number of bits = 4</div>
<div class="line">VME_SET_TopModes_IntraMxMPredModeB10(p, v)</div>
<div class="line">VME_SET_TopModes_IntraMxMPredModeB11(p, v)</div>
<div class="line">VME_SET_TopModes_IntraMxMPredModeB14(p, v)</div>
<div class="line">VME_SET_TopModes_IntraMxMPredModeB15(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Number of bits = 16, Format = S13.2</div>
<div class="line">VME_SET_Ref0_SkipCenter0(p, DeltaX, DeltaY)</div>
<div class="line">VME_SET_Ref1_SkipCenter0(p, DeltaX, DeltaY)</div>
<div class="line">VME_SET_Ref0_SkipCenter1(p, DeltaX, DeltaY)</div>
<div class="line">VME_SET_Ref1_SkipCenter1(p, DeltaX, DeltaY)</div>
<div class="line">VME_SET_Ref0_SkipCenter2(p, DeltaX, DeltaY)</div>
<div class="line">VME_SET_Ref1_SkipCenter2(p, DeltaX, DeltaY)</div>
<div class="line">VME_SET_Ref0_SkipCenter3(p, DeltaX, DeltaY)</div>
<div class="line">VME_SET_Ref1_SkipCenter3(p, DeltaX, DeltaY)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_Intra4x4ModeMask(p, v)</div>
<div class="line">VME_SET_Intra8x8ModeMask(p, v)</div>
<div class="line">VME_SET_Intra16x16ModeMask(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U16</div>
<div class="line">VME_SET_StreamIn_Rec0_16x8_0Distortion(p, v)</div>
<div class="line">VME_SET_StreamIn_Rec0_16x8_1Distortion(p, v)</div>
<div class="line">VME_SET_StreamIn_Rec0_8x16_0Distortion(p, v)</div>
<div class="line">VME_SET_StreamIn_Rec0_8x16_1Distortion(p, v)</div>
<div class="line">VME_SET_StreamIn_Rec0_8x8_0Distortion(p, v)</div>
<div class="line">VME_SET_StreamIn_Rec0_8x8_1Distortion(p, v)</div>
<div class="line">VME_SET_StreamIn_Rec0_8x8_2Distortion(p, v)</div>
<div class="line">VME_SET_StreamIn_Rec0_8x8_3Distortion(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U14</div>
<div class="line">VME_SET_StreamIn_Rec0_16x16_Distortion(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = S13.2</div>
<div class="line">VME_SET_StreamIn_Rec0_16x16_X(p, v)</div>
<div class="line">VME_SET_StreamIn_Rec0_16x16_Y(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U16</div>
<div class="line">VME_SET_StreamIn_Rec0_16x8_0X(p, v)</div>
<div class="line">VME_SET_StreamIn_Rec0_16x8_0Y(p, v)</div>
<div class="line">VME_SET_StreamIn_Rec0_16x8_1X(p, v)</div>
<div class="line">VME_SET_StreamIn_Rec0_16x8_1Y(p, v)</div>
<div class="line">VME_SET_StreamIn_Rec0_8x16_0X(p, v)</div>
<div class="line">VME_SET_StreamIn_Rec0_8x16_0Y(p, v)</div>
<div class="line">VME_SET_StreamIn_Rec0_8x16_1X(p, v)</div>
<div class="line">VME_SET_StreamIn_Rec0_8x16_1Y(p, v)</div>
<div class="line">VME_SET_StreamIn_Rec0_8x8_0X(p, v)</div>
<div class="line">VME_SET_StreamIn_Rec0_8x8_0Y(p, v)</div>
<div class="line">VME_SET_StreamIn_Rec0_8x8_1X(p, v)</div>
<div class="line">VME_SET_StreamIn_Rec0_8x8_1Y(p, v)</div>
<div class="line">VME_SET_StreamIn_Rec0_8x8_2X(p, v)</div>
<div class="line">VME_SET_StreamIn_Rec0_8x8_2Y(p, v)</div>
<div class="line">VME_SET_StreamIn_Rec0_8x8_3X(p, v)</div>
<div class="line">VME_SET_StreamIn_Rec0_8x8_3Y(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U16</div>
<div class="line">VME_SET_StreamIn_Rec1_16x8_0Distortion(p, v)</div>
<div class="line">VME_SET_StreamIn_Rec1_16x8_1Distortion(p, v)</div>
<div class="line">VME_SET_StreamIn_Rec1_8x16_0Distortion(p, v)</div>
<div class="line">VME_SET_StreamIn_Rec1_8x16_1Distortion(p, v)</div>
<div class="line">VME_SET_StreamIn_Rec1_8x8_0Distortion(p, v)</div>
<div class="line">VME_SET_StreamIn_Rec1_8x8_1Distortion(p, v)</div>
<div class="line">VME_SET_StreamIn_Rec1_8x8_2Distortion(p, v)</div>
<div class="line">VME_SET_StreamIn_Rec1_8x8_3Distortion(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U14</div>
<div class="line">VME_SET_StreamIn_Rec1_16x16_Distortion(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = S13.2</div>
<div class="line">VME_SET_StreamIn_Rec1_16x16_X(p, v)</div>
<div class="line">VME_SET_StreamIn_Rec1_16x16_Y(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U16</div>
<div class="line">VME_SET_StreamIn_Rec1_16x8_0X(p, v)</div>
<div class="line">VME_SET_StreamIn_Rec1_16x8_0Y(p, v)</div>
<div class="line">VME_SET_StreamIn_Rec1_16x8_1X(p, v)</div>
<div class="line">VME_SET_StreamIn_Rec1_16x8_1Y(p, v)</div>
<div class="line">VME_SET_StreamIn_Rec1_8x16_0X(p, v)</div>
<div class="line">VME_SET_StreamIn_Rec1_8x16_0Y(p, v)</div>
<div class="line">VME_SET_StreamIn_Rec1_8x16_1X(p, v)</div>
<div class="line">VME_SET_StreamIn_Rec1_8x16_1Y(p, v)</div>
<div class="line">VME_SET_StreamIn_Rec1_8x8_0X(p, v)</div>
<div class="line">VME_SET_StreamIn_Rec1_8x8_0Y(p, v)</div>
<div class="line">VME_SET_StreamIn_Rec1_8x8_1X(p, v)</div>
<div class="line">VME_SET_StreamIn_Rec1_8x8_1Y(p, v)</div>
<div class="line">VME_SET_StreamIn_Rec1_8x8_2X(p, v)</div>
<div class="line">VME_SET_StreamIn_Rec1_8x8_2Y(p, v)</div>
<div class="line">VME_SET_StreamIn_Rec1_8x8_3X(p, v)</div>
<div class="line">VME_SET_StreamIn_Rec1_8x8_3Y(p, v)</div>
<div class="line"><br /></div>
<div class="line">List of Output Access Macros:</div>
<div class="line"><br /></div>
<div class="line">MODE_INTER_16X16 0x00</div>
<div class="line">MODE_INTER_16X8 0x01</div>
<div class="line">MODE_INTER_8X16 0x02</div>
<div class="line">MODE_INTER_8X8 0x03</div>
<div class="line">MODE_INTER_MINOR 0x03</div>
<div class="line">VME_GET_MbMode_InterMbMode(p, v)</div>
<div class="line"><br /></div>
<div class="line">MODE_SKIP_FLAG 0x04</div>
<div class="line">VME_GET_MbMode_MbSkipFlag(p, v)</div>
<div class="line"><br /></div>
<div class="line">MODE_INTRA_16X16 0x00</div>
<div class="line">MODE_INTRA_8X8 0x10</div>
<div class="line">MODE_INTRA_4X4 0x20</div>
<div class="line">MODE_INTRA_PCM 0x30</div>
<div class="line">VME_GET_MbMode_IntraMbMode(p, v)</div>
<div class="line"><br /></div>
<div class="line">MODE_FIELD_MB_POLARITY 0x80</div>
<div class="line">VME_GET_MbMode_FieldMbPolarityFlag(p, v)</div>
<div class="line"><br /></div>
<div class="line">TYPE_IS_INTRA 0x20</div>
<div class="line">TYPE_IS_FIELD 0x40</div>
<div class="line">TYPE_TRANSFORM8X8 0x80</div>
<div class="line">TYPE_INTRA_16X16 0x35 // 0x21-0x38</div>
<div class="line">TYPE_INTRA_16X16_021 0x35</div>
<div class="line">TYPE_INTRA_16X16_121 0x36</div>
<div class="line">TYPE_INTRA_16X16_221 0x37</div>
<div class="line">TYPE_INTRA_16X16_321 0x38</div>
<div class="line">TYPE_INTRA_8X8 0xA0</div>
<div class="line">TYPE_INTRA_4X4 0x20</div>
<div class="line">TYPE_INTER_16X16_0 0x01</div>
<div class="line">TYPE_INTER_16X16_1 0x02</div>
<div class="line">TYPE_INTER_16X16_2 0x03</div>
<div class="line">TYPE_INTER_16X8_00 0x04</div>
<div class="line">TYPE_INTER_16X8_11 0x06</div>
<div class="line">TYPE_INTER_16X8_01 0x08</div>
<div class="line">TYPE_INTER_16X8_10 0x0A</div>
<div class="line">TYPE_INTER_16X8_02 0x0C</div>
<div class="line">TYPE_INTER_16X8_12 0x0E</div>
<div class="line">TYPE_INTER_16X8_20 0x10</div>
<div class="line">TYPE_INTER_16X8_21 0x12</div>
<div class="line">TYPE_INTER_16X8_22 0x14</div>
<div class="line">TYPE_INTER_8X16_00 0x05</div>
<div class="line">TYPE_INTER_8X16_11 0x07</div>
<div class="line">TYPE_INTER_8X16_01 0x09</div>
<div class="line">TYPE_INTER_8X16_10 0x0B</div>
<div class="line">TYPE_INTER_8X16_02 0x0D</div>
<div class="line">TYPE_INTER_8X16_12 0x0F</div>
<div class="line">TYPE_INTER_8X16_20 0x11</div>
<div class="line">TYPE_INTER_8X16_21 0x13</div>
<div class="line">TYPE_INTER_8X16_22 0x15</div>
<div class="line">TYPE_INTER_8X8 0x16</div>
<div class="line">TYPE_INTER_OTHER 0x16</div>
<div class="line">VME_GET_MbType(p, v)</div>
<div class="line"><br /></div>
<div class="line">MVSZ_NULL 0x00</div>
<div class="line">MVSZ_8_MVS 0x40</div>
<div class="line">MVSZ_32_MVS 0x60</div>
<div class="line">VME_GET_MvSizeFlag(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_GET_MvQuantitye(p, v)</div>
<div class="line"><br /></div>
<div class="line">BORDER_REF0_LEFT 0x01</div>
<div class="line">BORDER_REF0_RIGHT 0x02</div>
<div class="line">BORDER_REF0_TOP 0x04</div>
<div class="line">BORDER_REF0_BOTTOM 0x08</div>
<div class="line">VME_GET_RefBorderMark_Ref0BorderReached(p, v)</div>
<div class="line"><br /></div>
<div class="line">BORDER_REF1_LEFT 0x10</div>
<div class="line">BORDER_REF1_RIGHT 0x20</div>
<div class="line">BORDER_REF1_TOP 0x40</div>
<div class="line">BORDER_REF1_BOTTOM 0x80</div>
<div class="line">VME_GET_RefBorderMark_Ref1BorderReached(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_GET_NumSUinIME(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Number of bits = 14</div>
<div class="line">VME_GET_MinDist(p, v)</div>
<div class="line">VME_GET_DistInter(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Number of bits = 14</div>
<div class="line">VME_GET_DistIntra16_SkipRawDistortion(p, v)</div>
<div class="line">// Number of bits = 1</div>
<div class="line">VME_GET_DistIntra16_SkipRawDistortionInvalid(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Number of bits = 14</div>
<div class="line">VME_GET_DistIntra8or4(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Number of bits = 4</div>
<div class="line">BDirect8x8_0 0x10</div>
<div class="line">BDirect8x8_1 0x20</div>
<div class="line">BDirect8x8_2 0x40</div>
<div class="line">BDirect8x8_3 0x80</div>
<div class="line">VME_GET_D8x8Pattern(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_GET_IntraPredModes_LumaIntraPredModes0(p, v)</div>
<div class="line">VME_GET_IntraPredModes_LumaIntraPredModes1(p, v)</div>
<div class="line">VME_GET_IntraPredModes_LumaIntraPredModes2(p, v)</div>
<div class="line">VME_GET_IntraPredModes_LumaIntraPredModes3(p, v)</div>
<div class="line"><br /></div>
<div class="line">INTRA_AVAIL_F 0x80</div>
<div class="line">INTRA_AVAIL_E 0x40</div>
<div class="line">INTRA_AVAIL_A 0x20</div>
<div class="line">INTRA_AVAIL_B 0x10</div>
<div class="line">INTRA_AVAIL_C 0x08</div>
<div class="line">INTRA_AVAIL_D 0x04</div>
<div class="line">VME_GET_IntraAvail(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_GET_ClockCompute(p, v)</div>
<div class="line">VME_GET_ClockStalled(p, v)</div>
<div class="line">VME_GET_AltNumSUinIME(p, v)</div>
<div class="line">VME_GET_MbSubShape(p, v)</div>
<div class="line">VME_GET_MbSubPredMode(p, v)</div>
<div class="line"><br /></div>
<div class="line">PERFORM_SKIP 0x0001</div>
<div class="line">PERFORM_IME 0x0002</div>
<div class="line">PERFORM_1ST_FME 0x0004</div>
<div class="line">PERFORM_2ND_FME 0x0008</div>
<div class="line">PERFORM_1ST_BME 0x0010</div>
<div class="line">PERFORM_2ND_BME 0x0020</div>
<div class="line">PERFORM_INTRA 0x0040</div>
<div class="line">VME_GET_VmeDecisionLog_SubFuncs(p, v)</div>
<div class="line"><br /></div>
<div class="line">OCCURRED_EARLY_SKIP 0x0080</div>
<div class="line">OCCURRED_IME_STOP 0x0100</div>
<div class="line">OCCURRED_TOO_GOOD 0x0200</div>
<div class="line">OCCURRED_TOO_BAD 0x0400</div>
<div class="line">OCCURRED_EARLY_FME 0x0800</div>
<div class="line">VME_GET_VmeDecisionLog_EarlyExitCond(p, v)</div>
<div class="line"><br /></div>
<div class="line">IMPROVED_FME 0x1000</div>
<div class="line">IMPROVED_BME 0x2000</div>
<div class="line">IMPROVED_ALT 0x4000</div>
<div class="line">CAPPED_MAXMV 0x8000</div>
<div class="line">VME_GET_VmeDecisionLog_SubModules(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_GET_Mvs(p, v)</div>
<div class="line">VME_GET_Distortion(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U16</div>
<div class="line">VME_GET_StreamOut_Rec0_16x8_0Distortion(p, v)</div>
<div class="line">VME_GET_StreamOut_Rec0_16x8_1Distortion(p, v)</div>
<div class="line">VME_GET_StreamOut_Rec0_8x16_0Distortion(p, v)</div>
<div class="line">VME_GET_StreamOut_Rec0_8x16_1Distortion(p, v)</div>
<div class="line">VME_GET_StreamOut_Rec0_8x8_0Distortion(p, v)</div>
<div class="line">VME_GET_StreamOut_Rec0_8x8_1Distortion(p, v)</div>
<div class="line">VME_GET_StreamOut_Rec0_8x8_2Distortion(p, v)</div>
<div class="line">VME_GET_StreamOut_Rec0_8x8_3Distortion(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U14</div>
<div class="line">VME_GET_StreamOut_Rec0_16x16_Distortion(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = S13.2</div>
<div class="line">VME_GET_StreamOut_Rec0_16x16_X(p, v)</div>
<div class="line">VME_GET_StreamOut_Rec0_16x16_Y(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U16</div>
<div class="line">VME_GET_StreamOut_Rec0_16x8_0X(p, v)</div>
<div class="line">VME_GET_StreamOut_Rec0_16x8_0Y(p, v)</div>
<div class="line">VME_GET_StreamOut_Rec0_16x8_1X(p, v)</div>
<div class="line">VME_GET_StreamOut_Rec0_16x8_1Y(p, v)</div>
<div class="line">VME_GET_StreamOut_Rec0_8x16_0X(p, v)</div>
<div class="line">VME_GET_StreamOut_Rec0_8x16_0Y(p, v)</div>
<div class="line">VME_GET_StreamOut_Rec0_8x16_1X(p, v)</div>
<div class="line">VME_GET_StreamOut_Rec0_8x16_1Y(p, v)</div>
<div class="line">VME_GET_StreamOut_Rec0_8x8_0X(p, v)</div>
<div class="line">VME_GET_StreamOut_Rec0_8x8_0Y(p, v)</div>
<div class="line">VME_GET_StreamOut_Rec0_8x8_1X(p, v)</div>
<div class="line">VME_GET_StreamOut_Rec0_8x8_1Y(p, v)</div>
<div class="line">VME_GET_StreamOut_Rec0_8x8_2X(p, v)</div>
<div class="line">VME_GET_StreamOut_Rec0_8x8_2Y(p, v)</div>
<div class="line">VME_GET_StreamOut_Rec0_8x8_3X(p, v)</div>
<div class="line">VME_GET_StreamOut_Rec0_8x8_3Y(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U16</div>
<div class="line">VME_GET_StreamOut_Rec1_16x8_0Distortion(p, v)</div>
<div class="line">VME_GET_StreamOut_Rec1_16x8_1Distortion(p, v)</div>
<div class="line">VME_GET_StreamOut_Rec1_8x16_0Distortion(p, v)</div>
<div class="line">VME_GET_StreamOut_Rec1_8x16_1Distortion(p, v)</div>
<div class="line">VME_GET_StreamOut_Rec1_8x8_0Distortion(p, v)</div>
<div class="line">VME_GET_StreamOut_Rec1_8x8_1Distortion(p, v)</div>
<div class="line">VME_GET_StreamOut_Rec1_8x8_2Distortion(p, v)</div>
<div class="line">VME_GET_StreamOut_Rec1_8x8_3Distortion(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U14</div>
<div class="line">VME_GET_StreamOut_Rec1_16x16_Distortion(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = S13.2</div>
<div class="line">VME_GET_StreamOut_Rec1_16x16_X(p, v)</div>
<div class="line">VME_GET_StreamOut_Rec1_16x16_Y(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U16</div>
<div class="line">VME_GET_StreamOut_Rec1_16x8_0X(p, v)</div>
<div class="line">VME_GET_StreamOut_Rec1_16x8_0Y(p, v)</div>
<div class="line">VME_GET_StreamOut_Rec1_16x8_1X(p, v)</div>
<div class="line">VME_GET_StreamOut_Rec1_16x8_1Y(p, v)</div>
<div class="line">VME_GET_StreamOut_Rec1_8x16_0X(p, v)</div>
<div class="line">VME_GET_StreamOut_Rec1_8x16_0Y(p, v)</div>
<div class="line">VME_GET_StreamOut_Rec1_8x16_1X(p, v)</div>
<div class="line">VME_GET_StreamOut_Rec1_8x16_1Y(p, v)</div>
<div class="line">VME_GET_StreamOut_Rec1_8x8_0X(p, v)</div>
<div class="line">VME_GET_StreamOut_Rec1_8x8_0Y(p, v)</div>
<div class="line">VME_GET_StreamOut_Rec1_8x8_1X(p, v)</div>
<div class="line">VME_GET_StreamOut_Rec1_8x8_1Y(p, v)</div>
<div class="line">VME_GET_StreamOut_Rec1_8x8_2X(p, v)</div>
<div class="line">VME_GET_StreamOut_Rec1_8x8_2Y(p, v)</div>
<div class="line">VME_GET_StreamOut_Rec1_8x8_3X(p, v)</div>
<div class="line">VME_GET_StreamOut_Rec1_8x8_3Y(p, v)</div>
</div>
</div>
</div>
<div class="section" id="vme-interface-access-macros-for-gen7-5">
<h3><a class="toc-backref" href="#id83">VME Interface Access Macros for Gen7_5</a><a class="headerlink" href="#vme-interface-access-macros-for-gen7-5" title="Permalink to this headline">¶</a></h3>
<p>The formats of input/output access macros are similar to those defined for Gen6. The types of
input/output data variables are specified in Section 4.12.3.</p>
<div class="section" id="id25">
<h4>List of Input Access Macros<a class="headerlink" href="#id25" title="Permalink to this headline">¶</a></h4>
<div class="line-block">
<div class="line">// Format = S15</div>
<div class="line">VME_SET_UNIInput_Ref0X(p, v)</div>
<div class="line">VME_SET_UNIInput_Ref0Y(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = S15</div>
<div class="line">VME_SET_UNIInput_Ref1X(p, v)</div>
<div class="line">VME_SET_UNIInput_Ref1Y(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U16</div>
<div class="line">VME_SET_UNIInput_SrcX(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U16</div>
<div class="line">VME_SET_UNIInput_SrcY(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Set - FieldBased</div>
<div class="line">// Clear - FrameBased</div>
<div class="line">VME_SET_UNIInput_SrcAccess(p)</div>
<div class="line">VME_CLEAR_UNIInput_SrcAccess(p)</div>
<div class="line"><br /></div>
<div class="line">// Set - FieldBased</div>
<div class="line">// Clear - FrameBased</div>
<div class="line">VME_SET_UNIInput_RefAccess(p)</div>
<div class="line">VME_CLEAR_UNIInput_RefAccess(p)</div>
<div class="line"><br /></div>
<div class="line">// Set - different paths</div>
<div class="line">// Clear - same path</div>
<div class="line">VME_SET_UNIInput_DualSearchPath(p)</div>
<div class="line">VME_CLEAR_UNIInput_DualSearchPath(p)</div>
<div class="line"><br /></div>
<div class="line">// INT_MODE 0x0</div>
<div class="line">// HALF_PEL_MODE 0x1</div>
<div class="line">// QUARTER_PEL_MODE 0x3</div>
<div class="line">VME_SET_UNIInput_SubPelMode(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Set - 4MVP</div>
<div class="line">// Clear - 1MVP</div>
<div class="line">VME_SET_UNIInput_SkipModeType(p)</div>
<div class="line">VME_CLEAR_UNIInput_SkipModeType(p)</div>
<div class="line"><br /></div>
<div class="line">// Set - Chroma mode</div>
<div class="line">// Clear - Luma mode</div>
<div class="line">VME_SET_UNIInput_InterChromaMode(p)</div>
<div class="line">VME_CLEAR_UNIInput_InterChromaMode(p)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_UNIInput_FTEnable(p)</div>
<div class="line">VME_CLEAR_UNIInput_FTEnable(p)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_UNIInput_BMEDisableFBR(p)</div>
<div class="line">VME_CLEAR_UNIInput_BMEDisableFBR(p)</div>
<div class="line"><br /></div>
<div class="line">// v is a 7-bit mask with the following definition:</div>
<div class="line">// xxxxxx1 : 16x16 sub-macroblock disabled</div>
<div class="line">// xxxxx1x : 2x(16x8) sub-macroblock within 16x16 disabled</div>
<div class="line">// xxxx1xx : 2x(8x16) sub-macroblock within 16x16 disabled</div>
<div class="line">// xxx1xxx : 1x(8x8) sub-partition for 4x(8x8) within 16x16 disabled</div>
<div class="line">// xx1xxxx : 2x(8x4) sub-partition for 4x(8x8) within 16x16 disabled</div>
<div class="line">// x1xxxxx : 2x(4x8) sub-partition for 4x(8x8) within 16x16 disabled</div>
<div class="line">// 1xxxxxx : 4x(4x4) sub-partition for 4x(8x8) within 16x16 disabled</div>
<div class="line">VME_SET_UNIInput_SubMbPartMask(p, v)</div>
<div class="line"><br /></div>
<div class="line">// The value must be a multiple of 4. Range = [20, 64]</div>
<div class="line">VME_SET_UNIInput_RefW(p, v)</div>
<div class="line"><br /></div>
<div class="line">// The value must be a multiple of 4. Range = [20, 64]</div>
<div class="line">VME_SET_UNIInput_RefH(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_UNIInput_SkipModeEn(p)</div>
<div class="line">VME_CLEAR_UNIInput_SkipModeEn(p)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_UNIInput_AdaptiveEn(p)</div>
<div class="line">VME_CLEAR_UNIInput_AdaptiveEn(p)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_UNIInput_EarlyImeSuccessEn(p)</div>
<div class="line">VME_CLEAR_UNIInput_EarlyImeSuccessEn(p)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_UNIInput_T8x8FlagForInterEn(p)</div>
<div class="line">VME_CLEAR_UNIInput_T8x8FlagForInterEn(p)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_UNIInput_EarlyImeStop(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_UNIInput_MaxNumMVs(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U6, Valid Values: [16, 21, 32, 43, 48]</div>
<div class="line">VME_SET_UNIInput_BiWeight(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U8, Valid range [1,63]</div>
<div class="line">VME_SET_UNIInput_LenSP(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U8, Valid range [1,63]</div>
<div class="line">VME_SET_UNIInput_MaxNumSU(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U4</div>
<div class="line">VME_SET_UNIInput_StartCenter0(p, StartCenter0X, StartCenter0Y)</div>
<div class="line"><br /></div>
<div class="line">// Format = U4</div>
<div class="line">VME_SET_UNIInput_StartCenter1(p, StartCenter1X, StartCenter1Y)</div>
<div class="line"><br /></div>
<div class="line">// Format = S13.2, Valid range [-2048.00 to 2047.75]</div>
<div class="line">// Note: The parameter should be specified as unsigned type.</div>
<div class="line">//            CM does not have native type support for S13.2, etc.</div>
<div class="line">//            These are treated as unsigned data and programmer must ensure the proper encoding</div>
<div class="line">//            as per HW format requirement.</div>
<div class="line">VME_SET_UNIInput_CostCenter0(p, CostCenter0X, CostCenter0Y)</div>
<div class="line"><br /></div>
<div class="line">// Format = S13.2, Valid range [-2048.00 to 2047.75]</div>
<div class="line">VME_SET_UNIInput_CostCenter1(p, CostCenter1X, CostCenter1Y)</div>
<div class="line"><br /></div>
<div class="line">// Format = U4</div>
<div class="line">VME_SET_UNIInput_Blk0RefID(p, FwdBlk0RefID, BwdBlk0RefID)</div>
<div class="line"><br /></div>
<div class="line">// Format = U4</div>
<div class="line">VME_SET_UNIInput_Blk1RefID(p, FwdBlk1RefID, BwdBlk1RefID)</div>
<div class="line"><br /></div>
<div class="line">// Format = U4</div>
<div class="line">VME_SET_UNIInput_Blk2RefID(p, FwdBlk2RefID, BwdBlk2RefID)</div>
<div class="line"><br /></div>
<div class="line">// Format = U4</div>
<div class="line">VME_SET_UNIInput_Blk3RefID(p, FwdBlk3RefID, BwdBlk3RefID)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_UNIInput_IntraFlags(p, v)</div>
<div class="line"><br /></div>
<div class="line">// v is a 8-bit mask with the following definition:</div>
<div class="line">// Bit-7 Reserved : MBZ (for IntraPredAvailFlagF – F (pixel[-1,7] available for MbAff)</div>
<div class="line">// Bit-6 Reserved : MBZ (for IntraPredAvailFlagA/E – A (left neighbor top half for MbAff)</div>
<div class="line">// Bit-5 IntraPredAvailFlagE/A – A (Left neighbor or Left bottom half)</div>
<div class="line">// Bit-4 IntraPredAvailFlagB – B (Upper neighbor)</div>
<div class="line">// Bit-3 IntraPredAvailFlagC – C (Upper left neighbor)</div>
<div class="line">// Bit-2 IntraPredAvailFlagD – D (Upper right neighbor)</div>
<div class="line">// Bit-1:0 Reserved: MBZ (ChromaIntraPredMode)</div>
<div class="line">VME_SET_UNIInput_MbIntraStruct(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_UNIInput_SrcFieldPolarity(p)</div>
<div class="line">VME_CLEAR_UNIInput_SrcFieldPolarity(p)</div>
<div class="line"><br /></div>
<div class="line">// v is a 8-bit mask with the following definition:</div>
<div class="line">// xxxx xxx1: Ref0 Skip Center 0 is enabled [corresponds to M2.0]</div>
<div class="line">// xxxx xx1x: Ref1 Skip Center 0 is enabled [corresponds to M2.1]</div>
<div class="line">// xxxx x1xx: Ref0 Skip Center 1 is enabled [corresponds to M2.2]</div>
<div class="line">// xxxx 1xxx: Ref1 Skip Center 1 is enabled [corresponds to M2.3]</div>
<div class="line">// xxx1 xxxx: Ref0 Skip Center 2 is enabled [corresponds to M2.4]</div>
<div class="line">// xx1x xxxx: Ref1 Skip Center 2 is enabled [corresponds to M2.5]</div>
<div class="line">// x1xx xxxx: Ref0 Skip Center 3 is enabled [corresponds to M2.6]</div>
<div class="line">// 1xxx xxxx: Ref1 Skip Center 3 is enabled [corresponds to M2.7]</div>
<div class="line">VME_SET_UNIInput_SkipCenterMask(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U4U4 (encoded value must fit in 12-bits)</div>
<div class="line">VME_SET_UNIInput_Mode0Cost(p, v)</div>
<div class="line">VME_SET_UNIInput_Mode1Cost(p, v)</div>
<div class="line">VME_SET_UNIInput_Mode2Cost(p, v)</div>
<div class="line">VME_SET_UNIInput_Mode3Cost(p, v)</div>
<div class="line">VME_SET_UNIInput_Mode4Cost(p, v)</div>
<div class="line">VME_SET_UNIInput_Mode5Cost(p, v)</div>
<div class="line">VME_SET_UNIInput_Mode6Cost(p, v)</div>
<div class="line">VME_SET_UNIInput_Mode7Cost(p, v)</div>
<div class="line">VME_SET_UNIInput_Mode8Cost(p, v)</div>
<div class="line">VME_SET_UNIInput_Mode9Cost(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U4U4 (encoded value must fit in 12-bits)</div>
<div class="line">VME_SET_UNIInput_RefIDCost(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U4U4 (encoded value must fit in 12-bits)</div>
<div class="line">VME_SET_UNIInput_ChromaIntraModeCost(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U4U4 (encoded value must fit in 10-bits)</div>
<div class="line">VME_SET_UNIInput_MV0Cost(p, v)</div>
<div class="line">VME_SET_UNIInput_MV1Cost(p, v)</div>
<div class="line">VME_SET_UNIInput_MV2Cost(p, v)</div>
<div class="line">VME_SET_UNIInput_MV3Cost(p, v)</div>
<div class="line">VME_SET_UNIInput_MV4Cost(p, v)</div>
<div class="line">VME_SET_UNIInput_MV5Cost(p, v)</div>
<div class="line">VME_SET_UNIInput_MV6Cost(p, v)</div>
<div class="line">VME_SET_UNIInput_MV7Cost(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U8</div>
<div class="line">VME_SET_UNIInput_FBRMbModeInput(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U8</div>
<div class="line">VME_SET_UNIInput_FBRSubMBShapeInput(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U8</div>
<div class="line">VME_SET_UNIInput_FBRSubPredModeInput(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U16</div>
<div class="line">VME_SET_UNIInput_SICFwdTCoeffThreshold0(p, v)</div>
<div class="line">// Format = U8</div>
<div class="line">VME_SET_UNIInput_SICFwdTCoeffThreshold1(p, v)</div>
<div class="line">VME_SET_UNIInput_SICFwdTCoeffThreshold2(p, v)</div>
<div class="line">VME_SET_UNIInput_SICFwdTCoeffThreshold3(p, v)</div>
<div class="line">VME_SET_UNIInput_SICFwdTCoeffThreshold4(p, v)</div>
<div class="line">VME_SET_UNIInput_SICFwdTCoeffThreshold5(p, v)</div>
<div class="line">VME_SET_UNIInput_SICFwdTCoeffThreshold6(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U8, with the following definition:</div>
<div class="line">// [7:4] (Y) – specifies relative Y distance to the next SU from previous SU in units of SU</div>
<div class="line">// [3:0] (X) – specifies relative X distance to the next SU from previous SU in units of SU</div>
<div class="line">// Format = U8, with the following definition:</div>
<div class="line">// [7:4] (Y) – specifies relative Y distance to the next SU from previous SU in units of SU</div>
<div class="line">// [3:0] (X) – specifies relative X distance to the next SU from previous SU in units of SU</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta0(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta1(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta2(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta3(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta4(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta5(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta6(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta7(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta8(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta9(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta10(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta11(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta12(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta13(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta14(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta15(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta16(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta17(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta18(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta19(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta20(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta21(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta22(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta23(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta24(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta25(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta26(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta27(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta28(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta29(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta30(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta31(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta32(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta33(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta34(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta35(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta36(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta37(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta38(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta39(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta40(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta41(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta42(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta43(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta44(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta45(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta46(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta47(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta48(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta49(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta50(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta51(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta52(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta53(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta54(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta55(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U16</div>
<div class="line">VME_SET_IMEInput_Rec0_16x8_0Distortion(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec0_16x8_1Distortion(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec0_8x16_0Distortion(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec0_8x16_1Distortion(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec0_8x8_0Distortion(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec0_8x8_1Distortion(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec0_8x8_2Distortion(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec0_8x8_3Distortion(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec0_16x16_Distortion(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U4</div>
<div class="line">VME_SET_UNIInput_Rec0_16x16_RefID(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = S13.2</div>
<div class="line">VME_SET_IMEInput_Rec0_16x16_X(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec0_16x16_Y(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U4</div>
<div class="line">VME_SET_IMEInput_Rec0_16x8_0RefID(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec0_16x8_1RefID(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec0_8x16_0RefID(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec0_8x16_1RefID(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec0_8x8_0RefID(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec0_8x8_1RefID(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec0_8x8_2RefID(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec0_8x8_3RefID(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = S13.2</div>
<div class="line">VME_SET_IMEInput_Rec0_16x8_0X(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec0_16x8_0Y(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec0_16x8_1X(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec0_16x8_1Y(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec0_8x16_0X(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec0_8x16_0Y(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec0_8x16_1X(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec0_8x16_1Y(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec0_8x8_0X(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec0_8x8_0Y(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec0_8x8_1X(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec0_8x8_1Y(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec0_8x8_2X(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec0_8x8_2Y(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec0_8x8_3X(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec0_8x8_3Y(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U16</div>
<div class="line">VME_SET_IMEInput_Rec1_16x8_0Distortion(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec1_16x8_1Distortion(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec1_8x16_0Distortion(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec1_8x16_1Distortion(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec1_8x8_0Distortion(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec1_8x8_1Distortion(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec1_8x8_2Distortion(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec1_8x8_3Distortion(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec1_16x16_Distortion(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U4</div>
<div class="line">VME_SET_UNIInput_Rec1_16x16_RefID(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = S13.2</div>
<div class="line">VME_SET_IMEInput_Rec1_16x16_X(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec1_16x16_Y(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U4</div>
<div class="line">VME_SET_IMEInput_Rec1_16x8_0RefID(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec1_16x8_1RefID(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec1_8x16_0RefID(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec1_8x16_1RefID(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec1_8x8_0RefID(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec1_8x8_1RefID(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec1_8x8_2RefID(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec1_8x8_3RefID(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = S13.2</div>
<div class="line">VME_SET_IMEInput_Rec1_16x8_0X(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec1_16x8_0Y(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec1_16x8_1X(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec1_16x8_1Y(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec1_8x16_0X(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec1_8x16_0Y(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec1_8x16_1X(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec1_8x16_1Y(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec1_8x8_0X(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec1_8x8_0Y(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec1_8x8_1X(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec1_8x8_1Y(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec1_8x8_2X(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec1_8x8_2Y(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec1_8x8_3X(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec1_8x8_3Y(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = S13.2, Valid Range: [-2048.00 to 2047.75]</div>
<div class="line">// For chroma skip: Format = S12.3, Hardware Range: [-1024.000 to 1023.875]</div>
<div class="line">VME_SET_SICInput_Ref0SkipCenter0DeltaXY(p, DeltaX, DeltaY)</div>
<div class="line">VME_SET_SICInput_Ref1SkipCenter0DeltaXY(p, DeltaX, DeltaY)</div>
<div class="line">VME_SET_SICInput_Ref0SkipCenter1DeltaXY(p, DeltaX, DeltaY)</div>
<div class="line">VME_SET_SICInput_Ref1SkipCenter1DeltaXY(p, DeltaX, DeltaY)</div>
<div class="line">VME_SET_SICInput_Ref0SkipCenter2DeltaXY(p, DeltaX, DeltaY)</div>
<div class="line">VME_SET_SICInput_Ref1SkipCenter2DeltaXY(p, DeltaX, DeltaY)</div>
<div class="line">VME_SET_SICInput_Ref0SkipCenter3DeltaXY(p, DeltaX, DeltaY)</div>
<div class="line">VME_SET_SICInput_Ref1SkipCenter3DeltaXY(p, DeltaX, DeltaY)</div>
<div class="line"><br /></div>
<div class="line">// 2-bit field with the following definition</div>
<div class="line">// 00: Luma + Chroma enabled</div>
<div class="line">// 01: Luma only</div>
<div class="line">// 1X: Intra disabled</div>
<div class="line">VME_SET_SICInput_IntraComputeType(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_SICInput_CornerNeighborPixel0(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_SICInput_NeighborPixelLum0(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelLum1(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelLum2(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelLum3(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelLum4(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelLum5(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelLum6(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelLum7(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelLum8(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelLum9(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelLum10(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelLum11(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelLum12(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelLum13(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelLum14(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelLum15(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelLum16(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelLum17(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelLum18(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelLum19(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelLum20(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelLum21(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelLum22(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelLum23(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelLum24(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelLum25(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelLum26(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelLum27(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelLum28(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelLum29(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelLum30(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelLum31(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelLum32(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelLum33(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelLum34(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelLum35(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelLum36(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelLum37(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelLum38(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_SICInput_CornerNeighborPixel1(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U4</div>
<div class="line">VME_SET_SICInput_IntraMxMPredModeA5(p, v)</div>
<div class="line">VME_SET_SICInput_IntraMxMPredModeA7(p, v)</div>
<div class="line">VME_SET_SICInput_IntraMxMPredModeA13(p, v)</div>
<div class="line">VME_SET_SICInput_IntraMxMPredModeA15(p, v)</div>
<div class="line">VME_SET_SICInput_IntraMxMPredModeB10(p, v)</div>
<div class="line">VME_SET_SICInput_IntraMxMPredModeB11(p, v)</div>
<div class="line">VME_SET_SICInput_IntraMxMPredModeB14(p, v)</div>
<div class="line">VME_SET_SICInput_IntraMxMPredModeB15(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U8 pair</div>
<div class="line">VME_SET_SICInput_CornerNeighborPixelChroma(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U8</div>
<div class="line">VME_SET_SICInput_PenaltyIntra4x4NonDC(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U8</div>
<div class="line">VME_SET_SICInput_PenaltyIntra8x8NonDC(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U8</div>
<div class="line">VME_SET_SICInput_PenaltyIntra16x16NonDC(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_SICInput_NeighborPixelChroma0(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelChroma1(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelChroma2(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelChroma3(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_SICInput_NeighborPixelChroma4(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelChroma5(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelChroma6(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelChroma7(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_SICInput_NeighborPixelChroma8(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelChroma9(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelChroma10(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelChroma11(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_SICInput_NeighborPixelChroma12(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelChroma13(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelChroma14(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelChroma15(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_SICInput_NeighborPixelChroma16(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelChroma17(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelChroma18(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelChroma19(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_SICInput_NeighborPixelChroma20(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelChroma21(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelChroma22(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelChroma23(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_SICInput_NeighborPixelChroma24(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelChroma25(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelChroma26(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelChroma27(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_SICInput_NeighborPixelChroma28(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelChroma29(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelChroma30(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelChroma31(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_FBRInput_Ref0SubBlockX0(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref0SubBlockY0(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref1SubBlockX0(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref1SubBlockY0(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_FBRInput_Ref0SubBlockX1(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref0SubBlockY1(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref1SubBlockX1(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref1SubBlockY1(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_FBRInput_Ref0SubBlockX2(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref0SubBlockY2(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref1SubBlockX2(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref1SubBlockY2(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_FBRInput_Ref0SubBlockX3(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref0SubBlockY3(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref1SubBlockX3(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref1SubBlockY3(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_FBRInput_Ref0SubBlockX4(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref0SubBlockY4(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref1SubBlockX4(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref1SubBlockY4(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_FBRInput_Ref0SubBlockX5(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref0SubBlockY5(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref1SubBlockX5(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref1SubBlockY5(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_FBRInput_Ref0SubBlockX6(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref0SubBlockY6(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref1SubBlockX6(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref1SubBlockY6(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_FBRInput_Ref0SubBlockX7(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref0SubBlockY7(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref1SubBlockX7(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref1SubBlockY7(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_FBRInput_Ref0SubBlockX8(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref0SubBlockY8(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref1SubBlockX8(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref1SubBlockY8(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_FBRInput_Ref0SubBlockX9(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref0SubBlockY9(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref1SubBlockX9(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref1SubBlockY9(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_FBRInput_Ref0SubBlockX10(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref0SubBlockY10(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref1SubBlockX10(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref1SubBlockY10(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_FBRInput_Ref0SubBlockX11(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref0SubBlockY11(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref1SubBlockX11(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref1SubBlockY11(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_FBRInput_Ref0SubBlockX12(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref0SubBlockY12(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref1SubBlockX12(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref1SubBlockY12(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_FBRInput_Ref0SubBlockX13(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref0SubBlockY13(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref1SubBlockX13(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref1SubBlockY13(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_FBRInput_Ref0SubBlockX14(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref0SubBlockY14(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref1SubBlockX14(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref1SubBlockY14(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_FBRInput_Ref0SubBlockX15(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref0SubBlockY15(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref1SubBlockX15(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref1SubBlockY15(p, v)</div>
</div>
</div>
<div class="section" id="id26">
<h4>List of Output Access Macros<a class="headerlink" href="#id26" title="Permalink to this headline">¶</a></h4>
<div class="line-block">
<div class="line">MODE_INTER_16X16 0x00</div>
<div class="line">MODE_INTER_16X8 0x01</div>
<div class="line">MODE_INTER_8X16 0x02</div>
<div class="line">MODE_INTER_8X8 0x03</div>
<div class="line">MODE_INTER_MINOR 0x03</div>
<div class="line">VME_GET_UNIOutput_InterMbMode(p, v)</div>
<div class="line"><br /></div>
<div class="line">MODE_INTRA_16X16 0x00</div>
<div class="line">MODE_INTRA_8X8 0x10</div>
<div class="line">MODE_INTRA_4X4 0x20</div>
<div class="line">MODE_INTRA_PCM 0x30</div>
<div class="line">VME_GET_UNIOutput_IntraMbMode(p, v)</div>
<div class="line"><br /></div>
<div class="line">MODE_FIELD_MB_POLARITY 0x80</div>
<div class="line">VME_GET_UNIOutput_FieldMbPolarityFlag(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_GET_UNIOutput_InterMbType(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_GET_UNIOutput_FieldMbFlag(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_GET_UNIOutput_IntraMbType(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_GET_UNIOutput_IntraMbType(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_GET_UNIOutput_MvQuantity(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U16</div>
<div class="line">VME_GET_UNIOutput_BestInterDistortion(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U16</div>
<div class="line">VME_GET_UNIOutput_SkipRawDistortion(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U16</div>
<div class="line">VME_GET_UNIOutput_BestIntraDistortion(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U16</div>
<div class="line">VME_GET_UNIOutput_BestChromaIntraDistortion(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_GET_UNIOutput_LumaIntraPredMode0(p, v)</div>
<div class="line">VME_GET_UNIOutput_LumaIntraPredMode1(p, v)</div>
<div class="line">VME_GET_UNIOutput_LumaIntraPredMode2(p, v)</div>
<div class="line">VME_GET_UNIOutput_LumaIntraPredMode3(p, v)</div>
<div class="line"><br /></div>
<div class="line">// 8-bit field with the following definition:</div>
<div class="line">// 7 Reserved : MBZ (for IntraPredAvailFlagF – F (pixel[-1,7] available for MbAff)</div>
<div class="line">// 6 Reserved : MBZ (for IntraPredAvailFlagA/E – A (left neighbor top half for MbAff)</div>
<div class="line">// 5 IntraPredAvailFlagE/A – A (Left neighbor or Left bottom half)</div>
<div class="line">// 4 IntraPredAvailFlagB – B (Upper neighbor)</div>
<div class="line">// 3 IntraPredAvailFlagC – C (Upper left neighbor)</div>
<div class="line">// 2 IntraPredAvailFlagD – D (Upper right neighbor)</div>
<div class="line">// 1:0 ChromaIntraPredMode</div>
<div class="line">VME_GET_UNIOutput_MbIntraStruct(p, v)</div>
<div class="line"><br /></div>
<div class="line">// 8-bit field with the following definition:</div>
<div class="line">// Bits [1:0]: SubMbShape[0]</div>
<div class="line">// Bits [3:2]: SubMbShape[1]</div>
<div class="line">// Bits [5:4]: SubMbShape[2]</div>
<div class="line">// Bits [7:6]: SubMbShape[3]</div>
<div class="line">VME_GET_UNIOutput_SubMbShape(p, v)</div>
<div class="line"><br /></div>
<div class="line">// 8-bit field with the following definition:</div>
<div class="line">// Bits [1:0]: SubMbPredMode[0]</div>
<div class="line">// Bits [3:2]: SubMbPredMode[1]</div>
<div class="line">// Bits [5:4]: SubMbPredMode[2]</div>
<div class="line">// Bits [7:6]: SubMbPredMode[3]</div>
<div class="line">VME_GET_UNIOutput_SubMbPredMode(p, v)</div>
<div class="line"><br /></div>
<div class="line">// v is a 4x16 int2 type matrix that stores the motion vectors as follows:</div>
<div class="line">// MVa[0].x, MVa[0].y, MVb[0].x, MVb[0].x</div>
<div class="line">// MVa[1].x, MVa[1].y, MVb[1].x, MVb[1].x</div>
<div class="line">// …</div>
<div class="line">// MVa[15].x, MVa[15].y, MVb[15].x, MVb[15].x</div>
<div class="line">VME_GET_UNIOutput_Mvs(p, v)</div>
<div class="line"><br /></div>
<div class="line">// v is a 1x16 int2 type matrix that stores the inter distortions as follows:</div>
<div class="line">// InterDistortion[0], InterDistortion[1], …, InterDistortion[15]</div>
<div class="line">VME_GET_UNIOutput_InterDistortion(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U4</div>
<div class="line">VME_GET_UNIOutput_FwdBlk0RefID(p, v)</div>
<div class="line">VME_GET_UNIOutput_BwdBlk0RefID(p, v)</div>
<div class="line">VME_GET_UNIOutput_FwdBlk1RefID(p, v)</div>
<div class="line">VME_GET_UNIOutput_BwdBlk1RefID(p, v)</div>
<div class="line">VME_GET_UNIOutput_FwdBlk2RefID(p, v)</div>
<div class="line">VME_GET_UNIOutput_BwdBlk2RefID(p, v)</div>
<div class="line">VME_GET_UNIOutput_FwdBlk3RefID(p, v)</div>
<div class="line">VME_GET_UNIOutput_BwdBlk3RefID(p, v)</div>
<div class="line"><br /></div>
<div class="line"><br /></div>
<div class="line">VME_GET_UNIOutput_Blk0LumaNZC(p, v)</div>
<div class="line">VME_GET_UNIOutput_Blk1LumaNZC(p, v)</div>
<div class="line">VME_GET_UNIOutput_Blk2LumaNZC(p, v)</div>
<div class="line">VME_GET_UNIOutput_Blk3LumaNZC(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U8</div>
<div class="line">VME_GET_UNIOutput_Blk0ChromaCbNZC(p, v)</div>
<div class="line">VME_GET_UNIOutput_Blk0ChromaCrNZC(p, v)</div>
<div class="line"><br /></div>
<div class="line">MODE_INTER_16X16 0x00</div>
<div class="line">MODE_INTER_16X8 0x01</div>
<div class="line">MODE_INTER_8X16 0x02</div>
<div class="line">MODE_INTER_8X8 0x03</div>
<div class="line">MODE_INTER_MINOR 0x03</div>
<div class="line">VME_GET_IMEOutput_InterMbMode(p, v)</div>
<div class="line"><br /></div>
<div class="line">MODE_INTRA_16X16 0x00</div>
<div class="line">MODE_INTRA_8X8 0x10</div>
<div class="line">MODE_INTRA_4X4 0x20</div>
<div class="line">MODE_INTRA_PCM 0x30</div>
<div class="line">VME_GET_IMEOutput_IntraMbMode(p, v)</div>
<div class="line"><br /></div>
<div class="line">MODE_FIELD_MB_POLARITY 0x80</div>
<div class="line">VME_GET_IMEOutput_FieldMbPolarityFlag(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_GET_IMEOutput_InterMbType(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_GET_IMEOutput_FieldMbFlag(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_GET_IMEOutput_IntraMbType(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_GET_IMEOutput_IntraMbType(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_GET_IMEOutput_MvQuantity(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U16</div>
<div class="line">VME_GET_IMEOutput_BestInterDistortion(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U16</div>
<div class="line">VME_GET_IMEOutput_SkipRawDistortion(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U16</div>
<div class="line">VME_GET_IMEOutput_BestIntraDistortion(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U16</div>
<div class="line">VME_GET_IMEOutput_BestChromaIntraDistortion(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_GET_IMEOutput_LumaIntraPredMode0(p, v)</div>
<div class="line">VME_GET_IMEOutput_LumaIntraPredMode1(p, v)</div>
<div class="line">VME_GET_IMEOutput_LumaIntraPredMode2(p, v)</div>
<div class="line">VME_GET_IMEOutput_LumaIntraPredMode3(p, v)</div>
<div class="line"><br /></div>
<div class="line">// 8-bit field with the following definition:</div>
<div class="line">// 7 Reserved : MBZ (for IntraPredAvailFlagF – F (pixel[-1,7] available for MbAff)</div>
<div class="line">// 6 Reserved : MBZ (for IntraPredAvailFlagA/E – A (left neighbor top half for MbAff)</div>
<div class="line">// 5 IntraPredAvailFlagE/A – A (Left neighbor or Left bottom half)</div>
<div class="line">// 4 IntraPredAvailFlagB – B (Upper neighbor)</div>
<div class="line">// 3 IntraPredAvailFlagC – C (Upper left neighbor)</div>
<div class="line">// 2 IntraPredAvailFlagD – D (Upper right neighbor)</div>
<div class="line">// 1:0 ChromaIntraPredMode</div>
<div class="line">VME_GET_IMEOutput_MbIntraStruct(p, v)</div>
<div class="line"><br /></div>
<div class="line">// 8-bit field with the following definition:</div>
<div class="line">// Bits [1:0]: SubMbShape[0]</div>
<div class="line">// Bits [3:2]: SubMbShape[1]</div>
<div class="line">// Bits [5:4]: SubMbShape[2]</div>
<div class="line">// Bits [7:6]: SubMbShape[3]</div>
<div class="line">VME_GET_IMEOutput_SubMbShape(p, v)</div>
<div class="line"><br /></div>
<div class="line">// 8-bit field with the following definition:</div>
<div class="line">// Bits [1:0]: SubMbPredMode[0]</div>
<div class="line">// Bits [3:2]: SubMbPredMode[1]</div>
<div class="line">// Bits [5:4]: SubMbPredMode[2]</div>
<div class="line">// Bits [7:6]: SubMbPredMode[3]</div>
<div class="line">VME_GET_IMEOutput_SubMbPredMode(p, v)</div>
<div class="line"><br /></div>
<div class="line">// v is a 4x16 int2 type matrix that stores the motion vectors as follows:</div>
<div class="line">// MVa[0].x, MVa[0].y, MVb[0].x, MVb[0].x</div>
<div class="line">// MVa[1].x, MVa[1].y, MVb[1].x, MVb[1].x</div>
<div class="line">// …</div>
<div class="line">// MVa[15].x, MVa[15].y, MVb[15].x, MVb[15].x</div>
<div class="line">VME_GET_IMEOutput_Mvs(p, v)</div>
<div class="line"><br /></div>
<div class="line">// v is a 1x16 int2 type matrix that stores the inter distortions as follows:</div>
<div class="line">// InterDistortion[0], InterDistortion[1], …, InterDistortion[15]</div>
<div class="line">VME_GET_IMEOutput_InterDistortion(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U4</div>
<div class="line">VME_GET_IMEOutput_FwdBlk0RefID(p, v)</div>
<div class="line">VME_GET_IMEOutput_BwdBlk0RefID(p, v)</div>
<div class="line">VME_GET_IMEOutput_FwdBlk1RefID(p, v)</div>
<div class="line">VME_GET_IMEOutput_BwdBlk1RefID(p, v)</div>
<div class="line">VME_GET_IMEOutput_FwdBlk2RefID(p, v)</div>
<div class="line">VME_GET_IMEOutput_BwdBlk2RefID(p, v)</div>
<div class="line">VME_GET_IMEOutput_FwdBlk3RefID(p, v)</div>
<div class="line">VME_GET_IMEOutput_BwdBlk3RefID(p, v)</div>
<div class="line"><br /></div>
<div class="line"><br /></div>
<div class="line">VME_GET_IMEOutput_Blk0LumaNZC(p, v)</div>
<div class="line">VME_GET_IMEOutput_Blk1LumaNZC(p, v)</div>
<div class="line">VME_GET_IMEOutput_Blk2LumaNZC(p, v)</div>
<div class="line">VME_GET_IMEOutput_Blk3LumaNZC(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U8</div>
<div class="line">VME_GET_IMEOutput_Blk0ChromaCbNZC(p, v)</div>
<div class="line">VME_GET_IMEOutput_Blk0ChromaCrNZC(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U16</div>
<div class="line">VME_GET_IMEOutput_Rec0_16x8_0Distortion(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec0_16x8_1Distortion(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec0_8x16_0Distortion(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec0_8x16_1Distortion(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec0_8x8_0Distortion(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec0_8x8_1Distortion(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec0_8x8_2Distortion(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec0_8x8_3Distortion(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec0_16x16_Distortion(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U4</div>
<div class="line">VME_GET_IMEOutput_Rec0_16x16_RefID(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U16</div>
<div class="line">VME_GET_IMEOutput_Rec0_16x16_X(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec0_16x16_Y(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U4</div>
<div class="line">VME_GET_IMEOutput_Rec0_16x8_0RefID(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec0_16x8_1RefID(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec0_8x16_0RefID(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec0_8x16_1RefID(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec0_8x8_0RefID(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec0_8x8_1RefID(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec0_8x8_2RefID(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec0_8x8_3RefID(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U16</div>
<div class="line">VME_GET_IMEOutput_Rec0_16x8_0X(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec0_16x8_0Y(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec0_16x8_1X(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec0_16x8_1Y(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec0_8x16_0X(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec0_8x16_0Y(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec0_8x16_1X(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec0_8x16_1Y(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec0_8x8_0X(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec0_8x8_0Y(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec0_8x8_1X(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec0_8x8_1Y(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec0_8x8_2X(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec0_8x8_2Y(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec0_8x8_3X(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec0_8x8_3Y(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U16</div>
<div class="line">VME_GET_IMEOutput_Rec1_16x8_0Distortion(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec1_16x8_1Distortion(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec1_8x16_0Distortion(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec1_8x16_1Distortion(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec1_8x8_0Distortion(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec1_8x8_1Distortion(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec1_8x8_2Distortion(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec1_8x8_3Distortion(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec1_16x16_Distortion(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U4</div>
<div class="line">VME_GET_IMEOutput_Rec1_16x16_RefID(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U16</div>
<div class="line">VME_GET_IMEOutput_Rec1_16x16_X(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec1_16x16_Y(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U4</div>
<div class="line">VME_GET_IMEOutput_Rec1_16x8_0RefID(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec1_16x8_1RefID(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec1_8x16_0RefID(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec1_8x16_1RefID(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec1_8x8_0RefID(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec1_8x8_1RefID(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec1_8x8_2RefID(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec1_8x8_3RefID(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U16</div>
<div class="line">VME_GET_IMEOutput_Rec1_16x8_0X(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec1_16x8_0Y(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec1_16x8_1X(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec1_16x8_1Y(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec1_8x16_0X(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec1_8x16_0Y(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec1_8x16_1X(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec1_8x16_1Y(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec1_8x8_0X(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec1_8x8_0Y(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec1_8x8_1X(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec1_8x8_1Y(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec1_8x8_2X(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec1_8x8_2Y(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec1_8x8_3X(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec1_8x8_3Y(p, v)</div>
</div>
</div>
</div>
<div class="section" id="vme-interface-access-macros-for-gen8">
<h3><a class="toc-backref" href="#id84">VME Interface Access Macros for Gen8</a><a class="headerlink" href="#vme-interface-access-macros-for-gen8" title="Permalink to this headline">¶</a></h3>
<p>The formats of input/output access macros are similar to those defined for Gen6. The types of
input/output data variables are specified in Section 4.12.4.</p>
<div class="section" id="id27">
<h4>List of Input Access Macros<a class="headerlink" href="#id27" title="Permalink to this headline">¶</a></h4>
<div class="line-block">
<div class="line">// Format = S15</div>
<div class="line">VME_SET_UNIInput_Ref0X(p, v)</div>
<div class="line">VME_SET_UNIInput_Ref0Y(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = S15</div>
<div class="line">VME_SET_UNIInput_Ref1X(p, v)</div>
<div class="line">VME_SET_UNIInput_Ref1Y(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U16</div>
<div class="line">VME_SET_UNIInput_SrcX(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U16</div>
<div class="line">VME_SET_UNIInput_SrcY(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Set - FieldBased</div>
<div class="line">// Clear - FrameBased</div>
<div class="line">VME_SET_UNIInput_SrcAccess(p)</div>
<div class="line">VME_CLEAR_UNIInput_SrcAccess(p)</div>
<div class="line"><br /></div>
<div class="line">// Set - FieldBased</div>
<div class="line">// Clear - FrameBased</div>
<div class="line">VME_SET_UNIInput_RefAccess(p)</div>
<div class="line">VME_CLEAR_UNIInput_RefAccess(p)</div>
<div class="line"><br /></div>
<div class="line">// Set - different paths</div>
<div class="line">// Clear - same path</div>
<div class="line">VME_SET_UNIInput_DualSearchPath(p)</div>
<div class="line">VME_CLEAR_UNIInput_DualSearchPath(p)</div>
<div class="line"><br /></div>
<div class="line">// INT_MODE 0x0</div>
<div class="line">// HALF_PEL_MODE 0x1</div>
<div class="line">// QUARTER_PEL_MODE 0x3</div>
<div class="line">VME_SET_UNIInput_SubPelMode(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Set - 4MVP</div>
<div class="line">// Clear - 1MVP</div>
<div class="line">VME_SET_UNIInput_SkipModeType(p)</div>
<div class="line">VME_CLEAR_UNIInput_SkipModeType(p)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_UNIInput_DisableFieldCacheAllocation(p)</div>
<div class="line">VME_CLEAR_UNIInput_DisableFieldCacheAllocation(p)</div>
<div class="line"><br /></div>
<div class="line">// Set - Chroma mode</div>
<div class="line">// Clear - Luma mode</div>
<div class="line">VME_SET_UNIInput_InterChromaMode(p)</div>
<div class="line">VME_CLEAR_UNIInput_InterChromaMode(p)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_UNIInput_FTEnable(p)</div>
<div class="line">VME_CLEAR_UNIInput_FTEnable(p)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_UNIInput_BMEDisableFBR(p)</div>
<div class="line">VME_CLEAR_UNIInput_BMEDisableFBR(p)</div>
<div class="line"><br /></div>
<div class="line">// v is a 7-bit mask with the following definition:</div>
<div class="line">// xxxxxx1 : 16x16 sub-macroblock disabled</div>
<div class="line">// xxxxx1x : 2x(16x8) sub-macroblock within 16x16 disabled</div>
<div class="line">// xxxx1xx : 2x(8x16) sub-macroblock within 16x16 disabled</div>
<div class="line">// xxx1xxx : 1x(8x8) sub-partition for 4x(8x8) within 16x16 disabled</div>
<div class="line">// xx1xxxx : 2x(8x4) sub-partition for 4x(8x8) within 16x16 disabled</div>
<div class="line">// x1xxxxx : 2x(4x8) sub-partition for 4x(8x8) within 16x16 disabled</div>
<div class="line">// 1xxxxxx : 4x(4x4) sub-partition for 4x(8x8) within 16x16 disabled</div>
<div class="line">VME_SET_UNIInput_SubMbPartMask(p, v)</div>
<div class="line"><br /></div>
<div class="line">// The value must be a multiple of 4. Range = [20, 64]</div>
<div class="line">VME_SET_UNIInput_RefW(p, v)</div>
<div class="line"><br /></div>
<div class="line">// The value must be a multiple of 4. Range = [20, 64]</div>
<div class="line">VME_SET_UNIInput_RefH(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_UNIInput_SkipModeEn(p)</div>
<div class="line">VME_CLEAR_UNIInput_SkipModeEn(p)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_UNIInput_AdaptiveEn(p)</div>
<div class="line">VME_CLEAR_UNIInput_AdaptiveEn(p)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_UNIInput_EarlyImeSuccessEn(p)</div>
<div class="line">VME_CLEAR_UNIInput_EarlyImeSuccessEn(p)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_UNIInput_T8x8FlagForInterEn(p)</div>
<div class="line">VME_CLEAR_UNIInput_T8x8FlagForInterEn(p)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_UNIInput_EarlyImeStop(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_UNIInput_MaxNumMVs(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_UNIInput_Ref0Polarity(p, v)</div>
<div class="line">VME_SET_UNIInput_Ref1Polarity(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U6, Valid Values: [16, 21, 32, 43, 48]</div>
<div class="line">VME_SET_UNIInput_BiWeight(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_UNIInput_RefPixelBiasEnable(p)</div>
<div class="line">VME_CLEAR_UNIInput_RefPixelBiasEnable(p)</div>
<div class="line"><br /></div>
<div class="line">// Format = U8, Valid range [1,63]</div>
<div class="line">VME_SET_UNIInput_LenSP(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U8, Valid range [1,63]</div>
<div class="line">VME_SET_UNIInput_MaxNumSU(p, v)</div>
<div class="line">// Format = U4</div>
<div class="line">VME_SET_UNIInput_StartCenter0(p, StartCenter0X, StartCenter0Y)</div>
<div class="line"><br /></div>
<div class="line">// Format = U4</div>
<div class="line">VME_SET_UNIInput_StartCenter1(p, StartCenter1X, StartCenter1Y)</div>
<div class="line"><br /></div>
<div class="line">// Format = U8</div>
<div class="line">VME_SET_UNIInput_WeightedSADCtrl0_3(p, v)</div>
<div class="line">VME_SET_UNIInput_WeightedSADCtrl4_7(p, v)</div>
<div class="line">VME_SET_UNIInput_WeightedSADCtrl8_11(p, v)</div>
<div class="line">VME_SET_UNIInput_WeightedSADCtrl12_15(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U4</div>
<div class="line">VME_SET_UNIInput_Blk0RefID(p, FwdBlk0RefID, BwdBlk0RefID)</div>
<div class="line"><br /></div>
<div class="line">// Format = U4</div>
<div class="line">VME_SET_UNIInput_Blk1RefID(p, FwdBlk1RefID, BwdBlk1RefID)</div>
<div class="line"><br /></div>
<div class="line">// Format = U4</div>
<div class="line">VME_SET_UNIInput_Blk2RefID(p, FwdBlk2RefID, BwdBlk2RefID)</div>
<div class="line"><br /></div>
<div class="line">// Format = U4</div>
<div class="line">VME_SET_UNIInput_Blk3RefID(p, FwdBlk3RefID, BwdBlk3RefID)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_UNIInput_IntraFlags(p, v)</div>
<div class="line"><br /></div>
<div class="line">// v is a 8-bit mask with the following definition:</div>
<div class="line">// Bit-7 Reserved : MBZ (for IntraPredAvailFlagF – F (pixel[-1,7] available for MbAff)</div>
<div class="line">// Bit-6 Reserved : MBZ (for IntraPredAvailFlagA/E – A (left neighbor top half for MbAff)</div>
<div class="line">// Bit-5 IntraPredAvailFlagE/A – A (Left neighbor or Left bottom half)</div>
<div class="line">// Bit-4 IntraPredAvailFlagB – B (Upper neighbor)</div>
<div class="line">// Bit-3 IntraPredAvailFlagC – C (Upper left neighbor)</div>
<div class="line">// Bit-2 IntraPredAvailFlagD – D (Upper right neighbor)</div>
<div class="line">// Bit-1:0 Reserved: MBZ (ChromaIntraPredMode)</div>
<div class="line">VME_SET_UNIInput_MbIntraStruct(p, v)</div>
<div class="line"><br /></div>
<div class="line"><br /></div>
<div class="line">// v is a 2-bit value:</div>
<div class="line">// 00: qpel [Qpel difference between MV and cost center: eff cost range 0-15pel]</div>
<div class="line">// 01: hpel [Hpel difference between MV and cost center: eff cost range 0-31pel]</div>
<div class="line">// 10: pel  [Pel  difference between MV and cost center: eff cost range 0-63pel]</div>
<div class="line">// 11: 2pel [2Pel difference between MV and cost center: eff cost range 0-127pel]</div>
<div class="line">VME_SET_UNIInput_MVCostScaleFactor(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_UNIInput_SrcFieldPolarity(p)</div>
<div class="line">VME_CLEAR_UNIInput_SrcFieldPolarity(p)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_UNIInput_BilinearEnable(p)</div>
<div class="line">VME_CLEAR_UNIInput_BilinearEnable(p)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_UNIInput_WeightedSADHAAR(p)</div>
<div class="line">VME_CLEAR_UNIInput_WeightedSADHAAR(p)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_UNIInput_AConlyHAAR(p)</div>
<div class="line">VME_CLEAR_UNIInput_AConlyHAAR(p)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_UNIInput_RefIDCostMode(p)</div>
<div class="line">VME_CLEAR_UNIInput_RefIDCostMode(p)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_UNIInput_IDMShapeMode(p)</div>
<div class="line">VME_CLEAR_UNIInput_IDMShapeMode(p)</div>
<div class="line"><br /></div>
<div class="line"><br /></div>
<div class="line">// v is a 8-bit mask with the following definition:</div>
<div class="line">// xxxx xxx1: Ref0 Skip Center 0 is enabled [corresponds to M2.0]</div>
<div class="line">// xxxx xx1x: Ref1 Skip Center 0 is enabled [corresponds to M2.1]</div>
<div class="line">// xxxx x1xx: Ref0 Skip Center 1 is enabled [corresponds to M2.2]</div>
<div class="line">// xxxx 1xxx: Ref1 Skip Center 1 is enabled [corresponds to M2.3]</div>
<div class="line">// xxx1 xxxx: Ref0 Skip Center 2 is enabled [corresponds to M2.4]</div>
<div class="line">// xx1x xxxx: Ref1 Skip Center 2 is enabled [corresponds to M2.5]</div>
<div class="line">// x1xx xxxx: Ref0 Skip Center 3 is enabled [corresponds to M2.6]</div>
<div class="line">// 1xxx xxxx: Ref1 Skip Center 3 is enabled [corresponds to M2.7]</div>
<div class="line">VME_SET_UNIInput_SkipCenterMask(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U4U4 (encoded value must fit in 12-bits)</div>
<div class="line">VME_SET_UNIInput_Mode0Cost(p, v)</div>
<div class="line">VME_SET_UNIInput_Mode1Cost(p, v)</div>
<div class="line">VME_SET_UNIInput_Mode2Cost(p, v)</div>
<div class="line">VME_SET_UNIInput_Mode3Cost(p, v)</div>
<div class="line">VME_SET_UNIInput_Mode4Cost(p, v)</div>
<div class="line">VME_SET_UNIInput_Mode5Cost(p, v)</div>
<div class="line">VME_SET_UNIInput_Mode6Cost(p, v)</div>
<div class="line">VME_SET_UNIInput_Mode7Cost(p, v)</div>
<div class="line">VME_SET_UNIInput_Mode8Cost(p, v)</div>
<div class="line">VME_SET_UNIInput_Mode9Cost(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U4U4 (encoded value must fit in 12-bits)</div>
<div class="line">VME_SET_UNIInput_RefIDCost(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U4U4 (encoded value must fit in 12-bits)</div>
<div class="line">VME_SET_UNIInput_ChromaIntraModeCost(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U4U4 (encoded value must fit in 10-bits)</div>
<div class="line">VME_SET_UNIInput_MV0Cost(p, v)</div>
<div class="line">VME_SET_UNIInput_MV1Cost(p, v)</div>
<div class="line">VME_SET_UNIInput_MV2Cost(p, v)</div>
<div class="line">VME_SET_UNIInput_MV3Cost(p, v)</div>
<div class="line">VME_SET_UNIInput_MV4Cost(p, v)</div>
<div class="line">VME_SET_UNIInput_MV5Cost(p, v)</div>
<div class="line">VME_SET_UNIInput_MV6Cost(p, v)</div>
<div class="line">VME_SET_UNIInput_MV7Cost(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U8</div>
<div class="line">VME_SET_UNIInput_FBRMbModeInput(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U8</div>
<div class="line">VME_SET_UNIInput_FBRSubMBShapeInput(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U8</div>
<div class="line">VME_SET_UNIInput_FBRSubPredModeInput(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U16</div>
<div class="line">VME_SET_UNIInput_SICFwdTCoeffThreshold0(p, v)</div>
<div class="line">// Format = U8</div>
<div class="line">VME_SET_UNIInput_SICFwdTCoeffThreshold1(p, v)</div>
<div class="line">VME_SET_UNIInput_SICFwdTCoeffThreshold2(p, v)</div>
<div class="line">VME_SET_UNIInput_SICFwdTCoeffThreshold3(p, v)</div>
<div class="line">VME_SET_UNIInput_SICFwdTCoeffThreshold4(p, v)</div>
<div class="line">VME_SET_UNIInput_SICFwdTCoeffThreshold5(p, v)</div>
<div class="line">VME_SET_UNIInput_SICFwdTCoeffThreshold6(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = S13.2, DletaX Valid Range: [-2048.00 to 2047.75], DletaY Valid Range: [-512.00 to 511.75]</div>
<div class="line">VME_SET_UNIInput_FWDCostCenter0(p, DeltaX, DeltaY)</div>
<div class="line">VME_SET_UNIInput_BWDCostCenter0(p, DeltaX, DeltaY)</div>
<div class="line">VME_SET_UNIInput_FWDCostCenter1(p, DeltaX, DeltaY)</div>
<div class="line">VME_SET_UNIInput_BWDCostCenter1(p, DeltaX, DeltaY)</div>
<div class="line">VME_SET_UNIInput_FWDCostCenter2(p, DeltaX, DeltaY)</div>
<div class="line">VME_SET_UNIInput_BWDCostCenter2(p, DeltaX, DeltaY)</div>
<div class="line">VME_SET_UNIInput_FWDCostCenter3(p, DeltaX, DeltaY)</div>
<div class="line">VME_SET_UNIInput_BWDCostCenter3(p, DeltaX, DeltaY)</div>
<div class="line"><br /></div>
<div class="line">// Format = U8, with the following definition:</div>
<div class="line">// [7:4] (Y) – specifies relative Y distance to the next SU from previous SU in units of SU</div>
<div class="line">// [3:0] (X) – specifies relative X distance to the next SU from previous SU in units of SU</div>
<div class="line">// Format = U8, with the following definition:</div>
<div class="line">// [7:4] (Y) – specifies relative Y distance to the next SU from previous SU in units of SU</div>
<div class="line">// [3:0] (X) – specifies relative X distance to the next SU from previous SU in units of SU</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta0(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta1(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta2(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta3(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta4(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta5(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta6(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta7(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta8(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta9(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta10(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta11(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta12(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta13(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta14(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta15(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta16(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta17(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta18(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta19(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta20(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta21(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta22(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta23(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta24(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta25(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta26(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta27(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta28(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta29(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta30(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta31(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta32(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta33(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta34(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta35(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta36(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta37(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta38(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta39(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta40(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta41(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta42(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta43(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta44(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta45(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta46(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta47(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta48(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta49(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta50(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta51(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta52(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta53(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta54(p, v)</div>
<div class="line">VME_SET_IMEInput_IMESearchPathDelta55(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U16</div>
<div class="line">VME_SET_IMEInput_Rec0_16x8_0Distortion(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec0_16x8_1Distortion(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec0_8x16_0Distortion(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec0_8x16_1Distortion(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec0_8x8_0Distortion(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec0_8x8_1Distortion(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec0_8x8_2Distortion(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec0_8x8_3Distortion(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec0_16x16_Distortion(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U4</div>
<div class="line">VME_SET_IMEInput_Rec0_16x16_RefID(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = S13.2</div>
<div class="line">VME_SET_IMEInput_Rec0_16x16_X(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec0_16x16_Y(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U4</div>
<div class="line">VME_SET_IMEInput_Rec0_16x8_0RefID(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec0_16x8_1RefID(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec0_8x16_0RefID(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec0_8x16_1RefID(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec0_8x8_0RefID(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec0_8x8_1RefID(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec0_8x8_2RefID(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec0_8x8_3RefID(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = S13.2</div>
<div class="line">VME_SET_IMEInput_Rec0_16x8_0X(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec0_16x8_0Y(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec0_16x8_1X(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec0_16x8_1Y(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec0_8x16_0X(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec0_8x16_0Y(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec0_8x16_1X(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec0_8x16_1Y(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec0_8x8_0X(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec0_8x8_0Y(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec0_8x8_1X(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec0_8x8_1Y(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec0_8x8_2X(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec0_8x8_2Y(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec0_8x8_3X(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec0_8x8_3Y(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U16</div>
<div class="line">VME_SET_IMEInput_Rec1_16x8_0Distortion(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec1_16x8_1Distortion(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec1_8x16_0Distortion(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec1_8x16_1Distortion(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec1_8x8_0Distortion(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec1_8x8_1Distortion(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec1_8x8_2Distortion(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec1_8x8_3Distortion(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec1_16x16_Distortion(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U4</div>
<div class="line">VME_SET_IMEInput_Rec1_16x16_RefID(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = S13.2</div>
<div class="line">VME_SET_IMEInput_Rec1_16x16_X(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec1_16x16_Y(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U4</div>
<div class="line">VME_SET_IMEInput_Rec1_16x8_0RefID(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec1_16x8_1RefID(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec1_8x16_0RefID(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec1_8x16_1RefID(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec1_8x8_0RefID(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec1_8x8_1RefID(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec1_8x8_2RefID(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec1_8x8_3RefID(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = S13.2</div>
<div class="line">VME_SET_IMEInput_Rec1_16x8_0X(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec1_16x8_0Y(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec1_16x8_1X(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec1_16x8_1Y(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec1_8x16_0X(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec1_8x16_0Y(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec1_8x16_1X(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec1_8x16_1Y(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec1_8x8_0X(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec1_8x8_0Y(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec1_8x8_1X(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec1_8x8_1Y(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec1_8x8_2X(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec1_8x8_2Y(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec1_8x8_3X(p, v)</div>
<div class="line">VME_SET_IMEInput_Rec1_8x8_3Y(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = S13.2, Valid Range: [-2048.00 to 2047.75]</div>
<div class="line">// For chroma skip: Format = S12.3, Hardware Range: [-1024.000 to 1023.875]</div>
<div class="line">VME_SET_SICInput_Ref0SkipCenter0DeltaXY(p, DeltaX, DeltaY)</div>
<div class="line">VME_SET_SICInput_Ref1SkipCenter0DeltaXY(p, DeltaX, DeltaY)</div>
<div class="line">VME_SET_SICInput_Ref0SkipCenter1DeltaXY(p, DeltaX, DeltaY)</div>
<div class="line">VME_SET_SICInput_Ref1SkipCenter1DeltaXY(p, DeltaX, DeltaY)</div>
<div class="line">VME_SET_SICInput_Ref0SkipCenter2DeltaXY(p, DeltaX, DeltaY)</div>
<div class="line">VME_SET_SICInput_Ref1SkipCenter2DeltaXY(p, DeltaX, DeltaY)</div>
<div class="line">VME_SET_SICInput_Ref0SkipCenter3DeltaXY(p, DeltaX, DeltaY)</div>
<div class="line">VME_SET_SICInput_Ref1SkipCenter3DeltaXY(p, DeltaX, DeltaY)</div>
<div class="line"><br /></div>
<div class="line">// 2-bit field with the following definition</div>
<div class="line">// 00: Luma + Chroma enabled</div>
<div class="line">// 01: Luma only</div>
<div class="line">// 1X: Intra disabled</div>
<div class="line">VME_SET_SICInput_IntraComputeType(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_SICInput_CornerNeighborPixel0(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_SICInput_NeighborPixelLum0(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelLum1(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelLum2(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelLum3(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelLum4(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelLum5(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelLum6(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelLum7(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelLum8(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelLum9(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelLum10(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelLum11(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelLum12(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelLum13(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelLum14(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelLum15(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelLum16(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelLum17(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelLum18(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelLum19(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelLum20(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelLum21(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelLum22(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelLum23(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelLum24(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelLum25(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelLum26(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelLum27(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelLum28(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelLum29(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelLum30(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelLum31(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelLum32(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelLum33(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelLum34(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelLum35(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelLum36(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelLum37(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelLum38(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_SICInput_CornerNeighborPixel1(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U4</div>
<div class="line">VME_SET_SICInput_IntraMxMPredModeA5(p, v)</div>
<div class="line">VME_SET_SICInput_IntraMxMPredModeA7(p, v)</div>
<div class="line">VME_SET_SICInput_IntraMxMPredModeA13(p, v)</div>
<div class="line">VME_SET_SICInput_IntraMxMPredModeA15(p, v)</div>
<div class="line">VME_SET_SICInput_IntraMxMPredModeB10(p, v)</div>
<div class="line">VME_SET_SICInput_IntraMxMPredModeB11(p, v)</div>
<div class="line">VME_SET_SICInput_IntraMxMPredModeB14(p, v)</div>
<div class="line">VME_SET_SICInput_IntraMxMPredModeB15(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U8 pair</div>
<div class="line">VME_SET_SICInput_CornerNeighborPixelChroma(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U8</div>
<div class="line">VME_SET_SICInput_PenaltyIntra4x4NonDC(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U8</div>
<div class="line">VME_SET_SICInput_PenaltyIntra8x8NonDC(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U8</div>
<div class="line">VME_SET_SICInput_PenaltyIntra16x16NonDC(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_SICInput_NeighborPixelChroma0(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelChroma1(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelChroma2(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelChroma3(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_SICInput_NeighborPixelChroma4(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelChroma5(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelChroma6(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelChroma7(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_SICInput_NeighborPixelChroma8(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelChroma9(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelChroma10(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelChroma11(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_SICInput_NeighborPixelChroma12(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelChroma13(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelChroma14(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelChroma15(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_SICInput_NeighborPixelChroma16(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelChroma17(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelChroma18(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelChroma19(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_SICInput_NeighborPixelChroma20(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelChroma21(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelChroma22(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelChroma23(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_SICInput_NeighborPixelChroma24(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelChroma25(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelChroma26(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelChroma27(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_SICInput_NeighborPixelChroma28(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelChroma29(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelChroma30(p, v)</div>
<div class="line">VME_SET_SICInput_NeighborPixelChroma31(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_FBRInput_Ref0SubBlockX0(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref0SubBlockY0(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref1SubBlockX0(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref1SubBlockY0(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_FBRInput_Ref0SubBlockX1(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref0SubBlockY1(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref1SubBlockX1(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref1SubBlockY1(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_FBRInput_Ref0SubBlockX2(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref0SubBlockY2(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref1SubBlockX2(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref1SubBlockY2(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_FBRInput_Ref0SubBlockX3(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref0SubBlockY3(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref1SubBlockX3(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref1SubBlockY3(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_FBRInput_Ref0SubBlockX4(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref0SubBlockY4(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref1SubBlockX4(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref1SubBlockY4(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_FBRInput_Ref0SubBlockX5(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref0SubBlockY5(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref1SubBlockX5(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref1SubBlockY5(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_FBRInput_Ref0SubBlockX6(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref0SubBlockY6(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref1SubBlockX6(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref1SubBlockY6(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_FBRInput_Ref0SubBlockX7(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref0SubBlockY7(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref1SubBlockX7(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref1SubBlockY7(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_FBRInput_Ref0SubBlockX8(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref0SubBlockY8(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref1SubBlockX8(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref1SubBlockY8(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_FBRInput_Ref0SubBlockX9(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref0SubBlockY9(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref1SubBlockX9(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref1SubBlockY9(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_FBRInput_Ref0SubBlockX10(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref0SubBlockY10(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref1SubBlockX10(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref1SubBlockY10(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_FBRInput_Ref0SubBlockX11(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref0SubBlockY11(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref1SubBlockX11(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref1SubBlockY11(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_FBRInput_Ref0SubBlockX12(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref0SubBlockY12(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref1SubBlockX12(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref1SubBlockY12(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_FBRInput_Ref0SubBlockX13(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref0SubBlockY13(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref1SubBlockX13(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref1SubBlockY13(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_FBRInput_Ref0SubBlockX14(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref0SubBlockY14(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref1SubBlockX14(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref1SubBlockY14(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_FBRInput_Ref0SubBlockX15(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref0SubBlockY15(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref1SubBlockX15(p, v)</div>
<div class="line">VME_SET_FBRInput_Ref1SubBlockY15(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_SET_IDMInput_SrcMBPixelMaskRow0(p, v)</div>
<div class="line">VME_SET_IDMInput_SrcMBPixelMaskRow1(p, v)</div>
<div class="line">VME_SET_IDMInput_SrcMBPixelMaskRow2(p, v)</div>
<div class="line">VME_SET_IDMInput_SrcMBPixelMaskRow3(p, v)</div>
<div class="line">VME_SET_IDMInput_SrcMBPixelMaskRow4(p, v)</div>
<div class="line">VME_SET_IDMInput_SrcMBPixelMaskRow5(p, v)</div>
<div class="line">VME_SET_IDMInput_SrcMBPixelMaskRow6(p, v)</div>
<div class="line">VME_SET_IDMInput_SrcMBPixelMaskRow7(p, v)</div>
<div class="line">VME_SET_IDMInput_SrcMBPixelMaskRow8(p, v)</div>
<div class="line">VME_SET_IDMInput_SrcMBPixelMaskRow9(p, v)</div>
<div class="line">VME_SET_IDMInput_SrcMBPixelMaskRow10(p, v)</div>
<div class="line">VME_SET_IDMInput_SrcMBPixelMaskRow11(p, v)</div>
<div class="line">VME_SET_IDMInput_SrcMBPixelMaskRow12(p, v)</div>
<div class="line">VME_SET_IDMInput_SrcMBPixelMaskRow13(p, v)</div>
<div class="line">VME_SET_IDMInput_SrcMBPixelMaskRow14(p, v)</div>
<div class="line">VME_SET_IDMInput_SrcMBPixelMaskRow15(p, v)</div>
</div>
</div>
<div class="section" id="id28">
<h4>List of Output Access Macros<a class="headerlink" href="#id28" title="Permalink to this headline">¶</a></h4>
<div class="line-block">
<div class="line">MODE_INTER_16X16 0x00</div>
<div class="line">MODE_INTER_16X8 0x01</div>
<div class="line">MODE_INTER_8X16 0x02</div>
<div class="line">MODE_INTER_8X8 0x03</div>
<div class="line">MODE_INTER_MINOR 0x03</div>
<div class="line">VME_GET_UNIOutput_InterMbMode(p, v)</div>
<div class="line"><br /></div>
<div class="line">MODE_INTRA_16X16 0x00</div>
<div class="line">MODE_INTRA_8X8 0x10</div>
<div class="line">MODE_INTRA_4X4 0x20</div>
<div class="line">MODE_INTRA_PCM 0x30</div>
<div class="line">VME_GET_UNIOutput_IntraMbMode(p, v)</div>
<div class="line"><br /></div>
<div class="line">MODE_FIELD_MB_POLARITY 0x80</div>
<div class="line">VME_GET_UNIOutput_FieldMbPolarityFlag(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_GET_UNIOutput_InterMbType(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_GET_UNIOutput_FieldMbFlag(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_GET_UNIOutput_IntraMbType(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_GET_UNIOutput_IntraMbType(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_GET_UNIOutput_MvQuantity(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U16</div>
<div class="line">VME_GET_UNIOutput_BestInterDistortion(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U16</div>
<div class="line">VME_GET_UNIOutput_SkipRawDistortion(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U16</div>
<div class="line">VME_GET_UNIOutput_BestIntraDistortion(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U16</div>
<div class="line">VME_GET_UNIOutput_BestChromaIntraDistortion(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_GET_UNIOutput_LumaIntraPredMode0(p, v)</div>
<div class="line">VME_GET_UNIOutput_LumaIntraPredMode1(p, v)</div>
<div class="line">VME_GET_UNIOutput_LumaIntraPredMode2(p, v)</div>
<div class="line">VME_GET_UNIOutput_LumaIntraPredMode3(p, v)</div>
<div class="line"><br /></div>
<div class="line">// 8-bit field with the following definition:</div>
<div class="line">// 7 Reserved : MBZ (for IntraPredAvailFlagF – F (pixel[-1,7] available for MbAff)</div>
<div class="line">// 6 Reserved : MBZ (for IntraPredAvailFlagA/E – A (left neighbor top half for MbAff)</div>
<div class="line">// 5 IntraPredAvailFlagE/A – A (Left neighbor or Left bottom half)</div>
<div class="line">// 4 IntraPredAvailFlagB – B (Upper neighbor)</div>
<div class="line">// 3 IntraPredAvailFlagC – C (Upper left neighbor)</div>
<div class="line">// 2 IntraPredAvailFlagD – D (Upper right neighbor)</div>
<div class="line">// 1:0 ChromaIntraPredMode</div>
<div class="line">VME_GET_UNIOutput_MbIntraStruct(p, v)</div>
<div class="line"><br /></div>
<div class="line">// 8-bit field with the following definition:</div>
<div class="line">// Bits [1:0]: SubMbShape[0]</div>
<div class="line">// Bits [3:2]: SubMbShape[1]</div>
<div class="line">// Bits [5:4]: SubMbShape[2]</div>
<div class="line">// Bits [7:6]: SubMbShape[3]</div>
<div class="line">VME_GET_UNIOutput_SubMbShape(p, v)</div>
<div class="line"><br /></div>
<div class="line">// 8-bit field with the following definition:</div>
<div class="line">// Bits [1:0]: SubMbPredMode[0]</div>
<div class="line">// Bits [3:2]: SubMbPredMode[1]</div>
<div class="line">// Bits [5:4]: SubMbPredMode[2]</div>
<div class="line">// Bits [7:6]: SubMbPredMode[3]</div>
<div class="line">VME_GET_UNIOutput_SubMbPredMode(p, v)</div>
<div class="line"><br /></div>
<div class="line">// v is a 4x16 int2 type matrix that stores the motion vectors as follows:</div>
<div class="line">// MVa[0].x, MVa[0].y, MVb[0].x, MVb[0].x</div>
<div class="line">// MVa[1].x, MVa[1].y, MVb[1].x, MVb[1].x</div>
<div class="line">// …</div>
<div class="line">// MVa[15].x, MVa[15].y, MVb[15].x, MVb[15].x</div>
<div class="line">VME_GET_UNIOutput_Mvs(p, v)</div>
<div class="line"><br /></div>
<div class="line">// v is a 1x16 int2 type matrix that stores the inter distortions as follows:</div>
<div class="line">// InterDistortion[0], InterDistortion[1], …, InterDistortion[15]</div>
<div class="line">VME_GET_UNIOutput_InterDistortion(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U4</div>
<div class="line">VME_GET_UNIOutput_FwdBlk0RefID(p, v)</div>
<div class="line">VME_GET_UNIOutput_BwdBlk0RefID(p, v)</div>
<div class="line">VME_GET_UNIOutput_FwdBlk1RefID(p, v)</div>
<div class="line">VME_GET_UNIOutput_BwdBlk1RefID(p, v)</div>
<div class="line">VME_GET_UNIOutput_FwdBlk2RefID(p, v)</div>
<div class="line">VME_GET_UNIOutput_BwdBlk2RefID(p, v)</div>
<div class="line">VME_GET_UNIOutput_FwdBlk3RefID(p, v)</div>
<div class="line">VME_GET_UNIOutput_BwdBlk3RefID(p, v)</div>
<div class="line"><br /></div>
<div class="line"><br /></div>
<div class="line">VME_GET_UNIOutput_Blk0LumaNZC(p, v)</div>
<div class="line">VME_GET_UNIOutput_Blk1LumaNZC(p, v)</div>
<div class="line">VME_GET_UNIOutput_Blk2LumaNZC(p, v)</div>
<div class="line">VME_GET_UNIOutput_Blk3LumaNZC(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U8</div>
<div class="line">VME_GET_UNIOutput_Blk0ChromaCbNZC(p, v)</div>
<div class="line">VME_GET_UNIOutput_Blk0ChromaCrNZC(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_GET_UNIOutput_SumInterDistL0(p, v)</div>
<div class="line">VME_GET_UNIOutput_SumInterDistL1(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_GET_UNIOutput_MaxRef0InterDist(p, v)</div>
<div class="line">VME_GET_UNIOutput_MaxRef1InterDist(p, v)</div>
<div class="line"><br /></div>
<div class="line">MODE_INTER_16X16 0x00</div>
<div class="line">MODE_INTER_16X8 0x01</div>
<div class="line">MODE_INTER_8X16 0x02</div>
<div class="line">MODE_INTER_8X8 0x03</div>
<div class="line">MODE_INTER_MINOR 0x03</div>
<div class="line">VME_GET_IMEOutput_InterMbMode(p, v)</div>
<div class="line"><br /></div>
<div class="line">MODE_INTRA_16X16 0x00</div>
<div class="line">MODE_INTRA_8X8 0x10</div>
<div class="line">MODE_INTRA_4X4 0x20</div>
<div class="line">MODE_INTRA_PCM 0x30</div>
<div class="line">VME_GET_IMEOutput_IntraMbMode(p, v)</div>
<div class="line"><br /></div>
<div class="line">MODE_FIELD_MB_POLARITY 0x80</div>
<div class="line">VME_GET_IMEOutput_FieldMbPolarityFlag(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_GET_IMEOutput_InterMbType(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_GET_IMEOutput_FieldMbFlag(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_GET_IMEOutput_IntraMbType(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_GET_IMEOutput_IntraMbType(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_GET_IMEOutput_MvQuantity(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U16</div>
<div class="line">VME_GET_IMEOutput_BestInterDistortion(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U16</div>
<div class="line">VME_GET_IMEOutput_SkipRawDistortion(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U16</div>
<div class="line">VME_GET_IMEOutput_BestIntraDistortion(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U16</div>
<div class="line">VME_GET_IMEOutput_BestChromaIntraDistortion(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_GET_IMEOutput_LumaIntraPredMode0(p, v)</div>
<div class="line">VME_GET_IMEOutput_LumaIntraPredMode1(p, v)</div>
<div class="line">VME_GET_IMEOutput_LumaIntraPredMode2(p, v)</div>
<div class="line">VME_GET_IMEOutput_LumaIntraPredMode3(p, v)</div>
<div class="line"><br /></div>
<div class="line">// 8-bit field with the following definition:</div>
<div class="line">// 7 Reserved : MBZ (for IntraPredAvailFlagF – F (pixel[-1,7] available for MbAff)</div>
<div class="line">// 6 Reserved : MBZ (for IntraPredAvailFlagA/E – A (left neighbor top half for MbAff)</div>
<div class="line">// 5 IntraPredAvailFlagE/A – A (Left neighbor or Left bottom half)</div>
<div class="line">// 4 IntraPredAvailFlagB – B (Upper neighbor)</div>
<div class="line">// 3 IntraPredAvailFlagC – C (Upper left neighbor)</div>
<div class="line">// 2 IntraPredAvailFlagD – D (Upper right neighbor)</div>
<div class="line">// 1:0 ChromaIntraPredMode</div>
<div class="line">VME_GET_IMEOutput_MbIntraStruct(p, v)</div>
<div class="line"><br /></div>
<div class="line">// 8-bit field with the following definition:</div>
<div class="line">// Bits [1:0]: SubMbShape[0]</div>
<div class="line">// Bits [3:2]: SubMbShape[1]</div>
<div class="line">// Bits [5:4]: SubMbShape[2]</div>
<div class="line">// Bits [7:6]: SubMbShape[3]</div>
<div class="line">VME_GET_IMEOutput_SubMbShape(p, v)</div>
<div class="line"><br /></div>
<div class="line">// 8-bit field with the following definition:</div>
<div class="line">// Bits [1:0]: SubMbPredMode[0]</div>
<div class="line">// Bits [3:2]: SubMbPredMode[1]</div>
<div class="line">// Bits [5:4]: SubMbPredMode[2]</div>
<div class="line">// Bits [7:6]: SubMbPredMode[3]</div>
<div class="line">VME_GET_IMEOutput_SubMbPredMode(p, v)</div>
<div class="line"><br /></div>
<div class="line">// v is a 4x16 int2 type matrix that stores the motion vectors as follows:</div>
<div class="line">// MVa[0].x, MVa[0].y, MVb[0].x, MVb[0].x</div>
<div class="line">// MVa[1].x, MVa[1].y, MVb[1].x, MVb[1].x</div>
<div class="line">// …</div>
<div class="line">// MVa[15].x, MVa[15].y, MVb[15].x, MVb[15].x</div>
<div class="line">VME_GET_IMEOutput_Mvs(p, v)</div>
<div class="line"><br /></div>
<div class="line">// v is a 1x16 int2 type matrix that stores the inter distortions as follows:</div>
<div class="line">// InterDistortion[0], InterDistortion[1], …, InterDistortion[15]</div>
<div class="line">VME_GET_IMEOutput_InterDistortion(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U4</div>
<div class="line">VME_GET_IMEOutput_FwdBlk0RefID(p, v)</div>
<div class="line">VME_GET_IMEOutput_BwdBlk0RefID(p, v)</div>
<div class="line">VME_GET_IMEOutput_FwdBlk1RefID(p, v)</div>
<div class="line">VME_GET_IMEOutput_BwdBlk1RefID(p, v)</div>
<div class="line">VME_GET_IMEOutput_FwdBlk2RefID(p, v)</div>
<div class="line">VME_GET_IMEOutput_BwdBlk2RefID(p, v)</div>
<div class="line">VME_GET_IMEOutput_FwdBlk3RefID(p, v)</div>
<div class="line">VME_GET_IMEOutput_BwdBlk3RefID(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_GET_IMEOutput_Blk0LumaNZC(p, v)</div>
<div class="line">VME_GET_IMEOutput_Blk1LumaNZC(p, v)</div>
<div class="line">VME_GET_IMEOutput_Blk2LumaNZC(p, v)</div>
<div class="line">VME_GET_IMEOutput_Blk3LumaNZC(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U8</div>
<div class="line">VME_GET_IMEOutput_Blk0ChromaCbNZC(p, v)</div>
<div class="line">VME_GET_IMEOutput_Blk0ChromaCrNZC(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U16</div>
<div class="line">VME_GET_IMEOutput_Rec0_16x8_0Distortion(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec0_16x8_1Distortion(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec0_8x16_0Distortion(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec0_8x16_1Distortion(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec0_8x8_0Distortion(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec0_8x8_1Distortion(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec0_8x8_2Distortion(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec0_8x8_3Distortion(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec0_16x16_Distortion(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U4</div>
<div class="line">VME_GET_IMEOutput_Rec0_16x16_RefID(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U16</div>
<div class="line">VME_GET_IMEOutput_Rec0_16x16_X(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec0_16x16_Y(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U4</div>
<div class="line">VME_GET_IMEOutput_Rec0_16x8_0RefID(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec0_16x8_1RefID(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec0_8x16_0RefID(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec0_8x16_1RefID(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec0_8x8_0RefID(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec0_8x8_1RefID(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec0_8x8_2RefID(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec0_8x8_3RefID(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U16</div>
<div class="line">VME_GET_IMEOutput_Rec0_16x8_0X(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec0_16x8_0Y(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec0_16x8_1X(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec0_16x8_1Y(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec0_8x16_0X(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec0_8x16_0Y(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec0_8x16_1X(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec0_8x16_1Y(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec0_8x8_0X(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec0_8x8_0Y(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec0_8x8_1X(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec0_8x8_1Y(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec0_8x8_2X(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec0_8x8_2Y(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec0_8x8_3X(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec0_8x8_3Y(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U16</div>
<div class="line">VME_GET_IMEOutput_Rec1_16x8_0Distortion(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec1_16x8_1Distortion(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec1_8x16_0Distortion(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec1_8x16_1Distortion(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec1_8x8_0Distortion(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec1_8x8_1Distortion(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec1_8x8_2Distortion(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec1_8x8_3Distortion(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec1_16x16_Distortion(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U4</div>
<div class="line">VME_GET_IMEOutput_Rec1_16x16_RefID(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U16</div>
<div class="line">VME_GET_IMEOutput_Rec1_16x16_X(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec1_16x16_Y(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U4</div>
<div class="line">VME_GET_IMEOutput_Rec1_16x8_0RefID(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec1_16x8_1RefID(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec1_8x16_0RefID(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec1_8x16_1RefID(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec1_8x8_0RefID(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec1_8x8_1RefID(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec1_8x8_2RefID(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec1_8x8_3RefID(p, v)</div>
<div class="line"><br /></div>
<div class="line">// Format = U16</div>
<div class="line">VME_GET_IMEOutput_Rec1_16x8_0X(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec1_16x8_0Y(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec1_16x8_1X(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec1_16x8_1Y(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec1_8x16_0X(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec1_8x16_0Y(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec1_8x16_1X(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec1_8x16_1Y(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec1_8x8_0X(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec1_8x8_0Y(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec1_8x8_1X(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec1_8x8_1Y(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec1_8x8_2X(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec1_8x8_2Y(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec1_8x8_3X(p, v)</div>
<div class="line">VME_GET_IMEOutput_Rec1_8x8_3Y(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock0_SearchPoint0(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock0_SearchPoint1(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock0_SearchPoint2(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock0_SearchPoint3(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock0_SearchPoint4(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock0_SearchPoint5(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock0_SearchPoint6(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock0_SearchPoint7(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock0_SearchPoint8(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock0_SearchPoint9(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock0_SearchPoint10(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock0_SearchPoint11(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock0_SearchPoint12(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock0_SearchPoint13(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock0_SearchPoint14(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock0_SearchPoint15(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock1_SearchPoint0(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock1_SearchPoint1(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock1_SearchPoint2(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock1_SearchPoint3(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock1_SearchPoint4(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock1_SearchPoint5(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock1_SearchPoint6(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock1_SearchPoint7(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock1_SearchPoint8(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock1_SearchPoint9(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock1_SearchPoint10(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock1_SearchPoint11(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock1_SearchPoint12(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock1_SearchPoint13(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock1_SearchPoint14(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock1_SearchPoint15(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock2_SearchPoint0(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock2_SearchPoint1(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock2_SearchPoint2(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock2_SearchPoint3(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock2_SearchPoint4(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock2_SearchPoint5(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock2_SearchPoint6(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock2_SearchPoint7(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock2_SearchPoint8(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock2_SearchPoint9(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock2_SearchPoint10(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock2_SearchPoint11(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock2_SearchPoint12(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock2_SearchPoint13(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock2_SearchPoint14(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock2_SearchPoint15(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock3_SearchPoint0(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock3_SearchPoint1(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock3_SearchPoint2(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock3_SearchPoint3(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock3_SearchPoint4(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock3_SearchPoint5(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock3_SearchPoint6(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock3_SearchPoint7(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock3_SearchPoint8(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock3_SearchPoint9(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock3_SearchPoint10(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock3_SearchPoint11(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock3_SearchPoint12(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock3_SearchPoint13(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock3_SearchPoint14(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock3_SearchPoint15(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock4_SearchPoint0(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock4_SearchPoint1(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock4_SearchPoint2(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock4_SearchPoint3(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock4_SearchPoint4(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock4_SearchPoint5(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock4_SearchPoint6(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock4_SearchPoint7(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock4_SearchPoint8(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock4_SearchPoint9(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock4_SearchPoint10(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock4_SearchPoint11(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock4_SearchPoint12(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock4_SearchPoint13(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock4_SearchPoint14(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock4_SearchPoint15(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock5_SearchPoint0(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock5_SearchPoint1(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock5_SearchPoint2(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock5_SearchPoint3(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock5_SearchPoint4(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock5_SearchPoint5(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock5_SearchPoint6(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock5_SearchPoint7(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock5_SearchPoint8(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock5_SearchPoint9(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock5_SearchPoint10(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock5_SearchPoint11(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock5_SearchPoint12(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock5_SearchPoint13(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock5_SearchPoint14(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock5_SearchPoint15(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock6_SearchPoint0(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock6_SearchPoint1(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock6_SearchPoint2(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock6_SearchPoint3(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock6_SearchPoint4(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock6_SearchPoint5(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock6_SearchPoint6(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock6_SearchPoint7(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock6_SearchPoint8(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock6_SearchPoint9(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock6_SearchPoint10(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock6_SearchPoint11(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock6_SearchPoint12(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock6_SearchPoint13(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock6_SearchPoint14(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock6_SearchPoint15(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock7_SearchPoint0(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock7_SearchPoint1(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock7_SearchPoint2(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock7_SearchPoint3(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock7_SearchPoint4(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock7_SearchPoint5(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock7_SearchPoint6(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock7_SearchPoint7(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock7_SearchPoint8(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock7_SearchPoint9(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock7_SearchPoint10(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock7_SearchPoint11(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock7_SearchPoint12(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock7_SearchPoint13(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock7_SearchPoint14(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock7_SearchPoint15(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock8_SearchPoint0(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock8_SearchPoint1(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock8_SearchPoint2(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock8_SearchPoint3(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock8_SearchPoint4(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock8_SearchPoint5(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock8_SearchPoint6(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock8_SearchPoint7(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock8_SearchPoint8(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock8_SearchPoint9(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock8_SearchPoint10(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock8_SearchPoint11(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock8_SearchPoint12(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock8_SearchPoint13(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock8_SearchPoint14(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock8_SearchPoint15(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock9_SearchPoint0(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock9_SearchPoint1(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock9_SearchPoint2(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock9_SearchPoint3(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock9_SearchPoint4(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock9_SearchPoint5(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock9_SearchPoint6(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock9_SearchPoint7(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock9_SearchPoint8(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock9_SearchPoint9(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock9_SearchPoint10(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock9_SearchPoint11(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock9_SearchPoint12(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock9_SearchPoint13(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock9_SearchPoint14(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock9_SearchPoint15(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock10_SearchPoint0(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock10_SearchPoint1(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock10_SearchPoint2(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock10_SearchPoint3(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock10_SearchPoint4(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock10_SearchPoint5(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock10_SearchPoint6(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock10_SearchPoint7(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock10_SearchPoint8(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock10_SearchPoint9(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock10_SearchPoint10(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock10_SearchPoint11(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock10_SearchPoint12(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock10_SearchPoint13(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock10_SearchPoint14(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock10_SearchPoint15(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock11_SearchPoint0(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock11_SearchPoint1(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock11_SearchPoint2(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock11_SearchPoint3(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock11_SearchPoint4(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock11_SearchPoint5(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock11_SearchPoint6(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock11_SearchPoint7(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock11_SearchPoint8(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock11_SearchPoint9(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock11_SearchPoint10(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock11_SearchPoint11(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock11_SearchPoint12(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock11_SearchPoint13(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock11_SearchPoint14(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock11_SearchPoint15(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock12_SearchPoint0(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock12_SearchPoint1(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock12_SearchPoint2(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock12_SearchPoint3(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock12_SearchPoint4(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock12_SearchPoint5(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock12_SearchPoint6(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock12_SearchPoint7(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock12_SearchPoint8(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock12_SearchPoint9(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock12_SearchPoint10(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock12_SearchPoint11(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock12_SearchPoint12(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock12_SearchPoint13(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock12_SearchPoint14(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock12_SearchPoint15(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock13_SearchPoint0(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock13_SearchPoint1(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock13_SearchPoint2(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock13_SearchPoint3(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock13_SearchPoint4(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock13_SearchPoint5(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock13_SearchPoint6(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock13_SearchPoint7(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock13_SearchPoint8(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock13_SearchPoint9(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock13_SearchPoint10(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock13_SearchPoint11(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock13_SearchPoint12(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock13_SearchPoint13(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock13_SearchPoint14(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock13_SearchPoint15(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock14_SearchPoint0(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock14_SearchPoint1(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock14_SearchPoint2(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock14_SearchPoint3(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock14_SearchPoint4(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock14_SearchPoint5(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock14_SearchPoint6(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock14_SearchPoint7(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock14_SearchPoint8(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock14_SearchPoint9(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock14_SearchPoint10(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock14_SearchPoint11(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock14_SearchPoint12(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock14_SearchPoint13(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock14_SearchPoint14(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock14_SearchPoint15(p, v)</div>
<div class="line"><br /></div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock15_SearchPoint0(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock15_SearchPoint1(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock15_SearchPoint2(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock15_SearchPoint3(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock15_SearchPoint4(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock15_SearchPoint5(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock15_SearchPoint6(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock15_SearchPoint7(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock15_SearchPoint8(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock15_SearchPoint9(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock15_SearchPoint10(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock15_SearchPoint11(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock15_SearchPoint12(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock15_SearchPoint13(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock15_SearchPoint14(p, v)</div>
<div class="line">VME_GET_IDMOutput_DistortionMeshBlock15_SearchPoint15(p, v)</div>
</div>
</div>
</div>
</div>
</div>


          </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../cmcuserguide/cmcuserguide.html" title="CMC User Guide"
             >next</a> |</li>
        <li class="right" >
          <a href="../index.html" title="Documentation for CM"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">CM 6.0 documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2009-2016, Intel Corporation. All rights reserved.
      Last updated on Fri Feb 22 15:24:15 2019 -0800.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.1.
    </div>
  </body>
</html>