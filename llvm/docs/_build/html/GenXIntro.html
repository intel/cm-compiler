

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Introduction to the GenX backend &#8212; LLVM 6 documentation</title>
    
    <link rel="stylesheet" href="_static/llvm-theme.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '6',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="GenX backend design" href="GenXDesign.html" />
    <link rel="prev" title="GenX backend documentation" href="GenXIndex.html" />
<style type="text/css">
  table.right { float: right; margin-left: 20px; }
  table.right td { border: 1px solid #ccc; }
</style>

  </head>
  <body>
<div class="logo">
  <a href="index.html">
    <img src="_static/logo.png"
         alt="LLVM Logo" width="250" height="88"/></a>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="GenXDesign.html" title="GenX backend design"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="GenXIndex.html" title="GenX backend documentation"
             accesskey="P">previous</a> |</li>
  <li><a href="http://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="index.html">Documentation</a>&raquo;</li>

          <li class="nav-item nav-item-1"><a href="GenXIndex.html" accesskey="U">GenX backend documentation</a> &#187;</li> 
      </ul>
    </div>


    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <div class="section" id="introduction-to-the-genx-backend">
<h1>Introduction to the GenX backend<a class="headerlink" href="#introduction-to-the-genx-backend" title="Permalink to this headline">¶</a></h1>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><a class="reference internal" href="#llvm-ir-representation-of-cm" id="id6">LLVM IR representation of CM</a><ul>
<li><a class="reference internal" href="#static-single-assignment-form" id="id7">Static single assignment form</a><ul>
<li><a class="reference internal" href="#llvm-ir-and-ssa" id="id8">LLVM IR and SSA</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-ir-and-visa-gen" id="id9">LLVM IR and vISA/Gen</a><ul>
<li><a class="reference internal" href="#use-of-ssa" id="id10">Use of SSA</a></li>
<li><a class="reference internal" href="#cm-and-visa-representation" id="id11">CM and vISA representation</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#the-genx-backend" id="id12">The GenX backend</a></li>
<li><a class="reference internal" href="#example-walk-throughs" id="id13">Example walk-throughs</a><ul>
<li><a class="reference internal" href="#example-simple-arithmetic" id="id14">Example: simple arithmetic</a><ul>
<li><a class="reference internal" href="#after-clang" id="id15">After clang</a></li>
<li><a class="reference internal" href="#after-sroa" id="id16">After SRoA</a></li>
<li><a class="reference internal" href="#categories" id="id17">Categories</a></li>
<li><a class="reference internal" href="#live-ranges" id="id18">Live ranges</a></li>
<li><a class="reference internal" href="#visa-register-allocation" id="id19">vISA register allocation</a></li>
<li><a class="reference internal" href="#visa-function-writer" id="id20">vISA function writer</a></li>
</ul>
</li>
<li><a class="reference internal" href="#example-read-region-baling-legalization-vector-decomposition" id="id21">Example: read region, baling, legalization, vector decomposition</a><ul>
<li><a class="reference internal" href="#id1" id="id22">After SRoA</a></li>
<li><a class="reference internal" href="#region-collapsing" id="id23">Region collapsing</a></li>
<li><a class="reference internal" href="#first-baling" id="id24">First baling</a></li>
<li><a class="reference internal" href="#legalization" id="id25">Legalization</a></li>
<li><a class="reference internal" href="#genxpostlegalization-and-vector-decomposition" id="id26">GenXPostLegalization and vector decomposition</a></li>
<li><a class="reference internal" href="#id2" id="id27">Categories</a></li>
<li><a class="reference internal" href="#second-baling" id="id28">Second baling</a></li>
<li><a class="reference internal" href="#id3" id="id29">Live ranges</a></li>
<li><a class="reference internal" href="#coalescing" id="id30">Coalescing</a></li>
<li><a class="reference internal" href="#id4" id="id31">vISA register allocation</a></li>
<li><a class="reference internal" href="#id5" id="id32">vISA function writer</a></li>
</ul>
</li>
<li><a class="reference internal" href="#example-phi-nodes" id="id33">Example: phi nodes</a><ul>
<li><a class="reference internal" href="#critical-edge-splitting" id="id34">Critical edge splitting</a></li>
<li><a class="reference internal" href="#circular-phi-nodes" id="id35">Circular phi nodes</a></li>
<li><a class="reference internal" href="#numbering-and-live-ranges-for-phi-nodes" id="id36">Numbering and live ranges for phi nodes</a></li>
<li><a class="reference internal" href="#phi-coalescing" id="id37">Phi coalescing</a></li>
</ul>
</li>
<li><a class="reference internal" href="#example-indirect-regions-and-address-optimization" id="id38">Example: indirect regions and address optimization</a></li>
</ul>
</li>
<li><a class="reference internal" href="#glossary" id="id39">Glossary</a></li>
</ul>
</div>
<div class="section" id="llvm-ir-representation-of-cm">
<h2><a class="toc-backref" href="#id6">LLVM IR representation of CM</a><a class="headerlink" href="#llvm-ir-representation-of-cm" title="Permalink to this headline">¶</a></h2>
<div class="section" id="static-single-assignment-form">
<h3><a class="toc-backref" href="#id7">Static single assignment form</a><a class="headerlink" href="#static-single-assignment-form" title="Permalink to this headline">¶</a></h3>
<p>Many compiler analyses and optimizations
need to find the possible definitions of a variable for a particular use, or
the possible uses of a particular definition of a variable. Compilers often use
def-use chains and use-def chains to represent these relationships and make
hopping between defs or uses more efficient.</p>
<p>An extension of the idea of a def-use chain
is <em>static single
assignment</em> form, or <em>SSA</em>, a
form of compiler intermediate language where each value has only one definition
and potentially multiple uses, and the def and uses are permanently linked
together. Each definition of a variable becomes a separate SSA value. A
definition <em>dominates</em> all of its uses (meaning that execution must pass through the
definition to be able to get to any use). A join point in the control flow
where a variable has two or more possible values (for example an endif or the
top of a loop) is handled by a <em>phi
node</em>, which counts as a new definition which in
turn dominates its uses.</p>
<p>The way that, in SSA, you can only create a
new value for a variable, and not modify it in place, is like programming in a
functional programming language. (Ignoring phi nodes.)</p>
<p><em>Modern
Compiler Implementation in C</em> by Andrew W. Appel,
chapter 19, p433, lists several benefits of SSA:</p>
<ol class="arabic simple">
<li>Dataflow analysis and optimization algorithms
can be made simpler when each variable has only one definition.</li>
<li>For a variable with N uses and M defs, the size
of SSA is usually linear in N + M and thus linear in the size of the program,
whereas non-SSA def-use and use-def chains take space and time proportional to
N * M.</li>
<li>The dominance property of SSA simplifies
interference graph construction, needed for register allocation (or, in our
case, virtual register packing).</li>
<li>Unrelated webs of defs and uses of the same variable are obviously
unrelated in SSA, and are not constrained to be in the same register.</li>
</ol>
<p>To convert the SSA into real non-SSA
machine code (or in our case non-SSA vISA code), the compiler needs to
implement the phi nodes by inserting the appropriate copy at the end of each
predecessor block leading to the phi node. The compiler needs to do its best to
allocate values linked by a phi node into the same register, so no copy is
actually needed.</p>
<div class="section" id="llvm-ir-and-ssa">
<h4><a class="toc-backref" href="#id8">LLVM IR and SSA</a><a class="headerlink" href="#llvm-ir-and-ssa" title="Permalink to this headline">¶</a></h4>
<p>LLVM is built from the ground up on SSA.
All the existing analyses and passes in LLVM rely on SSA. Using SSA usually
makes a compiler analysis or optimization simpler to express, and thus, in the
previous experience of the UK compiler team, easier to write and maintain and
more reliable.</p>
</div>
</div>
<div class="section" id="llvm-ir-and-visa-gen">
<h3><a class="toc-backref" href="#id9">LLVM IR and vISA/Gen</a><a class="headerlink" href="#llvm-ir-and-visa-gen" title="Permalink to this headline">¶</a></h3>
<div class="section" id="use-of-ssa">
<h4><a class="toc-backref" href="#id10">Use of SSA</a><a class="headerlink" href="#use-of-ssa" title="Permalink to this headline">¶</a></h4>
<p>The approach of cm-llvm is that we
want to use and benefit from LLVM’s SSA as much as possible. For this reason,
we ensure that a CM scalar or vector variable is representable as SSA values in
LLVM IR, and is never left in an alloca. If we sometimes leave a variable in
memory, then it loses out on any existing LLVM analyses that use SSA, and it
makes it more difficult for us to write any pass that needs to process the
variable.</p>
<p>To ensure that a variable is never left in
an alloca (after LLVM’s Mem2Reg pass), we never take the address of a variable,
and we never use a pointer to point at or into a vector or matrix.</p>
<p>A number of design decisions arise from
this:</p>
<ul class="simple">
<li>A region read is an intrinsic acting on a value,
not on a variable in memory.</li>
<li>A region write is an intrinsic acting on a value
and returning the updated value, not modifying a variable in memory.</li>
<li>Indirect indexing is represented as a region
read/write with a variable index (like in CM’s select and iselect), not using
some notion of an address register that needs further analysis to determine
what it could point to (like in vISA). The translation to vISA address register
is done later on in the LLVM vISA code generator.</li>
<li>Pass-by-ref in a call is represented by copy-in
copy-out, where the callee takes the parameter by value and returns the updated
value. If there is more than one pass-by-ref parameter, the callee returns a
struct with the multiple updated values.</li>
<li>Any read-from-memory intrinsic is declared such
that it returns the read data, rather than passing in a reference to the area
to write the data into.</li>
</ul>
<p>An issue with this approach is that LLVM
will be considering a whole vector or matrix as a value, not regions inside it.
To fix that we have a vector decomposition pass to allow the use of a region to
be linked directly to a write of the same region where possible.</p>
<p>See <a class="reference internal" href="GenXLangRef.html"><span class="doc">LLVM IR for the GenX backend</span></a> for details on the LLVM IR accepted by the GenX backend.</p>
</div>
<div class="section" id="cm-and-visa-representation">
<h4><a class="toc-backref" href="#id11">CM and vISA representation</a><a class="headerlink" href="#cm-and-visa-representation" title="Permalink to this headline">¶</a></h4>
<p>The general principle is that LLVM IR represents
the functionality of vISA, but generalized in the following ways to make it
more convenient to represent CM:</p>
<ul class="simple">
<li>no restriction on vector/matrix size;</li>
<li>no restriction on region size or GRF crossing;</li>
<li>no restriction on number of values (general,
address or state);</li>
<li>a 2D region write is allowed;</li>
</ul>
<p>Restrictions to vISA functionality are
imposed to ease code analysis within LLVM (as mentioned above):</p>
<ul class="simple">
<li>No concept of an address variable being set to the address of a general
variable. Instead, the intrinsics for region addressing take a variable
offset.</li>
</ul>
</div>
</div>
</div>
<div class="section" id="the-genx-backend">
<h2><a class="toc-backref" href="#id12">The GenX backend</a><a class="headerlink" href="#the-genx-backend" title="Permalink to this headline">¶</a></h2>
<p>The GenX backend is the part of the cm-llvm compiler that takes the LLVM IR used
to represent CM and vISA, and generates actual vISA.</p>
<p>Almost all LLVM backends (targets) use the <em>target independent code generator</em>.
The GenX backend does not; instead it continues to use LLVM IR through the
backend, with many passes transforming the LLVM IR in order to further restrict
what can be represented, until at the end the GenXVisaFuncWriter pass writes
the LLVM IR as vISA.</p>
<p>The use of LLVM IR in the GenX backend is discussed more fully
in <a class="reference internal" href="GenXDesign.html"><span class="doc">GenX backend design</span></a>.</p>
</div>
<div class="section" id="example-walk-throughs">
<h2><a class="toc-backref" href="#id13">Example walk-throughs</a><a class="headerlink" href="#example-walk-throughs" title="Permalink to this headline">¶</a></h2>
<div class="section" id="example-simple-arithmetic">
<h3><a class="toc-backref" href="#id14">Example: simple arithmetic</a><a class="headerlink" href="#example-simple-arithmetic" title="Permalink to this headline">¶</a></h3>
<p>Here is a source line from Scale_FaceDetect, doing a simple bit of arithmetic
on a vector of 2 ints:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">rd_y</span><span class="p">;</span>
<span class="p">...</span>
<span class="n">rd_y</span> <span class="o">&lt;&lt;=</span> <span class="mi">3</span><span class="p">;</span>
</pre></div>
</div>
<p>This ends up as the following vISA:</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>LOC 65
shl (M1, 2) V60(0,0)&lt;1&gt;:d V60(0,0)&lt;0;2,1&gt;:d 0x3:d
</pre></div>
</div>
<p>Here we see what happens to this source statement in LLVM and the GenX backend
to get to this vISA.</p>
<div class="section" id="after-clang">
<h4><a class="toc-backref" href="#id15">After clang</a><a class="headerlink" href="#after-clang" title="Permalink to this headline">¶</a></h4>
<p>Clang gives each variable a space on the stack using alloca. Each use of the
variable loads from that memory location, and each def of it stores to the
memory location.</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv">%rd_y</span> <span class="p">=</span> <span class="k">alloca</span> <span class="p">&lt;</span><span class="m">2</span> <span class="k">x</span> <span class="k">i32</span><span class="p">&gt;,</span> <span class="k">align</span> <span class="m">8</span>
<span class="p">...</span>
<span class="nv nv-Anonymous">%10</span> <span class="p">=</span> <span class="k">load</span> <span class="p">&lt;</span><span class="m">2</span> <span class="k">x</span> <span class="k">i32</span><span class="p">&gt;*</span> <span class="nv">%rd_y</span><span class="p">,</span> <span class="k">align</span> <span class="m">8</span><span class="p">,</span> <span class="nv">!dbg</span> <span class="nv nv-Anonymous">!200</span><span class="p">,</span> <span class="nv">!tbaa</span> <span class="nv nv-Anonymous">!186</span>
<span class="nv">%shl</span> <span class="p">=</span> <span class="k">shl</span> <span class="p">&lt;</span><span class="m">2</span> <span class="k">x</span> <span class="k">i32</span><span class="p">&gt;</span> <span class="nv nv-Anonymous">%10</span><span class="p">,</span> <span class="p">&lt;</span><span class="k">i32</span> <span class="m">3</span><span class="p">,</span> <span class="k">i32</span> <span class="m">3</span><span class="p">&gt;,</span> <span class="nv">!dbg</span> <span class="nv nv-Anonymous">!200</span>
<span class="k">store</span> <span class="p">&lt;</span><span class="m">2</span> <span class="k">x</span> <span class="k">i32</span><span class="p">&gt;</span> <span class="nv">%shl</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">2</span> <span class="k">x</span> <span class="k">i32</span><span class="p">&gt;*</span> <span class="nv">%rd_y</span><span class="p">,</span> <span class="k">align</span> <span class="m">8</span><span class="p">,</span> <span class="nv">!dbg</span> <span class="nv nv-Anonymous">!200</span><span class="p">,</span> <span class="nv">!tbaa</span> <span class="nv nv-Anonymous">!186</span>
</pre></div>
</div>
</div>
<div class="section" id="after-sroa">
<h4><a class="toc-backref" href="#id16">After SRoA</a><a class="headerlink" href="#after-sroa" title="Permalink to this headline">¶</a></h4>
<p>SROA (scalar replacement of aggregates) is the standard LLVM pass
that promotes the alloca
variables from clang into LLVM IR values, in SSA so each value has exactly one
def.</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv">%shl</span> <span class="p">=</span> <span class="k">shl</span> <span class="p">&lt;</span><span class="m">2</span> <span class="k">x</span> <span class="k">i32</span><span class="p">&gt;</span> <span class="nv">%wrregion17</span><span class="p">,</span> <span class="p">&lt;</span><span class="k">i32</span> <span class="m">3</span><span class="p">,</span> <span class="k">i32</span> <span class="m">3</span><span class="p">&gt;,</span> <span class="nv">!dbg</span> <span class="nv nv-Anonymous">!195</span>
</pre></div>
</div>
<p>There are now multiple separate values for what was the variable rd_y. Here we
see %wrregion17 for the value just before this line, and %shl for the value
defined in this line as a result of the shift left. These values now have
no connection with the original variable declaration (other than in debug info,
which the GenX backend does not yet implement).</p>
</div>
<div class="section" id="categories">
<h4><a class="toc-backref" href="#id17">Categories</a><a class="headerlink" href="#categories" title="Permalink to this headline">¶</a></h4>
<p>This example is so simple that nothing else happens to it until we reach
the GenXCategory pass in the GenX backend.
The two values of the original
variable, %wrregion17 and %shl, are both set to category <code class="docutils literal"><span class="pre">{general}</span></code>, because
there is no def or use in some other category (address, predicate, surface,
sampler, vme).</p>
<p>The category of a value is stored in a <code class="docutils literal"><span class="pre">LiveRange</span></code> object created for the
value. At this stage, the <code class="docutils literal"><span class="pre">LiveRange</span></code> does not yet have any live range
information; this is added in GenXLiveRanges below.</p>
</div>
<div class="section" id="live-ranges">
<h4><a class="toc-backref" href="#id18">Live ranges</a><a class="headerlink" href="#live-ranges" title="Permalink to this headline">¶</a></h4>
<p>The next step is to determine the live ranges of these values.</p>
<p>First, the GenXLiveRanges pass numbers the IR instructions.</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>[804]  %shl.i.i142 = shl &lt;2 x i32&gt; %wrregion17.i.i141, &lt;i32 3, i32 3&gt;, !dbg !247 // line 65
</pre></div>
</div>
<p>Then it determines each live range in terms of those instruction numbers:</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>wrregion17.i.i141:[797,804){general}
shl.i.i142:[804,2444){general}
</pre></div>
</div>
<p>Here we see that the live range of %wrregion17.i.i141 finishes at instruction
804, and the live range of %shl.i.i142 starts at instruction 804.</p>
<p>The instruction numbering and the live ranges are kept in a separate “on the side”
data structure, the analysis pass GenXLiveness. This is then maintained through
subsequent passes; each pass states that it maintains the GenXLiveness analysis.</p>
<p>An “on the side” data structure, an analysis pass, is the standard way of adding
information to LLVM IR without having to extend the IR data structures. The instruction
numbering is kept in a map from an <code class="docutils literal"><span class="pre">Instruction</span> <span class="pre">*</span></code> to an integer giving the number;
the live ranges are kept in a map from a <code class="docutils literal"><span class="pre">Value</span> <span class="pre">*</span></code> to the <code class="docutils literal"><span class="pre">LiveRange</span> <span class="pre">*</span></code>.
Looking something up in a map has log(n) complexity, thus making the algorithm
that uses it have at least n log(n) complexity (which it probably had already).</p>
<p>A <code class="docutils literal"><span class="pre">LiveRange</span></code> object contains</p>
<ul class="simple">
<li>a vector of all the Values that are attached to it (initially just one,
but possibly more after coalescing);</li>
<li>a vector of segments each with inclusive start and exclusive end instruction
number;</li>
<li>the vISA register category of the live range.</li>
</ul>
<p>The segments are kept in order, with no abutting or overlapping segments.</p>
</div>
<div class="section" id="visa-register-allocation">
<h4><a class="toc-backref" href="#id19">vISA register allocation</a><a class="headerlink" href="#visa-register-allocation" title="Permalink to this headline">¶</a></h4>
<p>In principle, vISA register allocation simply allocates a new vISA register to
each live range (after coalescing, which did not happen in this example). If
a single live range is used with different types, then each distinct type gets
a vISA register alias of the base register.</p>
<p>However, vISA register allocation performs one form of coalescing,
<em>extra coalescing</em>. The point of most coalescing is to remove copy instructions;
the point of extra coalescing is just to reduce the number of vISA registers
to reduce the chance of fragmentation in the jitter register allocator.</p>
<p>In this case, extra coalescing sees that the %wrregion17.i.i141 operand and the
%shl.i.i142 result of this shl instruction do not interfere, and have the same
size, so it coalesces them together, giving a single merged live range.</p>
<p>Then vISA the register allocator allocates the register V60 to this coalesced
live range:</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>[v60]  %shl.i.i142 = shl &lt;2 x i32&gt; %wrregion17.i.i141, &lt;i32 3, i32 3&gt;, !dbg !247
</pre></div>
</div>
<p>The results of vISA register allocation are kept in another “on the side” data
structure for the use of the vISA function writer.</p>
</div>
<div class="section" id="visa-function-writer">
<h4><a class="toc-backref" href="#id20">vISA function writer</a><a class="headerlink" href="#visa-function-writer" title="Permalink to this headline">¶</a></h4>
<p>The vISA function writer writes the shl instruction as vISA, looking up the vISA
register of each (non-constant) operand in the vISA register allocation analysis,
resulting in this code:</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>LOC 65
shl (M1, 2) V60(0,0)&lt;1&gt;:d V60(0,0)&lt;0;2,1&gt;:d 0x3:d
</pre></div>
</div>
<p>Note that the vISA register allocator has also output a <code class="docutils literal"><span class="pre">LOC</span> <span class="pre">65</span></code>, giving the
source line number of this instruction. An LLVM IR instruction can include a
<em>debug location</em> (a <code class="docutils literal"><span class="pre">DebugLoc</span></code>), which is maintained through all the passes,
as long as any pass that modifies the code remembers to set the debug location
on any new instruction it creates (calling <code class="docutils literal"><span class="pre">getDebugLoc()</span></code> on the old
instruction and using the result in <code class="docutils literal"><span class="pre">setDebugLoc()</span></code> on the new instruction).
The vISA function writer uses the debug location to output FILE and LOC vISA
instructions.</p>
</div>
</div>
<div class="section" id="example-read-region-baling-legalization-vector-decomposition">
<h3><a class="toc-backref" href="#id21">Example: read region, baling, legalization, vector decomposition</a><a class="headerlink" href="#example-read-region-baling-legalization-vector-decomposition" title="Permalink to this headline">¶</a></h3>
<p>Here is a source line from linear, reading a region from a uchar matrix
and converting it to float:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">matrix</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="n">in</span><span class="p">;</span>
<span class="n">matrix</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">24</span><span class="o">&gt;</span> <span class="n">m</span><span class="p">;</span>
<span class="p">...</span>
<span class="n">m</span>  <span class="o">=</span> <span class="n">in</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">6</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">24</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span>
</pre></div>
</div>
<p>This ends up as the following vISA:</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>LOC 23
mov (M1, 16) V91(0,0)&lt;1&gt;:f V36(1,3)&lt;0;16,1&gt;:ub
mov (M1, 16) V103{V95}(0,0)&lt;1&gt;:f V36(1,19)&lt;16;8,1&gt;:ub
mov (M1, 16) V103{V95}(2,0)&lt;1&gt;:f V36(2,11)&lt;0;16,1&gt;:ub
mov (M1, 16) V92(0,0)&lt;1&gt;:f V36(3,3)&lt;0;16,1&gt;:ub
mov (M1, 16) V104{V97}(0,0)&lt;1&gt;:f V36(3,19)&lt;16;8,1&gt;:ub
mov (M1, 16) V104{V97}(2,0)&lt;1&gt;:f V36(4,11)&lt;0;16,1&gt;:ub
mov (M1, 16) V93(0,0)&lt;1&gt;:f V36(5,3)&lt;0;16,1&gt;:ub
mov (M1, 16) V105{V99}(0,0)&lt;1&gt;:f V36(5,19)&lt;16;8,1&gt;:ub
mov (M1, 16) V105{V99}(2,0)&lt;1&gt;:f V36(6,11)&lt;0;16,1&gt;:ub
</pre></div>
</div>
<p>Note that the uchar matrix in is represented by a single vISA register V36,
but the float matrix m has been split into several vISA registers. This
helps to reduce register fragmentation in the jitter’s register allocator.</p>
<div class="section" id="id1">
<h4><a class="toc-backref" href="#id22">After SRoA</a><a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h4>
<p>Once SRoA has got rid of the allocas, loads and stores, and converted the variables
to multiple SSA values, we have this IR:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv">%rdr.rows</span> <span class="p">=</span> <span class="k">tail</span> <span class="k">call</span> <span class="p">&lt;</span><span class="m">192</span> <span class="k">x</span> <span class="k">i8</span><span class="p">&gt;</span> <span class="vg">@llvm.genx.rdregion.v192i8.v256i8.i16</span><span class="p">(&lt;</span><span class="m">256</span> <span class="k">x</span> <span class="k">i8</span><span class="p">&gt;</span> <span class="nv">%call1.i.i</span><span class="p">,</span> <span class="k">i32</span> <span class="m">32</span><span class="p">,</span> <span class="k">i32</span> <span class="m">32</span><span class="p">,</span> <span class="k">i32</span> <span class="m">1</span><span class="p">,</span> <span class="k">i16</span> <span class="m">32</span><span class="p">,</span> <span class="k">i32</span> <span class="m">32</span><span class="p">),</span> <span class="nv">!dbg</span> <span class="nv nv-Anonymous">!42</span>
<span class="nv">%rdr.cols</span> <span class="p">=</span> <span class="k">tail</span> <span class="k">call</span> <span class="p">&lt;</span><span class="m">144</span> <span class="k">x</span> <span class="k">i8</span><span class="p">&gt;</span> <span class="vg">@llvm.genx.rdregion.v144i8.v192i8.i16</span><span class="p">(&lt;</span><span class="m">192</span> <span class="k">x</span> <span class="k">i8</span><span class="p">&gt;</span> <span class="nv">%rdr.rows</span><span class="p">,</span> <span class="k">i32</span> <span class="m">32</span><span class="p">,</span> <span class="k">i32</span> <span class="m">24</span><span class="p">,</span> <span class="k">i32</span> <span class="m">1</span><span class="p">,</span> <span class="k">i16</span> <span class="m">3</span><span class="p">,</span> <span class="k">i32</span> <span class="m">32</span><span class="p">),</span> <span class="nv">!dbg</span> <span class="nv nv-Anonymous">!42</span>
<span class="nv">%conv</span> <span class="p">=</span> <span class="k">uitofp</span> <span class="p">&lt;</span><span class="m">144</span> <span class="k">x</span> <span class="k">i8</span><span class="p">&gt;</span> <span class="nv">%rdr.cols</span> <span class="k">to</span> <span class="p">&lt;</span><span class="m">144</span> <span class="k">x</span> <span class="kt">float</span><span class="p">&gt;,</span> <span class="nv">!dbg</span> <span class="nv nv-Anonymous">!42</span>
</pre></div>
</div>
<p>Here we see the <code class="docutils literal"><span class="pre">llvm.genx.rdregion</span></code> intrinsic, which is used to represent a
read of a region. Intrinsics are the extension mechanism of LLVM IR; inventing
a new IR Instruction is more difficult and not recommended.
The <code class="docutils literal"><span class="pre">.v144i8.v192i8.i16</span></code> suffix specifies the overloaded
types in the intrinsic. The arguments are as follows (using the second rdregion
as an example):</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">&lt;192</span> <span class="pre">x</span> <span class="pre">i8&gt;</span> <span class="pre">%rdr.rows</span></code></dt>
<dd>The input vector/matrix</dd>
<dt><code class="docutils literal"><span class="pre">i32</span> <span class="pre">32</span></code></dt>
<dd>vstride</dd>
<dt><code class="docutils literal"><span class="pre">i32</span> <span class="pre">24</span></code></dt>
<dd>width</dd>
<dt><code class="docutils literal"><span class="pre">i32</span> <span class="pre">1</span></code></dt>
<dd>stride</dd>
<dt><code class="docutils literal"><span class="pre">i16</span> <span class="pre">3</span></code></dt>
<dd>start index in bytes</dd>
<dt><code class="docutils literal"><span class="pre">i32</span> <span class="pre">32</span></code></dt>
<dd>parent width – ignored when the index is constant</dd>
</dl>
<p>A 2D region read is implemented as two separate rdregions by clang, one to read
the requested rows out of the original matrix, then the second to read the
requested columns out of those rows. Splitting it like this provides
useful information to GenXRegionCollapsing if either or both of the indices
are variable; clang does the split anyway for the constant indices case
for uniformity.</p>
<p>At this stage, a region in the IR is not necessarily a legal vISA region.</p>
</div>
<div class="section" id="region-collapsing">
<h4><a class="toc-backref" href="#id23">Region collapsing</a><a class="headerlink" href="#region-collapsing" title="Permalink to this headline">¶</a></h4>
<p>GenXRegionCollapsing implements collapsing (combining) rdregion and wrregion
instructions. Part of the requirement of this comes from the way that a 2D
region access is split into row then column access. But it also deals with
cases where the original source had two region accesses – a select of a select –
that can be combined.</p>
<p>At this stage, a region is not necessarily a legal vISA region, but it has to
be representable as a 2D region, with vstride, width and stride.
GenXRegionCollapsing has to go to some effort to ensure that this is the case,
more so when a variable index is involved.</p>
<p>In this example, the two rdregions can be combined, recreating the region that
the original source was using, which was a 6x24 region in an 8x32 matrix with
a start index of 35 (1 row and 3 columns).</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv">%rdr.cols.regioncollapsed</span> <span class="p">=</span> <span class="k">call</span> <span class="p">&lt;</span><span class="m">144</span> <span class="k">x</span> <span class="k">i8</span><span class="p">&gt;</span> <span class="vg">@llvm.genx.rdregion.v144i8.v256i8.i16</span><span class="p">(&lt;</span><span class="m">256</span> <span class="k">x</span> <span class="k">i8</span><span class="p">&gt;</span> <span class="nv">%call1.i.i</span><span class="p">,</span> <span class="k">i32</span> <span class="m">32</span><span class="p">,</span> <span class="k">i32</span> <span class="m">24</span><span class="p">,</span> <span class="k">i32</span> <span class="m">1</span><span class="p">,</span> <span class="k">i16</span> <span class="m">35</span><span class="p">,</span> <span class="k">i32</span> <span class="k">undef</span><span class="p">),</span> <span class="nv">!dbg</span> <span class="nv nv-Anonymous">!42</span>
<span class="nv">%conv</span> <span class="p">=</span> <span class="k">uitofp</span> <span class="p">&lt;</span><span class="m">144</span> <span class="k">x</span> <span class="k">i8</span><span class="p">&gt;</span> <span class="nv">%rdr.cols.regioncollapsed</span> <span class="k">to</span> <span class="p">&lt;</span><span class="m">144</span> <span class="k">x</span> <span class="kt">float</span><span class="p">&gt;,</span> <span class="nv">!dbg</span> <span class="nv nv-Anonymous">!42</span>
</pre></div>
</div>
</div>
<div class="section" id="first-baling">
<h4><a class="toc-backref" href="#id24">First baling</a><a class="headerlink" href="#first-baling" title="Permalink to this headline">¶</a></h4>
<p>GenXBaling is the pass that spots when multiple IR instructions can be combined
into a single vISA instruction. It does not actually combine them (if it did we
would need intrinsics for all the vISA instructions with all operands
regions and with modifiers). Instead it is an analysis pass that constructs
an “on the side” data structure marking how the IR instructions are combined
into a <strong>bale</strong>.</p>
<p>A <strong>bale</strong> is a tree of IR instructions that will be combined into a vISA
instruction. The <strong>head</strong> of the bale is the last instruction in code order,
the root of the tree, which is the only instruction whose value is used outside
the bale. The <strong>main instruction</strong> of a bale is the IR instruction that
corresponds to the actual vISA instruction, such as add. It is possible to have
a bale with no main instruction, such as when the bale just reads a region and
writes the result into another region. This would become a vISA mov instruction.</p>
<p>GenXBaling is not a pure analysis, in that it can modify the IR. If it decides
to bale an IR instruction (e.g. a rdregion) into another instruction even though
it has multiple uses, it clones the instruction such that the one baled in has
only a single use.</p>
<p>GenXBaling keeps the baling information in the form of a map from an
<code class="docutils literal"><span class="pre">Instruction</span> <span class="pre">*</span></code> to a <code class="docutils literal"><span class="pre">BaleInfo</span></code>. The <code class="docutils literal"><span class="pre">BaleInfo</span></code> for an instruction is a
bitmap of which operands are baled in, plus a field indicating the instruction’s
role in the bale, for example rdregion or modifier or main instruction.</p>
<p>Some other passes that use baling information then ask GenXBaling to create
a <code class="docutils literal"><span class="pre">Bale</span></code> from an instruction known to be the head of a bale. A <code class="docutils literal"><span class="pre">Bale</span></code> is
essentially a vector of the instructions in the bale. A <code class="docutils literal"><span class="pre">Bale</span></code> is not persistent
between passes.</p>
<p>GenXBaling runs in two places in the GenX backend. First baling is run just
before GenXLegalization. In this example, the rdregion is baled into the
uitofp.</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>bale {
   %rdr.cols.regioncollapsed = call &lt;144 x i8&gt; @llvm.genx.rdregion.v144i8.v256i8.i16(&lt;256 x i8&gt; %call1.i.i, i32 32, i32 24, i32 1, i16 35, i32 undef), !dbg !42 {rdregion} // line 23
   %conv = uitofp &lt;144 x i8&gt; %rdr.cols.regioncollapsed to &lt;144 x float&gt;, !dbg !42 // line 23
}
</pre></div>
</div>
</div>
<div class="section" id="legalization">
<h4><a class="toc-backref" href="#id25">Legalization</a><a class="headerlink" href="#legalization" title="Permalink to this headline">¶</a></h4>
<p>As shown in this example, IR can represent arbitrary size vector operations
and region reads and writes. It is the job of GenXLegalization to split
an illegally sized vector operation or illegally strided or GRF crossing
region.</p>
<p>GenXLegalization considers a whole bale (using the information from first
baling above). Generally, with a bale that potentially has some rdregions,
a main instruction and a wrregion, it calculates the split that gives
legal regions and vector size for the whole bale. There are cases where it
has to unbale, that is, remove say a rdregion from a bale and consider
it separately, resulting in separate mov instruction(s) for that region.</p>
<p>In this case, the rdregion has a 6x24 region in an 8x32 matrix, and it
needs to be done as</p>
<ul class="simple">
<li>a 1D 16 wide vector to cover the first 2/3 of the first row;</li>
<li>a 2D 2x8 region to cover the last 1/3 of the first row and the first 1/3
of the second row;</li>
<li>a 1D 16 wide vector to cover the last 2/3 of the second row;</li>
<li>and so on for the other rows.</li>
</ul>
<p>For each split, GenXLegalization needs to create:</p>
<ul class="simple">
<li>a rdregion to read the smaller subregion out of the original input;</li>
<li>a smaller uitofp instruction;</li>
<li>a wrregion to join the result of the uitofp back up with the other
splits.</li>
</ul>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv">%rdr.cols.regioncollapsed3</span> <span class="p">=</span> <span class="k">call</span> <span class="p">&lt;</span><span class="m">16</span> <span class="k">x</span> <span class="k">i8</span><span class="p">&gt;</span> <span class="vg">@llvm.genx.rdregion.v16i8.v256i8.i16</span><span class="p">(&lt;</span><span class="m">256</span> <span class="k">x</span> <span class="k">i8</span><span class="p">&gt;</span> <span class="nv">%call1.i.i</span><span class="p">,</span> <span class="k">i32</span> <span class="m">16</span><span class="p">,</span> <span class="k">i32</span> <span class="m">16</span><span class="p">,</span> <span class="k">i32</span> <span class="m">1</span><span class="p">,</span> <span class="k">i16</span> <span class="m">35</span><span class="p">,</span> <span class="k">i32</span> <span class="k">undef</span><span class="p">),</span> <span class="nv">!dbg</span> <span class="nv nv-Anonymous">!42</span>
<span class="nv">%conv4</span> <span class="p">=</span> <span class="k">uitofp</span> <span class="p">&lt;</span><span class="m">16</span> <span class="k">x</span> <span class="k">i8</span><span class="p">&gt;</span> <span class="nv">%rdr.cols.regioncollapsed3</span> <span class="k">to</span> <span class="p">&lt;</span><span class="m">16</span> <span class="k">x</span> <span class="kt">float</span><span class="p">&gt;,</span> <span class="nv">!dbg</span> <span class="nv nv-Anonymous">!42</span>
<span class="nv">%conv.addedwrregion.join</span> <span class="p">=</span> <span class="k">call</span> <span class="p">&lt;</span><span class="m">144</span> <span class="k">x</span> <span class="kt">float</span><span class="p">&gt;</span> <span class="vg">@llvm.genx.wrregion.v144f32.v16f32.i16.i1</span><span class="p">(&lt;</span><span class="m">144</span> <span class="k">x</span> <span class="kt">float</span><span class="p">&gt;</span> <span class="k">undef</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">16</span> <span class="k">x</span> <span class="kt">float</span><span class="p">&gt;</span> <span class="nv">%conv4</span><span class="p">,</span> <span class="k">i32</span> <span class="m">16</span><span class="p">,</span> <span class="k">i32</span> <span class="m">16</span><span class="p">,</span> <span class="k">i32</span> <span class="m">1</span><span class="p">,</span> <span class="k">i16</span> <span class="m">0</span><span class="p">,</span> <span class="k">i32</span> <span class="k">undef</span><span class="p">,</span> <span class="k">i1</span> <span class="k">true</span><span class="p">),</span> <span class="nv">!dbg</span> <span class="nv nv-Anonymous">!42</span>
<span class="nv">%rdr.cols.regioncollapsed5</span> <span class="p">=</span> <span class="k">call</span> <span class="p">&lt;</span><span class="m">16</span> <span class="k">x</span> <span class="k">i8</span><span class="p">&gt;</span> <span class="vg">@llvm.genx.rdregion.v16i8.v256i8.i16</span><span class="p">(&lt;</span><span class="m">256</span> <span class="k">x</span> <span class="k">i8</span><span class="p">&gt;</span> <span class="nv">%call1.i.i</span><span class="p">,</span> <span class="k">i32</span> <span class="m">16</span><span class="p">,</span> <span class="k">i32</span> <span class="m">8</span><span class="p">,</span> <span class="k">i32</span> <span class="m">1</span><span class="p">,</span> <span class="k">i16</span> <span class="m">51</span><span class="p">,</span> <span class="k">i32</span> <span class="k">undef</span><span class="p">),</span> <span class="nv">!dbg</span> <span class="nv nv-Anonymous">!42</span>
<span class="nv">%conv6</span> <span class="p">=</span> <span class="k">uitofp</span> <span class="p">&lt;</span><span class="m">16</span> <span class="k">x</span> <span class="k">i8</span><span class="p">&gt;</span> <span class="nv">%rdr.cols.regioncollapsed5</span> <span class="k">to</span> <span class="p">&lt;</span><span class="m">16</span> <span class="k">x</span> <span class="kt">float</span><span class="p">&gt;,</span> <span class="nv">!dbg</span> <span class="nv nv-Anonymous">!42</span>
<span class="nv">%conv.addedwrregion.join7</span> <span class="p">=</span> <span class="k">call</span> <span class="p">&lt;</span><span class="m">144</span> <span class="k">x</span> <span class="kt">float</span><span class="p">&gt;</span> <span class="vg">@llvm.genx.wrregion.v144f32.v16f32.i16.i1</span><span class="p">(&lt;</span><span class="m">144</span> <span class="k">x</span> <span class="kt">float</span><span class="p">&gt;</span> <span class="nv">%conv.addedwrregion.join</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">16</span> <span class="k">x</span> <span class="kt">float</span><span class="p">&gt;</span> <span class="nv">%conv6</span><span class="p">,</span> <span class="k">i32</span> <span class="m">16</span><span class="p">,</span> <span class="k">i32</span> <span class="m">16</span><span class="p">,</span> <span class="k">i32</span> <span class="m">1</span><span class="p">,</span> <span class="k">i16</span> <span class="m">64</span><span class="p">,</span> <span class="k">i32</span> <span class="k">undef</span><span class="p">,</span> <span class="k">i1</span> <span class="k">true</span><span class="p">),</span> <span class="nv">!dbg</span> <span class="nv nv-Anonymous">!42</span>
<span class="nv">%rdr.cols.regioncollapsed8</span> <span class="p">=</span> <span class="k">call</span> <span class="p">&lt;</span><span class="m">16</span> <span class="k">x</span> <span class="k">i8</span><span class="p">&gt;</span> <span class="vg">@llvm.genx.rdregion.v16i8.v256i8.i16</span><span class="p">(&lt;</span><span class="m">256</span> <span class="k">x</span> <span class="k">i8</span><span class="p">&gt;</span> <span class="nv">%call1.i.i</span><span class="p">,</span> <span class="k">i32</span> <span class="m">16</span><span class="p">,</span> <span class="k">i32</span> <span class="m">16</span><span class="p">,</span> <span class="k">i32</span> <span class="m">1</span><span class="p">,</span> <span class="k">i16</span> <span class="m">75</span><span class="p">,</span> <span class="k">i32</span> <span class="k">undef</span><span class="p">),</span> <span class="nv">!dbg</span> <span class="nv nv-Anonymous">!42</span>
<span class="nv">%conv9</span> <span class="p">=</span> <span class="k">uitofp</span> <span class="p">&lt;</span><span class="m">16</span> <span class="k">x</span> <span class="k">i8</span><span class="p">&gt;</span> <span class="nv">%rdr.cols.regioncollapsed8</span> <span class="k">to</span> <span class="p">&lt;</span><span class="m">16</span> <span class="k">x</span> <span class="kt">float</span><span class="p">&gt;,</span> <span class="nv">!dbg</span> <span class="nv nv-Anonymous">!42</span>
<span class="nv">%conv.addedwrregion.join10</span> <span class="p">=</span> <span class="k">call</span> <span class="p">&lt;</span><span class="m">144</span> <span class="k">x</span> <span class="kt">float</span><span class="p">&gt;</span> <span class="vg">@llvm.genx.wrregion.v144f32.v16f32.i16.i1</span><span class="p">(&lt;</span><span class="m">144</span> <span class="k">x</span> <span class="kt">float</span><span class="p">&gt;</span> <span class="nv">%conv.addedwrregion.join7</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">16</span> <span class="k">x</span> <span class="kt">float</span><span class="p">&gt;</span> <span class="nv">%conv9</span><span class="p">,</span> <span class="k">i32</span> <span class="m">16</span><span class="p">,</span> <span class="k">i32</span> <span class="m">16</span><span class="p">,</span> <span class="k">i32</span> <span class="m">1</span><span class="p">,</span> <span class="k">i16</span> <span class="m">128</span><span class="p">,</span> <span class="k">i32</span> <span class="k">undef</span><span class="p">,</span> <span class="k">i1</span> <span class="k">true</span><span class="p">),</span> <span class="nv">!dbg</span> <span class="nv nv-Anonymous">!42</span>
<span class="nv">%rdr.cols.regioncollapsed11</span> <span class="p">=</span> <span class="k">call</span> <span class="p">&lt;</span><span class="m">16</span> <span class="k">x</span> <span class="k">i8</span><span class="p">&gt;</span> <span class="vg">@llvm.genx.rdregion.v16i8.v256i8.i16</span><span class="p">(&lt;</span><span class="m">256</span> <span class="k">x</span> <span class="k">i8</span><span class="p">&gt;</span> <span class="nv">%call1.i.i</span><span class="p">,</span> <span class="k">i32</span> <span class="m">16</span><span class="p">,</span> <span class="k">i32</span> <span class="m">16</span><span class="p">,</span> <span class="k">i32</span> <span class="m">1</span><span class="p">,</span> <span class="k">i16</span> <span class="m">99</span><span class="p">,</span> <span class="k">i32</span> <span class="k">undef</span><span class="p">),</span> <span class="nv">!dbg</span> <span class="nv nv-Anonymous">!42</span>
<span class="nv">%conv12</span> <span class="p">=</span> <span class="k">uitofp</span> <span class="p">&lt;</span><span class="m">16</span> <span class="k">x</span> <span class="k">i8</span><span class="p">&gt;</span> <span class="nv">%rdr.cols.regioncollapsed11</span> <span class="k">to</span> <span class="p">&lt;</span><span class="m">16</span> <span class="k">x</span> <span class="kt">float</span><span class="p">&gt;,</span> <span class="nv">!dbg</span> <span class="nv nv-Anonymous">!42</span>
<span class="nv">%conv.addedwrregion.join13</span> <span class="p">=</span> <span class="k">call</span> <span class="p">&lt;</span><span class="m">144</span> <span class="k">x</span> <span class="kt">float</span><span class="p">&gt;</span> <span class="vg">@llvm.genx.wrregion.v144f32.v16f32.i16.i1</span><span class="p">(&lt;</span><span class="m">144</span> <span class="k">x</span> <span class="kt">float</span><span class="p">&gt;</span> <span class="nv">%conv.addedwrregion.join10</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">16</span> <span class="k">x</span> <span class="kt">float</span><span class="p">&gt;</span> <span class="nv">%conv12</span><span class="p">,</span> <span class="k">i32</span> <span class="m">16</span><span class="p">,</span> <span class="k">i32</span> <span class="m">16</span><span class="p">,</span> <span class="k">i32</span> <span class="m">1</span><span class="p">,</span> <span class="k">i16</span> <span class="m">192</span><span class="p">,</span> <span class="k">i32</span> <span class="k">undef</span><span class="p">,</span> <span class="k">i1</span> <span class="k">true</span><span class="p">),</span> <span class="nv">!dbg</span> <span class="nv nv-Anonymous">!42</span>
<span class="nv">%rdr.cols.regioncollapsed14</span> <span class="p">=</span> <span class="k">call</span> <span class="p">&lt;</span><span class="m">16</span> <span class="k">x</span> <span class="k">i8</span><span class="p">&gt;</span> <span class="vg">@llvm.genx.rdregion.v16i8.v256i8.i16</span><span class="p">(&lt;</span><span class="m">256</span> <span class="k">x</span> <span class="k">i8</span><span class="p">&gt;</span> <span class="nv">%call1.i.i</span><span class="p">,</span> <span class="k">i32</span> <span class="m">16</span><span class="p">,</span> <span class="k">i32</span> <span class="m">8</span><span class="p">,</span> <span class="k">i32</span> <span class="m">1</span><span class="p">,</span> <span class="k">i16</span> <span class="m">115</span><span class="p">,</span> <span class="k">i32</span> <span class="k">undef</span><span class="p">),</span> <span class="nv">!dbg</span> <span class="nv nv-Anonymous">!42</span>
<span class="nv">%conv15</span> <span class="p">=</span> <span class="k">uitofp</span> <span class="p">&lt;</span><span class="m">16</span> <span class="k">x</span> <span class="k">i8</span><span class="p">&gt;</span> <span class="nv">%rdr.cols.regioncollapsed14</span> <span class="k">to</span> <span class="p">&lt;</span><span class="m">16</span> <span class="k">x</span> <span class="kt">float</span><span class="p">&gt;,</span> <span class="nv">!dbg</span> <span class="nv nv-Anonymous">!42</span>
<span class="nv">%conv.addedwrregion.join16</span> <span class="p">=</span> <span class="k">call</span> <span class="p">&lt;</span><span class="m">144</span> <span class="k">x</span> <span class="kt">float</span><span class="p">&gt;</span> <span class="vg">@llvm.genx.wrregion.v144f32.v16f32.i16.i1</span><span class="p">(&lt;</span><span class="m">144</span> <span class="k">x</span> <span class="kt">float</span><span class="p">&gt;</span> <span class="nv">%conv.addedwrregion.join13</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">16</span> <span class="k">x</span> <span class="kt">float</span><span class="p">&gt;</span> <span class="nv">%conv15</span><span class="p">,</span> <span class="k">i32</span> <span class="m">16</span><span class="p">,</span> <span class="k">i32</span> <span class="m">16</span><span class="p">,</span> <span class="k">i32</span> <span class="m">1</span><span class="p">,</span> <span class="k">i16</span> <span class="m">256</span><span class="p">,</span> <span class="k">i32</span> <span class="k">undef</span><span class="p">,</span> <span class="k">i1</span> <span class="k">true</span><span class="p">),</span> <span class="nv">!dbg</span> <span class="nv nv-Anonymous">!42</span>
<span class="nv">%rdr.cols.regioncollapsed17</span> <span class="p">=</span> <span class="k">call</span> <span class="p">&lt;</span><span class="m">16</span> <span class="k">x</span> <span class="k">i8</span><span class="p">&gt;</span> <span class="vg">@llvm.genx.rdregion.v16i8.v256i8.i16</span><span class="p">(&lt;</span><span class="m">256</span> <span class="k">x</span> <span class="k">i8</span><span class="p">&gt;</span> <span class="nv">%call1.i.i</span><span class="p">,</span> <span class="k">i32</span> <span class="m">16</span><span class="p">,</span> <span class="k">i32</span> <span class="m">16</span><span class="p">,</span> <span class="k">i32</span> <span class="m">1</span><span class="p">,</span> <span class="k">i16</span> <span class="m">139</span><span class="p">,</span> <span class="k">i32</span> <span class="k">undef</span><span class="p">),</span> <span class="nv">!dbg</span> <span class="nv nv-Anonymous">!42</span>
<span class="nv">%conv18</span> <span class="p">=</span> <span class="k">uitofp</span> <span class="p">&lt;</span><span class="m">16</span> <span class="k">x</span> <span class="k">i8</span><span class="p">&gt;</span> <span class="nv">%rdr.cols.regioncollapsed17</span> <span class="k">to</span> <span class="p">&lt;</span><span class="m">16</span> <span class="k">x</span> <span class="kt">float</span><span class="p">&gt;,</span> <span class="nv">!dbg</span> <span class="nv nv-Anonymous">!42</span>
<span class="nv">%conv.addedwrregion.join19</span> <span class="p">=</span> <span class="k">call</span> <span class="p">&lt;</span><span class="m">144</span> <span class="k">x</span> <span class="kt">float</span><span class="p">&gt;</span> <span class="vg">@llvm.genx.wrregion.v144f32.v16f32.i16.i1</span><span class="p">(&lt;</span><span class="m">144</span> <span class="k">x</span> <span class="kt">float</span><span class="p">&gt;</span> <span class="nv">%conv.addedwrregion.join16</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">16</span> <span class="k">x</span> <span class="kt">float</span><span class="p">&gt;</span> <span class="nv">%conv18</span><span class="p">,</span> <span class="k">i32</span> <span class="m">16</span><span class="p">,</span> <span class="k">i32</span> <span class="m">16</span><span class="p">,</span> <span class="k">i32</span> <span class="m">1</span><span class="p">,</span> <span class="k">i16</span> <span class="m">320</span><span class="p">,</span> <span class="k">i32</span> <span class="k">undef</span><span class="p">,</span> <span class="k">i1</span> <span class="k">true</span><span class="p">),</span> <span class="nv">!dbg</span> <span class="nv nv-Anonymous">!42</span>
<span class="nv">%rdr.cols.regioncollapsed20</span> <span class="p">=</span> <span class="k">call</span> <span class="p">&lt;</span><span class="m">16</span> <span class="k">x</span> <span class="k">i8</span><span class="p">&gt;</span> <span class="vg">@llvm.genx.rdregion.v16i8.v256i8.i16</span><span class="p">(&lt;</span><span class="m">256</span> <span class="k">x</span> <span class="k">i8</span><span class="p">&gt;</span> <span class="nv">%call1.i.i</span><span class="p">,</span> <span class="k">i32</span> <span class="m">16</span><span class="p">,</span> <span class="k">i32</span> <span class="m">16</span><span class="p">,</span> <span class="k">i32</span> <span class="m">1</span><span class="p">,</span> <span class="k">i16</span> <span class="m">163</span><span class="p">,</span> <span class="k">i32</span> <span class="k">undef</span><span class="p">),</span> <span class="nv">!dbg</span> <span class="nv nv-Anonymous">!42</span>
<span class="nv">%conv21</span> <span class="p">=</span> <span class="k">uitofp</span> <span class="p">&lt;</span><span class="m">16</span> <span class="k">x</span> <span class="k">i8</span><span class="p">&gt;</span> <span class="nv">%rdr.cols.regioncollapsed20</span> <span class="k">to</span> <span class="p">&lt;</span><span class="m">16</span> <span class="k">x</span> <span class="kt">float</span><span class="p">&gt;,</span> <span class="nv">!dbg</span> <span class="nv nv-Anonymous">!42</span>
<span class="nv">%conv.addedwrregion.join22</span> <span class="p">=</span> <span class="k">call</span> <span class="p">&lt;</span><span class="m">144</span> <span class="k">x</span> <span class="kt">float</span><span class="p">&gt;</span> <span class="vg">@llvm.genx.wrregion.v144f32.v16f32.i16.i1</span><span class="p">(&lt;</span><span class="m">144</span> <span class="k">x</span> <span class="kt">float</span><span class="p">&gt;</span> <span class="nv">%conv.addedwrregion.join19</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">16</span> <span class="k">x</span> <span class="kt">float</span><span class="p">&gt;</span> <span class="nv">%conv21</span><span class="p">,</span> <span class="k">i32</span> <span class="m">16</span><span class="p">,</span> <span class="k">i32</span> <span class="m">16</span><span class="p">,</span> <span class="k">i32</span> <span class="m">1</span><span class="p">,</span> <span class="k">i16</span> <span class="m">384</span><span class="p">,</span> <span class="k">i32</span> <span class="k">undef</span><span class="p">,</span> <span class="k">i1</span> <span class="k">true</span><span class="p">),</span> <span class="nv">!dbg</span> <span class="nv nv-Anonymous">!42</span>
<span class="nv">%rdr.cols.regioncollapsed23</span> <span class="p">=</span> <span class="k">call</span> <span class="p">&lt;</span><span class="m">16</span> <span class="k">x</span> <span class="k">i8</span><span class="p">&gt;</span> <span class="vg">@llvm.genx.rdregion.v16i8.v256i8.i16</span><span class="p">(&lt;</span><span class="m">256</span> <span class="k">x</span> <span class="k">i8</span><span class="p">&gt;</span> <span class="nv">%call1.i.i</span><span class="p">,</span> <span class="k">i32</span> <span class="m">16</span><span class="p">,</span> <span class="k">i32</span> <span class="m">8</span><span class="p">,</span> <span class="k">i32</span> <span class="m">1</span><span class="p">,</span> <span class="k">i16</span> <span class="m">179</span><span class="p">,</span> <span class="k">i32</span> <span class="k">undef</span><span class="p">),</span> <span class="nv">!dbg</span> <span class="nv nv-Anonymous">!42</span>
<span class="nv">%conv24</span> <span class="p">=</span> <span class="k">uitofp</span> <span class="p">&lt;</span><span class="m">16</span> <span class="k">x</span> <span class="k">i8</span><span class="p">&gt;</span> <span class="nv">%rdr.cols.regioncollapsed23</span> <span class="k">to</span> <span class="p">&lt;</span><span class="m">16</span> <span class="k">x</span> <span class="kt">float</span><span class="p">&gt;,</span> <span class="nv">!dbg</span> <span class="nv nv-Anonymous">!42</span>
<span class="nv">%conv.addedwrregion.join25</span> <span class="p">=</span> <span class="k">call</span> <span class="p">&lt;</span><span class="m">144</span> <span class="k">x</span> <span class="kt">float</span><span class="p">&gt;</span> <span class="vg">@llvm.genx.wrregion.v144f32.v16f32.i16.i1</span><span class="p">(&lt;</span><span class="m">144</span> <span class="k">x</span> <span class="kt">float</span><span class="p">&gt;</span> <span class="nv">%conv.addedwrregion.join22</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">16</span> <span class="k">x</span> <span class="kt">float</span><span class="p">&gt;</span> <span class="nv">%conv24</span><span class="p">,</span> <span class="k">i32</span> <span class="m">16</span><span class="p">,</span> <span class="k">i32</span> <span class="m">16</span><span class="p">,</span> <span class="k">i32</span> <span class="m">1</span><span class="p">,</span> <span class="k">i16</span> <span class="m">448</span><span class="p">,</span> <span class="k">i32</span> <span class="k">undef</span><span class="p">,</span> <span class="k">i1</span> <span class="k">true</span><span class="p">),</span> <span class="nv">!dbg</span> <span class="nv nv-Anonymous">!42</span>
<span class="nv">%rdr.cols.regioncollapsed26</span> <span class="p">=</span> <span class="k">call</span> <span class="p">&lt;</span><span class="m">16</span> <span class="k">x</span> <span class="k">i8</span><span class="p">&gt;</span> <span class="vg">@llvm.genx.rdregion.v16i8.v256i8.i16</span><span class="p">(&lt;</span><span class="m">256</span> <span class="k">x</span> <span class="k">i8</span><span class="p">&gt;</span> <span class="nv">%call1.i.i</span><span class="p">,</span> <span class="k">i32</span> <span class="m">16</span><span class="p">,</span> <span class="k">i32</span> <span class="m">16</span><span class="p">,</span> <span class="k">i32</span> <span class="m">1</span><span class="p">,</span> <span class="k">i16</span> <span class="m">203</span><span class="p">,</span> <span class="k">i32</span> <span class="k">undef</span><span class="p">),</span> <span class="nv">!dbg</span> <span class="nv nv-Anonymous">!42</span>
<span class="nv">%conv27</span> <span class="p">=</span> <span class="k">uitofp</span> <span class="p">&lt;</span><span class="m">16</span> <span class="k">x</span> <span class="k">i8</span><span class="p">&gt;</span> <span class="nv">%rdr.cols.regioncollapsed26</span> <span class="k">to</span> <span class="p">&lt;</span><span class="m">16</span> <span class="k">x</span> <span class="kt">float</span><span class="p">&gt;,</span> <span class="nv">!dbg</span> <span class="nv nv-Anonymous">!42</span>
<span class="nv">%conv.addedwrregion.join28</span> <span class="p">=</span> <span class="k">call</span> <span class="p">&lt;</span><span class="m">144</span> <span class="k">x</span> <span class="kt">float</span><span class="p">&gt;</span> <span class="vg">@llvm.genx.wrregion.v144f32.v16f32.i16.i1</span><span class="p">(&lt;</span><span class="m">144</span> <span class="k">x</span> <span class="kt">float</span><span class="p">&gt;</span> <span class="nv">%conv.addedwrregion.join25</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">16</span> <span class="k">x</span> <span class="kt">float</span><span class="p">&gt;</span> <span class="nv">%conv27</span><span class="p">,</span> <span class="k">i32</span> <span class="m">16</span><span class="p">,</span> <span class="k">i32</span> <span class="m">16</span><span class="p">,</span> <span class="k">i32</span> <span class="m">1</span><span class="p">,</span> <span class="k">i16</span> <span class="m">512</span><span class="p">,</span> <span class="k">i32</span> <span class="k">undef</span><span class="p">,</span> <span class="k">i1</span> <span class="k">true</span><span class="p">),</span> <span class="nv">!dbg</span> <span class="nv nv-Anonymous">!42</span>
</pre></div>
</div>
<p>Note that baling information has now been discarded, as it applied to the original
unsplit instructions, not these new split instructions.</p>
</div>
<div class="section" id="genxpostlegalization-and-vector-decomposition">
<h4><a class="toc-backref" href="#id26">GenXPostLegalization and vector decomposition</a><a class="headerlink" href="#genxpostlegalization-and-vector-decomposition" title="Permalink to this headline">¶</a></h4>
<p>One of the purposes of the GenXPostLegalization pass is to call
GenXVectorDecomposer.</p>
<p>For a vector written by wrregion and read by rdregion (often
but not always from legalization),
the vector decomposer it finds the way that
the vector can be divided into parts, with each part a range of one or more
GRFs, such that no rdregion or wrregion crosses a part boundary. Then it
decomposes the vector into those parts. A rdregion/wrregion that reads/writes
a whole part can be removed completely; a rdregion/wrregion that reads/writes
only some of the part is replaced to read/write just the applicable part.</p>
<p>In fact it does all this for a web of vectors linked by wrregion, phi nodes
and bitcasts.</p>
<p>The idea is that having lots of small vectors instead of one big vector
reduces register fragmentation in the finalizer’s register allocator.</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv">%rdr.cols.regioncollapsed3</span> <span class="p">=</span> <span class="k">call</span> <span class="p">&lt;</span><span class="m">16</span> <span class="k">x</span> <span class="k">i8</span><span class="p">&gt;</span> <span class="vg">@llvm.genx.rdregion.v16i8.v256i8.i16</span><span class="p">(&lt;</span><span class="m">256</span> <span class="k">x</span> <span class="k">i8</span><span class="p">&gt;</span> <span class="nv">%call1.i.i</span><span class="p">,</span> <span class="k">i32</span> <span class="m">16</span><span class="p">,</span> <span class="k">i32</span> <span class="m">16</span><span class="p">,</span> <span class="k">i32</span> <span class="m">1</span><span class="p">,</span> <span class="k">i16</span> <span class="m">35</span><span class="p">,</span> <span class="k">i32</span> <span class="k">undef</span><span class="p">),</span> <span class="nv">!dbg</span> <span class="nv nv-Anonymous">!42</span>
<span class="nv">%conv4</span> <span class="p">=</span> <span class="k">uitofp</span> <span class="p">&lt;</span><span class="m">16</span> <span class="k">x</span> <span class="k">i8</span><span class="p">&gt;</span> <span class="nv">%rdr.cols.regioncollapsed3</span> <span class="k">to</span> <span class="p">&lt;</span><span class="m">16</span> <span class="k">x</span> <span class="kt">float</span><span class="p">&gt;,</span> <span class="nv">!dbg</span> <span class="nv nv-Anonymous">!42</span>
<span class="nv">%rdr.cols.regioncollapsed5</span> <span class="p">=</span> <span class="k">call</span> <span class="p">&lt;</span><span class="m">16</span> <span class="k">x</span> <span class="k">i8</span><span class="p">&gt;</span> <span class="vg">@llvm.genx.rdregion.v16i8.v256i8.i16</span><span class="p">(&lt;</span><span class="m">256</span> <span class="k">x</span> <span class="k">i8</span><span class="p">&gt;</span> <span class="nv">%call1.i.i</span><span class="p">,</span> <span class="k">i32</span> <span class="m">16</span><span class="p">,</span> <span class="k">i32</span> <span class="m">8</span><span class="p">,</span> <span class="k">i32</span> <span class="m">1</span><span class="p">,</span> <span class="k">i16</span> <span class="m">51</span><span class="p">,</span> <span class="k">i32</span> <span class="k">undef</span><span class="p">),</span> <span class="nv">!dbg</span> <span class="nv nv-Anonymous">!42</span>
<span class="nv">%conv6</span> <span class="p">=</span> <span class="k">uitofp</span> <span class="p">&lt;</span><span class="m">16</span> <span class="k">x</span> <span class="k">i8</span><span class="p">&gt;</span> <span class="nv">%rdr.cols.regioncollapsed5</span> <span class="k">to</span> <span class="p">&lt;</span><span class="m">16</span> <span class="k">x</span> <span class="kt">float</span><span class="p">&gt;,</span> <span class="nv">!dbg</span> <span class="nv nv-Anonymous">!42</span>
<span class="nv">%conv.addedwrregion.join7.decomp.1</span> <span class="p">=</span> <span class="k">call</span> <span class="p">&lt;</span><span class="m">32</span> <span class="k">x</span> <span class="kt">float</span><span class="p">&gt;</span> <span class="vg">@llvm.genx.wrregion.v32f32.v16f32.i16.i1</span><span class="p">(&lt;</span><span class="m">32</span> <span class="k">x</span> <span class="kt">float</span><span class="p">&gt;</span> <span class="k">undef</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">16</span> <span class="k">x</span> <span class="kt">float</span><span class="p">&gt;</span> <span class="nv">%conv6</span><span class="p">,</span> <span class="k">i32</span> <span class="m">0</span><span class="p">,</span> <span class="k">i32</span> <span class="m">16</span><span class="p">,</span> <span class="k">i32</span> <span class="m">1</span><span class="p">,</span> <span class="k">i16</span> <span class="m">0</span><span class="p">,</span> <span class="k">i32</span> <span class="k">undef</span><span class="p">,</span> <span class="k">i1</span> <span class="k">true</span><span class="p">),</span> <span class="nv">!dbg</span> <span class="nv nv-Anonymous">!42</span>
<span class="nv">%rdr.cols.regioncollapsed8</span> <span class="p">=</span> <span class="k">call</span> <span class="p">&lt;</span><span class="m">16</span> <span class="k">x</span> <span class="k">i8</span><span class="p">&gt;</span> <span class="vg">@llvm.genx.rdregion.v16i8.v256i8.i16</span><span class="p">(&lt;</span><span class="m">256</span> <span class="k">x</span> <span class="k">i8</span><span class="p">&gt;</span> <span class="nv">%call1.i.i</span><span class="p">,</span> <span class="k">i32</span> <span class="m">16</span><span class="p">,</span> <span class="k">i32</span> <span class="m">16</span><span class="p">,</span> <span class="k">i32</span> <span class="m">1</span><span class="p">,</span> <span class="k">i16</span> <span class="m">75</span><span class="p">,</span> <span class="k">i32</span> <span class="k">undef</span><span class="p">),</span> <span class="nv">!dbg</span> <span class="nv nv-Anonymous">!42</span>
<span class="nv">%conv9</span> <span class="p">=</span> <span class="k">uitofp</span> <span class="p">&lt;</span><span class="m">16</span> <span class="k">x</span> <span class="k">i8</span><span class="p">&gt;</span> <span class="nv">%rdr.cols.regioncollapsed8</span> <span class="k">to</span> <span class="p">&lt;</span><span class="m">16</span> <span class="k">x</span> <span class="kt">float</span><span class="p">&gt;,</span> <span class="nv">!dbg</span> <span class="nv nv-Anonymous">!42</span>
<span class="nv">%conv.addedwrregion.join10.decomp.1</span> <span class="p">=</span> <span class="k">call</span> <span class="p">&lt;</span><span class="m">32</span> <span class="k">x</span> <span class="kt">float</span><span class="p">&gt;</span> <span class="vg">@llvm.genx.wrregion.v32f32.v16f32.i16.i1</span><span class="p">(&lt;</span><span class="m">32</span> <span class="k">x</span> <span class="kt">float</span><span class="p">&gt;</span> <span class="nv">%conv.addedwrregion.join7.decomp.1</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">16</span> <span class="k">x</span> <span class="kt">float</span><span class="p">&gt;</span> <span class="nv">%conv9</span><span class="p">,</span> <span class="k">i32</span> <span class="m">0</span><span class="p">,</span> <span class="k">i32</span> <span class="m">16</span><span class="p">,</span> <span class="k">i32</span> <span class="m">1</span><span class="p">,</span> <span class="k">i16</span> <span class="m">64</span><span class="p">,</span> <span class="k">i32</span> <span class="k">undef</span><span class="p">,</span> <span class="k">i1</span> <span class="k">true</span><span class="p">),</span> <span class="nv">!dbg</span> <span class="nv nv-Anonymous">!42</span>
<span class="nv">%rdr.cols.regioncollapsed11</span> <span class="p">=</span> <span class="k">call</span> <span class="p">&lt;</span><span class="m">16</span> <span class="k">x</span> <span class="k">i8</span><span class="p">&gt;</span> <span class="vg">@llvm.genx.rdregion.v16i8.v256i8.i16</span><span class="p">(&lt;</span><span class="m">256</span> <span class="k">x</span> <span class="k">i8</span><span class="p">&gt;</span> <span class="nv">%call1.i.i</span><span class="p">,</span> <span class="k">i32</span> <span class="m">16</span><span class="p">,</span> <span class="k">i32</span> <span class="m">16</span><span class="p">,</span> <span class="k">i32</span> <span class="m">1</span><span class="p">,</span> <span class="k">i16</span> <span class="m">99</span><span class="p">,</span> <span class="k">i32</span> <span class="k">undef</span><span class="p">),</span> <span class="nv">!dbg</span> <span class="nv nv-Anonymous">!42</span>
<span class="nv">%conv12</span> <span class="p">=</span> <span class="k">uitofp</span> <span class="p">&lt;</span><span class="m">16</span> <span class="k">x</span> <span class="k">i8</span><span class="p">&gt;</span> <span class="nv">%rdr.cols.regioncollapsed11</span> <span class="k">to</span> <span class="p">&lt;</span><span class="m">16</span> <span class="k">x</span> <span class="kt">float</span><span class="p">&gt;,</span> <span class="nv">!dbg</span> <span class="nv nv-Anonymous">!42</span>
<span class="nv">%rdr.cols.regioncollapsed14</span> <span class="p">=</span> <span class="k">call</span> <span class="p">&lt;</span><span class="m">16</span> <span class="k">x</span> <span class="k">i8</span><span class="p">&gt;</span> <span class="vg">@llvm.genx.rdregion.v16i8.v256i8.i16</span><span class="p">(&lt;</span><span class="m">256</span> <span class="k">x</span> <span class="k">i8</span><span class="p">&gt;</span> <span class="nv">%call1.i.i</span><span class="p">,</span> <span class="k">i32</span> <span class="m">16</span><span class="p">,</span> <span class="k">i32</span> <span class="m">8</span><span class="p">,</span> <span class="k">i32</span> <span class="m">1</span><span class="p">,</span> <span class="k">i16</span> <span class="m">115</span><span class="p">,</span> <span class="k">i32</span> <span class="k">undef</span><span class="p">),</span> <span class="nv">!dbg</span> <span class="nv nv-Anonymous">!42</span>
<span class="nv">%conv15</span> <span class="p">=</span> <span class="k">uitofp</span> <span class="p">&lt;</span><span class="m">16</span> <span class="k">x</span> <span class="k">i8</span><span class="p">&gt;</span> <span class="nv">%rdr.cols.regioncollapsed14</span> <span class="k">to</span> <span class="p">&lt;</span><span class="m">16</span> <span class="k">x</span> <span class="kt">float</span><span class="p">&gt;,</span> <span class="nv">!dbg</span> <span class="nv nv-Anonymous">!42</span>
<span class="nv">%conv.addedwrregion.join16.decomp.3</span> <span class="p">=</span> <span class="k">call</span> <span class="p">&lt;</span><span class="m">32</span> <span class="k">x</span> <span class="kt">float</span><span class="p">&gt;</span> <span class="vg">@llvm.genx.wrregion.v32f32.v16f32.i16.i1</span><span class="p">(&lt;</span><span class="m">32</span> <span class="k">x</span> <span class="kt">float</span><span class="p">&gt;</span> <span class="k">undef</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">16</span> <span class="k">x</span> <span class="kt">float</span><span class="p">&gt;</span> <span class="nv">%conv15</span><span class="p">,</span> <span class="k">i32</span> <span class="m">0</span><span class="p">,</span> <span class="k">i32</span> <span class="m">16</span><span class="p">,</span> <span class="k">i32</span> <span class="m">1</span><span class="p">,</span> <span class="k">i16</span> <span class="m">0</span><span class="p">,</span> <span class="k">i32</span> <span class="k">undef</span><span class="p">,</span> <span class="k">i1</span> <span class="k">true</span><span class="p">),</span> <span class="nv">!dbg</span> <span class="nv nv-Anonymous">!42</span>
<span class="nv">%rdr.cols.regioncollapsed17</span> <span class="p">=</span> <span class="k">call</span> <span class="p">&lt;</span><span class="m">16</span> <span class="k">x</span> <span class="k">i8</span><span class="p">&gt;</span> <span class="vg">@llvm.genx.rdregion.v16i8.v256i8.i16</span><span class="p">(&lt;</span><span class="m">256</span> <span class="k">x</span> <span class="k">i8</span><span class="p">&gt;</span> <span class="nv">%call1.i.i</span><span class="p">,</span> <span class="k">i32</span> <span class="m">16</span><span class="p">,</span> <span class="k">i32</span> <span class="m">16</span><span class="p">,</span> <span class="k">i32</span> <span class="m">1</span><span class="p">,</span> <span class="k">i16</span> <span class="m">139</span><span class="p">,</span> <span class="k">i32</span> <span class="k">undef</span><span class="p">),</span> <span class="nv">!dbg</span> <span class="nv nv-Anonymous">!42</span>
<span class="nv">%conv18</span> <span class="p">=</span> <span class="k">uitofp</span> <span class="p">&lt;</span><span class="m">16</span> <span class="k">x</span> <span class="k">i8</span><span class="p">&gt;</span> <span class="nv">%rdr.cols.regioncollapsed17</span> <span class="k">to</span> <span class="p">&lt;</span><span class="m">16</span> <span class="k">x</span> <span class="kt">float</span><span class="p">&gt;,</span> <span class="nv">!dbg</span> <span class="nv nv-Anonymous">!42</span>
<span class="nv">%conv.addedwrregion.join19.decomp.3</span> <span class="p">=</span> <span class="k">call</span> <span class="p">&lt;</span><span class="m">32</span> <span class="k">x</span> <span class="kt">float</span><span class="p">&gt;</span> <span class="vg">@llvm.genx.wrregion.v32f32.v16f32.i16.i1</span><span class="p">(&lt;</span><span class="m">32</span> <span class="k">x</span> <span class="kt">float</span><span class="p">&gt;</span> <span class="nv">%conv.addedwrregion.join16.decomp.3</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">16</span> <span class="k">x</span> <span class="kt">float</span><span class="p">&gt;</span> <span class="nv">%conv18</span><span class="p">,</span> <span class="k">i32</span> <span class="m">0</span><span class="p">,</span> <span class="k">i32</span> <span class="m">16</span><span class="p">,</span> <span class="k">i32</span> <span class="m">1</span><span class="p">,</span> <span class="k">i16</span> <span class="m">64</span><span class="p">,</span> <span class="k">i32</span> <span class="k">undef</span><span class="p">,</span> <span class="k">i1</span> <span class="k">true</span><span class="p">),</span> <span class="nv">!dbg</span> <span class="nv nv-Anonymous">!42</span>
<span class="nv">%rdr.cols.regioncollapsed20</span> <span class="p">=</span> <span class="k">call</span> <span class="p">&lt;</span><span class="m">16</span> <span class="k">x</span> <span class="k">i8</span><span class="p">&gt;</span> <span class="vg">@llvm.genx.rdregion.v16i8.v256i8.i16</span><span class="p">(&lt;</span><span class="m">256</span> <span class="k">x</span> <span class="k">i8</span><span class="p">&gt;</span> <span class="nv">%call1.i.i</span><span class="p">,</span> <span class="k">i32</span> <span class="m">16</span><span class="p">,</span> <span class="k">i32</span> <span class="m">16</span><span class="p">,</span> <span class="k">i32</span> <span class="m">1</span><span class="p">,</span> <span class="k">i16</span> <span class="m">163</span><span class="p">,</span> <span class="k">i32</span> <span class="k">undef</span><span class="p">),</span> <span class="nv">!dbg</span> <span class="nv nv-Anonymous">!42</span>
<span class="nv">%conv21</span> <span class="p">=</span> <span class="k">uitofp</span> <span class="p">&lt;</span><span class="m">16</span> <span class="k">x</span> <span class="k">i8</span><span class="p">&gt;</span> <span class="nv">%rdr.cols.regioncollapsed20</span> <span class="k">to</span> <span class="p">&lt;</span><span class="m">16</span> <span class="k">x</span> <span class="kt">float</span><span class="p">&gt;,</span> <span class="nv">!dbg</span> <span class="nv nv-Anonymous">!42</span>
<span class="nv">%rdr.cols.regioncollapsed23</span> <span class="p">=</span> <span class="k">call</span> <span class="p">&lt;</span><span class="m">16</span> <span class="k">x</span> <span class="k">i8</span><span class="p">&gt;</span> <span class="vg">@llvm.genx.rdregion.v16i8.v256i8.i16</span><span class="p">(&lt;</span><span class="m">256</span> <span class="k">x</span> <span class="k">i8</span><span class="p">&gt;</span> <span class="nv">%call1.i.i</span><span class="p">,</span> <span class="k">i32</span> <span class="m">16</span><span class="p">,</span> <span class="k">i32</span> <span class="m">8</span><span class="p">,</span> <span class="k">i32</span> <span class="m">1</span><span class="p">,</span> <span class="k">i16</span> <span class="m">179</span><span class="p">,</span> <span class="k">i32</span> <span class="k">undef</span><span class="p">),</span> <span class="nv">!dbg</span> <span class="nv nv-Anonymous">!42</span>
<span class="nv">%conv24</span> <span class="p">=</span> <span class="k">uitofp</span> <span class="p">&lt;</span><span class="m">16</span> <span class="k">x</span> <span class="k">i8</span><span class="p">&gt;</span> <span class="nv">%rdr.cols.regioncollapsed23</span> <span class="k">to</span> <span class="p">&lt;</span><span class="m">16</span> <span class="k">x</span> <span class="kt">float</span><span class="p">&gt;,</span> <span class="nv">!dbg</span> <span class="nv nv-Anonymous">!42</span>
<span class="nv">%conv.addedwrregion.join25.decomp.5</span> <span class="p">=</span> <span class="k">call</span> <span class="p">&lt;</span><span class="m">32</span> <span class="k">x</span> <span class="kt">float</span><span class="p">&gt;</span> <span class="vg">@llvm.genx.wrregion.v32f32.v16f32.i16.i1</span><span class="p">(&lt;</span><span class="m">32</span> <span class="k">x</span> <span class="kt">float</span><span class="p">&gt;</span> <span class="k">undef</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">16</span> <span class="k">x</span> <span class="kt">float</span><span class="p">&gt;</span> <span class="nv">%conv24</span><span class="p">,</span> <span class="k">i32</span> <span class="m">0</span><span class="p">,</span> <span class="k">i32</span> <span class="m">16</span><span class="p">,</span> <span class="k">i32</span> <span class="m">1</span><span class="p">,</span> <span class="k">i16</span> <span class="m">0</span><span class="p">,</span> <span class="k">i32</span> <span class="k">undef</span><span class="p">,</span> <span class="k">i1</span> <span class="k">true</span><span class="p">),</span> <span class="nv">!dbg</span> <span class="nv nv-Anonymous">!42</span>
<span class="nv">%rdr.cols.regioncollapsed26</span> <span class="p">=</span> <span class="k">call</span> <span class="p">&lt;</span><span class="m">16</span> <span class="k">x</span> <span class="k">i8</span><span class="p">&gt;</span> <span class="vg">@llvm.genx.rdregion.v16i8.v256i8.i16</span><span class="p">(&lt;</span><span class="m">256</span> <span class="k">x</span> <span class="k">i8</span><span class="p">&gt;</span> <span class="nv">%call1.i.i</span><span class="p">,</span> <span class="k">i32</span> <span class="m">16</span><span class="p">,</span> <span class="k">i32</span> <span class="m">16</span><span class="p">,</span> <span class="k">i32</span> <span class="m">1</span><span class="p">,</span> <span class="k">i16</span> <span class="m">203</span><span class="p">,</span> <span class="k">i32</span> <span class="k">undef</span><span class="p">),</span> <span class="nv">!dbg</span> <span class="nv nv-Anonymous">!42</span>
<span class="nv">%conv27</span> <span class="p">=</span> <span class="k">uitofp</span> <span class="p">&lt;</span><span class="m">16</span> <span class="k">x</span> <span class="k">i8</span><span class="p">&gt;</span> <span class="nv">%rdr.cols.regioncollapsed26</span> <span class="k">to</span> <span class="p">&lt;</span><span class="m">16</span> <span class="k">x</span> <span class="kt">float</span><span class="p">&gt;,</span> <span class="nv">!dbg</span> <span class="nv nv-Anonymous">!42</span>
<span class="nv">%conv.addedwrregion.join28.decomp.5</span> <span class="p">=</span> <span class="k">call</span> <span class="p">&lt;</span><span class="m">32</span> <span class="k">x</span> <span class="kt">float</span><span class="p">&gt;</span> <span class="vg">@llvm.genx.wrregion.v32f32.v16f32.i16.i1</span><span class="p">(&lt;</span><span class="m">32</span> <span class="k">x</span> <span class="kt">float</span><span class="p">&gt;</span> <span class="nv">%conv.addedwrregion.join25.decomp.5</span><span class="p">,</span> <span class="p">&lt;</span><span class="m">16</span> <span class="k">x</span> <span class="kt">float</span><span class="p">&gt;</span> <span class="nv">%conv27</span><span class="p">,</span> <span class="k">i32</span> <span class="m">0</span><span class="p">,</span> <span class="k">i32</span> <span class="m">16</span><span class="p">,</span> <span class="k">i32</span> <span class="m">1</span><span class="p">,</span> <span class="k">i16</span> <span class="m">64</span><span class="p">,</span> <span class="k">i32</span> <span class="k">undef</span><span class="p">,</span> <span class="k">i1</span> <span class="k">true</span><span class="p">),</span> <span class="nv">!dbg</span> <span class="nv nv-Anonymous">!42</span>
</pre></div>
</div>
<p>Here the 6x24 float matrix (144 elements) has been decomposed into six vectors:</p>
<ul class="simple">
<li>&lt;16 x float&gt; %conv4</li>
<li>&lt;32 x float&gt; %conv.addedwrregion.join10.decomp.1 (which still needs two
wrregions to be joined together from its two 16 wide uitofp instructions)</li>
<li>&lt;16 x float&gt; %conv12</li>
<li>&lt;32 x float&gt; %conv.addedwrregion.join19.decomp.3 (ditto)</li>
<li>&lt;16 x float&gt; %conv21</li>
<li>&lt;32 x float&gt; %conv.addedwrregion.join28.decomp.5 (ditto)</li>
</ul>
<p>The 8x32 uchar input matrix does not get decomposed at all, because it is written
by a llvm.genx.media.ld that writes to the whole matrix in one go.</p>
</div>
<div class="section" id="id2">
<h4><a class="toc-backref" href="#id27">Categories</a><a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>Again, GenXCategory determines that all these values need to be <code class="docutils literal"><span class="pre">{general}</span></code>
category, and it create a <code class="docutils literal"><span class="pre">LiveRange</span></code> for each one to store that information
in.</p>
</div>
<div class="section" id="second-baling">
<h4><a class="toc-backref" href="#id28">Second baling</a><a class="headerlink" href="#second-baling" title="Permalink to this headline">¶</a></h4>
<p>At this point, GenXBaling is run again. Because the code has now been legalized
(split into legal regions and vector sizes), this time the bales pretty much
represent how the IR instructions will be joined into vISA instructions.</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>bale {
   %rdr.cols.regioncollapsed3 = call &lt;16 x i8&gt; @llvm.genx.rdregion.v16i8.v256i8.i16(&lt;256 x i8&gt; %call1.i.i, i32 16, i32 16, i32 1, i16 35, i32 undef), !dbg !42 {rdregion} // line 23
   %conv4 = uitofp &lt;16 x i8&gt; %rdr.cols.regioncollapsed3 to &lt;16 x float&gt;, !dbg !42 // line 23
}
bale {
   %rdr.cols.regioncollapsed5 = call &lt;16 x i8&gt; @llvm.genx.rdregion.v16i8.v256i8.i16(&lt;256 x i8&gt; %call1.i.i, i32 16, i32 8, i32 1, i16 51, i32 undef), !dbg !42 {rdregion} // line 23
   %conv6 = uitofp &lt;16 x i8&gt; %rdr.cols.regioncollapsed5 to &lt;16 x float&gt;, !dbg !42 // line 23
   %conv.addedwrregion.join7.decomp.1 = call &lt;32 x float&gt; @llvm.genx.wrregion.v32f32.v16f32.i16.i1(&lt;32 x float&gt; undef, &lt;16 x float&gt; %conv6, i32 0, i32 16, i32 1, i16 0, i32 undef, i1 true), !dbg !42 {wrregion} // line 23
}
bale {
   %rdr.cols.regioncollapsed8 = call &lt;16 x i8&gt; @llvm.genx.rdregion.v16i8.v256i8.i16(&lt;256 x i8&gt; %call1.i.i, i32 16, i32 16, i32 1, i16 75, i32 undef), !dbg !42 {rdregion} // line 23
   %conv9 = uitofp &lt;16 x i8&gt; %rdr.cols.regioncollapsed8 to &lt;16 x float&gt;, !dbg !42 // line 23
   %conv.addedwrregion.join10.decomp.1 = call &lt;32 x float&gt; @llvm.genx.wrregion.v32f32.v16f32.i16.i1(&lt;32 x float&gt; %conv.addedwrregion.join7.decomp.1, &lt;16 x float&gt; %conv9, i32 0, i32 16, i32 1, i16 64, i32 undef, i1 true), !dbg !42 {wrregion} // line 23
}
bale {
   %rdr.cols.regioncollapsed11 = call &lt;16 x i8&gt; @llvm.genx.rdregion.v16i8.v256i8.i16(&lt;256 x i8&gt; %call1.i.i, i32 16, i32 16, i32 1, i16 99, i32 undef), !dbg !42 {rdregion} // line 23
   %conv12 = uitofp &lt;16 x i8&gt; %rdr.cols.regioncollapsed11 to &lt;16 x float&gt;, !dbg !42 // line 23
}
bale {
   %rdr.cols.regioncollapsed14 = call &lt;16 x i8&gt; @llvm.genx.rdregion.v16i8.v256i8.i16(&lt;256 x i8&gt; %call1.i.i, i32 16, i32 8, i32 1, i16 115, i32 undef), !dbg !42 {rdregion} // line 23
   %conv15 = uitofp &lt;16 x i8&gt; %rdr.cols.regioncollapsed14 to &lt;16 x float&gt;, !dbg !42 // line 23
   %conv.addedwrregion.join16.decomp.3 = call &lt;32 x float&gt; @llvm.genx.wrregion.v32f32.v16f32.i16.i1(&lt;32 x float&gt; undef, &lt;16 x float&gt; %conv15, i32 0, i32 16, i32 1, i16 0, i32 undef, i1 true), !dbg !42 {wrregion} // line 23
}
bale {
   %rdr.cols.regioncollapsed17 = call &lt;16 x i8&gt; @llvm.genx.rdregion.v16i8.v256i8.i16(&lt;256 x i8&gt; %call1.i.i, i32 16, i32 16, i32 1, i16 139, i32 undef), !dbg !42 {rdregion} // line 23
   %conv18 = uitofp &lt;16 x i8&gt; %rdr.cols.regioncollapsed17 to &lt;16 x float&gt;, !dbg !42 // line 23
   %conv.addedwrregion.join19.decomp.3 = call &lt;32 x float&gt; @llvm.genx.wrregion.v32f32.v16f32.i16.i1(&lt;32 x float&gt; %conv.addedwrregion.join16.decomp.3, &lt;16 x float&gt; %conv18, i32 0, i32 16, i32 1, i16 64, i32 undef, i1 true), !dbg !42 {wrregion} // line 23
}
bale {
   %rdr.cols.regioncollapsed20 = call &lt;16 x i8&gt; @llvm.genx.rdregion.v16i8.v256i8.i16(&lt;256 x i8&gt; %call1.i.i, i32 16, i32 16, i32 1, i16 163, i32 undef), !dbg !42 {rdregion} // line 23
   %conv21 = uitofp &lt;16 x i8&gt; %rdr.cols.regioncollapsed20 to &lt;16 x float&gt;, !dbg !42 // line 23
}
bale {
   %rdr.cols.regioncollapsed23 = call &lt;16 x i8&gt; @llvm.genx.rdregion.v16i8.v256i8.i16(&lt;256 x i8&gt; %call1.i.i, i32 16, i32 8, i32 1, i16 179, i32 undef), !dbg !42 {rdregion} // line 23
   %conv24 = uitofp &lt;16 x i8&gt; %rdr.cols.regioncollapsed23 to &lt;16 x float&gt;, !dbg !42 // line 23
   %conv.addedwrregion.join25.decomp.5 = call &lt;32 x float&gt; @llvm.genx.wrregion.v32f32.v16f32.i16.i1(&lt;32 x float&gt; undef, &lt;16 x float&gt; %conv24, i32 0, i32 16, i32 1, i16 0, i32 undef, i1 true), !dbg !42 {wrregion} // line 23
}
bale {
   %rdr.cols.regioncollapsed26 = call &lt;16 x i8&gt; @llvm.genx.rdregion.v16i8.v256i8.i16(&lt;256 x i8&gt; %call1.i.i, i32 16, i32 16, i32 1, i16 203, i32 undef), !dbg !42 {rdregion} // line 23
   %conv27 = uitofp &lt;16 x i8&gt; %rdr.cols.regioncollapsed26 to &lt;16 x float&gt;, !dbg !42 // line 23
   %conv.addedwrregion.join28.decomp.5 = call &lt;32 x float&gt; @llvm.genx.wrregion.v32f32.v16f32.i16.i1(&lt;32 x float&gt; %conv.addedwrregion.join25.decomp.5, &lt;16 x float&gt; %conv27, i32 0, i32 16, i32 1, i16 64, i32 undef, i1 true), !dbg !42 {wrregion} // line 23
}
</pre></div>
</div>
<p>This second baling now survives until the vISA writer at the end of the GenX
backend.</p>
</div>
<div class="section" id="id3">
<h4><a class="toc-backref" href="#id29">Live ranges</a><a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<p>Again, the GenXLiveRanges pass starts by numbering the instructions. But, within a
bale, all instructions get the same number, because they will be part of the
same vISA instruction.</p>
<p>The jump in number between each bale is partly an artifact of the way GenXLiveRanges
numbers the instructions then decides to change all the instructions in a bale to
match the head (the last instruction). But, even without baling, it leaves a gap
of one between each instruction. This number is then used as the number of an inserted
copy from a failed two-address coalesce (see below).</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>[39]  bale {
[39]     %rdr.cols.regioncollapsed3 = call &lt;16 x i8&gt; @llvm.genx.rdregion.v16i8.v256i8.i16(&lt;256 x i8&gt; %call1.i.i, i32 16, i32 16, i32 1, i16 35, i32 undef), !dbg !42 {rdregion} // line 23
[39]     %conv4 = uitofp &lt;16 x i8&gt; %rdr.cols.regioncollapsed3 to &lt;16 x float&gt;, !dbg !42 // line 23
[39]  }
[48]  bale {
[48]     %rdr.cols.regioncollapsed5 = call &lt;16 x i8&gt; @llvm.genx.rdregion.v16i8.v256i8.i16(&lt;256 x i8&gt; %call1.i.i, i32 16, i32 8, i32 1, i16 51, i32 undef), !dbg !42 {rdregion} // line 23
[48]     %conv6 = uitofp &lt;16 x i8&gt; %rdr.cols.regioncollapsed5 to &lt;16 x float&gt;, !dbg !42 // line 23
[48]     %conv.addedwrregion.join7.decomp.1 = call &lt;32 x float&gt; @llvm.genx.wrregion.v32f32.v16f32.i16.i1(&lt;32 x float&gt; undef, &lt;16 x float&gt; %conv6, i32 0, i32 16, i32 1, i16 0, i32 undef, i1 true), !dbg !42 {wrregion} // line 23
[48]  }
[58]  bale {
[58]     %rdr.cols.regioncollapsed8 = call &lt;16 x i8&gt; @llvm.genx.rdregion.v16i8.v256i8.i16(&lt;256 x i8&gt; %call1.i.i, i32 16, i32 16, i32 1, i16 75, i32 undef), !dbg !42 {rdregion} // line 23
[58]     %conv9 = uitofp &lt;16 x i8&gt; %rdr.cols.regioncollapsed8 to &lt;16 x float&gt;, !dbg !42 // line 23
[58]     %conv.addedwrregion.join10.decomp.1 = call &lt;32 x float&gt; @llvm.genx.wrregion.v32f32.v16f32.i16.i1(&lt;32 x float&gt; %conv.addedwrregion.join7.decomp.1, &lt;16 x float&gt; %conv9, i32 0, i32 16, i32 1, i16 64, i32 undef, i1 true), !dbg !42 {wrregion} // line 23
[58]  }
[61]  bale {
[61]     %rdr.cols.regioncollapsed11 = call &lt;16 x i8&gt; @llvm.genx.rdregion.v16i8.v256i8.i16(&lt;256 x i8&gt; %call1.i.i, i32 16, i32 16, i32 1, i16 99, i32 undef), !dbg !42 {rdregion} // line 23
[61]     %conv12 = uitofp &lt;16 x i8&gt; %rdr.cols.regioncollapsed11 to &lt;16 x float&gt;, !dbg !42 // line 23
[61]  }
[70]  bale {
[70]     %rdr.cols.regioncollapsed14 = call &lt;16 x i8&gt; @llvm.genx.rdregion.v16i8.v256i8.i16(&lt;256 x i8&gt; %call1.i.i, i32 16, i32 8, i32 1, i16 115, i32 undef), !dbg !42 {rdregion} // line 23
[70]     %conv15 = uitofp &lt;16 x i8&gt; %rdr.cols.regioncollapsed14 to &lt;16 x float&gt;, !dbg !42 // line 23
[70]     %conv.addedwrregion.join16.decomp.3 = call &lt;32 x float&gt; @llvm.genx.wrregion.v32f32.v16f32.i16.i1(&lt;32 x float&gt; undef, &lt;16 x float&gt; %conv15, i32 0, i32 16, i32 1, i16 0, i32 undef, i1 true), !dbg !42 {wrregion} // line 23
[70]  }
[80]  bale {
[80]     %rdr.cols.regioncollapsed17 = call &lt;16 x i8&gt; @llvm.genx.rdregion.v16i8.v256i8.i16(&lt;256 x i8&gt; %call1.i.i, i32 16, i32 16, i32 1, i16 139, i32 undef), !dbg !42 {rdregion} // line 23
[80]     %conv18 = uitofp &lt;16 x i8&gt; %rdr.cols.regioncollapsed17 to &lt;16 x float&gt;, !dbg !42 // line 23
[80]     %conv.addedwrregion.join19.decomp.3 = call &lt;32 x float&gt; @llvm.genx.wrregion.v32f32.v16f32.i16.i1(&lt;32 x float&gt; %conv.addedwrregion.join16.decomp.3, &lt;16 x float&gt; %conv18, i32 0, i32 16, i32 1, i16 64, i32 undef, i1 true), !dbg !42 {wrregion} // line 23
[80]  }
[83]  bale {
[83]     %rdr.cols.regioncollapsed20 = call &lt;16 x i8&gt; @llvm.genx.rdregion.v16i8.v256i8.i16(&lt;256 x i8&gt; %call1.i.i, i32 16, i32 16, i32 1, i16 163, i32 undef), !dbg !42 {rdregion} // line 23
[83]     %conv21 = uitofp &lt;16 x i8&gt; %rdr.cols.regioncollapsed20 to &lt;16 x float&gt;, !dbg !42 // line 23
[83]  }
[92]  bale {
[92]     %rdr.cols.regioncollapsed23 = call &lt;16 x i8&gt; @llvm.genx.rdregion.v16i8.v256i8.i16(&lt;256 x i8&gt; %call1.i.i, i32 16, i32 8, i32 1, i16 179, i32 undef), !dbg !42 {rdregion} // line 23
[92]     %conv24 = uitofp &lt;16 x i8&gt; %rdr.cols.regioncollapsed23 to &lt;16 x float&gt;, !dbg !42 // line 23
[92]     %conv.addedwrregion.join25.decomp.5 = call &lt;32 x float&gt; @llvm.genx.wrregion.v32f32.v16f32.i16.i1(&lt;32 x float&gt; undef, &lt;16 x float&gt; %conv24, i32 0, i32 16, i32 1, i16 0, i32 undef, i1 true), !dbg !42 {wrregion} // line 23
[92]  }
[102]  bale {
[102]     %rdr.cols.regioncollapsed26 = call &lt;16 x i8&gt; @llvm.genx.rdregion.v16i8.v256i8.i16(&lt;256 x i8&gt; %call1.i.i, i32 16, i32 16, i32 1, i16 203, i32 undef), !dbg !42 {rdregion} // line 23
[102]     %conv27 = uitofp &lt;16 x i8&gt; %rdr.cols.regioncollapsed26 to &lt;16 x float&gt;, !dbg !42 // line 23
[102]     %conv.addedwrregion.join28.decomp.5 = call &lt;32 x float&gt; @llvm.genx.wrregion.v32f32.v16f32.i16.i1(&lt;32 x float&gt; %conv.addedwrregion.join25.decomp.5, &lt;16 x float&gt; %conv27, i32 0, i32 16, i32 1, i16 64, i32 undef, i1 true), !dbg !42 {wrregion} // line 23
[102]  }
</pre></div>
</div>
<p>Within a bale, only the head instruction (the last one in code order, the one
whose value is used outside the bale) needs a vISA register, and hence needs
a live range. All the other instructions in bales now have their <code class="docutils literal"><span class="pre">LiveRange</span></code>
objects deleted.</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>conv4:[39,123){general}
conv.addedwrregion.join7.decomp.1:[48,58){general}
conv.addedwrregion.join10.decomp.1:[58,132){general}
conv12:[61,145){general}
conv.addedwrregion.join16.decomp.3:[70,80){general}
conv.addedwrregion.join19.decomp.3:[80,154){general}
conv21:[83,167){general}
conv.addedwrregion.join25.decomp.5:[92,102){general}
conv.addedwrregion.join28.decomp.5:[102,176){general}
</pre></div>
</div>
<p>Note the short live ranges for
conv.addedwrregion.join7.decomp.1,
conv.addedwrregion.join16.decomp.3,
conv.addedwrregion.join25.decomp.5.
For each of the three 32 x float vectors resulting from vector decomposition,
there is a uitofp+wrregion bale creating the first half of the vector, and
a uitofp+wrregion bale creating the second half. These short live ranges are
the result of the first wrregion feeding in to the second wrregion. As required
by SSA, each result (of wrregion or any other instruction) is a separate value.</p>
</div>
<div class="section" id="coalescing">
<h4><a class="toc-backref" href="#id30">Coalescing</a><a class="headerlink" href="#coalescing" title="Permalink to this headline">¶</a></h4>
<p>The GenXCoalescing pass coalesces live ranges to avoid needing to insert copy
instructions, and inserts the required copy instructions where coalescing fails.</p>
<p>There are several different kinds of coalescing; the one we see in this example
is <em>two-address coalescing</em>. This is where we have an instruction where the
result and one of the inputs needs to be in the same vISA register.
The name comes from a two-address instruction set such as x86, where one
source and the destination are the same register, as opposed to a three-address
instruction set such as ARM.</p>
<p>The most
obvious example of two-address coalescing,
and the one we see here, is a wrregion: the “old value of vector”
input and the result need to be in the same vISA register.</p>
<p>Two-address coalescing consists of:</p>
<ul class="simple">
<li>spotting such a case (here, a wrregion);</li>
<li>if the two live ranges do not interfere, coalesce them, that is merge the
live ranges, giving a single <code class="docutils literal"><span class="pre">LiveRange</span></code> object attached to the union
of all values attached to the two original <code class="docutils literal"><span class="pre">LiveRange</span></code> objects;</li>
<li>if the two live ranges interfere, coalescing fails, so a copy needs to be
inserted just before the instruction. The result of the copy is a new
value which is added to the <code class="docutils literal"><span class="pre">LiveRange</span></code> for the original instruction’s
result. The instruction number of the inserted copy is the gap, the
unused number, just before the original instruction.</li>
</ul>
<p>In our example we have a pair of wrregions for each one of the three 32 x float
decomposed vectors. The first one of each pair has an UndefValue as its “old
value of vector” input, and thus does not need coalescing as it is writing a
region in a vector that was previously completely undefined. The second one
of each pair does need coalescing.</p>
<p>Here, each one of the three coalesces succeeds, so the results of the two
wrregions in each pair end up in the same <code class="docutils literal"><span class="pre">LiveRange</span></code> (and will thus be in
the same vISA register). Each also gets coalesced in wrregions later in the
program, so each live range has quite a few values attached.</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>conv4:[39,123){general}
conv511.decomp.1,conv50.addedwrregion.join396.decomp.1,mul49.addedwrregion.join389.inplacecast394.decomp.1,conv50.addedwrregion.join393.decomp.1,mul49.addedwrregion.join389.inplacecast391.decomp.1,conv50.inplacecast.decomp.1,mul49.addedwrregion.join377.decomp.1,mul49.addedwrregion.join375.decomp.1,add48.addedwrregion.join354.decomp.1,add48.addedwrregion.join351.decomp.1,add42.addedwrregion.join311.decomp.1,add42.addedwrregion.join308.decomp.1,add36.addedwrregion.join268.decomp.1,add36.addedwrregion.join265.decomp.1,add30.addedwrregion.join225.decomp.1,add30.addedwrregion.join222.decomp.1,add24.addedwrregion.join182.decomp.1,add24.addedwrregion.join179.decomp.1,add18.addedwrregion.join139.decomp.1,add18.addedwrregion.join136.decomp.1,add12.addedwrregion.join96.decomp.1,add12.addedwrregion.join93.decomp.1,add.addedwrregion.join53.decomp.1,add.addedwrregion.join50.decomp.1,conv.addedwrregion.join10.decomp.1,conv.addedwrregion.join7.decomp.1:[48,952){general}
conv12:[61,145){general}
conv511.decomp.3,conv50.addedwrregion.join405.decomp.3,mul49.addedwrregion.join389.inplacecast403.decomp.3,conv50.addedwrregion.join402.decomp.3,mul49.addedwrregion.join389.inplacecast400.decomp.3,conv50.inplacecast.decomp.3,mul49.addedwrregion.join383.decomp.3,mul49.addedwrregion.join381.decomp.3,add48.addedwrregion.join363.decomp.3,add48.addedwrregion.join360.decomp.3,add42.addedwrregion.join320.decomp.3,add42.addedwrregion.join317.decomp.3,add36.addedwrregion.join277.decomp.3,add36.addedwrregion.join274.decomp.3,add30.addedwrregion.join234.decomp.3,add30.addedwrregion.join231.decomp.3,add24.addedwrregion.join191.decomp.3,add24.addedwrregion.join188.decomp.3,add18.addedwrregion.join148.decomp.3,add18.addedwrregion.join145.decomp.3,add12.addedwrregion.join105.decomp.3,add12.addedwrregion.join102.decomp.3,add.addedwrregion.join62.decomp.3,add.addedwrregion.join59.decomp.3,conv.addedwrregion.join19.decomp.3,conv.addedwrregion.join16.decomp.3:[70,992){general}
conv21:[83,167){general}
conv511.decomp.5,conv50.addedwrregion.join414.decomp.5,mul49.addedwrregion.join389.inplacecast412.decomp.5,conv50.addedwrregion.join411.decomp.5,mul49.addedwrregion.join389.inplacecast409.decomp.5,conv50.inplacecast.decomp.5,mul49.addedwrregion.join389.decomp.5,mul49.addedwrregion.join387.decomp.5,add48.addedwrregion.join372.decomp.5,add48.addedwrregion.join369.decomp.5,add42.addedwrregion.join329.decomp.5,add42.addedwrregion.join326.decomp.5,add36.addedwrregion.join286.decomp.5,add36.addedwrregion.join283.decomp.5,add30.addedwrregion.join243.decomp.5,add30.addedwrregion.join240.decomp.5,add24.addedwrregion.join200.decomp.5,add24.addedwrregion.join197.decomp.5,add18.addedwrregion.join157.decomp.5,add18.addedwrregion.join154.decomp.5,add12.addedwrregion.join114.decomp.5,add12.addedwrregion.join111.decomp.5,add.addedwrregion.join71.decomp.5,add.addedwrregion.join68.decomp.5,conv.addedwrregion.join28.decomp.5,conv.addedwrregion.join25.decomp.5:[92,1032){general}
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h4><a class="toc-backref" href="#id31">vISA register allocation</a><a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<p>GenXVisaRegAlloc allocates a vISA register to each of these six live ranges
(V91, V101, V92, V102, V93, V103):</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>  %rdr.cols.regioncollapsed3 = call &lt;16 x i8&gt; @llvm.genx.rdregion.v16i8.v256i8.i16(&lt;256 x i8&gt; %call1.i.i, i32 16, i32 16, i32 1, i16 35, i32 undef), !dbg !42
[v91]  %conv4 = uitofp &lt;16 x i8&gt; %rdr.cols.regioncollapsed3 to &lt;16 x float&gt;, !dbg !42
  %rdr.cols.regioncollapsed5 = call &lt;16 x i8&gt; @llvm.genx.rdregion.v16i8.v256i8.i16(&lt;256 x i8&gt; %call1.i.i, i32 16, i32 8, i32 1, i16 51, i32 undef), !dbg !42
  %conv6 = uitofp &lt;16 x i8&gt; %rdr.cols.regioncollapsed5 to &lt;16 x float&gt;, !dbg !42
[v101]  %conv.addedwrregion.join7.decomp.1 = call &lt;32 x float&gt; @llvm.genx.wrregion.v32f32.v16f32.i16.i1(&lt;32 x float&gt; undef, &lt;16 x float&gt; %conv6, i32 0, i32 16, i32 1, i16 0, i32 undef, i1 true), !dbg !42
  %rdr.cols.regioncollapsed8 = call &lt;16 x i8&gt; @llvm.genx.rdregion.v16i8.v256i8.i16(&lt;256 x i8&gt; %call1.i.i, i32 16, i32 16, i32 1, i16 75, i32 undef), !dbg !42
  %conv9 = uitofp &lt;16 x i8&gt; %rdr.cols.regioncollapsed8 to &lt;16 x float&gt;, !dbg !42
[v101]  %conv.addedwrregion.join10.decomp.1 = call &lt;32 x float&gt; @llvm.genx.wrregion.v32f32.v16f32.i16.i1(&lt;32 x float&gt; %conv.addedwrregion.join7.decomp.1, &lt;16 x float&gt; %conv9, i32 0, i32 16, i32 1, i16 64, i32 undef, i1 true), !dbg !42
  %rdr.cols.regioncollapsed11 = call &lt;16 x i8&gt; @llvm.genx.rdregion.v16i8.v256i8.i16(&lt;256 x i8&gt; %call1.i.i, i32 16, i32 16, i32 1, i16 99, i32 undef), !dbg !42
[v92]  %conv12 = uitofp &lt;16 x i8&gt; %rdr.cols.regioncollapsed11 to &lt;16 x float&gt;, !dbg !42
  %rdr.cols.regioncollapsed14 = call &lt;16 x i8&gt; @llvm.genx.rdregion.v16i8.v256i8.i16(&lt;256 x i8&gt; %call1.i.i, i32 16, i32 8, i32 1, i16 115, i32 undef), !dbg !42
  %conv15 = uitofp &lt;16 x i8&gt; %rdr.cols.regioncollapsed14 to &lt;16 x float&gt;, !dbg !42
[v102]  %conv.addedwrregion.join16.decomp.3 = call &lt;32 x float&gt; @llvm.genx.wrregion.v32f32.v16f32.i16.i1(&lt;32 x float&gt; undef, &lt;16 x float&gt; %conv15, i32 0, i32 16, i32 1, i16 0, i32 undef, i1 true), !dbg !42
  %rdr.cols.regioncollapsed17 = call &lt;16 x i8&gt; @llvm.genx.rdregion.v16i8.v256i8.i16(&lt;256 x i8&gt; %call1.i.i, i32 16, i32 16, i32 1, i16 139, i32 undef), !dbg !42
  %conv18 = uitofp &lt;16 x i8&gt; %rdr.cols.regioncollapsed17 to &lt;16 x float&gt;, !dbg !42
[v102]  %conv.addedwrregion.join19.decomp.3 = call &lt;32 x float&gt; @llvm.genx.wrregion.v32f32.v16f32.i16.i1(&lt;32 x float&gt; %conv.addedwrregion.join16.decomp.3, &lt;16 x float&gt; %conv18, i32 0, i32 16, i32 1, i16 64, i32 undef, i1 true), !dbg !42
  %rdr.cols.regioncollapsed20 = call &lt;16 x i8&gt; @llvm.genx.rdregion.v16i8.v256i8.i16(&lt;256 x i8&gt; %call1.i.i, i32 16, i32 16, i32 1, i16 163, i32 undef), !dbg !42
[v93]  %conv21 = uitofp &lt;16 x i8&gt; %rdr.cols.regioncollapsed20 to &lt;16 x float&gt;, !dbg !42
  %rdr.cols.regioncollapsed23 = call &lt;16 x i8&gt; @llvm.genx.rdregion.v16i8.v256i8.i16(&lt;256 x i8&gt; %call1.i.i, i32 16, i32 8, i32 1, i16 179, i32 undef), !dbg !42
  %conv24 = uitofp &lt;16 x i8&gt; %rdr.cols.regioncollapsed23 to &lt;16 x float&gt;, !dbg !42
[v103]  %conv.addedwrregion.join25.decomp.5 = call &lt;32 x float&gt; @llvm.genx.wrregion.v32f32.v16f32.i16.i1(&lt;32 x float&gt; undef, &lt;16 x float&gt; %conv24, i32 0, i32 16, i32 1, i16 0, i32 undef, i1 true), !dbg !42
  %rdr.cols.regioncollapsed26 = call &lt;16 x i8&gt; @llvm.genx.rdregion.v16i8.v256i8.i16(&lt;256 x i8&gt; %call1.i.i, i32 16, i32 16, i32 1, i16 203, i32 undef), !dbg !42
  %conv27 = uitofp &lt;16 x i8&gt; %rdr.cols.regioncollapsed26 to &lt;16 x float&gt;, !dbg !42
[v103]  %conv.addedwrregion.join28.decomp.5 = call &lt;32 x float&gt; @llvm.genx.wrregion.v32f32.v16f32.i16.i1(&lt;32 x float&gt; %conv.addedwrregion.join25.decomp.5, &lt;16 x float&gt; %conv27, i32 0, i32 16, i32 1, i16 64, i32 undef, i1 true), !dbg !42
</pre></div>
</div>
<p>There is still baling information at this point, but it is not showing up
in this dump. But we can see that any instruction not at the head of a bale
does not have a vISA register allocated, because it is not part of a live range.</p>
</div>
<div class="section" id="id5">
<h4><a class="toc-backref" href="#id32">vISA function writer</a><a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h4>
<p>In this example with regions and baling, the logic followed in GenXVisaFuncWriter
is a little more complex. It looks at each bale in turn, starting at the head
of the bale. (An unbaled instruction by itself counts as a bale with a single
instruction that is the head.) It then has to handle cases such as:</p>
<ul class="simple">
<li>The head is a wrregion is in a bale by itself, so write a mov with a region in the
destination.</li>
<li>The head is a wrregion whose “new value” input is a rdregion, so write a mov with
regions in the source and destination.</li>
<li>The head is a wrregion whose “new value” input is a main instruction. The main
instruction’s operands may in turn be rdregions (or modifiers such as abs).</li>
<li>The head is a main instruction whose operands may be rdregions (or modifiers).</li>
<li>The head is a source modifier or a rdregion, and there is no main instruction.</li>
</ul>
<p>Looking at the first three bales in our example code gives two different cases:</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>  bale {
     %rdr.cols.regioncollapsed3 = call &lt;16 x i8&gt; @llvm.genx.rdregion.v16i8.v256i8.i16(&lt;256 x i8&gt; %call1.i.i, i32 16, i32 16, i32 1, i16 35, i32 undef), !dbg !42 {rdregion} // line 23
[v91]%conv4 = uitofp &lt;16 x i8&gt; %rdr.cols.regioncollapsed3 to &lt;16 x float&gt;, !dbg !42 // line 23
  }
  bale {
     %rdr.cols.regioncollapsed5 = call &lt;16 x i8&gt; @llvm.genx.rdregion.v16i8.v256i8.i16(&lt;256 x i8&gt; %call1.i.i, i32 16, i32 8, i32 1, i16 51, i32 undef), !dbg !42 {rdregion} // line 23
     %conv6 = uitofp &lt;16 x i8&gt; %rdr.cols.regioncollapsed5 to &lt;16 x float&gt;, !dbg !42 // line 23
[v101]%conv.addedwrregion.join7.decomp.1 = call &lt;32 x float&gt; @llvm.genx.wrregion.v32f32.v16f32.i16.i1(&lt;32 x float&gt; undef, &lt;16 x float&gt; %conv6, i32 0, i32 16, i32 1, i16 0, i32 undef, i1 true), !dbg !42 {wrregion} // line 23
  }
bale {
   %rdr.cols.regioncollapsed8 = call &lt;16 x i8&gt; @llvm.genx.rdregion.v16i8.v256i8.i16(&lt;256 x i8&gt; %call1.i.i, i32 16, i32 16, i32 1, i16 75, i32 undef), !dbg !42 {rdregion} // line 23
   %conv9 = uitofp &lt;16 x i8&gt; %rdr.cols.regioncollapsed8 to &lt;16 x float&gt;, !dbg !42 // line 23
[v101]%conv.addedwrregion.join10.decomp.1 = call &lt;32 x float&gt; @llvm.genx.wrregion.v32f32.v16f32.i16.i1(&lt;32 x float&gt; %conv.addedwrregion.join7.decomp.1, &lt;16 x float&gt; %conv9, i32 0, i32 16, i32 1, i16 64, i32 undef, i1 true), !dbg !42 {wrregion} // line 23
}
</pre></div>
</div>
<p>The first bale is a main instruction uitofp whose operand is a rdregion. Uitofp
is written as a mov instruction that does type conversion, and the rdregion becomes
the region in the source operand:</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>LOC 23
mov (M1, 16) V91(0,0)&lt;1&gt;:f V36(1,3)&lt;0;16,1&gt;:ub
</pre></div>
</div>
<p>The second and third bales are each a rdregion-uitofp-wrregion bale. Again the
uitofp is written as a mov instruction that does type conversion, and this time
both the destination and the source are regioned, from the wrregion and rdregion
respectively:</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>mov (M1, 16) V103{V95}(0,0)&lt;1&gt;:f V36(1,19)&lt;16;8,1&gt;:ub
mov (M1, 16) V103{V95}(2,0)&lt;1&gt;:f V36(2,11)&lt;0;16,1&gt;:ub
</pre></div>
</div>
</div>
</div>
<div class="section" id="example-phi-nodes">
<h3><a class="toc-backref" href="#id33">Example: phi nodes</a><a class="headerlink" href="#example-phi-nodes" title="Permalink to this headline">¶</a></h3>
<p>This is line 294 of BitonicSort_1m_SLM:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="p">(</span> <span class="n">uint</span> <span class="n">stride</span> <span class="o">=</span> <span class="n">size</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="n">stride</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">stride</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// bitonic mergeglobal</span>

  <span class="kt">int</span> <span class="n">numBlocks</span> <span class="o">=</span> <span class="n">boundary</span> <span class="o">/</span> <span class="p">(</span><span class="n">stride</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">numThreadPerBlock</span> <span class="o">=</span> <span class="n">num_threads</span> <span class="o">/</span> <span class="n">numBlocks</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">stride</span> <span class="o">&lt;=</span> <span class="mi">128</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">numThreadPerBlock</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
</pre></div>
</div>
<p>This gives the following vISA:</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>  LOC 294
  shr (M1, 1) V261(0,0)&lt;1&gt;:ud V257(0,0)&lt;0;1,0&gt;:ud 0x1:ud
  cmp (M1, 1).eq P26 V261(0,0)&lt;0;1,0&gt;:ud 0:d
  (P26) jmp (M1, 1) BB_25
  LOC 305
  div (M1, 1) V448{V260}(0,0)&lt;1&gt;:ud V557{V256}(0,0)&lt;0;1,0&gt;:ud V257(0,0)&lt;0;1,0&gt;:ud
  and (M1, 1) V558{V260}(0,0)&lt;1&gt;:d V558{V260}(0,0)&lt;0;1,0&gt;:d 0x1:d
  xor (M1, 1) V558{V260}(0,0)&lt;1&gt;:d V558{V260}(0,0)&lt;0;1,0&gt;:d V253(0,0)&lt;0;1,0&gt;:d
  LOC 344
  mov (M1, 1) V262(0,0)&lt;1&gt;:ud V257(0,0)&lt;0;1,0&gt;:ud
BB_16:
  LOC 294
  mov (M1, 1) V263(0,0)&lt;1&gt;:d V261(0,0)&lt;0;1,0&gt;:ud
  LOC 297
  shl (M1, 1) V264(0,0)&lt;1&gt;:d V263(0,0)&lt;0;1,0&gt;:d 0x1:d
  div (M1, 1) V265(0,0)&lt;1&gt;:ud V254(0,0)&lt;0;1,0&gt;:ud V559{V264}(0,0)&lt;0;1,0&gt;:ud
  LOC 298
  div (M1, 1) V265(0,0)&lt;1&gt;:ud V560{V37}(0,0)&lt;0;1,0&gt;:ud V265(0,0)&lt;0;1,0&gt;:ud
  LOC 303
  add (M1, 1) V561{V265}(0,0)&lt;1&gt;:d V561{V265}(0,0)&lt;0;1,0&gt;:d 0xffffffff:d
  LOC 299
  cmp (M1, 1).lt P27 V262(0,0)&lt;0;1,0&gt;:ud 0x102:ud
  LOC 303
  (P27) sel (M1, 1) V265(0,0)&lt;1&gt;:ud 0:d V265(0,0)&lt;0;1,0&gt;:ud
</pre></div>
</div>
<p>BB_16 is the start of the loop body for this loop. LLVM seems to have done some
LICM (loop invariant code motion) such that the divide and associated code from
line 305 (a source line not shown in the snippet above) is outside the loop.</p>
<p>The state of the IR when it enters the GenX backend illustrates the use of
<em>phi nodes</em> as join points in SSA:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>  <span class="nv">%stride253.0619</span> <span class="p">=</span> <span class="k">lshr</span> <span class="k">exact</span> <span class="k">i32</span> <span class="nv">%size249.0630</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="nv">!dbg</span> <span class="nv nv-Anonymous">!424</span>
  <span class="p">...</span>
  <span class="k">br</span> <span class="kt">label</span> <span class="nv">%for.body256</span><span class="p">,</span> <span class="nv">!dbg</span> <span class="nv nv-Anonymous">!425</span>
<span class="nl">for.body256:</span>                                      <span class="c">; preds = %if.end356.7, %for.body256.lr.ph</span>
  <span class="nv">%stride253.0624</span> <span class="p">=</span> <span class="k">phi</span> <span class="k">i32</span> <span class="p">[</span> <span class="nv">%stride253.0619</span><span class="p">,</span> <span class="nv">%for.body256.lr.ph</span> <span class="p">],</span> <span class="p">[</span> <span class="nv">%stride253.0</span><span class="p">,</span> <span class="nv">%if.end356.7</span> <span class="p">]</span>
  <span class="nv">%stride253.0.in623</span> <span class="p">=</span> <span class="k">phi</span> <span class="k">i32</span> <span class="p">[</span> <span class="nv">%size249.0630</span><span class="p">,</span> <span class="nv">%for.body256.lr.ph</span> <span class="p">],</span> <span class="p">[</span> <span class="nv">%stride253.0624</span><span class="p">,</span> <span class="nv">%if.end356.7</span> <span class="p">]</span>
  <span class="nv">%E.0.load607622</span> <span class="p">=</span> <span class="k">phi</span> <span class="p">&lt;</span><span class="m">16</span> <span class="k">x</span> <span class="k">i32</span><span class="p">&gt;</span> <span class="p">[</span> <span class="nv">%E.0.load606629</span><span class="p">,</span> <span class="nv">%for.body256.lr.ph</span> <span class="p">],</span> <span class="p">[</span> <span class="nv">%merge375.7</span><span class="p">,</span> <span class="nv">%if.end356.7</span> <span class="p">]</span>
  <span class="nv">%D.0.load610621</span> <span class="p">=</span> <span class="k">phi</span> <span class="p">&lt;</span><span class="m">16</span> <span class="k">x</span> <span class="k">i32</span><span class="p">&gt;</span> <span class="p">[</span> <span class="nv">%D.0.load609628</span><span class="p">,</span> <span class="nv">%for.body256.lr.ph</span> <span class="p">],</span> <span class="p">[</span> <span class="nv">%merge368.7</span><span class="p">,</span> <span class="nv">%if.end356.7</span> <span class="p">]</span>
  <span class="nv">%shl257</span> <span class="p">=</span> <span class="k">shl</span> <span class="k">nuw</span> <span class="k">i32</span> <span class="nv">%stride253.0624</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="nv">!dbg</span> <span class="nv nv-Anonymous">!429</span>
  <span class="nv">%div258</span> <span class="p">=</span> <span class="k">udiv</span> <span class="k">i32</span> <span class="nv">%N.</span><span class="p">,</span> <span class="nv">%shl257</span><span class="p">,</span> <span class="nv">!dbg</span> <span class="nv nv-Anonymous">!429</span>
  <span class="k">tail</span> <span class="k">call</span> <span class="kt">void</span> <span class="vg">@llvm.dbg.value</span><span class="p">(</span><span class="kt">metadata</span> <span class="p">!{</span><span class="k">i32</span> <span class="nv">%div258</span><span class="p">},</span> <span class="k">i64</span> <span class="m">0</span><span class="p">,</span> <span class="kt">metadata</span> <span class="nv nv-Anonymous">!184</span><span class="p">),</span> <span class="nv">!dbg</span> <span class="nv nv-Anonymous">!430</span>
  <span class="nv">%div259</span> <span class="p">=</span> <span class="k">udiv</span> <span class="k">i32</span> <span class="nv nv-Anonymous">%10</span><span class="p">,</span> <span class="nv">%div258</span><span class="p">,</span> <span class="nv">!dbg</span> <span class="nv nv-Anonymous">!431</span>
  <span class="k">tail</span> <span class="k">call</span> <span class="kt">void</span> <span class="vg">@llvm.dbg.value</span><span class="p">(</span><span class="kt">metadata</span> <span class="p">!{</span><span class="k">i32</span> <span class="nv">%div259</span><span class="p">},</span> <span class="k">i64</span> <span class="m">0</span><span class="p">,</span> <span class="kt">metadata</span> <span class="nv nv-Anonymous">!186</span><span class="p">),</span> <span class="nv">!dbg</span> <span class="nv nv-Anonymous">!432</span>
  <span class="nv">%cmp260</span> <span class="p">=</span> <span class="k">icmp</span> <span class="k">ult</span> <span class="k">i32</span> <span class="nv">%stride253.0.in623</span><span class="p">,</span> <span class="m">258</span><span class="p">,</span> <span class="nv">!dbg</span> <span class="nv nv-Anonymous">!433</span>
  <span class="nv">%div259.op</span> <span class="p">=</span> <span class="k">add</span> <span class="k">i32</span> <span class="nv">%div259</span><span class="p">,</span> <span class="m">-1</span><span class="p">,</span> <span class="nv">!dbg</span> <span class="nv nv-Anonymous">!422</span>
  <span class="nv">%sub264</span> <span class="p">=</span> <span class="k">select</span> <span class="k">i1</span> <span class="nv">%cmp260</span><span class="p">,</span> <span class="k">i32</span> <span class="m">0</span><span class="p">,</span> <span class="k">i32</span> <span class="nv">%div259.op</span><span class="p">,</span> <span class="nv">!dbg</span> <span class="nv nv-Anonymous">!422</span>
  <span class="p">...</span>
  <span class="nv">%stride253.0</span> <span class="p">=</span> <span class="k">lshr</span> <span class="k">i32</span> <span class="nv">%stride253.0624</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="nv">!dbg</span> <span class="nv nv-Anonymous">!424</span>
  <span class="nv">%cmp255</span> <span class="p">=</span> <span class="k">icmp</span> <span class="k">eq</span> <span class="k">i32</span> <span class="nv">%stride253.0</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="nv">!dbg</span> <span class="nv nv-Anonymous">!425</span>
  <span class="k">br</span> <span class="k">i1</span> <span class="nv">%cmp255</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%for.inc382.loopexit</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%for.body256</span><span class="p">,</span> <span class="nv">!dbg</span> <span class="nv nv-Anonymous">!425</span>
</pre></div>
</div>
<p>The basic block <code class="docutils literal"><span class="pre">for.body256</span></code> is the start of the loop body for this loop, and as such
it has two predecessors: <code class="docutils literal"><span class="pre">for.body256.lr.ph</span></code>, the loop pre-header (i.e. code executed
just before going into the loop), and <code class="docutils literal"><span class="pre">if.end356.7</span></code>, which is at the end of the loop
body and conditionally branches back.</p>
<p>In SSA, a value has a single definition, and that definition <em>dominates</em> all
its uses, that is, execution must pass through the definition to reach a use.
This is the <em>dominance property</em>.</p>
<p>A <em>phi node</em> is used to represent a join point of two or more different values
of a variable where there is a join point in the control flow. A phi node has
an <em>incoming value</em> for each incoming basic block. The phi node is at the start
of the basic block at the join point, but each incoming value counts as being
at the end of the incoming block for the purposes of the dominance property.</p>
<p>Any variable that is set inside the loop thus needs to have a phi node at the top of
the loop to represent the join of the value coming in to the loop and the
value coming round from the bottom of the loop. Thus, for example,
<code class="docutils literal"><span class="pre">%E.0.load607622</span></code> is the value of the variable <code class="docutils literal"><span class="pre">E</span></code> at the top of the loop,
a merge of the value <code class="docutils literal"><span class="pre">%E.0.load606629</span></code> coming in to the loop and <code class="docutils literal"><span class="pre">%merge375.7</span></code>
coming round from the bottom of the loop.</p>
<div class="section" id="critical-edge-splitting">
<h4><a class="toc-backref" href="#id34">Critical edge splitting</a><a class="headerlink" href="#critical-edge-splitting" title="Permalink to this headline">¶</a></h4>
<p>In terms of the real vISA code generated, a phi node represents a copy at the
end of each incoming block, except where a copy can be avoided by coalescing (ensuring
the incoming value and the phi node result are in the same vISA register).</p>
<p>For that to work, there needs to be somewhere to insert such a copy. If an incoming
block ends with a conditional branch, so it has another successor in addition to
the start of the loop body (for example, a do..while loop, which LLVM tries to
turn all loops into), then inserting the copy at the end of the loop just before
the conditional branch is no good because it also affects execution if the loop
backedge is not taken.</p>
<p>This situation, where a CFG edge comes from a block with more than one successor
and goes to a block with more than one predecessor, is called a <em>critical edge</em>.
We use a standard LLVM pass BreakCriticalEdges to ensure that there is somewhere
to put the copies that implement the phi nodes.</p>
<p>After BreakCriticalEdges, the start of the loop looks like this:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nl">for.body256:</span>                                      <span class="c">; preds = %if.end356.7.for.body256_crit_edge, %for.body256.lr.ph</span>
  <span class="nv">%stride253.0624</span> <span class="p">=</span> <span class="k">phi</span> <span class="k">i32</span> <span class="p">[</span> <span class="nv">%stride253.0619</span><span class="p">,</span> <span class="nv">%for.body256.lr.ph</span> <span class="p">],</span> <span class="p">[</span> <span class="nv">%stride253.0</span><span class="p">,</span> <span class="nv">%if.end356.7.for.body256_crit_edge</span> <span class="p">]</span>
  <span class="nv">%stride253.0.in623</span> <span class="p">=</span> <span class="k">phi</span> <span class="k">i32</span> <span class="p">[</span> <span class="nv">%size249.0630</span><span class="p">,</span> <span class="nv">%for.body256.lr.ph</span> <span class="p">],</span> <span class="p">[</span> <span class="nv">%stride253.0624</span><span class="p">,</span> <span class="nv">%if.end356.7.for.body256_crit_edge</span> <span class="p">]</span>
  <span class="nv">%E.0.load607622</span> <span class="p">=</span> <span class="k">phi</span> <span class="p">&lt;</span><span class="m">16</span> <span class="k">x</span> <span class="k">i32</span><span class="p">&gt;</span> <span class="p">[</span> <span class="nv">%E.0.load606629</span><span class="p">,</span> <span class="nv">%for.body256.lr.ph</span> <span class="p">],</span> <span class="p">[</span> <span class="nv">%merge375.7</span><span class="p">,</span> <span class="nv">%if.end356.7.for.body256_crit_edge</span> <span class="p">]</span>
  <span class="nv">%D.0.load610621</span> <span class="p">=</span> <span class="k">phi</span> <span class="p">&lt;</span><span class="m">16</span> <span class="k">x</span> <span class="k">i32</span><span class="p">&gt;</span> <span class="p">[</span> <span class="nv">%D.0.load609628</span><span class="p">,</span> <span class="nv">%for.body256.lr.ph</span> <span class="p">],</span> <span class="p">[</span> <span class="nv">%merge368.7</span><span class="p">,</span> <span class="nv">%if.end356.7.for.body256_crit_edge</span> <span class="p">]</span>
</pre></div>
</div>
<p>and the end looks like this:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span>  <span class="nv">%cmp255</span> <span class="p">=</span> <span class="k">icmp</span> <span class="k">eq</span> <span class="k">i32</span> <span class="nv">%stride253.0</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="nv">!dbg</span> <span class="nv nv-Anonymous">!414</span>
  <span class="k">br</span> <span class="k">i1</span> <span class="nv">%cmp255</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%if.end356.7.for.inc382_crit_edge</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%if.end356.7.for.body256_crit_edge</span><span class="p">,</span> <span class="nv">!dbg</span> <span class="nv nv-Anonymous">!414</span>

<span class="nl">if.end356.7.for.body256_crit_edge:</span>                <span class="c">; preds = %if.end356.7</span>
  <span class="k">br</span> <span class="kt">label</span> <span class="nv">%for.body256</span><span class="p">,</span> <span class="nv">!dbg</span> <span class="nv nv-Anonymous">!414</span>

<span class="nl">if.end356.7.for.inc382_crit_edge:</span>                 <span class="c">; preds = %if.end356.7</span>
</pre></div>
</div>
<p>The critical edge has been split by creating a new block <code class="docutils literal"><span class="pre">if.end356.7.for.body256_crit_edge</span></code>,
which now has an unconditional branch back to <code class="docutils literal"><span class="pre">for.body256</span></code>. The incoming blocks in
the phi nodes have been changed accordingly.</p>
</div>
<div class="section" id="circular-phi-nodes">
<h4><a class="toc-backref" href="#id35">Circular phi nodes</a><a class="headerlink" href="#circular-phi-nodes" title="Permalink to this headline">¶</a></h4>
<p>The variable <code class="docutils literal"><span class="pre">stride</span></code> is slightly different.
The standard LLVM passes seem to have made a transformation which means that we have
two values of the induction variable <code class="docutils literal"><span class="pre">stride</span></code> live at the same time: the “next” one
and the “current” one. These are <code class="docutils literal"><span class="pre">%stride253.0624</span></code> and <code class="docutils literal"><span class="pre">%stride253.0.in623</span></code>.</p>
<p>An issue with the phi nodes here is that the ordering looks wrong for the <code class="docutils literal"><span class="pre">stride</span></code>
ones, although it is not really wrong once we understand how LLVM IR phi nodes work:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nv">%stride253.0624</span> <span class="p">=</span> <span class="k">phi</span> <span class="k">i32</span> <span class="p">[</span> <span class="nv">%stride253.0619</span><span class="p">,</span> <span class="nv">%for.body256.lr.ph</span> <span class="p">],</span> <span class="p">[</span> <span class="nv">%stride253.0</span><span class="p">,</span> <span class="nv">%if.end356.7</span> <span class="p">]</span>
<span class="nv">%stride253.0.in623</span> <span class="p">=</span> <span class="k">phi</span> <span class="k">i32</span> <span class="p">[</span> <span class="nv">%size249.0630</span><span class="p">,</span> <span class="nv">%for.body256.lr.ph</span> <span class="p">],</span> <span class="p">[</span> <span class="nv">%stride253.0624</span><span class="p">,</span> <span class="nv">%if.end356.7</span> <span class="p">]</span>
</pre></div>
</div>
<p>The second phi node has an incoming value from round the loop of <code class="docutils literal"><span class="pre">%stride253.0624</span></code>, which
is the result of the first phi node. So it looks like it is immediately using that value.
The key here is that LLVM IR defines that the incoming value must come via the incoming
block <code class="docutils literal"><span class="pre">%if.end356.7</span></code>, thus it comes from the first phi node <em>in the previous iteration
of the loop</em>. The semantics would be exactly the same if the two phi nodes were swapped;
LLVM IR attaches no meaning to the order of the phi nodes in one basic block.</p>
<p>When we get to GenXLiveRanges, where the instructions, including the phi nodes,
are numbered, and we calculate the live ranges in terms of instruction numbers,
the order of phi nodes becomes significant, and the above IR would generate an
incorrect result as it fails to account for <code class="docutils literal"><span class="pre">%stride253.0624</span></code> interfering with
itself as it comes round the loop.</p>
<p>So we need some way of avoiding this <em>circular phi node</em> situation.</p>
<p>The GenXCategory pass, before it creates <code class="docutils literal"><span class="pre">LiveRange</span></code> objects and sets the
category in each one, fixes this situation. Currently it just inserts a copy
just after the phi nodes of the circular phi node, and replaces all the uses.
A better solution in the future might be to try and re-order the phi nodes,
and fall back to inserting a copy only if no ordering can be found that avoids
circular phi nodes.</p>
<p>So after GenXCategory, the circular phi node has been fixed by inserting a copy:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="nl">for.body256:</span>
  <span class="nv">%stride253.0624</span> <span class="p">=</span> <span class="k">phi</span> <span class="k">i32</span> <span class="p">[</span> <span class="nv">%stride253.0619</span><span class="p">,</span> <span class="nv">%for.body256.lr.ph</span> <span class="p">],</span> <span class="p">[</span> <span class="nv">%stride253.0</span><span class="p">,</span> <span class="nv">%if.end356.7.for.body256_crit_edge</span> <span class="p">]</span>
  <span class="nv">%stride253.0.in623</span> <span class="p">=</span> <span class="k">phi</span> <span class="k">i32</span> <span class="p">[</span> <span class="nv">%size249.0630</span><span class="p">,</span> <span class="nv">%for.body256.lr.ph</span> <span class="p">],</span> <span class="p">[</span> <span class="nv">%stride253.0624.unoverlapper</span><span class="p">,</span> <span class="nv">%if.end356.7.for.body256_crit_edge</span> <span class="p">]</span>
  <span class="nv">%E.0.load607622</span> <span class="p">=</span> <span class="k">phi</span> <span class="p">&lt;</span><span class="m">16</span> <span class="k">x</span> <span class="k">i32</span><span class="p">&gt;</span> <span class="p">[</span> <span class="nv">%E.0.load606629</span><span class="p">,</span> <span class="nv">%for.body256.lr.ph</span> <span class="p">],</span> <span class="p">[</span> <span class="nv">%merge375.7</span><span class="p">,</span> <span class="nv">%if.end356.7.for.body256_crit_edge</span> <span class="p">]</span>
  <span class="nv">%D.0.load610621</span> <span class="p">=</span> <span class="k">phi</span> <span class="p">&lt;</span><span class="m">16</span> <span class="k">x</span> <span class="k">i32</span><span class="p">&gt;</span> <span class="p">[</span> <span class="nv">%D.0.load609628</span><span class="p">,</span> <span class="nv">%for.body256.lr.ph</span> <span class="p">],</span> <span class="p">[</span> <span class="nv">%merge368.7</span><span class="p">,</span> <span class="nv">%if.end356.7.for.body256_crit_edge</span> <span class="p">]</span>
  <span class="nv">%stride253.0624.unoverlapper</span> <span class="p">=</span> <span class="k">bitcast</span> <span class="k">i32</span> <span class="nv">%stride253.0624</span> <span class="k">to</span> <span class="k">i32</span>
</pre></div>
</div>
<p>and all other uses of <code class="docutils literal"><span class="pre">%stride253.0624</span></code>, including the one in the first phi node,
have been changed to use <code class="docutils literal"><span class="pre">%stride253.0624.unoverlapper</span></code>.</p>
<p>Now we can treat the ordering of the phi nodes as significant, and assume
that inserted copies to implement phi nodes will appear in the same order
in each incoming block as the phi nodes themselves in this block.</p>
</div>
<div class="section" id="numbering-and-live-ranges-for-phi-nodes">
<h4><a class="toc-backref" href="#id36">Numbering and live ranges for phi nodes</a><a class="headerlink" href="#numbering-and-live-ranges-for-phi-nodes" title="Permalink to this headline">¶</a></h4>
<p>GenXLiveRanges numbers the instructions and calculates live ranges.</p>
<p>A phi node gets special treatment in instruction numbering. As well as a
number for the phi node itself, the site of its inserted copy in each
incoming block also gets a number reserved for it. These reserved numbers
are not explicity shown in any dump, but they might look like this:</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>[4476]  %xor272.reduceintsize217 = bitcast i32 %xor272 to &lt;2 x i16&gt;, !dbg !417 // line 344
[4477]  // reserved for phi copy for %stride253.0624
[4478]  // reserved for phi copy for %stride253.0.in623
[4479]  // reserved for phi copy for %E.0.load607622
[4480]  // reserved for phi copy for %D.0.load610621
[4482]  br label %for.body256, !dbg !414 // line 294
for.body256:
[4485]  %stride253.0624 = phi i32 [ %stride253.0619, %for.body256.lr.ph ], [ %stride253.0, %if.end356.7.for.body256_crit_edge ]
[4487]  %stride253.0.in623 = phi i32 [ %size249.0630, %for.body256.lr.ph ], [ %stride253.0624.unoverlapper, %if.end356.7.for.body256_crit_edge ]
[4489]  %E.0.load607622 = phi &lt;16 x i32&gt; [ %E.0.load606629, %for.body256.lr.ph ], [ %merge375.7, %if.end356.7.for.body256_crit_edge ]
[4491]  %D.0.load610621 = phi &lt;16 x i32&gt; [ %D.0.load609628, %for.body256.lr.ph ], [ %merge368.7, %if.end356.7.for.body256_crit_edge ]
[4493]  %stride253.0624.unoverlapper = bitcast i32 %stride253.0624 to i32
...
[6769]  br i1 %cmp255, label %if.end356.7.for.inc382_crit_edge, label %if.end356.7.for.body256_crit_edge, !dbg !414 // line 294
if.end356.7.for.body256_crit_edge:
[6771]  // reserved for phi copy for %stride253.0624
[6772]  // reserved for phi copy for %stride253.0.in623
[6773]  // reserved for phi copy for %E.0.load607622
[6774]  // reserved for phi copy for %D.0.load610621
[6776]  br label %for.body256, !dbg !414 // line 294
if.end356.7.for.inc382_crit_edge:
</pre></div>
</div>
<p>Then the live range of a phi node includes a segment for each of its phi copy
site, up to the end of that basic block, and a segment from the start of the
phi node’s basic block. This reflects the actual live range of the register
that will be assigned to the phi node once its copies have been inserted.</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>stride253.0624:[4477,4493)[6771,6777){general}
stride253.0.in623:[4478,4642)[6772,6777){general}
E.0.load607622:[4479,4773)[6773,6777){general}
D.0.load610621:[4480,4754)[6774,6777){general}
stride253.0624.unoverlapper:[4493,4861)[5127,6772){general}
</pre></div>
</div>
</div>
<div class="section" id="phi-coalescing">
<h4><a class="toc-backref" href="#id37">Phi coalescing</a><a class="headerlink" href="#phi-coalescing" title="Permalink to this headline">¶</a></h4>
<p>It is the job of GenXCoalescing to insert copies where required to implement
phi nodes, but to avoid copies where possible by coalescing. Like in
two-address coalescing, two live ranges can be coalesced if they do
not interfere.</p>
<p>Inserting copies to implement phi nodes is a process often known as <em>DeSSA</em>.
This is what it is called in LLVM’s target independent code generator, and I
believe that is also the name used in IGC. But the usual approach is for
the IR to leave SSA at this point. In LLVM’s target independent code generator,
a different IR (machine IR) is being used at that point, which can be taken
out of SSA at that point.</p>
<p>The GenX backend uses LLVM IR throughout, which only allows SSA. So its approach
is to add the copies where necessary, but remain in SSA. The phi nodes remain,
but we have ensured that a phi node is coalesced with each incoming value.
If necessary, we insert a copy at the end of the incoming block, and change
the phi node to use that as an incoming. The copy can always be coalesced
with the phi node.</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>[4476]  %xor272.reduceintsize217 = bitcast i32 %xor272 to &lt;2 x i16&gt;, !dbg !417 // line 344
[4478]  %phicopy = bitcast i32 %size249.0630 to i32
[4482]  br label %for.body256, !dbg !414 // line 294
for.body256:
[4485]  %stride253.0624 = phi i32 [ %stride253.0619, %for.body256.lr.ph ], [ %stride253.0, %if.end356.7.for.body256_crit_edge ]
[4487]  %stride253.0.in623 = phi i32 [ %phicopy, %for.body256.lr.ph ], [ %phicopy1426, %if.end356.7.for.body256_crit_edge ]
[4489]  %E.0.load607622 = phi &lt;16 x i32&gt; [ %E.0.load606629, %for.body256.lr.ph ], [ %merge375.7, %if.end356.7.for.body256_crit_edge ]
[4491]  %D.0.load610621 = phi &lt;16 x i32&gt; [ %D.0.load609628, %for.body256.lr.ph ], [ %merge368.7, %if.end356.7.for.body256_crit_edge ]
[4493]  %stride253.0624.unoverlapper = bitcast i32 %stride253.0624 to i32
...
[6769]  br i1 %cmp255, label %if.end356.7.for.inc382_crit_edge, label %if.end356.7.for.body256_crit_edge, !dbg !414 // line 294
if.end356.7.for.body256_crit_edge:
[6772]  %phicopy1426 = bitcast i32 %stride253.0624.unoverlapper to i32
[6776]  br label %for.body256, !dbg !414 // line 294
if.end356.7.for.inc382_crit_edge:
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">%stride253.0.in623</span></code> failed to coalesce both its incomings, causing the insertion
of phi copies <code class="docutils literal"><span class="pre">%phicopy</span></code> and <code class="docutils literal"><span class="pre">%phicopy1426</span></code>. The other three phi nodes
successfully coalesced both incomings, so no copies were inserted.</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>stride253.0624,stride253.0619,stride253.0:[4458,4463)[4468,4493)[6765,6777){general}
stride253.0.in623,phicopy,phicopy1426:[4478,4642)[6772,6777){general}
E.0.load606629,E.0.load607.lcssa,E.0.load607622,scaled1115,merge375.7:[4446,4808)[4861,4882)[6714,6782){general}
D.0.load609628,D.0.load610.lcssa,D.0.load610621,scaled1116,merge368.7:[4447,4808)[4861,4882)[6708,6782){general}
stride253.0624.unoverlapper,splat.splat359213:[4493,4861)[5127,6772){general}
</pre></div>
</div>
<p>The new copies have been coalesced into the corresponding phi nodes. This does
not change the live range, as the live range of a phi node already accounts
for a copy in case it needs to be inserted.</p>
<p>The IR is still in SSA form, but with phi copies inserted and coalescing done so
that each phi node is in the same register as all its incoming values.</p>
</div>
</div>
<div class="section" id="example-indirect-regions-and-address-optimization">
<h3><a class="toc-backref" href="#id38">Example: indirect regions and address optimization</a><a class="headerlink" href="#example-indirect-regions-and-address-optimization" title="Permalink to this headline">¶</a></h3>
<p>ult2/addrTest1 is a tiny test that contains this loop:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">8</span><span class="o">&gt;</span> <span class="n">src</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">8</span><span class="o">&gt;</span> <span class="n">dst</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="c1">// other code ...</span>

<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">dst</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="n">src</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">dst</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">src</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>As the IR comes into the GenX backend, the body of the loop looks like this:</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>%add5 = add nsw i32 %i1.031, 1, !dbg !21 // ult2/addrTest1_genx.cpp:44:9
%conv6 = trunc i32 %add5 to i16, !dbg !21 // ult2/addrTest1_genx.cpp:44:9
%2 = shl i16 %conv6, 2, !dbg !21 // ult2/addrTest1_genx.cpp:44:9
%rdr = tail call &lt;1 x i32&gt; @llvm.genx.rdregioni.v1i32.v8i32.i16(&lt;8 x i32&gt; %wrregion.lcssa, i32 0, i32 1, i32 0, i16 %2, i32 undef), !dbg !21 // ult2/addrTest1_genx.cpp:44:9
%conv7 = trunc i32 %i1.031 to i16, !dbg !21 // ult2/addrTest1_genx.cpp:44:9
%3 = shl i16 %conv7, 2, !dbg !21 // ult2/addrTest1_genx.cpp:44:9
%wrregion8 = tail call &lt;8 x i32&gt; @llvm.genx.wrregioni.v8i32.v1i32.i16.i1(&lt;8 x i32&gt; %dst.030, &lt;1 x i32&gt; %rdr, i32 0, i32 1, i32 0, i16 %3, i32 undef, i1 true), !dbg !21 // ult2/addrTest1_genx.cpp:44:9
%rdr11 = tail call &lt;1 x i32&gt; @llvm.genx.rdregioni.v1i32.v8i32.i16(&lt;8 x i32&gt; %wrregion.lcssa, i32 0, i32 1, i32 0, i16 %3, i32 undef), !dbg !24 // ult2/addrTest1_genx.cpp:45:9
%wrregion14 = tail call &lt;8 x i32&gt; @llvm.genx.wrregioni.v8i32.v1i32.i16.i1(&lt;8 x i32&gt; %wrregion8, &lt;1 x i32&gt; %rdr11, i32 0, i32 1, i32 0, i16 %2, i32 undef, i1 true), !dbg !24 // ult2/addrTest1_genx.cpp:45:9
</pre></div>
</div>
<img alt="_images/GenXIntro_AddrOpt2.png" src="_images/GenXIntro_AddrOpt2.png" />
<p>Earlier LLVM passes have already done some common subexpression elimination on
this. It is still calculating the i+1 index separately from the i index, but it
is not doing all four indices separately.</p>
<p>After GenXLowering, it looks like this:</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>%add5 = add nsw i32 %i1.031, 1, !dbg !21 // ult2/addrTest1_genx.cpp:44:9
%conv610 = bitcast i32 %add5 to &lt;2 x i16&gt;, !dbg !21 // ult2/addrTest1_genx.cpp:44:9
%conv611 = call i16 @llvm.genx.rdregioni.i16.v2i16.i16(&lt;2 x i16&gt; %conv610, i32 2, i32 1, i32 2, i16 0, i32 undef), !dbg !21 // ult2/addrTest1_genx.cpp:44:9
%conv618 = bitcast i32 %i1.031 to &lt;2 x i16&gt;, !dbg !21 // ult2/addrTest1_genx.cpp:44:9
%conv619 = call i16 @llvm.genx.rdregioni.i16.v2i16.i16(&lt;2 x i16&gt; %conv618, i32 2, i32 1, i32 2, i16 0, i32 undef), !dbg !21 // ult2/addrTest1_genx.cpp:44:9
%2 = shl i16 %conv619, 2, !dbg !21 // ult2/addrTest1_genx.cpp:44:9
%addr_add = add i16 %2, 4, !dbg !21 // ult2/addrTest1_genx.cpp:44:9
%conv646 = bitcast i32 %i1.031 to &lt;2 x i16&gt;, !dbg !21 // ult2/addrTest1_genx.cpp:44:9
%conv647 = call i16 @llvm.genx.rdregioni.i16.v2i16.i16(&lt;2 x i16&gt; %conv646, i32 2, i32 1, i32 2, i16 0, i32 undef), !dbg !21 // ult2/addrTest1_genx.cpp:44:9
%3 = shl i16 %conv647, 2, !dbg !21 // ult2/addrTest1_genx.cpp:44:9
%addr_add5 = add i16 %3, 4, !dbg !21 // ult2/addrTest1_genx.cpp:44:9
%4 = shl i16 %conv611, 2, !dbg !21 // ult2/addrTest1_genx.cpp:44:9
%rdr = tail call &lt;1 x i32&gt; @llvm.genx.rdregioni.v1i32.v8i32.i16(&lt;8 x i32&gt; %wrregion.lcssa, i32 0, i32 1, i32 0, i16 %addr_add5, i32 undef), !dbg !21 // ult2/addrTest1_genx.cpp:44:9
%conv72 = bitcast i32 %i1.031 to &lt;2 x i16&gt;, !dbg !21 // ult2/addrTest1_genx.cpp:44:9
%conv73 = call i16 @llvm.genx.rdregioni.i16.v2i16.i16(&lt;2 x i16&gt; %conv72, i32 2, i32 1, i32 2, i16 0, i32 undef), !dbg !21 // ult2/addrTest1_genx.cpp:44:9
%5 = shl i16 %conv73, 2, !dbg !21 // ult2/addrTest1_genx.cpp:44:9
%wrregion8 = tail call &lt;8 x i32&gt; @llvm.genx.wrregioni.v8i32.v1i32.i16.i1(&lt;8 x i32&gt; %dst.030, &lt;1 x i32&gt; %rdr, i32 0, i32 1, i32 0, i16 %5, i32 undef, i1 true), !dbg !21 // ult2/addrTest1_genx.cpp:44:9
%rdr11 = tail call &lt;1 x i32&gt; @llvm.genx.rdregioni.v1i32.v8i32.i16(&lt;8 x i32&gt; %wrregion.lcssa, i32 0, i32 1, i32 0, i16 %5, i32 undef), !dbg !24 // ult2/addrTest1_genx.cpp:45:9
%wrregion14 = tail call &lt;8 x i32&gt; @llvm.genx.wrregioni.v8i32.v1i32.i16.i1(&lt;8 x i32&gt; %wrregion8, &lt;1 x i32&gt; %rdr11, i32 0, i32 1, i32 0, i16 %addr_add, i32 undef, i1 true), !dbg !24 // ult2/addrTest1_genx.cpp:45:9
</pre></div>
</div>
<img alt="_images/GenXIntro_AddrOpt3.png" src="_images/GenXIntro_AddrOpt3.png" />
<p>GenXLowering has done <em>add sinking</em>, where it spots that the calculation for
an indirect region index includes a constant add, and ensures that the
constant add is the last thing that happens. It does this because it knows that:</p>
<ul class="simple">
<li>the constant add can probably be baled into the region as a constant offset,
saving an instruction;</li>
<li>cases like this happen frequently, where two address calculations are the
same other than the add, and sinking the add makes it more likely that the
calculations can be commoned up.</li>
</ul>
<p>However, in doing the address sinking, it has undone some of the earlier CSE.
That does not matter, because we will be doing another CSE later.</p>
<p>Also, GenXLowering has turned a trunc into the equivalent bitcast and strided
region read. The bitcast does not generate any code, as GenXCoalescing will
ensure that its operand and result are in the same register. The strided
region read will probably not use an instruction in itself because it will
be baled into whatever uses it. I have continued to represent the
bitcast-and-strided-rdregion as trunc in the diagram.</p>
<p>After CSE and dead code elimination, it is all commoned up again:</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>%conv618 = bitcast i32 %i1.031 to &lt;2 x i16&gt;, !dbg !21 // ult2/addrTest1_genx.cpp:44:9
%conv619 = call i16 @llvm.genx.rdregioni.i16.v2i16.i16(&lt;2 x i16&gt; %conv618, i32 2, i32 1, i32 2, i16 0, i32 undef), !dbg !21 // ult2/addrTest1_genx.cpp:44:9
%1 = shl i16 %conv619, 2, !dbg !21 // ult2/addrTest1_genx.cpp:44:9
%addr_add = add i16 %1, 4, !dbg !21 // ult2/addrTest1_genx.cpp:44:9
%rdr = tail call &lt;1 x i32&gt; @llvm.genx.rdregioni.v1i32.v8i32.i16(&lt;8 x i32&gt; %wrregion, i32 0, i32 1, i32 0, i16 %addr_add, i32 undef), !dbg !21 // ult2/addrTest1_genx.cpp:44:9
%wrregion8 = tail call &lt;8 x i32&gt; @llvm.genx.wrregioni.v8i32.v1i32.i16.i1(&lt;8 x i32&gt; %dst.030, &lt;1 x i32&gt; %rdr, i32 0, i32 1, i32 0, i16 %1, i32 undef, i1 true), !dbg !21 // ult2/addrTest1_genx.cpp:44:9
%rdr11 = tail call &lt;1 x i32&gt; @llvm.genx.rdregioni.v1i32.v8i32.i16(&lt;8 x i32&gt; %wrregion, i32 0, i32 1, i32 0, i16 %1, i32 undef), !dbg !24 // ult2/addrTest1_genx.cpp:45:9
%wrregion14 = tail call &lt;8 x i32&gt; @llvm.genx.wrregioni.v8i32.v1i32.i16.i1(&lt;8 x i32&gt; %wrregion8, &lt;1 x i32&gt; %rdr11, i32 0, i32 1, i32 0, i16 %addr_add, i32 undef, i1 true), !dbg !24 // ult2/addrTest1_genx.cpp:45:9
%add16 = add nsw i32 %i1.031, 2, !dbg !25 // ult2/addrTest1_genx.cpp:43:28
</pre></div>
</div>
<img alt="_images/GenXIntro_AddrOpt4.png" src="_images/GenXIntro_AddrOpt4.png" />
<p>GenXCategory is the pass that inserts conversions between different register
categories if necessary, in particular address registers. After GenXCategory,
the IR looks like this:</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>%conv618 = bitcast i32 %i1.031 to &lt;2 x i16&gt;, !dbg !21 // ult2/addrTest1_genx.cpp:44:9
%conv619 = call i16 @llvm.genx.rdregioni.i16.v2i16.i16(&lt;2 x i16&gt; %conv618, i32 2, i32 1, i32 2, i16 0, i32 undef), !dbg !21 // ult2/addrTest1_genx.cpp:44:9
%shl = shl i16 %conv619, 2, !dbg !21 // ult2/addrTest1_genx.cpp:44:9
%shl.categoryconv = call i16 @llvm.genx.convert.addr.i16(i16 %shl, i16 0), !dbg !21 // ult2/addrTest1_genx.cpp:44:9
%addr_add.addradd18 = call i16 @llvm.genx.add.addr.i16(i16 %shl.categoryconv, i16 4), !dbg !21 // ult2/addrTest1_genx.cpp:44:9
%rdr = tail call &lt;1 x i32&gt; @llvm.genx.rdregioni.v1i32.v8i32.i16(&lt;8 x i32&gt; %wrregion, i32 0, i32 1, i32 0, i16 %addr_add.addradd18, i32 undef), !dbg !21 // ult2/addrTest1_genx.cpp:44:9
%shl.categoryconv21 = call i16 @llvm.genx.convert.addr.i16(i16 %shl, i16 0), !dbg !21 // ult2/addrTest1_genx.cpp:44:9
%wrregion8 = tail call &lt;8 x i32&gt; @llvm.genx.wrregioni.v8i32.v1i32.i16.i1(&lt;8 x i32&gt; %dst.030, &lt;1 x i32&gt; %rdr, i32 0, i32 1, i32 0, i16 %shl.categoryconv21, i32 undef, i1 true), !dbg !21 // ult2/addrTest1_genx.cpp:44:9
%shl.categoryconv20 = call i16 @llvm.genx.convert.addr.i16(i16 %shl, i16 0), !dbg !24 // ult2/addrTest1_genx.cpp:45:9
%rdr11 = tail call &lt;1 x i32&gt; @llvm.genx.rdregioni.v1i32.v8i32.i16(&lt;8 x i32&gt; %wrregion, i32 0, i32 1, i32 0, i16 %shl.categoryconv20, i32 undef), !dbg !24 // ult2/addrTest1_genx.cpp:45:9
%shl.categoryconv19 = call i16 @llvm.genx.convert.addr.i16(i16 %shl, i16 0), !dbg !24 // ult2/addrTest1_genx.cpp:45:9
%addr_add.addradd = call i16 @llvm.genx.add.addr.i16(i16 %shl.categoryconv19, i16 4), !dbg !24 // ult2/addrTest1_genx.cpp:45:9
%wrregion14 = tail call &lt;8 x i32&gt; @llvm.genx.wrregioni.v8i32.v1i32.i16.i1(&lt;8 x i32&gt; %wrregion8, &lt;1 x i32&gt; %rdr11, i32 0, i32 1, i32 0, i16 %addr_add.addradd, i32 undef, i1 true), !dbg !24 // ult2/addrTest1_genx.cpp:45:9
</pre></div>
</div>
<img alt="_images/GenXIntro_AddrOpt5.png" src="_images/GenXIntro_AddrOpt5.png" />
<p><code class="docutils literal"><span class="pre">llvm.genx.convert.addr</span></code> represents a conversion from an integer index to
an address register. However, although the integer index is its only operand,
it implicitly uses the base register of any indirect region it is used in, as
the value in the address register is actually the start of the base register
plus the index.</p>
<p>At the time that GenXCategory runs, it does not know which indirect regions
will be in the same base register, so it has to assume that each indirect
region has a separate base register. Thus there are four separate category
conversions in here.</p>
<p>The adds that GenXLowering ensured were sunk are now able to be expressed as
<code class="docutils literal"><span class="pre">llvm.genx.add.addr</span></code>, after the category conversion. That ensures that the
adds can be baled into their indirect regions.</p>
<p>GenXCoalescing then works out how the live ranges for individual LLVM IR values
can be coalesced, such that the whole coalesced live range will be allocated
to the same vISA register. This is where the GenX backend realizes that all the
values of the variable <code class="docutils literal"><span class="pre">dst</span></code> (the input to the first wrregion, the result of
that that is the input to the second wrregion, and the result of that) can
all be coalesced together. So, after GenXCoalescing, the liveness information
includes this line</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>dst.030,wrregion14,constant17,wrregion8:[35,38)[43,92){general,align32}
</pre></div>
</div>
<p>Now we can tell which address conversions we can common up because they have the
same base register. This is the job of the GenXAddressCommoning pass. After that
pass, the IR looks like this:</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>[54]  %conv618 = bitcast i32 %i1.031 to &lt;2 x i16&gt;, !dbg !21 // ult2/addrTest1_genx.cpp:44:9
[58]  bale {
[56]     %conv619 = call i16 @llvm.genx.rdregioni.i16.v2i16.i16(&lt;2 x i16&gt; %conv618, i32 2, i32 1, i32 2, i16 0, i32 undef), !dbg !21 // ult2/addrTest1_genx.cpp:44:9 {rdregion}
[58]     %shl = shl i16 %conv619, 2, !dbg !21 // ult2/addrTest1_genx.cpp:44:9
[58]  }
[60]  %shl.categoryconv = call i16 @llvm.genx.convert.addr.i16(i16 %shl, i16 0), !dbg !21 // ult2/addrTest1_genx.cpp:44:9
[62]  %shl.categoryconv21 = call i16 @llvm.genx.convert.addr.i16(i16 %shl, i16 0), !dbg !21 // ult2/addrTest1_genx.cpp:44:9
[68]  bale {
[64]     %addr_add.addradd18 = call i16 @llvm.genx.add.addr.i16(i16 %shl.categoryconv, i16 4), !dbg !21 // ult2/addrTest1_genx.cpp:44:9 {addradd}
[66]     %rdr = tail call &lt;1 x i32&gt; @llvm.genx.rdregioni.v1i32.v8i32.i16(&lt;8 x i32&gt; %wrregion, i32 0, i32 1, i32 0, i16 %addr_add.addradd18, i32 undef), !dbg !21 // ult2/addrTest1_genx.cpp:44:9 {rdregion}
[68]     %wrregion8 = tail call &lt;8 x i32&gt; @llvm.genx.wrregioni.v8i32.v1i32.i16.i1(&lt;8 x i32&gt; %dst.030, &lt;1 x i32&gt; %rdr, i32 0, i32 1, i32 0, i16 %shl.categoryconv21, i32 undef, i1 true), !dbg !21 // ult2/addrTest1_genx.cpp:44:9 {wrregion}
[68]  }
[78]  bale {
[74]     %rdr11 = tail call &lt;1 x i32&gt; @llvm.genx.rdregioni.v1i32.v8i32.i16(&lt;8 x i32&gt; %wrregion, i32 0, i32 1, i32 0, i16 %shl.categoryconv, i32 undef), !dbg !24 // ult2/addrTest1_genx.cpp:45:9 {rdregion}
[76]     %addr_add.addradd = call i16 @llvm.genx.add.addr.i16(i16 %shl.categoryconv21, i16 4), !dbg !24 // ult2/addrTest1_genx.cpp:45:9 {addradd}
[78]     %wrregion14 = tail call &lt;8 x i32&gt; @llvm.genx.wrregioni.v8i32.v1i32.i16.i1(&lt;8 x i32&gt; %wrregion8, &lt;1 x i32&gt; %rdr11, i32 0, i32 1, i32 0, i16 %addr_add.addradd, i32 undef, i1 true), !dbg !24 // ult2/addrTest1_genx.cpp:45:9 {wrregion}
[78]  }
</pre></div>
</div>
<img alt="_images/GenXIntro_AddrOpt6.png" src="_images/GenXIntro_AddrOpt6.png" />
<p>Now there are only two address conversions, and thus only two address registers
used between the four indirect accesses. Also note that the <code class="docutils literal"><span class="pre">add.addr</span></code>
intrinsics have been baled into their regions, so are not taking any extra
instructions.</p>
<p>Finally, the GenXVisaFuncWriter pass writes the vISA as:</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>LOC 44
shl (M1, 1) V37(0,0)&lt;1&gt;:w V40{V35}(0,0)&lt;0;1,0&gt;:w 0x2:w
addr_add (M1, 1) A1(0)&lt;1&gt; V33(0,0)&lt;0;1,0&gt;:d V41{V37}(0,0)&lt;0;1,0&gt;:uw
addr_add (M1, 1) A2(0)&lt;1&gt; V36(0,0)&lt;0;1,0&gt;:d V41{V37}(0,0)&lt;0;1,0&gt;:uw
mov (M1, 1) [A2(0)+0]{nogrfcross}&lt;0;1,1&gt;:d [A1(0)+4]&lt;0;1,0&gt;:d
LOC 45
mov (M1, 1) [A2(0)+4]&lt;0;1,1&gt;:d [A1(0)+0]{nogrfcross}&lt;0;1,0&gt;:d
</pre></div>
</div>
</div>
</div>
<div class="section" id="glossary">
<h2><a class="toc-backref" href="#id39">Glossary</a><a class="headerlink" href="#glossary" title="Permalink to this headline">¶</a></h2>
<dl class="docutils">
<dt><strong>Bale</strong></dt>
<dd>A tree of IR instructions marked by GenXBaling that they will be combined into a
single vISA
instruction. The <strong>head</strong> of the bale is the last instruction in code order,
the root of the tree, which is the only instruction whose value is used outside
the bale. The <strong>main instruction</strong> of a bale is the IR instruction that
corresponds to the actual vISA instruction, such as add. It is possible to have
a bale with no main instruction, such as when the bale just reads a region and
writes the result into another region. This would become a vISA mov instruction.</dd>
<dt><strong>Coalescing</strong></dt>
<dd>Merging two live ranges into one, in order to save a copy instruction that
would otherwise be needed from one to the other.</dd>
<dt><strong>Extra coalescing</strong></dt>
<dd>Coalescing two live ranges, but in this case it is not to save a copy
instruction. Rather it is where one live range has a kill use and the other
has its definition at the same instruction, and they have the same data
size. They are coalesced to ensure they get the same vISA register allocated,
in order to reduce the chance of fragmentation in the jitter’s register
allocator.</dd>
<dt><strong>SRoA</strong></dt>
<dd>Scalar Replacement of Aggregates</dd>
<dt><strong>SSA</strong></dt>
<dd>Static Single Assignment</dd>
<dt><strong>Two address coalescing</strong></dt>
<dd>Coalescing two live ranges into one in order to save a copy instruction, in
the specific case that one is an input and the other is the result of an
instruction that requires them to be in the same vISA register, for example
the “old value of vector” input and the result of a wrregion.</dd>
</dl>
</div>
</div>


          </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="GenXDesign.html" title="GenX backend design"
             >next</a> |</li>
        <li class="right" >
          <a href="GenXIndex.html" title="GenX backend documentation"
             >previous</a> |</li>
  <li><a href="http://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="index.html">Documentation</a>&raquo;</li>

          <li class="nav-item nav-item-1"><a href="GenXIndex.html" >GenX backend documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2003-2019, LLVM Project.
      Last updated on Wed Feb 13 10:08:12 2019 -0800.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.1.
    </div>
  </body>
</html>