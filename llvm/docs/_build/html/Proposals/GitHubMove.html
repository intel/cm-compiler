

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Moving LLVM Projects to GitHub &#8212; LLVM 6 documentation</title>
    
    <link rel="stylesheet" href="../_static/llvm-theme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '6',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="prev" title="How To Validate a New Release" href="../ReleaseProcess.html" />
<style type="text/css">
  table.right { float: right; margin-left: 20px; }
  table.right td { border: 1px solid #ccc; }
</style>

  </head>
  <body>
<div class="logo">
  <a href="../index.html">
    <img src="../_static/logo.png"
         alt="LLVM Logo" width="250" height="88"/></a>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../ReleaseProcess.html" title="How To Validate a New Release"
             accesskey="P">previous</a> |</li>
  <li><a href="http://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="../index.html">Documentation</a>&raquo;</li>
 
      </ul>
    </div>


    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <div class="section" id="moving-llvm-projects-to-github">
<h1>Moving LLVM Projects to GitHub<a class="headerlink" href="#moving-llvm-projects-to-github" title="Permalink to this headline">¶</a></h1>
<div class="contents local topic" id="table-of-contents">
<p class="topic-title first">Table of Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#introduction" id="id26">Introduction</a></li>
<li><a class="reference internal" href="#what-this-proposal-is-not-about" id="id27">What This Proposal is <em>Not</em> About</a></li>
<li><a class="reference internal" href="#why-git-and-why-github" id="id28">Why Git, and Why GitHub?</a><ul>
<li><a class="reference internal" href="#why-move-at-all" id="id29">Why Move At All?</a></li>
<li><a class="reference internal" href="#why-git" id="id30">Why Git?</a></li>
<li><a class="reference internal" href="#why-github" id="id31">Why GitHub?</a></li>
<li><a class="reference internal" href="#on-managing-revision-numbers-with-git" id="id32">On Managing Revision Numbers with Git</a></li>
<li><a class="reference internal" href="#what-about-branches-and-merges" id="id33">What About Branches and Merges?</a></li>
<li><a class="reference internal" href="#what-about-commit-emails" id="id34">What About Commit Emails?</a></li>
</ul>
</li>
<li><a class="reference internal" href="#straw-man-migration-plan" id="id35">Straw Man Migration Plan</a><ul>
<li><a class="reference internal" href="#step-1-before-the-move" id="id36">Step #1 : Before The Move</a></li>
<li><a class="reference internal" href="#step-2-git-move" id="id37">Step #2 : Git Move</a></li>
<li><a class="reference internal" href="#step-3-write-access-move" id="id38">Step #3: Write Access Move</a></li>
<li><a class="reference internal" href="#step-4-post-move" id="id39">Step #4 : Post Move</a></li>
</ul>
</li>
<li><a class="reference internal" href="#one-or-multiple-repositories" id="id40">One or Multiple Repositories?</a><ul>
<li><a class="reference internal" href="#multirepo-variant" id="id41">Multirepo Variant</a><ul>
<li><a class="reference internal" href="#umbrella-repository" id="id42">Umbrella Repository</a></li>
<li><a class="reference internal" href="#living-downstream" id="id43">Living Downstream</a></li>
<li><a class="reference internal" href="#multirepo-preview" id="id44">Multirepo Preview</a></li>
<li><a class="reference internal" href="#concerns" id="id45">Concerns</a></li>
<li><a class="reference internal" href="#workflows" id="id46">Workflows</a></li>
</ul>
</li>
<li><a class="reference internal" href="#monorepo-variant" id="id47">Monorepo Variant</a><ul>
<li><a class="reference internal" href="#building-a-single-sub-project" id="id48">Building a single sub-project</a></li>
<li><a class="reference internal" href="#read-write-sub-project-mirrors" id="id49">Read/write sub-project mirrors</a></li>
<li><a class="reference internal" href="#id9" id="id50">Living Downstream</a></li>
<li><a class="reference internal" href="#monorepo-preview" id="id51">Monorepo Preview</a></li>
<li><a class="reference internal" href="#id12" id="id52">Concerns</a></li>
<li><a class="reference internal" href="#id13" id="id53">Workflows</a></li>
</ul>
</li>
<li><a class="reference internal" href="#multi-mono-hybrid-variant" id="id54">Multi/Mono Hybrid Variant</a><ul>
<li><a class="reference internal" href="#id14" id="id55">Concerns</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#workflow-before-after" id="id56">Workflow Before/After</a><ul>
<li><a class="reference internal" href="#checkout-clone-a-single-project-without-commit-access" id="id57">Checkout/Clone a Single Project, without Commit Access</a></li>
<li><a class="reference internal" href="#checkout-clone-a-single-project-with-commit-access" id="id58">Checkout/Clone a Single Project, with Commit Access</a><ul>
<li><a class="reference internal" href="#currently" id="id59">Currently</a></li>
<li><a class="reference internal" href="#workflow-multicheckout-nocommit" id="id60">Multirepo Variant</a></li>
<li><a class="reference internal" href="#workflow-monocheckout-nocommit" id="id61">Monorepo Variant</a></li>
</ul>
</li>
<li><a class="reference internal" href="#checkout-clone-multiple-projects-with-commit-access" id="id62">Checkout/Clone Multiple Projects, with Commit Access</a><ul>
<li><a class="reference internal" href="#id17" id="id63">Currently</a></li>
<li><a class="reference internal" href="#workflow-multicheckout-multicommit" id="id64">Multirepo Variant</a></li>
<li><a class="reference internal" href="#workflow-monocheckout-multicommit" id="id65">Monorepo Variant</a></li>
</ul>
</li>
<li><a class="reference internal" href="#commit-an-api-change-in-llvm-and-update-the-sub-projects" id="id66">Commit an API Change in LLVM and Update the Sub-projects</a></li>
<li><a class="reference internal" href="#branching-stashing-updating-for-local-development-or-experiments" id="id67">Branching/Stashing/Updating for Local Development or Experiments</a><ul>
<li><a class="reference internal" href="#id20" id="id68">Currently</a></li>
<li><a class="reference internal" href="#workflow-multi-branching" id="id69">Multirepo Variant</a></li>
<li><a class="reference internal" href="#workflow-mono-branching" id="id70">Monorepo Variant</a></li>
</ul>
</li>
<li><a class="reference internal" href="#bisecting" id="id71">Bisecting</a><ul>
<li><a class="reference internal" href="#id23" id="id72">Currently</a></li>
<li><a class="reference internal" href="#workflow-multi-bisecting" id="id73">Multirepo Variant</a></li>
<li><a class="reference internal" href="#workflow-mono-bisecting" id="id74">Monorepo Variant</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#references" id="id75">References</a></li>
</ul>
</div>
<div class="section" id="introduction">
<h2><a class="toc-backref" href="#id26">Introduction</a><a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>This is a proposal to move our current revision control system from our own
hosted Subversion to GitHub. Below are the financial and technical arguments as
to why we are proposing such a move and how people (and validation
infrastructure) will continue to work with a Git-based LLVM.</p>
<p>There will be a survey pointing at this document which we’ll use to gauge the
community’s reaction and, if we collectively decide to move, the time-frame. Be
sure to make your view count.</p>
<p>Additionally, we will discuss this during a BoF at the next US LLVM Developer
meeting (<a class="reference external" href="http://llvm.org/devmtg/2016-11/">http://llvm.org/devmtg/2016-11/</a>).</p>
</div>
<div class="section" id="what-this-proposal-is-not-about">
<h2><a class="toc-backref" href="#id27">What This Proposal is <em>Not</em> About</a><a class="headerlink" href="#what-this-proposal-is-not-about" title="Permalink to this headline">¶</a></h2>
<p>Changing the development policy.</p>
<p>This proposal relates only to moving the hosting of our source-code repository
from SVN hosted on our own servers to Git hosted on GitHub. We are not proposing
using GitHub’s issue tracker, pull-requests, or code-review.</p>
<p>Contributors will continue to earn commit access on demand under the Developer
Policy, except that that a GitHub account will be required instead of SVN
username/password-hash.</p>
</div>
<div class="section" id="why-git-and-why-github">
<h2><a class="toc-backref" href="#id28">Why Git, and Why GitHub?</a><a class="headerlink" href="#why-git-and-why-github" title="Permalink to this headline">¶</a></h2>
<div class="section" id="why-move-at-all">
<h3><a class="toc-backref" href="#id29">Why Move At All?</a><a class="headerlink" href="#why-move-at-all" title="Permalink to this headline">¶</a></h3>
<p>This discussion began because we currently host our own Subversion server
and Git mirror on a voluntary basis. The LLVM Foundation sponsors the server and
provides limited support, but there is only so much it can do.</p>
<p>Volunteers are not sysadmins themselves, but compiler engineers that happen
to know a thing or two about hosting servers. We also don’t have 24/7 support,
and we sometimes wake up to see that continuous integration is broken because
the SVN server is either down or unresponsive.</p>
<p>We should take advantage of one of the services out there (GitHub, GitLab,
and BitBucket, among others) that offer better service (24/7 stability, disk
space, Git server, code browsing, forking facilities, etc) for free.</p>
</div>
<div class="section" id="why-git">
<h3><a class="toc-backref" href="#id30">Why Git?</a><a class="headerlink" href="#why-git" title="Permalink to this headline">¶</a></h3>
<p>Many new coders nowadays start with Git, and a lot of people have never used
SVN, CVS, or anything else. Websites like GitHub have changed the landscape
of open source contributions, reducing the cost of first contribution and
fostering collaboration.</p>
<p>Git is also the version control many LLVM developers use. Despite the
sources being stored in a SVN server, these developers are already using Git
through the Git-SVN integration.</p>
<p>Git allows you to:</p>
<ul class="simple">
<li>Commit, squash, merge, and fork locally without touching the remote server.</li>
<li>Maintain local branches, enabling multiple threads of development.</li>
<li>Collaborate on these branches (e.g. through your own fork of llvm on GitHub).</li>
<li>Inspect the repository history (blame, log, bisect) without Internet access.</li>
<li>Maintain remote forks and branches on Git hosting services and
integrate back to the main repository.</li>
</ul>
<p>In addition, because Git seems to be replacing many OSS projects’ version
control systems, there are many tools that are built over Git.
Future tooling may support Git first (if not only).</p>
</div>
<div class="section" id="why-github">
<h3><a class="toc-backref" href="#id31">Why GitHub?</a><a class="headerlink" href="#why-github" title="Permalink to this headline">¶</a></h3>
<p>GitHub, like GitLab and BitBucket, provides free code hosting for open source
projects. Any of these could replace the code-hosting infrastructure that we
have today.</p>
<p>These services also have a dedicated team to monitor, migrate, improve and
distribute the contents of the repositories depending on region and load.</p>
<p>GitHub has one important advantage over GitLab and
BitBucket: it offers read-write <strong>SVN</strong> access to the repository
(<a class="reference external" href="https://github.com/blog/626-announcing-svn-support">https://github.com/blog/626-announcing-svn-support</a>).
This would enable people to continue working post-migration as though our code
were still canonically in an SVN repository.</p>
<p>In addition, there are already multiple LLVM mirrors on GitHub, indicating that
part of our community has already settled there.</p>
</div>
<div class="section" id="on-managing-revision-numbers-with-git">
<h3><a class="toc-backref" href="#id32">On Managing Revision Numbers with Git</a><a class="headerlink" href="#on-managing-revision-numbers-with-git" title="Permalink to this headline">¶</a></h3>
<p>The current SVN repository hosts all the LLVM sub-projects alongside each other.
A single revision number (e.g. r123456) thus identifies a consistent version of
all LLVM sub-projects.</p>
<p>Git does not use sequential integer revision number but instead uses a hash to
identify each commit. (Linus mentioned that the lack of such revision number
is “the only real design mistake” in Git <a class="reference internal" href="#torvaldrevnum" id="id1">[TorvaldRevNum]</a>.)</p>
<p>The loss of a sequential integer revision number has been a sticking point in
past discussions about Git:</p>
<ul class="simple">
<li>“The ‘branch’ I most care about is mainline, and losing the ability to say
‘fixed in r1234’ (with some sort of monotonically increasing number) would
be a tragic loss.” <a class="reference internal" href="#lattnerrevnum" id="id2">[LattnerRevNum]</a></li>
<li>“I like those results sorted by time and the chronology should be obvious, but
timestamps are incredibly cumbersome and make it difficult to verify that a
given checkout matches a given set of results.” <a class="reference internal" href="#trickrevnum" id="id3">[TrickRevNum]</a></li>
<li>“There is still the major regression with unreadable version numbers.
Given the amount of Bugzilla traffic with ‘Fixed in…’, that’s a
non-trivial issue.” <a class="reference internal" href="#jsonnrevnum" id="id4">[JSonnRevNum]</a></li>
<li>“Sequential IDs are important for LNT and llvmlab bisection tool.” <a class="reference internal" href="#matthewsrevnum" id="id5">[MatthewsRevNum]</a>.</li>
</ul>
<p>However, Git can emulate this increasing revision number:
<code class="docutils literal"><span class="pre">git</span> <span class="pre">rev-list</span> <span class="pre">--count</span> <span class="pre">&lt;commit-hash&gt;</span></code>. This identifier is unique only
within a single branch, but this means the tuple <cite>(num, branch-name)</cite> uniquely
identifies a commit.</p>
<p>We can thus use this revision number to ensure that e.g. <cite>clang -v</cite> reports a
user-friendly revision number (e.g. <cite>master-12345</cite> or <cite>4.0-5321</cite>), addressing
the objections raised above with respect to this aspect of Git.</p>
</div>
<div class="section" id="what-about-branches-and-merges">
<h3><a class="toc-backref" href="#id33">What About Branches and Merges?</a><a class="headerlink" href="#what-about-branches-and-merges" title="Permalink to this headline">¶</a></h3>
<p>In contrast to SVN, Git makes branching easy. Git’s commit history is
represented as a DAG, a departure from SVN’s linear history. However, we propose
to mandate making merge commits illegal in our canonical Git repository.</p>
<p>Unfortunately, GitHub does not support server side hooks to enforce such a
policy.  We must rely on the community to avoid pushing merge commits.</p>
<p>GitHub offers a feature called <cite>Status Checks</cite>: a branch protected by
<cite>status checks</cite> requires commits to be whitelisted before the push can happen.
We could supply a pre-push hook on the client side that would run and check the
history, before whitelisting the commit being pushed <a class="reference internal" href="#statuschecks" id="id6">[statuschecks]</a>.
However this solution would be somewhat fragile (how do you update a script
installed on every developer machine?) and prevents SVN access to the
repository.</p>
</div>
<div class="section" id="what-about-commit-emails">
<h3><a class="toc-backref" href="#id34">What About Commit Emails?</a><a class="headerlink" href="#what-about-commit-emails" title="Permalink to this headline">¶</a></h3>
<p>We will need a new bot to send emails for each commit. This proposal leaves the
email format unchanged besides the commit URL.</p>
</div>
</div>
<div class="section" id="straw-man-migration-plan">
<h2><a class="toc-backref" href="#id35">Straw Man Migration Plan</a><a class="headerlink" href="#straw-man-migration-plan" title="Permalink to this headline">¶</a></h2>
<div class="section" id="step-1-before-the-move">
<h3><a class="toc-backref" href="#id36">Step #1 : Before The Move</a><a class="headerlink" href="#step-1-before-the-move" title="Permalink to this headline">¶</a></h3>
<ol class="arabic simple">
<li>Update docs to mention the move, so people are aware of what is going on.</li>
<li>Set up a read-only version of the GitHub project, mirroring our current SVN
repository.</li>
<li>Add the required bots to implement the commit emails, as well as the
umbrella repository update (if the multirepo is selected) or the read-only
Git views for the sub-projects (if the monorepo is selected).</li>
</ol>
</div>
<div class="section" id="step-2-git-move">
<h3><a class="toc-backref" href="#id37">Step #2 : Git Move</a><a class="headerlink" href="#step-2-git-move" title="Permalink to this headline">¶</a></h3>
<ol class="arabic simple" start="4">
<li>Update the buildbots to pick up updates and commits from the GitHub
repository. Not all bots have to migrate at this point, but it’ll help
provide infrastructure testing.</li>
<li>Update Phabricator to pick up commits from the GitHub repository.</li>
<li>LNT and llvmlab have to be updated: they rely on unique monotonically
increasing integer across branch <a class="reference internal" href="#matthewsrevnum" id="id7">[MatthewsRevNum]</a>.</li>
<li>Instruct downstream integrators to pick up commits from the GitHub
repository.</li>
<li>Review and prepare an update for the LLVM documentation.</li>
</ol>
<p>Until this point nothing has changed for developers, it will just
boil down to a lot of work for buildbot and other infrastructure
owners.</p>
<p>The migration will pause here until all dependencies have cleared, and all
problems have been solved.</p>
</div>
<div class="section" id="step-3-write-access-move">
<h3><a class="toc-backref" href="#id38">Step #3: Write Access Move</a><a class="headerlink" href="#step-3-write-access-move" title="Permalink to this headline">¶</a></h3>
<ol class="arabic simple" start="9">
<li>Collect developers’ GitHub account information, and add them to the project.</li>
<li>Switch the SVN repository to read-only and allow pushes to the GitHub repository.</li>
<li>Update the documentation.</li>
<li>Mirror Git to SVN.</li>
</ol>
</div>
<div class="section" id="step-4-post-move">
<h3><a class="toc-backref" href="#id39">Step #4 : Post Move</a><a class="headerlink" href="#step-4-post-move" title="Permalink to this headline">¶</a></h3>
<ol class="arabic simple" start="13">
<li>Archive the SVN repository.</li>
<li>Update links on the LLVM website pointing to viewvc/klaus/phab etc. to
point to GitHub instead.</li>
</ol>
</div>
</div>
<div class="section" id="one-or-multiple-repositories">
<h2><a class="toc-backref" href="#id40">One or Multiple Repositories?</a><a class="headerlink" href="#one-or-multiple-repositories" title="Permalink to this headline">¶</a></h2>
<p>There are two major variants for how to structure our Git repository: The
“multirepo” and the “monorepo”.</p>
<div class="section" id="multirepo-variant">
<h3><a class="toc-backref" href="#id41">Multirepo Variant</a><a class="headerlink" href="#multirepo-variant" title="Permalink to this headline">¶</a></h3>
<p>This variant recommends moving each LLVM sub-project to a separate Git
repository. This mimics the existing official read-only Git repositories
(e.g., <a class="reference external" href="http://llvm.org/git/compiler-rt.git">http://llvm.org/git/compiler-rt.git</a>), and creates new canonical
repositories for each sub-project.</p>
<p>This will allow the individual sub-projects to remain distinct: a
developer interested only in compiler-rt can checkout only this repository,
build it, and work in isolation of the other sub-projects.</p>
<p>A key need is to be able to check out multiple projects (i.e. lldb+clang+llvm or
clang+llvm+libcxx for example) at a specific revision.</p>
<p>A tuple of revisions (one entry per repository) accurately describes the state
across the sub-projects.
For example, a given version of clang would be
<em>&lt;LLVM-12345, clang-5432, libcxx-123, etc.&gt;</em>.</p>
<div class="section" id="umbrella-repository">
<h4><a class="toc-backref" href="#id42">Umbrella Repository</a><a class="headerlink" href="#umbrella-repository" title="Permalink to this headline">¶</a></h4>
<p>To make this more convenient, a separate <em>umbrella</em> repository will be
provided. This repository will be used for the sole purpose of understanding
the sequence in which commits were pushed to the different repositories and to
provide a single revision number.</p>
<p>This umbrella repository will be read-only and continuously updated
to record the above tuple. The proposed form to record this is to use Git
<a class="reference internal" href="#submodules" id="id8">[submodules]</a>, possibly along with a set of scripts to help check out a
specific revision of the LLVM distribution.</p>
<p>A regular LLVM developer does not need to interact with the umbrella repository
– the individual repositories can be checked out independently – but you would
need to use the umbrella repository to bisect multiple sub-projects at the same
time, or to check-out old revisions of LLVM with another sub-project at a
consistent state.</p>
<p>This umbrella repository will be updated automatically by a bot (running on
notice from a webhook on every push, and periodically) on a per commit basis: a
single commit in the umbrella repository would match a single commit in a
sub-project.</p>
</div>
<div class="section" id="living-downstream">
<h4><a class="toc-backref" href="#id43">Living Downstream</a><a class="headerlink" href="#living-downstream" title="Permalink to this headline">¶</a></h4>
<p>Downstream SVN users can use the read/write SVN bridges with the following
caveats:</p>
<blockquote>
<div><ul class="simple">
<li>Be prepared for a one-time change to the upstream revision numbers.</li>
<li>The upstream sub-project revision numbers will no longer be in sync.</li>
</ul>
</div></blockquote>
<p>Downstream Git users can continue without any major changes, with the minor
change of upstreaming using <cite>git push</cite> instead of <cite>git svn dcommit</cite>.</p>
<p>Git users also have the option of adopting an umbrella repository downstream.
The tooling for the upstream umbrella can easily be reused for downstream needs,
incorporating extra sub-projects and branching in parallel with sub-project
branches.</p>
</div>
<div class="section" id="multirepo-preview">
<h4><a class="toc-backref" href="#id44">Multirepo Preview</a><a class="headerlink" href="#multirepo-preview" title="Permalink to this headline">¶</a></h4>
<p>As a preview (disclaimer: this rough prototype, not polished and not
representative of the final solution), you can look at the following:</p>
<blockquote>
<div><ul class="simple">
<li>Repository: <a class="reference external" href="https://github.com/llvm-beanz/llvm-submodules">https://github.com/llvm-beanz/llvm-submodules</a></li>
<li>Update bot: <a class="reference external" href="http://beanz-bot.com:8180/jenkins/job/submodule-update/">http://beanz-bot.com:8180/jenkins/job/submodule-update/</a></li>
</ul>
</div></blockquote>
</div>
<div class="section" id="concerns">
<h4><a class="toc-backref" href="#id45">Concerns</a><a class="headerlink" href="#concerns" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><ul class="simple">
<li>Because GitHub does not allow server-side hooks, and because there is no
“push timestamp” in Git, the umbrella repository sequence isn’t totally
exact: commits from different repositories pushed around the same time can
appear in different orders. However, we don’t expect it to be the common case
or to cause serious issues in practice.</li>
<li>You can’t have a single cross-projects commit that would update both LLVM and
other sub-projects (something that can be achieved now). It would be possible
to establish a protocol whereby users add a special token to their commit
messages that causes the umbrella repo’s updater bot to group all of them
into a single revision.</li>
<li>Another option is to group commits that were pushed closely enough together
in the umbrella repository. This has the advantage of allowing cross-project
commits, and is less sensitive to mis-ordering commits. However, this has the
potential to group unrelated commits together, especially if the bot goes
down and needs to catch up.</li>
<li>This variant relies on heavier tooling. But the current prototype shows that
it is not out-of-reach.</li>
<li>Submodules don’t have a good reputation / are complicating the command line.
However, in the proposed setup, a regular developer will seldom interact with
submodules directly, and certainly never update them.</li>
<li>Refactoring across projects is not friendly: taking some functions from clang
to make it part of a utility in libSupport wouldn’t carry the history of the
code in the llvm repo, preventing recursively applying <cite>git blame</cite> for
instance. However, this is not very different than how most people are
Interacting with the repository today, by splitting such change in multiple
commits.</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="workflows">
<h4><a class="toc-backref" href="#id46">Workflows</a><a class="headerlink" href="#workflows" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><ul class="simple">
<li><a class="reference internal" href="#workflow-checkout-commit"><span class="std std-ref">Checkout/Clone a Single Project, without Commit Access</span></a>.</li>
<li><a class="reference internal" href="#workflow-multicheckout-nocommit"><span class="std std-ref">Checkout/Clone a Single Project, with Commit Access</span></a>.</li>
<li><a class="reference internal" href="#workflow-multicheckout-multicommit"><span class="std std-ref">Checkout/Clone Multiple Projects, with Commit Access</span></a>.</li>
<li><a class="reference internal" href="#workflow-cross-repo-commit"><span class="std std-ref">Commit an API Change in LLVM and Update the Sub-projects</span></a>.</li>
<li><a class="reference internal" href="#workflow-multi-branching"><span class="std std-ref">Branching/Stashing/Updating for Local Development or Experiments</span></a>.</li>
<li><a class="reference internal" href="#workflow-multi-bisecting"><span class="std std-ref">Bisecting</span></a>.</li>
</ul>
</div></blockquote>
</div>
</div>
<div class="section" id="monorepo-variant">
<h3><a class="toc-backref" href="#id47">Monorepo Variant</a><a class="headerlink" href="#monorepo-variant" title="Permalink to this headline">¶</a></h3>
<p>This variant recommends moving all LLVM sub-projects to a single Git repository,
similar to <a class="reference external" href="https://github.com/llvm-project/llvm-project">https://github.com/llvm-project/llvm-project</a>.
This would mimic an export of the current SVN repository, with each sub-project
having its own top-level directory.
Not all sub-projects are used for building toolchains. In practice, www/
and test-suite/ will probably stay out of the monorepo.</p>
<p>Putting all sub-projects in a single checkout makes cross-project refactoring
naturally simple:</p>
<blockquote>
<div><ul class="simple">
<li>New sub-projects can be trivially split out for better reuse and/or layering
(e.g., to allow libSupport and/or LIT to be used by runtimes without adding a
dependency on LLVM).</li>
<li>Changing an API in LLVM and upgrading the sub-projects will always be done in
a single commit, designing away a common source of temporary build breakage.</li>
<li>Moving code across sub-project (during refactoring for instance) in a single
commit enables accurate <cite>git blame</cite> when tracking code change history.</li>
<li>Tooling based on <cite>git grep</cite> works natively across sub-projects, allowing to
easier find refactoring opportunities across projects (for example reusing a
datastructure initially in LLDB by moving it into libSupport).</li>
<li>Having all the sources present encourages maintaining the other sub-projects
when changing API.</li>
</ul>
</div></blockquote>
<p>Finally, the monorepo maintains the property of the existing SVN repository that
the sub-projects move synchronously, and a single revision number (or commit
hash) identifies the state of the development across all projects.</p>
<div class="section" id="building-a-single-sub-project">
<span id="build-single-project"></span><h4><a class="toc-backref" href="#id48">Building a single sub-project</a><a class="headerlink" href="#building-a-single-sub-project" title="Permalink to this headline">¶</a></h4>
<p>Nobody will be forced to build unnecessary projects.  The exact structure
is TBD, but making it trivial to configure builds for a single sub-project
(or a subset of sub-projects) is a hard requirement.</p>
<p>As an example, it could look like the following:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">mkdir</span> <span class="n">build</span> <span class="o">&amp;&amp;</span> <span class="n">cd</span> <span class="n">build</span>
<span class="c1"># Configure only LLVM (default)</span>
<span class="n">cmake</span> <span class="n">path</span><span class="o">/</span><span class="n">to</span><span class="o">/</span><span class="n">monorepo</span>
<span class="c1"># Configure LLVM and lld</span>
<span class="n">cmake</span> <span class="n">path</span><span class="o">/</span><span class="n">to</span><span class="o">/</span><span class="n">monorepo</span> <span class="o">-</span><span class="n">DLLVM_ENABLE_PROJECTS</span><span class="o">=</span><span class="n">lld</span>
<span class="c1"># Configure LLVM and clang</span>
<span class="n">cmake</span> <span class="n">path</span><span class="o">/</span><span class="n">to</span><span class="o">/</span><span class="n">monorepo</span> <span class="o">-</span><span class="n">DLLVM_ENABLE_PROJECTS</span><span class="o">=</span><span class="n">clang</span>
</pre></div>
</div>
</div>
<div class="section" id="read-write-sub-project-mirrors">
<span id="git-svn-mirror"></span><h4><a class="toc-backref" href="#id49">Read/write sub-project mirrors</a><a class="headerlink" href="#read-write-sub-project-mirrors" title="Permalink to this headline">¶</a></h4>
<p>With the Monorepo, the existing single-subproject mirrors (e.g.
<a class="reference external" href="http://llvm.org/git/compiler-rt.git">http://llvm.org/git/compiler-rt.git</a>) with git-svn read-write access would
continue to be maintained: developers would continue to be able to use the
existing single-subproject git repositories as they do today, with <em>no changes
to workflow</em>. Everything (git fetch, git svn dcommit, etc.) could continue to
work identically to how it works today. The monorepo can be set-up such that the
SVN revision number matches the SVN revision in the GitHub SVN-bridge.</p>
</div>
<div class="section" id="id9">
<h4><a class="toc-backref" href="#id50">Living Downstream</a><a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h4>
<p>Downstream SVN users can use the read/write SVN bridge. The SVN revision
number can be preserved in the monorepo, minimizing the impact.</p>
<p>Downstream Git users can continue without any major changes, by using the
git-svn mirrors on top of the SVN bridge.</p>
<p>Git users can also work upstream with monorepo even if their downstream
fork has split repositories.  They can apply patches in the appropriate
subdirectories of the monorepo using, e.g., <cite>git am –directory=…</cite>, or
plain <cite>diff</cite> and <cite>patch</cite>.</p>
<p>Alternatively, Git users can migrate their own fork to the monorepo.  As a
demonstration, we’ve migrated the “CHERI” fork to the monorepo in two ways:</p>
<blockquote>
<div><ul class="simple">
<li>Using a script that rewrites history (including merges) so that it looks
like the fork always lived in the monorepo <a class="reference internal" href="#lebarcheri" id="id10">[LebarCHERI]</a>.  The upside of
this is when you check out an old revision, you get a copy of all llvm
sub-projects at a consistent revision.  (For instance, if it’s a clang
fork, when you check out an old revision you’ll get a consistent version
of llvm proper.)  The downside is that this changes the fork’s commit
hashes.</li>
<li>Merging the fork into the monorepo <a class="reference internal" href="#aminicheri" id="id11">[AminiCHERI]</a>.  This preserves the
fork’s commit hashes, but when you check out an old commit you only get
the one sub-project.</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="monorepo-preview">
<h4><a class="toc-backref" href="#id51">Monorepo Preview</a><a class="headerlink" href="#monorepo-preview" title="Permalink to this headline">¶</a></h4>
<p>As a preview (disclaimer: this rough prototype, not polished and not
representative of the final solution), you can look at the following:</p>
<blockquote>
<div><ul class="simple">
<li>Full Repository: <a class="reference external" href="https://github.com/joker-eph/llvm-project">https://github.com/joker-eph/llvm-project</a></li>
<li>Single sub-project view with <em>SVN write access</em> to the full repo:
<a class="reference external" href="https://github.com/joker-eph/compiler-rt">https://github.com/joker-eph/compiler-rt</a></li>
</ul>
</div></blockquote>
</div>
<div class="section" id="id12">
<h4><a class="toc-backref" href="#id52">Concerns</a><a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><ul class="simple">
<li>Using the monolithic repository may add overhead for those contributing to a
standalone sub-project, particularly on runtimes like libcxx and compiler-rt
that don’t rely on LLVM; currently, a fresh clone of libcxx is only 15MB (vs.
1GB for the monorepo), and the commit rate of LLVM may cause more frequent
<cite>git push</cite> collisions when upstreaming. Affected contributors can continue to
use the SVN bridge or the single-subproject Git mirrors with git-svn for
read-write.</li>
<li>Using the monolithic repository may add overhead for those <em>integrating</em> a
standalone sub-project, even if they aren’t contributing to it, due to the
same disk space concern as the point above. The availability of the
sub-project Git mirror addresses this, even without SVN access.</li>
<li>Preservation of the existing read/write SVN-based workflows relies on the
GitHub SVN bridge, which is an extra dependency.  Maintaining this locks us
into GitHub and could restrict future workflow changes.</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="id13">
<h4><a class="toc-backref" href="#id53">Workflows</a><a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><ul class="simple">
<li><a class="reference internal" href="#workflow-checkout-commit"><span class="std std-ref">Checkout/Clone a Single Project, without Commit Access</span></a>.</li>
<li><a class="reference internal" href="#workflow-monocheckout-nocommit"><span class="std std-ref">Checkout/Clone a Single Project, with Commit Access</span></a>.</li>
<li><a class="reference internal" href="#workflow-monocheckout-multicommit"><span class="std std-ref">Checkout/Clone Multiple Projects, with Commit Access</span></a>.</li>
<li><a class="reference internal" href="#workflow-cross-repo-commit"><span class="std std-ref">Commit an API Change in LLVM and Update the Sub-projects</span></a>.</li>
<li><a class="reference internal" href="#workflow-mono-branching"><span class="std std-ref">Branching/Stashing/Updating for Local Development or Experiments</span></a>.</li>
<li><a class="reference internal" href="#workflow-mono-bisecting"><span class="std std-ref">Bisecting</span></a>.</li>
</ul>
</div></blockquote>
</div>
</div>
<div class="section" id="multi-mono-hybrid-variant">
<h3><a class="toc-backref" href="#id54">Multi/Mono Hybrid Variant</a><a class="headerlink" href="#multi-mono-hybrid-variant" title="Permalink to this headline">¶</a></h3>
<p>This variant recommends moving only the LLVM sub-projects that are <em>rev-locked</em>
to LLVM into a monorepo (clang, lld, lldb, …), following the multirepo
proposal for the rest.  While neither variant recommends combining sub-projects
like www/ and test-suite/ (which are completely standalone), this goes further
and keeps sub-projects like libcxx and compiler-rt in their own distinct
repositories.</p>
<div class="section" id="id14">
<h4><a class="toc-backref" href="#id55">Concerns</a><a class="headerlink" href="#id14" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><ul class="simple">
<li>This has most disadvantages of multirepo and monorepo, without bringing many
of the advantages.</li>
<li>Downstream have to upgrade to the monorepo structure, but only partially. So
they will keep the infrastructure to integrate the other separate
sub-projects.</li>
<li>All projects that use LIT for testing are effectively rev-locked to LLVM.
Furthermore, some runtimes (like compiler-rt) are rev-locked with Clang.
It’s not clear where to draw the lines.</li>
</ul>
</div></blockquote>
</div>
</div>
</div>
<div class="section" id="workflow-before-after">
<h2><a class="toc-backref" href="#id56">Workflow Before/After</a><a class="headerlink" href="#workflow-before-after" title="Permalink to this headline">¶</a></h2>
<p>This section goes through a few examples of workflows, intended to illustrate
how end-users or developers would interact with the repository for
various use-cases.</p>
<div class="section" id="checkout-clone-a-single-project-without-commit-access">
<span id="workflow-checkout-commit"></span><h3><a class="toc-backref" href="#id57">Checkout/Clone a Single Project, without Commit Access</a><a class="headerlink" href="#checkout-clone-a-single-project-without-commit-access" title="Permalink to this headline">¶</a></h3>
<p>Except the URL, nothing changes. The possibilities today are:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">svn</span> <span class="n">co</span> <span class="n">http</span><span class="p">:</span><span class="o">//</span><span class="n">llvm</span><span class="o">.</span><span class="n">org</span><span class="o">/</span><span class="n">svn</span><span class="o">/</span><span class="n">llvm</span><span class="o">-</span><span class="n">project</span><span class="o">/</span><span class="n">llvm</span><span class="o">/</span><span class="n">trunk</span> <span class="n">llvm</span>
<span class="c1"># or with Git</span>
<span class="n">git</span> <span class="n">clone</span> <span class="n">http</span><span class="p">:</span><span class="o">//</span><span class="n">llvm</span><span class="o">.</span><span class="n">org</span><span class="o">/</span><span class="n">git</span><span class="o">/</span><span class="n">llvm</span><span class="o">.</span><span class="n">git</span>
</pre></div>
</div>
<p>After the move to GitHub, you would do either:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">git</span> <span class="n">clone</span> <span class="n">https</span><span class="p">:</span><span class="o">//</span><span class="n">github</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">llvm</span><span class="o">-</span><span class="n">project</span><span class="o">/</span><span class="n">llvm</span><span class="o">.</span><span class="n">git</span>
<span class="c1"># or using the GitHub svn native bridge</span>
<span class="n">svn</span> <span class="n">co</span> <span class="n">https</span><span class="p">:</span><span class="o">//</span><span class="n">github</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">llvm</span><span class="o">-</span><span class="n">project</span><span class="o">/</span><span class="n">llvm</span><span class="o">/</span><span class="n">trunk</span>
</pre></div>
</div>
<p>The above works for both the monorepo and the multirepo, as we’ll maintain the
existing read-only views of the individual sub-projects.</p>
</div>
<div class="section" id="checkout-clone-a-single-project-with-commit-access">
<h3><a class="toc-backref" href="#id58">Checkout/Clone a Single Project, with Commit Access</a><a class="headerlink" href="#checkout-clone-a-single-project-with-commit-access" title="Permalink to this headline">¶</a></h3>
<div class="section" id="currently">
<h4><a class="toc-backref" href="#id59">Currently</a><a class="headerlink" href="#currently" title="Permalink to this headline">¶</a></h4>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1"># direct SVN checkout</span>
<span class="n">svn</span> <span class="n">co</span> <span class="n">https</span><span class="p">:</span><span class="o">//</span><span class="n">user</span><span class="nd">@llvm</span><span class="o">.</span><span class="n">org</span><span class="o">/</span><span class="n">svn</span><span class="o">/</span><span class="n">llvm</span><span class="o">-</span><span class="n">project</span><span class="o">/</span><span class="n">llvm</span><span class="o">/</span><span class="n">trunk</span> <span class="n">llvm</span>
<span class="c1"># or using the read-only Git view, with git-svn</span>
<span class="n">git</span> <span class="n">clone</span> <span class="n">http</span><span class="p">:</span><span class="o">//</span><span class="n">llvm</span><span class="o">.</span><span class="n">org</span><span class="o">/</span><span class="n">git</span><span class="o">/</span><span class="n">llvm</span><span class="o">.</span><span class="n">git</span>
<span class="n">cd</span> <span class="n">llvm</span>
<span class="n">git</span> <span class="n">svn</span> <span class="n">init</span> <span class="n">https</span><span class="p">:</span><span class="o">//</span><span class="n">llvm</span><span class="o">.</span><span class="n">org</span><span class="o">/</span><span class="n">svn</span><span class="o">/</span><span class="n">llvm</span><span class="o">-</span><span class="n">project</span><span class="o">/</span><span class="n">llvm</span><span class="o">/</span><span class="n">trunk</span> <span class="o">--</span><span class="n">username</span><span class="o">=&lt;</span><span class="n">username</span><span class="o">&gt;</span>
<span class="n">git</span> <span class="n">config</span> <span class="n">svn</span><span class="o">-</span><span class="n">remote</span><span class="o">.</span><span class="n">svn</span><span class="o">.</span><span class="n">fetch</span> <span class="p">:</span><span class="n">refs</span><span class="o">/</span><span class="n">remotes</span><span class="o">/</span><span class="n">origin</span><span class="o">/</span><span class="n">master</span>
<span class="n">git</span> <span class="n">svn</span> <span class="n">rebase</span> <span class="o">-</span><span class="n">l</span>  <span class="c1"># -l avoids fetching ahead of the git mirror.</span>
</pre></div>
</div>
<p>Commits are performed using <cite>svn commit</cite> or with the sequence <cite>git commit</cite> and
<cite>git svn dcommit</cite>.</p>
</div>
<div class="section" id="workflow-multicheckout-nocommit">
<span id="id15"></span><h4><a class="toc-backref" href="#id60">Multirepo Variant</a><a class="headerlink" href="#workflow-multicheckout-nocommit" title="Permalink to this headline">¶</a></h4>
<p>With the multirepo variant, nothing changes but the URL, and commits can be
performed using <cite>svn commit</cite> or <cite>git commit</cite> and <cite>git push</cite>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">git</span> <span class="n">clone</span> <span class="n">https</span><span class="p">:</span><span class="o">//</span><span class="n">github</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">llvm</span><span class="o">/</span><span class="n">llvm</span><span class="o">.</span><span class="n">git</span> <span class="n">llvm</span>
<span class="c1"># or using the GitHub svn native bridge</span>
<span class="n">svn</span> <span class="n">co</span> <span class="n">https</span><span class="p">:</span><span class="o">//</span><span class="n">github</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">llvm</span><span class="o">/</span><span class="n">llvm</span><span class="o">/</span><span class="n">trunk</span><span class="o">/</span> <span class="n">llvm</span>
</pre></div>
</div>
</div>
<div class="section" id="workflow-monocheckout-nocommit">
<span id="id16"></span><h4><a class="toc-backref" href="#id61">Monorepo Variant</a><a class="headerlink" href="#workflow-monocheckout-nocommit" title="Permalink to this headline">¶</a></h4>
<p>With the monorepo variant, there are a few options, depending on your
constraints. First, you could just clone the full repository:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">git</span> <span class="n">clone</span> <span class="n">https</span><span class="p">:</span><span class="o">//</span><span class="n">github</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">llvm</span><span class="o">/</span><span class="n">llvm</span><span class="o">-</span><span class="n">projects</span><span class="o">.</span><span class="n">git</span> <span class="n">llvm</span>
<span class="c1"># or using the GitHub svn native bridge</span>
<span class="n">svn</span> <span class="n">co</span> <span class="n">https</span><span class="p">:</span><span class="o">//</span><span class="n">github</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">llvm</span><span class="o">/</span><span class="n">llvm</span><span class="o">-</span><span class="n">projects</span><span class="o">/</span><span class="n">trunk</span><span class="o">/</span> <span class="n">llvm</span>
</pre></div>
</div>
<p>At this point you have every sub-project (llvm, clang, lld, lldb, …), which
<a class="reference internal" href="#build-single-project"><span class="std std-ref">doesn’t imply you have to build all of them</span></a>. You
can still build only compiler-rt for instance. In this way it’s not different
from someone who would check out all the projects with SVN today.</p>
<p>You can commit as normal using <cite>git commit</cite> and <cite>git push</cite> or <cite>svn commit</cite>, and
read the history for a single project (<cite>git log libcxx</cite> for example).</p>
<p>Secondly, there are a few options to avoid checking out all the sources.</p>
<p><strong>Using the GitHub SVN bridge</strong></p>
<p>The GitHub SVN native bridge allows to checkout a subdirectory directly:</p>
<blockquote>
<div>svn co <a class="reference external" href="https://github.com/llvm/llvm-projects/trunk/compiler-rt">https://github.com/llvm/llvm-projects/trunk/compiler-rt</a> compiler-rt  —username=…</div></blockquote>
<p>This checks out only compiler-rt and provides commit access using “svn commit”,
in the same way as it would do today.</p>
<p><strong>Using a Subproject Git Nirror</strong></p>
<p>You can use <em>git-svn</em> and one of the sub-project mirrors:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span># Clone from the single read-only Git repo
git clone http://llvm.org/git/llvm.git
cd llvm
# Configure the SVN remote and initialize the svn metadata
$ git svn init https://github.com/joker-eph/llvm-project/trunk/llvm —username=...
git config svn-remote.svn.fetch :refs/remotes/origin/master
git svn rebase -l
</pre></div>
</div>
<p>In this case the repository contains only a single sub-project, and commits can
be made using <cite>git svn dcommit</cite>, again exactly as we do today.</p>
<p><strong>Using a Sparse Checkouts</strong></p>
<p>You can hide the other directories using a Git sparse checkout:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">git</span> <span class="n">config</span> <span class="n">core</span><span class="o">.</span><span class="n">sparseCheckout</span> <span class="n">true</span>
<span class="n">echo</span> <span class="o">/</span><span class="n">compiler</span><span class="o">-</span><span class="n">rt</span> <span class="o">&gt;</span> <span class="o">.</span><span class="n">git</span><span class="o">/</span><span class="n">info</span><span class="o">/</span><span class="n">sparse</span><span class="o">-</span><span class="n">checkout</span>
<span class="n">git</span> <span class="n">read</span><span class="o">-</span><span class="n">tree</span> <span class="o">-</span><span class="n">mu</span> <span class="n">HEAD</span>
</pre></div>
</div>
<p>The data for all sub-projects is still in your <cite>.git</cite> directory, but in your
checkout, you only see <cite>compiler-rt</cite>.
Before you push, you’ll need to fetch and rebase (<cite>git pull –rebase</cite>) as
usual.</p>
<p>Note that when you fetch you’ll likely pull in changes to sub-projects you don’t
care about. If you are using spasre checkout, the files from other projects
won’t appear on your disk. The only effect is that your commit hash changes.</p>
<p>You can check whether the changes in the last fetch are relevant to your commit
by running:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">git</span> <span class="n">log</span> <span class="n">origin</span><span class="o">/</span><span class="n">master</span><span class="o">@</span><span class="p">{</span><span class="mi">1</span><span class="p">}</span><span class="o">..</span><span class="n">origin</span><span class="o">/</span><span class="n">master</span> <span class="o">--</span> <span class="n">libcxx</span>
</pre></div>
</div>
<p>This command can be hidden in a script so that <cite>git llvmpush</cite> would perform all
these steps, fail only if such a dependent change exists, and show immediately
the change that prevented the push. An immediate repeat of the command would
(almost) certainly result in a successful push.
Note that today with SVN or git-svn, this step is not possible since the
“rebase” implicitly happens while committing (unless a conflict occurs).</p>
</div>
</div>
<div class="section" id="checkout-clone-multiple-projects-with-commit-access">
<h3><a class="toc-backref" href="#id62">Checkout/Clone Multiple Projects, with Commit Access</a><a class="headerlink" href="#checkout-clone-multiple-projects-with-commit-access" title="Permalink to this headline">¶</a></h3>
<p>Let’s look how to assemble llvm+clang+libcxx at a given revision.</p>
<div class="section" id="id17">
<h4><a class="toc-backref" href="#id63">Currently</a><a class="headerlink" href="#id17" title="Permalink to this headline">¶</a></h4>
<div class="highlight-default"><div class="highlight"><pre><span></span>svn co http://llvm.org/svn/llvm-project/llvm/trunk llvm -r $REVISION
cd llvm/tools
svn co http://llvm.org/svn/llvm-project/clang/trunk clang -r $REVISION
cd ../projects
svn co http://llvm.org/svn/llvm-project/libcxx/trunk libcxx -r $REVISION
</pre></div>
</div>
<p>Or using git-svn:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>git clone http://llvm.org/git/llvm.git
cd llvm/
git svn init https://llvm.org/svn/llvm-project/llvm/trunk --username=&lt;username&gt;
git config svn-remote.svn.fetch :refs/remotes/origin/master
git svn rebase -l
git checkout `git svn find-rev -B r258109`
cd tools
git clone http://llvm.org/git/clang.git
cd clang/
git svn init https://llvm.org/svn/llvm-project/clang/trunk --username=&lt;username&gt;
git config svn-remote.svn.fetch :refs/remotes/origin/master
git svn rebase -l
git checkout `git svn find-rev -B r258109`
cd ../../projects/
git clone http://llvm.org/git/libcxx.git
cd libcxx
git svn init https://llvm.org/svn/llvm-project/libcxx/trunk --username=&lt;username&gt;
git config svn-remote.svn.fetch :refs/remotes/origin/master
git svn rebase -l
git checkout `git svn find-rev -B r258109`
</pre></div>
</div>
<p>Note that the list would be longer with more sub-projects.</p>
</div>
<div class="section" id="workflow-multicheckout-multicommit">
<span id="id18"></span><h4><a class="toc-backref" href="#id64">Multirepo Variant</a><a class="headerlink" href="#workflow-multicheckout-multicommit" title="Permalink to this headline">¶</a></h4>
<p>With the multirepo variant, the umbrella repository will be used. This is
where the mapping from a single revision number to the individual repositories
revisions is stored.:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>git clone https://github.com/llvm-beanz/llvm-submodules
cd llvm-submodules
git checkout $REVISION
git submodule init
git submodule update clang llvm libcxx
# the list of sub-project is optional, `git submodule update` would get them all.
</pre></div>
</div>
<p>At this point the clang, llvm, and libcxx individual repositories are cloned
and stored alongside each other. There are CMake flags to describe the directory
structure; alternatively, you can just symlink <cite>clang</cite> to <cite>llvm/tools/clang</cite>,
etc.</p>
<p>Another option is to checkout repositories based on the commit timestamp:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>git checkout `git rev-list -n 1 --before=&quot;2009-07-27 13:37&quot; master`
</pre></div>
</div>
</div>
<div class="section" id="workflow-monocheckout-multicommit">
<span id="id19"></span><h4><a class="toc-backref" href="#id65">Monorepo Variant</a><a class="headerlink" href="#workflow-monocheckout-multicommit" title="Permalink to this headline">¶</a></h4>
<p>The repository contains natively the source for every sub-projects at the right
revision, which makes this straightforward:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>git clone https://github.com/llvm/llvm-projects.git llvm-projects
cd llvm-projects
git checkout $REVISION
</pre></div>
</div>
<p>As before, at this point clang, llvm, and libcxx are stored in directories
alongside each other.</p>
</div>
</div>
<div class="section" id="commit-an-api-change-in-llvm-and-update-the-sub-projects">
<span id="workflow-cross-repo-commit"></span><h3><a class="toc-backref" href="#id66">Commit an API Change in LLVM and Update the Sub-projects</a><a class="headerlink" href="#commit-an-api-change-in-llvm-and-update-the-sub-projects" title="Permalink to this headline">¶</a></h3>
<p>Today this is possible, even though not common (at least not documented) for
subversion users and for git-svn users. For example, few Git users try to update
LLD or Clang in the same commit as they change an LLVM API.</p>
<p>The multirepo variant does not address this: one would have to commit and push
separately in every individual repository. It would be possible to establish a
protocol whereby users add a special token to their commit messages that causes
the umbrella repo’s updater bot to group all of them into a single revision.</p>
<p>The monorepo variant handles this natively.</p>
</div>
<div class="section" id="branching-stashing-updating-for-local-development-or-experiments">
<h3><a class="toc-backref" href="#id67">Branching/Stashing/Updating for Local Development or Experiments</a><a class="headerlink" href="#branching-stashing-updating-for-local-development-or-experiments" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id20">
<h4><a class="toc-backref" href="#id68">Currently</a><a class="headerlink" href="#id20" title="Permalink to this headline">¶</a></h4>
<p>SVN does not allow this use case, but developers that are currently using
git-svn can do it. Let’s look in practice what it means when dealing with
multiple sub-projects.</p>
<p>To update the repository to tip of trunk:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">git</span> <span class="n">pull</span>
<span class="n">cd</span> <span class="n">tools</span><span class="o">/</span><span class="n">clang</span>
<span class="n">git</span> <span class="n">pull</span>
<span class="n">cd</span> <span class="o">../../</span><span class="n">projects</span><span class="o">/</span><span class="n">libcxx</span>
<span class="n">git</span> <span class="n">pull</span>
</pre></div>
</div>
<p>To create a new branch:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">git</span> <span class="n">checkout</span> <span class="o">-</span><span class="n">b</span> <span class="n">MyBranch</span>
<span class="n">cd</span> <span class="n">tools</span><span class="o">/</span><span class="n">clang</span>
<span class="n">git</span> <span class="n">checkout</span> <span class="o">-</span><span class="n">b</span> <span class="n">MyBranch</span>
<span class="n">cd</span> <span class="o">../../</span><span class="n">projects</span><span class="o">/</span><span class="n">libcxx</span>
<span class="n">git</span> <span class="n">checkout</span> <span class="o">-</span><span class="n">b</span> <span class="n">MyBranch</span>
</pre></div>
</div>
<p>To switch branches:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">git</span> <span class="n">checkout</span> <span class="n">AnotherBranch</span>
<span class="n">cd</span> <span class="n">tools</span><span class="o">/</span><span class="n">clang</span>
<span class="n">git</span> <span class="n">checkout</span> <span class="n">AnotherBranch</span>
<span class="n">cd</span> <span class="o">../../</span><span class="n">projects</span><span class="o">/</span><span class="n">libcxx</span>
<span class="n">git</span> <span class="n">checkout</span> <span class="n">AnotherBranch</span>
</pre></div>
</div>
</div>
<div class="section" id="workflow-multi-branching">
<span id="id21"></span><h4><a class="toc-backref" href="#id69">Multirepo Variant</a><a class="headerlink" href="#workflow-multi-branching" title="Permalink to this headline">¶</a></h4>
<p>The multirepo works the same as the current Git workflow: every command needs
to be applied to each of the individual repositories.
However, the umbrella repository makes this easy using <cite>git submodule foreach</cite>
to replicate a command on all the individual repositories (or submodules
in this case):</p>
<p>To create a new branch:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">git</span> <span class="n">submodule</span> <span class="n">foreach</span> <span class="n">git</span> <span class="n">checkout</span> <span class="o">-</span><span class="n">b</span> <span class="n">MyBranch</span>
</pre></div>
</div>
<p>To switch branches:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">git</span> <span class="n">submodule</span> <span class="n">foreach</span> <span class="n">git</span> <span class="n">checkout</span> <span class="n">AnotherBranch</span>
</pre></div>
</div>
</div>
<div class="section" id="workflow-mono-branching">
<span id="id22"></span><h4><a class="toc-backref" href="#id70">Monorepo Variant</a><a class="headerlink" href="#workflow-mono-branching" title="Permalink to this headline">¶</a></h4>
<p>Regular Git commands are sufficient, because everything is in a single
repository:</p>
<p>To update the repository to tip of trunk:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">git</span> <span class="n">pull</span>
</pre></div>
</div>
<p>To create a new branch:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">git</span> <span class="n">checkout</span> <span class="o">-</span><span class="n">b</span> <span class="n">MyBranch</span>
</pre></div>
</div>
<p>To switch branches:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">git</span> <span class="n">checkout</span> <span class="n">AnotherBranch</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="bisecting">
<h3><a class="toc-backref" href="#id71">Bisecting</a><a class="headerlink" href="#bisecting" title="Permalink to this headline">¶</a></h3>
<p>Assuming a developer is looking for a bug in clang (or lld, or lldb, …).</p>
<div class="section" id="id23">
<h4><a class="toc-backref" href="#id72">Currently</a><a class="headerlink" href="#id23" title="Permalink to this headline">¶</a></h4>
<p>SVN does not have builtin bisection support, but the single revision across
sub-projects makes it possible to script around.</p>
<p>Using the existing Git read-only view of the repositories, it is possible to use
the native Git bisection script over the llvm repository, and use some scripting
to synchronize the clang repository to match the llvm revision.</p>
</div>
<div class="section" id="workflow-multi-bisecting">
<span id="id24"></span><h4><a class="toc-backref" href="#id73">Multirepo Variant</a><a class="headerlink" href="#workflow-multi-bisecting" title="Permalink to this headline">¶</a></h4>
<p>With the multi-repositories variant, the cross-repository synchronization is
achieved using the umbrella repository. This repository contains only
submodules for the other sub-projects. The native Git bisection can be used on
the umbrella repository directly. A subtlety is that the bisect script itself
needs to make sure the submodules are updated accordingly.</p>
<p>For example, to find which commit introduces a regression where clang-3.9
crashes but not clang-3.8 passes, one should be able to simply do:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">git</span> <span class="n">bisect</span> <span class="n">start</span> <span class="n">release_39</span> <span class="n">release_38</span>
<span class="n">git</span> <span class="n">bisect</span> <span class="n">run</span> <span class="o">./</span><span class="n">bisect_script</span><span class="o">.</span><span class="n">sh</span>
</pre></div>
</div>
<p>With the <cite>bisect_script.sh</cite> script being:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>#!/bin/sh
cd $UMBRELLA_DIRECTORY
git submodule update llvm clang libcxx #....
cd $BUILD_DIR

ninja clang || exit 125   # an exit code of 125 asks &quot;git bisect&quot;
                          # to &quot;skip&quot; the current commit

./bin/clang some_crash_test.cpp
</pre></div>
</div>
<p>When the <cite>git bisect run</cite> command returns, the umbrella repository is set to
the state where the regression is introduced. The commit diff in the umbrella
indicate which submodule was updated, and the last commit in this sub-projects
is the one that the bisect found.</p>
</div>
<div class="section" id="workflow-mono-bisecting">
<span id="id25"></span><h4><a class="toc-backref" href="#id74">Monorepo Variant</a><a class="headerlink" href="#workflow-mono-bisecting" title="Permalink to this headline">¶</a></h4>
<p>Bisecting on the monorepo is straightforward, and very similar to the above,
except that the bisection script does not need to include the
<cite>git submodule update</cite> step.</p>
<p>The same example, finding which commit introduces a regression where clang-3.9
crashes but not clang-3.8 passes, will look like:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">git</span> <span class="n">bisect</span> <span class="n">start</span> <span class="n">release_39</span> <span class="n">release_38</span>
<span class="n">git</span> <span class="n">bisect</span> <span class="n">run</span> <span class="o">./</span><span class="n">bisect_script</span><span class="o">.</span><span class="n">sh</span>
</pre></div>
</div>
<p>With the <cite>bisect_script.sh</cite> script being:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>#!/bin/sh
cd $BUILD_DIR

ninja clang || exit 125   # an exit code of 125 asks &quot;git bisect&quot;
                          # to &quot;skip&quot; the current commit

./bin/clang some_crash_test.cpp
</pre></div>
</div>
<p>Also, since the monorepo handles commits update across multiple projects, you’re
less like to encounter a build failure where a commit change an API in LLVM and
another later one “fixes” the build in clang.</p>
</div>
</div>
</div>
<div class="section" id="references">
<h2><a class="toc-backref" href="#id75">References</a><a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h2>
<table class="docutils citation" frame="void" id="lattnerrevnum" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[LattnerRevNum]</a></td><td>Chris Lattner, <a class="reference external" href="http://lists.llvm.org/pipermail/llvm-dev/2011-July/041739.html">http://lists.llvm.org/pipermail/llvm-dev/2011-July/041739.html</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="trickrevnum" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[TrickRevNum]</a></td><td>Andrew Trick, <a class="reference external" href="http://lists.llvm.org/pipermail/llvm-dev/2011-July/041721.html">http://lists.llvm.org/pipermail/llvm-dev/2011-July/041721.html</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="jsonnrevnum" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[JSonnRevNum]</a></td><td>Joerg Sonnenberg, <a class="reference external" href="http://lists.llvm.org/pipermail/llvm-dev/2011-July/041688.html">http://lists.llvm.org/pipermail/llvm-dev/2011-July/041688.html</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="torvaldrevnum" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[TorvaldRevNum]</a></td><td>Linus Torvald, <a class="reference external" href="http://git.661346.n2.nabble.com/Git-commit-generation-numbers-td6584414.html">http://git.661346.n2.nabble.com/Git-commit-generation-numbers-td6584414.html</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="matthewsrevnum" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[MatthewsRevNum]</td><td><em>(<a class="fn-backref" href="#id5">1</a>, <a class="fn-backref" href="#id7">2</a>)</em> Chris Matthews, <a class="reference external" href="http://lists.llvm.org/pipermail/cfe-dev/2016-July/049886.html">http://lists.llvm.org/pipermail/cfe-dev/2016-July/049886.html</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="submodules" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id8">[submodules]</a></td><td>Git submodules, <a class="reference external" href="https://git-scm.com/book/en/v2/Git-Tools-Submodules">https://git-scm.com/book/en/v2/Git-Tools-Submodules</a>)</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="statuschecks" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[statuschecks]</a></td><td>GitHub status-checks, <a class="reference external" href="https://help.github.com/articles/about-required-status-checks/">https://help.github.com/articles/about-required-status-checks/</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="lebarcheri" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id10">[LebarCHERI]</a></td><td>Port <em>CHERI</em> to a single repository rewriting history, <a class="reference external" href="http://lists.llvm.org/pipermail/llvm-dev/2016-July/102787.html">http://lists.llvm.org/pipermail/llvm-dev/2016-July/102787.html</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="aminicheri" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id11">[AminiCHERI]</a></td><td>Port <em>CHERI</em> to a single repository preserving history, <a class="reference external" href="http://lists.llvm.org/pipermail/llvm-dev/2016-July/102804.html">http://lists.llvm.org/pipermail/llvm-dev/2016-July/102804.html</a></td></tr>
</tbody>
</table>
</div>
</div>


          </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../ReleaseProcess.html" title="How To Validate a New Release"
             >previous</a> |</li>
  <li><a href="http://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="../index.html">Documentation</a>&raquo;</li>
 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2003-2019, LLVM Project.
      Last updated on Wed Feb 13 10:08:12 2019 -0800.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.1.
    </div>
  </body>
</html>