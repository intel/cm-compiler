

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Vectorization Plan &#8212; LLVM 6 documentation</title>
    
    <link rel="stylesheet" href="../_static/llvm-theme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '6',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Writing an LLVM Backend" href="../WritingAnLLVMBackend.html" />
    <link rel="prev" title="Auto-Vectorization in LLVM" href="../Vectorizers.html" />
<style type="text/css">
  table.right { float: right; margin-left: 20px; }
  table.right td { border: 1px solid #ccc; }
</style>

  </head>
  <body>
<div class="logo">
  <a href="../index.html">
    <img src="../_static/logo.png"
         alt="LLVM Logo" width="250" height="88"/></a>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../WritingAnLLVMBackend.html" title="Writing an LLVM Backend"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="../Vectorizers.html" title="Auto-Vectorization in LLVM"
             accesskey="P">previous</a> |</li>
  <li><a href="http://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="../index.html">Documentation</a>&raquo;</li>

          <li class="nav-item nav-item-1"><a href="../Vectorizers.html" accesskey="U">Auto-Vectorization in LLVM</a> &#187;</li> 
      </ul>
    </div>


    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <div class="section" id="vectorization-plan">
<h1>Vectorization Plan<a class="headerlink" href="#vectorization-plan" title="Permalink to this headline">¶</a></h1>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id20">Abstract</a></li>
<li><a class="reference internal" href="#high-level-design" id="id21">High-level Design</a><ul>
<li><a class="reference internal" href="#vectorization-workflow" id="id22">Vectorization Workflow</a></li>
<li><a class="reference internal" href="#design-guidelines" id="id23">Design Guidelines</a></li>
</ul>
</li>
<li><a class="reference internal" href="#definitions" id="id24">Definitions</a></li>
<li><a class="reference internal" href="#the-planning-process-and-vplan-roadmap" id="id25">The Planning Process and VPlan Roadmap</a><ul>
<li><a class="reference internal" href="#related-llvm-components" id="id26">Related LLVM components</a></li>
<li><a class="reference internal" href="#references" id="id27">References</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="abstract">
<h2><a class="toc-backref" href="#id20">Abstract</a><a class="headerlink" href="#abstract" title="Permalink to this headline">¶</a></h2>
<p>The vectorization transformation can be rather complicated, involving several
potential alternatives, especially for outer-loops <a class="footnote-reference" href="#id11" id="id1">[1]</a> but also possibly for
innermost loops. These alternatives may have significant performance impact,
both positive and negative. A cost model is therefore employed to identify the
best alternative, including the alternative of avoiding any transformation
altogether.</p>
<p>The Vectorization Plan is an explicit model for describing vectorization
candidates. It serves for both optimizing candidates including estimating their
cost reliably, and for performing their final translation into IR. This
facilitates dealing with multiple vectorization candidates.</p>
</div>
<div class="section" id="high-level-design">
<h2><a class="toc-backref" href="#id21">High-level Design</a><a class="headerlink" href="#high-level-design" title="Permalink to this headline">¶</a></h2>
<div class="section" id="vectorization-workflow">
<h3><a class="toc-backref" href="#id22">Vectorization Workflow</a><a class="headerlink" href="#vectorization-workflow" title="Permalink to this headline">¶</a></h3>
<p>VPlan-based vectorization involves three major steps, taking a “scenario-based
approach” to vectorization planning:</p>
<ol class="arabic simple">
<li>Legal Step: check if a loop can be legally vectorized; encode constraints and
artifacts if so.</li>
<li>Plan Step:<ol class="loweralpha">
<li>Build initial VPlans following the constraints and decisions taken by
Legal Step 1, and compute their cost.</li>
<li>Apply optimizations to the VPlans, possibly forking additional VPlans.
Prune sub-optimal VPlans having relatively high cost.</li>
</ol>
</li>
<li>Execute Step: materialize the best VPlan. Note that this is the only step
that modifies the IR.</li>
</ol>
</div>
<div class="section" id="design-guidelines">
<h3><a class="toc-backref" href="#id23">Design Guidelines</a><a class="headerlink" href="#design-guidelines" title="Permalink to this headline">¶</a></h3>
<p>In what follows, the term “input IR” refers to code that is fed into the
vectorizer whereas the term “output IR” refers to code that is generated by the
vectorizer. The output IR contains code that has been vectorized or “widened”
according to a loop Vectorization Factor (VF), and/or loop unroll-and-jammed
according to an Unroll Factor (UF).
The design of VPlan follows several high-level guidelines:</p>
<ol class="arabic simple">
<li>Analysis-like: building and manipulating VPlans must not modify the input IR.
In particular, if the best option is not to vectorize at all, the
vectorization process terminates before reaching Step 3, and compilation
should proceed as if VPlans had not been built.</li>
<li>Align Cost &amp; Execute: each VPlan must support both estimating the cost and
generating the output IR code, such that the cost estimation evaluates the
to-be-generated code reliably.</li>
<li>Support vectorizing additional constructs:<ol class="loweralpha">
<li>Outer-loop vectorization. In particular, VPlan must be able to model the
control-flow of the output IR which may include multiple basic-blocks and
nested loops.</li>
<li>SLP vectorization.</li>
<li>Combinations of the above, including nested vectorization: vectorizing
both an inner loop and an outer-loop at the same time (each with its own
VF and UF), mixed vectorization: vectorizing a loop with SLP patterns
inside <a class="footnote-reference" href="#id14" id="id2">[4]</a>, (re)vectorizing input IR containing vector code.</li>
<li>Function vectorization <a class="footnote-reference" href="#id12" id="id3">[2]</a>.</li>
</ol>
</li>
<li>Support multiple candidates efficiently. In particular, similar candidates
related to a range of possible VF’s and UF’s must be represented efficiently.
Potential versioning needs to be supported efficiently.</li>
<li>Support vectorizing idioms, such as interleaved groups of strided loads or
stores. This is achieved by modeling a sequence of output instructions using
a “Recipe”, which is responsible for computing its cost and generating its
code.</li>
<li>Encapsulate Single-Entry Single-Exit regions (SESE). During vectorization
such regions may need to be, for example, predicated and linearized, or
replicated VF*UF times to handle scalarized and predicated instructions.
Innerloops are also modelled as SESE regions.</li>
<li>Support instruction-level analysis and transformation, as part of Planning
Step 2.b: During vectorization instructions may need to be traversed, moved,
replaced by other instructions or be created. For example, vector idiom
detection and formation involves searching for and optimizing instruction
patterns.</li>
</ol>
</div>
</div>
<div class="section" id="definitions">
<h2><a class="toc-backref" href="#id24">Definitions</a><a class="headerlink" href="#definitions" title="Permalink to this headline">¶</a></h2>
<p>The low-level design of VPlan comprises of the following classes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">LoopVectorizationPlanner:</th></tr>
<tr class="field-odd field"><td>&#160;</td><td class="field-body">A LoopVectorizationPlanner is designed to handle the vectorization of a loop
or a loop nest. It can construct, optimize and discard one or more VPlans,
each VPlan modelling a distinct way to vectorize the loop or the loop nest.
Once the best VPlan is determined, including the best VF and UF, this VPlan
drives the generation of output IR.</td>
</tr>
<tr class="field-even field"><th class="field-name">VPlan:</th><td class="field-body">A model of a vectorized candidate for a given input IR loop or loop nest. This
candidate is represented using a Hierarchical CFG. VPlan supports estimating
the cost and driving the generation of the output IR code it represents.</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">Hierarchical CFG:</th></tr>
<tr class="field-odd field"><td>&#160;</td><td class="field-body">A control-flow graph whose nodes are basic-blocks or Hierarchical CFG’s. The
Hierarchical CFG data structure is similar to the Tile Tree <a class="footnote-reference" href="#id15" id="id4">[5]</a>, where
cross-Tile edges are lifted to connect Tiles instead of the original
basic-blocks as in Sharir <a class="footnote-reference" href="#id16" id="id5">[6]</a>, promoting the Tile encapsulation. The terms
Region and Block are used rather than Tile <a class="footnote-reference" href="#id15" id="id6">[5]</a> to avoid confusion with loop
tiling.</td>
</tr>
<tr class="field-even field"><th class="field-name">VPBlockBase:</th><td class="field-body">The building block of the Hierarchical CFG. A pure-virtual base-class of
VPBasicBlock and VPRegionBlock, see below. VPBlockBase models the hierarchical
control-flow relations with other VPBlocks. Note that in contrast to the IR
BasicBlock, a VPBlockBase models its control-flow successors and predecessors
directly, rather than through a Terminator branch or through predecessor
branches that “use” the VPBlockBase.</td>
</tr>
<tr class="field-odd field"><th class="field-name">VPBasicBlock:</th><td class="field-body">VPBasicBlock is a subclass of VPBlockBase, and serves as the leaves of the
Hierarchical CFG. It represents a sequence of output IR instructions that will
appear consecutively in an output IR basic-block. The instructions of this
basic-block originate from one or more VPBasicBlocks. VPBasicBlock holds a
sequence of zero or more VPRecipes that model the cost and generation of the
output IR instructions.</td>
</tr>
<tr class="field-even field"><th class="field-name">VPRegionBlock:</th><td class="field-body">VPRegionBlock is a subclass of VPBlockBase. It models a collection of
VPBasicBlocks and VPRegionBlocks which form a SESE subgraph of the output IR
CFG. A VPRegionBlock may indicate that its contents are to be replicated a
constant number of times when output IR is generated, effectively representing
a loop with constant trip-count that will be completely unrolled. This is used
to support scalarized and predicated instructions with a single model for
multiple candidate VF’s and UF’s.</td>
</tr>
<tr class="field-odd field"><th class="field-name">VPRecipeBase:</th><td class="field-body">A pure-virtual base class modeling a sequence of one or more output IR
instructions, possibly based on one or more input IR instructions. These
input IR instructions are referred to as “Ingredients” of the Recipe. A Recipe
may specify how its ingredients are to be transformed to produce the output IR
instructions; e.g., cloned once, replicated multiple times or widened
according to selected VF.</td>
</tr>
<tr class="field-even field"><th class="field-name">VPValue:</th><td class="field-body">The base of VPlan’s def-use relations class hierarchy. When instantiated, it
models a constant or a live-in Value in VPlan. It has users, which are of type
VPUser, but no operands.</td>
</tr>
<tr class="field-odd field"><th class="field-name">VPUser:</th><td class="field-body">A VPValue representing a general vertex in the def-use graph of VPlan. It has
operands which are of type VPValue. When instantiated, it represents a
live-out Instruction that exists outside VPlan. VPUser is similar in some
aspects to LLVM’s User class.</td>
</tr>
<tr class="field-even field"><th class="field-name">VPInstruction:</th><td class="field-body">A VPInstruction is both a VPRecipe and a VPUser. It models a single
VPlan-level instruction to be generated if the VPlan is executed, including
its opcode and possibly additional characteristics. It is the basis for
writing instruction-level analyses and optimizations in VPlan as creating,
replacing or moving VPInstructions record both def-use and scheduling
decisions. VPInstructions also extend LLVM IR’s opcodes with idiomatic
operations that enrich the Vectorizer’s semantics.</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">VPTransformState:</th></tr>
<tr class="field-odd field"><td>&#160;</td><td class="field-body">Stores information used for generating output IR, passed from
LoopVectorizationPlanner to its selected VPlan for execution, and used to pass
additional information down to VPBlocks and VPRecipes.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="the-planning-process-and-vplan-roadmap">
<h2><a class="toc-backref" href="#id25">The Planning Process and VPlan Roadmap</a><a class="headerlink" href="#the-planning-process-and-vplan-roadmap" title="Permalink to this headline">¶</a></h2>
<p>Transforming the Loop Vectorizer to use VPlan follows a staged approach. First,
VPlan is used to record the final vectorization decisions, and to execute them:
the Hierarchical CFG models the planned control-flow, and Recipes capture
decisions taken inside basic-blocks. Next, VPlan will be used also as the basis
for taking these decisions, effectively turning them into a series of
VPlan-to-VPlan algorithms. Finally, VPlan will support the planning process
itself including cost-based analyses for making these decisions, to fully
support compositional and iterative decision making.</p>
<p>Some decisions are local to an instruction in the loop, such as whether to widen
it into a vector instruction or replicate it, keeping the generated instructions
in place. Other decisions, however, involve moving instructions, replacing them
with other instructions, and/or introducing new instructions. For example, a
cast may sink past a later instruction and be widened to handle first-order
recurrence; an interleave group of strided gathers or scatters may effectively
move to one place where they are replaced with shuffles and a common wide vector
load or store; new instructions may be introduced to compute masks, shuffle the
elements of vectors, and pack scalar values into vectors or vice-versa.</p>
<p>In order for VPlan to support making instruction-level decisions and analyses,
it needs to model the relevant instructions along with their def/use relations.
This too follows a staged approach: first, the new instructions that compute
masks are modeled as VPInstructions, along with their induced def/use subgraph.
This effectively models masks in VPlan, facilitating VPlan-based predication.
Next, the logic embedded within each Recipe for generating its instructions at
VPlan execution time, will instead take part in the planning process by modeling
them as VPInstructions. Finally, only logic that applies to instructions as a
group will remain in Recipes, such as interleave groups and potentially other
idiom groups having synergistic cost.</p>
<div class="section" id="related-llvm-components">
<h3><a class="toc-backref" href="#id26">Related LLVM components</a><a class="headerlink" href="#related-llvm-components" title="Permalink to this headline">¶</a></h3>
<ol class="arabic simple">
<li>SLP Vectorizer: one can compare the VPlan model with LLVM’s existing SLP
tree, where TSLP <a class="footnote-reference" href="#id13" id="id7">[3]</a> adds Plan Step 2.b.</li>
<li>RegionInfo: one can compare VPlan’s H-CFG with the Region Analysis as used by
Polly <a class="footnote-reference" href="#id17" id="id8">[7]</a>.</li>
<li>Loop Vectorizer: the Vectorization Plan aims to upgrade the infrastructure of
the Loop Vectorizer and extend it to handle outer loops <a class="footnote-reference" href="#id18" id="id9">[8]</a> and <a class="footnote-reference" href="#id19" id="id10">[9]</a>.</li>
</ol>
</div>
<div class="section" id="references">
<h3><a class="toc-backref" href="#id27">References</a><a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h3>
<table class="docutils footnote" frame="void" id="id11" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>“Outer-loop vectorization: revisited for short SIMD architectures”, Dorit
Nuzman and Ayal Zaks, PACT 2008.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id12" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[2]</a></td><td>“Proposal for function vectorization and loop vectorization with function
calls”, Xinmin Tian, [<a class="reference external" href="http://lists.llvm.org/pipermail/cfe-dev/2016-March/047732.html">cfe-dev</a>].,
March 2, 2016.
See also <a class="reference external" href="https://reviews.llvm.org/D22792">review</a>.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id13" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7">[3]</a></td><td>“Throttling Automatic Vectorization: When Less is More”, Vasileios
Porpodas and Tim Jones, PACT 2015 and LLVM Developers’ Meeting 2015.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id14" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[4]</a></td><td>“Exploiting mixed SIMD parallelism by reducing data reorganization
overhead”, Hao Zhou and Jingling Xue, CGO 2016.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id15" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[5]</td><td><em>(<a class="fn-backref" href="#id4">1</a>, <a class="fn-backref" href="#id6">2</a>)</em> “Register Allocation via Hierarchical Graph Coloring”, David Callahan and
Brian Koblenz, PLDI 1991</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id16" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[6]</a></td><td>“Structural analysis: A new approach to flow analysis in optimizing
compilers”, M. Sharir, Journal of Computer Languages, Jan. 1980</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id17" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id8">[7]</a></td><td>“Enabling Polyhedral Optimizations in LLVM”, Tobias Grosser, Diploma
thesis, 2011.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id18" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id9">[8]</a></td><td>“Introducing VPlan to the Loop Vectorizer”, Gil Rapaport and Ayal Zaks,
European LLVM Developers’ Meeting 2017.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id19" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id10">[9]</a></td><td>“Extending LoopVectorizer: OpenMP4.5 SIMD and Outer Loop
Auto-Vectorization”, Intel Vectorizer Team, LLVM Developers’ Meeting 2016.</td></tr>
</tbody>
</table>
</div>
</div>
</div>


          </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../WritingAnLLVMBackend.html" title="Writing an LLVM Backend"
             >next</a> |</li>
        <li class="right" >
          <a href="../Vectorizers.html" title="Auto-Vectorization in LLVM"
             >previous</a> |</li>
  <li><a href="http://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="../index.html">Documentation</a>&raquo;</li>

          <li class="nav-item nav-item-1"><a href="../Vectorizers.html" >Auto-Vectorization in LLVM</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2003-2019, LLVM Project.
      Last updated on Wed Feb 13 10:08:12 2019 -0800.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.1.
    </div>
  </body>
</html>