

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>CommandLine 2.0 Library Manual &#8212; LLVM 6 documentation</title>
    
    <link rel="stylesheet" href="_static/llvm-theme.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '6',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Architecture &amp; Platform Information for Compiler Writers" href="CompilerWriterInfo.html" />
    <link rel="prev" title="LLVM Coding Standards" href="CodingStandards.html" />
<style type="text/css">
  table.right { float: right; margin-left: 20px; }
  table.right td { border: 1px solid #ccc; }
</style>

  </head>
  <body>
<div class="logo">
  <a href="index.html">
    <img src="_static/logo.png"
         alt="LLVM Logo" width="250" height="88"/></a>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="CompilerWriterInfo.html" title="Architecture &amp; Platform Information for Compiler Writers"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="CodingStandards.html" title="LLVM Coding Standards"
             accesskey="P">previous</a> |</li>
  <li><a href="http://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="index.html">Documentation</a>&raquo;</li>
 
      </ul>
    </div>


    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <div class="section" id="commandline-2-0-library-manual">
<h1>CommandLine 2.0 Library Manual<a class="headerlink" href="#commandline-2-0-library-manual" title="Permalink to this headline">¶</a></h1>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><a class="reference internal" href="#introduction" id="id8">Introduction</a></li>
<li><a class="reference internal" href="#quick-start-guide" id="id9">Quick Start Guide</a><ul>
<li><a class="reference internal" href="#boolean-arguments" id="id10">Boolean Arguments</a></li>
<li><a class="reference internal" href="#argument-aliases" id="id11">Argument Aliases</a></li>
<li><a class="reference internal" href="#selecting-an-alternative-from-a-set-of-possibilities" id="id12">Selecting an alternative from a set of possibilities</a></li>
<li><a class="reference internal" href="#named-alternatives" id="id13">Named Alternatives</a></li>
<li><a class="reference internal" href="#parsing-a-list-of-options" id="id14">Parsing a list of options</a></li>
<li><a class="reference internal" href="#collecting-options-as-a-set-of-flags" id="id15">Collecting options as a set of flags</a></li>
<li><a class="reference internal" href="#adding-freeform-text-to-help-output" id="id16">Adding freeform text to help output</a></li>
<li><a class="reference internal" href="#grouping-options-into-categories" id="id17">Grouping options into categories</a></li>
</ul>
</li>
<li><a class="reference internal" href="#reference-guide" id="id18">Reference Guide</a><ul>
<li><a class="reference internal" href="#positional-options" id="id19">Positional Arguments</a><ul>
<li><a class="reference internal" href="#specifying-positional-options-with-hyphens" id="id20">Specifying positional options with hyphens</a></li>
<li><a class="reference internal" href="#determining-absolute-position-with-getposition" id="id21">Determining absolute position with getPosition()</a></li>
<li><a class="reference internal" href="#the-cl-consumeafter-modifier" id="id22">The <code class="docutils literal"><span class="pre">cl::ConsumeAfter</span></code> modifier</a></li>
</ul>
</li>
<li><a class="reference internal" href="#internal-vs-external-storage" id="id23">Internal vs External Storage</a></li>
<li><a class="reference internal" href="#option-attributes" id="id24">Option Attributes</a></li>
<li><a class="reference internal" href="#option-modifiers" id="id25">Option Modifiers</a><ul>
<li><a class="reference internal" href="#hiding-an-option-from-help-output" id="id26">Hiding an option from <code class="docutils literal"><span class="pre">-help</span></code> output</a></li>
<li><a class="reference internal" href="#controlling-the-number-of-occurrences-required-and-allowed" id="id27">Controlling the number of occurrences required and allowed</a></li>
<li><a class="reference internal" href="#controlling-whether-or-not-a-value-must-be-specified" id="id28">Controlling whether or not a value must be specified</a></li>
<li><a class="reference internal" href="#controlling-other-formatting-options" id="id29">Controlling other formatting options</a></li>
<li><a class="reference internal" href="#miscellaneous-option-modifiers" id="id30">Miscellaneous option modifiers</a></li>
<li><a class="reference internal" href="#response-files" id="id31">Response files</a></li>
</ul>
</li>
<li><a class="reference internal" href="#top-level-classes-and-functions" id="id32">Top-Level Classes and Functions</a><ul>
<li><a class="reference internal" href="#the-cl-getregisteredoptions-function" id="id33">The <code class="docutils literal"><span class="pre">cl::getRegisteredOptions</span></code> function</a></li>
<li><a class="reference internal" href="#the-cl-parsecommandlineoptions-function" id="id34">The <code class="docutils literal"><span class="pre">cl::ParseCommandLineOptions</span></code> function</a></li>
<li><a class="reference internal" href="#the-cl-parseenvironmentoptions-function" id="id35">The <code class="docutils literal"><span class="pre">cl::ParseEnvironmentOptions</span></code> function</a></li>
<li><a class="reference internal" href="#the-cl-setversionprinter-function" id="id36">The <code class="docutils literal"><span class="pre">cl::SetVersionPrinter</span></code> function</a></li>
<li><a class="reference internal" href="#the-cl-opt-class" id="id37">The <code class="docutils literal"><span class="pre">cl::opt</span></code> class</a></li>
<li><a class="reference internal" href="#the-cl-list-class" id="id38">The <code class="docutils literal"><span class="pre">cl::list</span></code> class</a></li>
<li><a class="reference internal" href="#the-cl-bits-class" id="id39">The <code class="docutils literal"><span class="pre">cl::bits</span></code> class</a></li>
<li><a class="reference internal" href="#the-cl-alias-class" id="id40">The <code class="docutils literal"><span class="pre">cl::alias</span></code> class</a></li>
<li><a class="reference internal" href="#the-cl-extrahelp-class" id="id41">The <code class="docutils literal"><span class="pre">cl::extrahelp</span></code> class</a></li>
<li><a class="reference internal" href="#the-cl-optioncategory-class" id="id42">The <code class="docutils literal"><span class="pre">cl::OptionCategory</span></code> class</a></li>
</ul>
</li>
<li><a class="reference internal" href="#builtin-parsers" id="id43">Builtin parsers</a></li>
</ul>
</li>
<li><a class="reference internal" href="#extending-the-library" id="id44">Extension Guide</a><ul>
<li><a class="reference internal" href="#writing-a-custom-parser" id="id45">Writing a custom parser</a></li>
<li><a class="reference internal" href="#exploiting-external-storage" id="id46">Exploiting external storage</a></li>
<li><a class="reference internal" href="#dynamically-adding-command-line-options" id="id47">Dynamically adding command line options</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="introduction">
<h2><a class="toc-backref" href="#id8">Introduction</a><a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>This document describes the CommandLine argument processing library.  It will
show you how to use it, and what it can do.  The CommandLine library uses a
declarative approach to specifying the command line options that your program
takes.  By default, these options declarations implicitly hold the value parsed
for the option declared (of course this <a class="reference internal" href="#can-be-changed">can be changed</a>).</p>
<p>Although there are a <strong>lot</strong> of command line argument parsing libraries out
there in many different languages, none of them fit well with what I needed.  By
looking at the features and problems of other libraries, I designed the
CommandLine library to have the following features:</p>
<ol class="arabic simple">
<li>Speed: The CommandLine library is very quick and uses little resources.  The
parsing time of the library is directly proportional to the number of
arguments parsed, not the number of options recognized.  Additionally,
command line argument values are captured transparently into user defined
global variables, which can be accessed like any other variable (and with the
same performance).</li>
<li>Type Safe: As a user of CommandLine, you don’t have to worry about
remembering the type of arguments that you want (is it an int?  a string? a
bool? an enum?) and keep casting it around.  Not only does this help prevent
error prone constructs, it also leads to dramatically cleaner source code.</li>
<li>No subclasses required: To use CommandLine, you instantiate variables that
correspond to the arguments that you would like to capture, you don’t
subclass a parser.  This means that you don’t have to write <strong>any</strong>
boilerplate code.</li>
<li>Globally accessible: Libraries can specify command line arguments that are
automatically enabled in any tool that links to the library.  This is
possible because the application doesn’t have to keep a list of arguments to
pass to the parser.  This also makes supporting <a class="reference internal" href="#dynamically-loaded-options">dynamically loaded options</a>
trivial.</li>
<li>Cleaner: CommandLine supports enum and other types directly, meaning that
there is less error and more security built into the library.  You don’t have
to worry about whether your integral command line argument accidentally got
assigned a value that is not valid for your enum type.</li>
<li>Powerful: The CommandLine library supports many different types of arguments,
from simple <a class="reference internal" href="#boolean-flags">boolean flags</a> to <a class="reference internal" href="#scalars-arguments">scalars arguments</a> (<a class="reference internal" href="#strings">strings</a>,
<a class="reference internal" href="#integers">integers</a>, <a class="reference internal" href="#enums">enums</a>, <a class="reference internal" href="#doubles">doubles</a>), to <a class="reference internal" href="#lists-of-arguments">lists of arguments</a>.  This is
possible because CommandLine is…</li>
<li>Extensible: It is very simple to add a new argument type to CommandLine.
Simply specify the parser that you want to use with the command line option
when you declare it. <a class="reference internal" href="#custom-parsers">Custom parsers</a> are no problem.</li>
<li>Labor Saving: The CommandLine library cuts down on the amount of grunt work
that you, the user, have to do.  For example, it automatically provides a
<code class="docutils literal"><span class="pre">-help</span></code> option that shows the available command line options for your tool.
Additionally, it does most of the basic correctness checking for you.</li>
<li>Capable: The CommandLine library can handle lots of different forms of
options often found in real programs.  For example, <a class="reference internal" href="#positional">positional</a> arguments,
<code class="docutils literal"><span class="pre">ls</span></code> style <a class="reference internal" href="#grouping">grouping</a> options (to allow processing ‘<code class="docutils literal"><span class="pre">ls</span> <span class="pre">-lad</span></code>’
naturally), <code class="docutils literal"><span class="pre">ld</span></code> style <a class="reference internal" href="#prefix">prefix</a> options (to parse ‘<code class="docutils literal"><span class="pre">-lmalloc</span>
<span class="pre">-L/usr/lib</span></code>’), and interpreter style options.</li>
</ol>
<p>This document will hopefully let you jump in and start using CommandLine in your
utility quickly and painlessly.  Additionally it should be a simple reference
manual to figure out how stuff works.</p>
</div>
<div class="section" id="quick-start-guide">
<h2><a class="toc-backref" href="#id9">Quick Start Guide</a><a class="headerlink" href="#quick-start-guide" title="Permalink to this headline">¶</a></h2>
<p>This section of the manual runs through a simple CommandLine’ification of a
basic compiler tool.  This is intended to show you how to jump into using the
CommandLine library in your own program, and show you some of the cool things it
can do.</p>
<p>To start out, you need to include the CommandLine header file into your program:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;llvm/Support/CommandLine.h&quot;</span><span class="cp"></span>
</pre></div>
</div>
<p>Additionally, you need to add this as the first line of your main program:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">cl</span><span class="o">::</span><span class="n">ParseCommandLineOptions</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>… which actually parses the arguments and fills in the variable declarations.</p>
<p>Now that you are ready to support command line arguments, we need to tell the
system which ones we want, and what type of arguments they are.  The CommandLine
library uses a declarative syntax to model command line arguments with the
global variable declarations that capture the parsed values.  This means that
for every command line option that you would like to support, there should be a
global variable declaration to capture the result.  For example, in a compiler,
we would like to support the Unix-standard ‘<code class="docutils literal"><span class="pre">-o</span> <span class="pre">&lt;filename&gt;</span></code>’ option to specify
where to put the output.  With the CommandLine library, this is represented like
this:</p>
<div class="highlight-c++" id="here"><span id="scalars-arguments"></span><div class="highlight"><pre><span></span><span class="n">cl</span><span class="o">::</span><span class="n">opt</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">OutputFilename</span><span class="p">(</span><span class="s">&quot;o&quot;</span><span class="p">,</span> <span class="n">cl</span><span class="o">::</span><span class="n">desc</span><span class="p">(</span><span class="s">&quot;Specify output filename&quot;</span><span class="p">),</span> <span class="n">cl</span><span class="o">::</span><span class="n">value_desc</span><span class="p">(</span><span class="s">&quot;filename&quot;</span><span class="p">));</span>
</pre></div>
</div>
<p>This declares a global variable “<code class="docutils literal"><span class="pre">OutputFilename</span></code>” that is used to capture the
result of the “<code class="docutils literal"><span class="pre">o</span></code>” argument (first parameter).  We specify that this is a
simple scalar option by using the “<code class="docutils literal"><span class="pre">cl::opt</span></code>” template (as opposed to the
“<code class="docutils literal"><span class="pre">cl::list</span></code>” template), and tell the CommandLine library that the data
type that we are parsing is a string.</p>
<p>The second and third parameters (which are optional) are used to specify what to
output for the “<code class="docutils literal"><span class="pre">-help</span></code>” option.  In this case, we get a line that looks like
this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">USAGE</span><span class="p">:</span> <span class="n">compiler</span> <span class="p">[</span><span class="n">options</span><span class="p">]</span>

<span class="n">OPTIONS</span><span class="p">:</span>
  <span class="o">-</span><span class="n">help</span>             <span class="o">-</span> <span class="n">display</span> <span class="n">available</span> <span class="n">options</span> <span class="p">(</span><span class="o">-</span><span class="n">help</span><span class="o">-</span><span class="n">hidden</span> <span class="k">for</span> <span class="n">more</span><span class="p">)</span>
  <span class="o">-</span><span class="n">o</span> <span class="o">&lt;</span><span class="n">filename</span><span class="o">&gt;</span>     <span class="o">-</span> <span class="n">Specify</span> <span class="n">output</span> <span class="n">filename</span>
</pre></div>
</div>
<p>Because we specified that the command line option should parse using the
<code class="docutils literal"><span class="pre">string</span></code> data type, the variable declared is automatically usable as a real
string in all contexts that a normal C++ string object may be used.  For
example:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="p">...</span>
<span class="n">std</span><span class="o">::</span><span class="n">ofstream</span> <span class="n">Output</span><span class="p">(</span><span class="n">OutputFilename</span><span class="p">.</span><span class="n">c_str</span><span class="p">());</span>
<span class="k">if</span> <span class="p">(</span><span class="n">Output</span><span class="p">.</span><span class="n">good</span><span class="p">())</span> <span class="p">...</span>
<span class="p">...</span>
</pre></div>
</div>
<p>There are many different options that you can use to customize the command line
option handling library, but the above example shows the general interface to
these options.  The options can be specified in any order, and are specified
with helper functions like <a class="reference internal" href="#cl-desc">cl::desc(…)</a>, so there are no positional
dependencies to remember.  The available options are discussed in detail in the
<a class="reference internal" href="#reference-guide">Reference Guide</a>.</p>
<p>Continuing the example, we would like to have our compiler take an input
filename as well as an output filename, but we do not want the input filename to
be specified with a hyphen (ie, not <code class="docutils literal"><span class="pre">-filename.c</span></code>).  To support this style of
argument, the CommandLine library allows for <a class="reference internal" href="#positional">positional</a> arguments to be
specified for the program.  These positional arguments are filled with command
line parameters that are not in option form.  We use this feature like this:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">cl</span><span class="o">::</span><span class="n">opt</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">InputFilename</span><span class="p">(</span><span class="n">cl</span><span class="o">::</span><span class="n">Positional</span><span class="p">,</span> <span class="n">cl</span><span class="o">::</span><span class="n">desc</span><span class="p">(</span><span class="s">&quot;&lt;input file&gt;&quot;</span><span class="p">),</span> <span class="n">cl</span><span class="o">::</span><span class="n">init</span><span class="p">(</span><span class="s">&quot;-&quot;</span><span class="p">));</span>
</pre></div>
</div>
<p>This declaration indicates that the first positional argument should be treated
as the input filename.  Here we use the <a class="reference internal" href="#cl-init">cl::init</a> option to specify an initial
value for the command line option, which is used if the option is not specified
(if you do not specify a <a class="reference internal" href="#cl-init">cl::init</a> modifier for an option, then the default
constructor for the data type is used to initialize the value).  Command line
options default to being optional, so if we would like to require that the user
always specify an input filename, we would add the <a class="reference internal" href="#cl-required">cl::Required</a> flag, and we
could eliminate the <a class="reference internal" href="#cl-init">cl::init</a> modifier, like this:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">cl</span><span class="o">::</span><span class="n">opt</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">InputFilename</span><span class="p">(</span><span class="n">cl</span><span class="o">::</span><span class="n">Positional</span><span class="p">,</span> <span class="n">cl</span><span class="o">::</span><span class="n">desc</span><span class="p">(</span><span class="s">&quot;&lt;input file&gt;&quot;</span><span class="p">),</span> <span class="n">cl</span><span class="o">::</span><span class="n">Required</span><span class="p">);</span>
</pre></div>
</div>
<p>Again, the CommandLine library does not require the options to be specified in
any particular order, so the above declaration is equivalent to:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">cl</span><span class="o">::</span><span class="n">opt</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">InputFilename</span><span class="p">(</span><span class="n">cl</span><span class="o">::</span><span class="n">Positional</span><span class="p">,</span> <span class="n">cl</span><span class="o">::</span><span class="n">Required</span><span class="p">,</span> <span class="n">cl</span><span class="o">::</span><span class="n">desc</span><span class="p">(</span><span class="s">&quot;&lt;input file&gt;&quot;</span><span class="p">));</span>
</pre></div>
</div>
<p>By simply adding the <a class="reference internal" href="#cl-required">cl::Required</a> flag, the CommandLine library will
automatically issue an error if the argument is not specified, which shifts all
of the command line option verification code out of your application into the
library.  This is just one example of how using flags can alter the default
behaviour of the library, on a per-option basis.  By adding one of the
declarations above, the <code class="docutils literal"><span class="pre">-help</span></code> option synopsis is now extended to:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">USAGE</span><span class="p">:</span> <span class="n">compiler</span> <span class="p">[</span><span class="n">options</span><span class="p">]</span> <span class="o">&lt;</span><span class="nb">input</span> <span class="n">file</span><span class="o">&gt;</span>

<span class="n">OPTIONS</span><span class="p">:</span>
  <span class="o">-</span><span class="n">help</span>             <span class="o">-</span> <span class="n">display</span> <span class="n">available</span> <span class="n">options</span> <span class="p">(</span><span class="o">-</span><span class="n">help</span><span class="o">-</span><span class="n">hidden</span> <span class="k">for</span> <span class="n">more</span><span class="p">)</span>
  <span class="o">-</span><span class="n">o</span> <span class="o">&lt;</span><span class="n">filename</span><span class="o">&gt;</span>     <span class="o">-</span> <span class="n">Specify</span> <span class="n">output</span> <span class="n">filename</span>
</pre></div>
</div>
<p>… indicating that an input filename is expected.</p>
<div class="section" id="boolean-arguments">
<h3><a class="toc-backref" href="#id10">Boolean Arguments</a><a class="headerlink" href="#boolean-arguments" title="Permalink to this headline">¶</a></h3>
<p>In addition to input and output filenames, we would like the compiler example to
support three boolean flags: “<code class="docutils literal"><span class="pre">-f</span></code>” to force writing binary output to a
terminal, “<code class="docutils literal"><span class="pre">--quiet</span></code>” to enable quiet mode, and “<code class="docutils literal"><span class="pre">-q</span></code>” for backwards
compatibility with some of our users.  We can support these by declaring options
of boolean type like this:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">cl</span><span class="o">::</span><span class="n">opt</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">Force</span> <span class="p">(</span><span class="s">&quot;f&quot;</span><span class="p">,</span> <span class="n">cl</span><span class="o">::</span><span class="n">desc</span><span class="p">(</span><span class="s">&quot;Enable binary output on terminals&quot;</span><span class="p">));</span>
<span class="n">cl</span><span class="o">::</span><span class="n">opt</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">Quiet</span> <span class="p">(</span><span class="s">&quot;quiet&quot;</span><span class="p">,</span> <span class="n">cl</span><span class="o">::</span><span class="n">desc</span><span class="p">(</span><span class="s">&quot;Don&#39;t print informational messages&quot;</span><span class="p">));</span>
<span class="n">cl</span><span class="o">::</span><span class="n">opt</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">Quiet2</span><span class="p">(</span><span class="s">&quot;q&quot;</span><span class="p">,</span> <span class="n">cl</span><span class="o">::</span><span class="n">desc</span><span class="p">(</span><span class="s">&quot;Don&#39;t print informational messages&quot;</span><span class="p">),</span> <span class="n">cl</span><span class="o">::</span><span class="n">Hidden</span><span class="p">);</span>
</pre></div>
</div>
<p>This does what you would expect: it declares three boolean variables
(“<code class="docutils literal"><span class="pre">Force</span></code>”, “<code class="docutils literal"><span class="pre">Quiet</span></code>”, and “<code class="docutils literal"><span class="pre">Quiet2</span></code>”) to recognize these options.  Note
that the “<code class="docutils literal"><span class="pre">-q</span></code>” option is specified with the “<a class="reference internal" href="#cl-hidden">cl::Hidden</a>” flag.  This
modifier prevents it from being shown by the standard “<code class="docutils literal"><span class="pre">-help</span></code>” output (note
that it is still shown in the “<code class="docutils literal"><span class="pre">-help-hidden</span></code>” output).</p>
<p>The CommandLine library uses a <a class="reference internal" href="#different-parser">different parser</a> for different data types.
For example, in the string case, the argument passed to the option is copied
literally into the content of the string variable… we obviously cannot do that
in the boolean case, however, so we must use a smarter parser.  In the case of
the boolean parser, it allows no options (in which case it assigns the value of
true to the variable), or it allows the values “<code class="docutils literal"><span class="pre">true</span></code>” or “<code class="docutils literal"><span class="pre">false</span></code>” to be
specified, allowing any of the following inputs:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">compiler</span> <span class="o">-</span><span class="n">f</span>          <span class="c1"># No value, &#39;Force&#39; == true</span>
<span class="n">compiler</span> <span class="o">-</span><span class="n">f</span><span class="o">=</span><span class="n">true</span>     <span class="c1"># Value specified, &#39;Force&#39; == true</span>
<span class="n">compiler</span> <span class="o">-</span><span class="n">f</span><span class="o">=</span><span class="n">TRUE</span>     <span class="c1"># Value specified, &#39;Force&#39; == true</span>
<span class="n">compiler</span> <span class="o">-</span><span class="n">f</span><span class="o">=</span><span class="n">FALSE</span>    <span class="c1"># Value specified, &#39;Force&#39; == false</span>
</pre></div>
</div>
<p>… you get the idea.  The <a class="reference internal" href="#bool-parser">bool parser</a> just turns the string values into
boolean values, and rejects things like ‘<code class="docutils literal"><span class="pre">compiler</span> <span class="pre">-f=foo</span></code>’.  Similarly, the
<a class="reference internal" href="#float">float</a>, <a class="reference internal" href="#double">double</a>, and <a class="reference internal" href="#int">int</a> parsers work like you would expect, using the
‘<code class="docutils literal"><span class="pre">strtol</span></code>’ and ‘<code class="docutils literal"><span class="pre">strtod</span></code>’ C library calls to parse the string value into the
specified data type.</p>
<p>With the declarations above, “<code class="docutils literal"><span class="pre">compiler</span> <span class="pre">-help</span></code>” emits this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">USAGE</span><span class="p">:</span> <span class="n">compiler</span> <span class="p">[</span><span class="n">options</span><span class="p">]</span> <span class="o">&lt;</span><span class="nb">input</span> <span class="n">file</span><span class="o">&gt;</span>

<span class="n">OPTIONS</span><span class="p">:</span>
  <span class="o">-</span><span class="n">f</span>     <span class="o">-</span> <span class="n">Enable</span> <span class="n">binary</span> <span class="n">output</span> <span class="n">on</span> <span class="n">terminals</span>
  <span class="o">-</span><span class="n">o</span>     <span class="o">-</span> <span class="n">Override</span> <span class="n">output</span> <span class="n">filename</span>
  <span class="o">-</span><span class="n">quiet</span> <span class="o">-</span> <span class="n">Don</span><span class="s1">&#39;t print informational messages</span>
  <span class="o">-</span><span class="n">help</span>  <span class="o">-</span> <span class="n">display</span> <span class="n">available</span> <span class="n">options</span> <span class="p">(</span><span class="o">-</span><span class="n">help</span><span class="o">-</span><span class="n">hidden</span> <span class="k">for</span> <span class="n">more</span><span class="p">)</span>
</pre></div>
</div>
<p>and “<code class="docutils literal"><span class="pre">compiler</span> <span class="pre">-help-hidden</span></code>” prints this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">USAGE</span><span class="p">:</span> <span class="n">compiler</span> <span class="p">[</span><span class="n">options</span><span class="p">]</span> <span class="o">&lt;</span><span class="nb">input</span> <span class="n">file</span><span class="o">&gt;</span>

<span class="n">OPTIONS</span><span class="p">:</span>
  <span class="o">-</span><span class="n">f</span>     <span class="o">-</span> <span class="n">Enable</span> <span class="n">binary</span> <span class="n">output</span> <span class="n">on</span> <span class="n">terminals</span>
  <span class="o">-</span><span class="n">o</span>     <span class="o">-</span> <span class="n">Override</span> <span class="n">output</span> <span class="n">filename</span>
  <span class="o">-</span><span class="n">q</span>     <span class="o">-</span> <span class="n">Don</span><span class="s1">&#39;t print informational messages</span>
  <span class="o">-</span><span class="n">quiet</span> <span class="o">-</span> <span class="n">Don</span><span class="s1">&#39;t print informational messages</span>
  <span class="o">-</span><span class="n">help</span>  <span class="o">-</span> <span class="n">display</span> <span class="n">available</span> <span class="n">options</span> <span class="p">(</span><span class="o">-</span><span class="n">help</span><span class="o">-</span><span class="n">hidden</span> <span class="k">for</span> <span class="n">more</span><span class="p">)</span>
</pre></div>
</div>
<p>This brief example has shown you how to use the ‘<a class="reference internal" href="#cl-opt">cl::opt</a>’ class to parse
simple scalar command line arguments.  In addition to simple scalar arguments,
the CommandLine library also provides primitives to support CommandLine option
<a class="reference internal" href="#aliases">aliases</a>, and <a class="reference internal" href="#lists">lists</a> of options.</p>
</div>
<div class="section" id="argument-aliases">
<span id="aliases"></span><h3><a class="toc-backref" href="#id11">Argument Aliases</a><a class="headerlink" href="#argument-aliases" title="Permalink to this headline">¶</a></h3>
<p>So far, the example works well, except for the fact that we need to check the
quiet condition like this now:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="p">...</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Quiet</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">Quiet2</span><span class="p">)</span> <span class="n">printInformationalMessage</span><span class="p">(...);</span>
<span class="p">...</span>
</pre></div>
</div>
<p>… which is a real pain!  Instead of defining two values for the same
condition, we can use the “<a class="reference internal" href="#cl-alias">cl::alias</a>” class to make the “<code class="docutils literal"><span class="pre">-q</span></code>” option an
<strong>alias</strong> for the “<code class="docutils literal"><span class="pre">-quiet</span></code>” option, instead of providing a value itself:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">cl</span><span class="o">::</span><span class="n">opt</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">Force</span> <span class="p">(</span><span class="s">&quot;f&quot;</span><span class="p">,</span> <span class="n">cl</span><span class="o">::</span><span class="n">desc</span><span class="p">(</span><span class="s">&quot;Overwrite output files&quot;</span><span class="p">));</span>
<span class="n">cl</span><span class="o">::</span><span class="n">opt</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">Quiet</span> <span class="p">(</span><span class="s">&quot;quiet&quot;</span><span class="p">,</span> <span class="n">cl</span><span class="o">::</span><span class="n">desc</span><span class="p">(</span><span class="s">&quot;Don&#39;t print informational messages&quot;</span><span class="p">));</span>
<span class="n">cl</span><span class="o">::</span><span class="n">alias</span>     <span class="n">QuietA</span><span class="p">(</span><span class="s">&quot;q&quot;</span><span class="p">,</span> <span class="n">cl</span><span class="o">::</span><span class="n">desc</span><span class="p">(</span><span class="s">&quot;Alias for -quiet&quot;</span><span class="p">),</span> <span class="n">cl</span><span class="o">::</span><span class="n">aliasopt</span><span class="p">(</span><span class="n">Quiet</span><span class="p">));</span>
</pre></div>
</div>
<p>The third line (which is the only one we modified from above) defines a “<code class="docutils literal"><span class="pre">-q</span></code>”
alias that updates the “<code class="docutils literal"><span class="pre">Quiet</span></code>” variable (as specified by the <a class="reference internal" href="#cl-aliasopt">cl::aliasopt</a>
modifier) whenever it is specified.  Because aliases do not hold state, the only
thing the program has to query is the <code class="docutils literal"><span class="pre">Quiet</span></code> variable now.  Another nice
feature of aliases is that they automatically hide themselves from the <code class="docutils literal"><span class="pre">-help</span></code>
output (although, again, they are still visible in the <code class="docutils literal"><span class="pre">-help-hidden</span> <span class="pre">output</span></code>).</p>
<p>Now the application code can simply use:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="p">...</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Quiet</span><span class="p">)</span> <span class="n">printInformationalMessage</span><span class="p">(...);</span>
<span class="p">...</span>
</pre></div>
</div>
<p>… which is much nicer!  The “<a class="reference internal" href="#cl-alias">cl::alias</a>” can be used to specify an
alternative name for any variable type, and has many uses.</p>
</div>
<div class="section" id="selecting-an-alternative-from-a-set-of-possibilities">
<span id="unnamed-alternatives-using-the-generic-parser"></span><h3><a class="toc-backref" href="#id12">Selecting an alternative from a set of possibilities</a><a class="headerlink" href="#selecting-an-alternative-from-a-set-of-possibilities" title="Permalink to this headline">¶</a></h3>
<p>So far we have seen how the CommandLine library handles builtin types like
<code class="docutils literal"><span class="pre">std::string</span></code>, <code class="docutils literal"><span class="pre">bool</span></code> and <code class="docutils literal"><span class="pre">int</span></code>, but how does it handle things it doesn’t
know about, like enums or ‘<code class="docutils literal"><span class="pre">int*</span></code>’s?</p>
<p>The answer is that it uses a table-driven generic parser (unless you specify
your own parser, as described in the <a class="reference internal" href="#extension-guide">Extension Guide</a>).  This parser maps
literal strings to whatever type is required, and requires you to tell it what
this mapping should be.</p>
<p>Let’s say that we would like to add four optimization levels to our optimizer,
using the standard flags “<code class="docutils literal"><span class="pre">-g</span></code>”, “<code class="docutils literal"><span class="pre">-O0</span></code>”, “<code class="docutils literal"><span class="pre">-O1</span></code>”, and “<code class="docutils literal"><span class="pre">-O2</span></code>”.  We
could easily implement this with boolean options like above, but there are
several problems with this strategy:</p>
<ol class="arabic simple">
<li>A user could specify more than one of the options at a time, for example,
“<code class="docutils literal"><span class="pre">compiler</span> <span class="pre">-O3</span> <span class="pre">-O2</span></code>”.  The CommandLine library would not be able to catch
this erroneous input for us.</li>
<li>We would have to test 4 different variables to see which ones are set.</li>
<li>This doesn’t map to the numeric levels that we want… so we cannot easily
see if some level &gt;= “<code class="docutils literal"><span class="pre">-O1</span></code>” is enabled.</li>
</ol>
<p>To cope with these problems, we can use an enum value, and have the CommandLine
library fill it in with the appropriate level directly, which is used like this:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">enum</span> <span class="n">OptLevel</span> <span class="p">{</span>
  <span class="n">g</span><span class="p">,</span> <span class="n">O1</span><span class="p">,</span> <span class="n">O2</span><span class="p">,</span> <span class="n">O3</span>
<span class="p">};</span>

<span class="n">cl</span><span class="o">::</span><span class="n">opt</span><span class="o">&lt;</span><span class="n">OptLevel</span><span class="o">&gt;</span> <span class="n">OptimizationLevel</span><span class="p">(</span><span class="n">cl</span><span class="o">::</span><span class="n">desc</span><span class="p">(</span><span class="s">&quot;Choose optimization level:&quot;</span><span class="p">),</span>
  <span class="n">cl</span><span class="o">::</span><span class="n">values</span><span class="p">(</span>
    <span class="n">clEnumVal</span><span class="p">(</span><span class="n">g</span> <span class="p">,</span> <span class="s">&quot;No optimizations, enable debugging&quot;</span><span class="p">),</span>
    <span class="n">clEnumVal</span><span class="p">(</span><span class="n">O1</span><span class="p">,</span> <span class="s">&quot;Enable trivial optimizations&quot;</span><span class="p">),</span>
    <span class="n">clEnumVal</span><span class="p">(</span><span class="n">O2</span><span class="p">,</span> <span class="s">&quot;Enable default optimizations&quot;</span><span class="p">),</span>
    <span class="n">clEnumVal</span><span class="p">(</span><span class="n">O3</span><span class="p">,</span> <span class="s">&quot;Enable expensive optimizations&quot;</span><span class="p">)));</span>

<span class="p">...</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">OptimizationLevel</span> <span class="o">&gt;=</span> <span class="n">O2</span><span class="p">)</span> <span class="n">doPartialRedundancyElimination</span><span class="p">(...);</span>
<span class="p">...</span>
</pre></div>
</div>
<p>This declaration defines a variable “<code class="docutils literal"><span class="pre">OptimizationLevel</span></code>” of the
“<code class="docutils literal"><span class="pre">OptLevel</span></code>” enum type.  This variable can be assigned any of the values that
are listed in the declaration.  The CommandLine library enforces that
the user can only specify one of the options, and it ensure that only valid enum
values can be specified.  The “<code class="docutils literal"><span class="pre">clEnumVal</span></code>” macros ensure that the command
line arguments matched the enum values.  With this option added, our help output
now is:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">USAGE</span><span class="p">:</span> <span class="n">compiler</span> <span class="p">[</span><span class="n">options</span><span class="p">]</span> <span class="o">&lt;</span><span class="nb">input</span> <span class="n">file</span><span class="o">&gt;</span>

<span class="n">OPTIONS</span><span class="p">:</span>
  <span class="n">Choose</span> <span class="n">optimization</span> <span class="n">level</span><span class="p">:</span>
    <span class="o">-</span><span class="n">g</span>          <span class="o">-</span> <span class="n">No</span> <span class="n">optimizations</span><span class="p">,</span> <span class="n">enable</span> <span class="n">debugging</span>
    <span class="o">-</span><span class="n">O1</span>         <span class="o">-</span> <span class="n">Enable</span> <span class="n">trivial</span> <span class="n">optimizations</span>
    <span class="o">-</span><span class="n">O2</span>         <span class="o">-</span> <span class="n">Enable</span> <span class="n">default</span> <span class="n">optimizations</span>
    <span class="o">-</span><span class="n">O3</span>         <span class="o">-</span> <span class="n">Enable</span> <span class="n">expensive</span> <span class="n">optimizations</span>
  <span class="o">-</span><span class="n">f</span>            <span class="o">-</span> <span class="n">Enable</span> <span class="n">binary</span> <span class="n">output</span> <span class="n">on</span> <span class="n">terminals</span>
  <span class="o">-</span><span class="n">help</span>         <span class="o">-</span> <span class="n">display</span> <span class="n">available</span> <span class="n">options</span> <span class="p">(</span><span class="o">-</span><span class="n">help</span><span class="o">-</span><span class="n">hidden</span> <span class="k">for</span> <span class="n">more</span><span class="p">)</span>
  <span class="o">-</span><span class="n">o</span> <span class="o">&lt;</span><span class="n">filename</span><span class="o">&gt;</span> <span class="o">-</span> <span class="n">Specify</span> <span class="n">output</span> <span class="n">filename</span>
  <span class="o">-</span><span class="n">quiet</span>        <span class="o">-</span> <span class="n">Don</span><span class="s1">&#39;t print informational messages</span>
</pre></div>
</div>
<p>In this case, it is sort of awkward that flag names correspond directly to enum
names, because we probably don’t want a enum definition named “<code class="docutils literal"><span class="pre">g</span></code>” in our
program.  Because of this, we can alternatively write this example like this:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">enum</span> <span class="n">OptLevel</span> <span class="p">{</span>
  <span class="n">Debug</span><span class="p">,</span> <span class="n">O1</span><span class="p">,</span> <span class="n">O2</span><span class="p">,</span> <span class="n">O3</span>
<span class="p">};</span>

<span class="n">cl</span><span class="o">::</span><span class="n">opt</span><span class="o">&lt;</span><span class="n">OptLevel</span><span class="o">&gt;</span> <span class="n">OptimizationLevel</span><span class="p">(</span><span class="n">cl</span><span class="o">::</span><span class="n">desc</span><span class="p">(</span><span class="s">&quot;Choose optimization level:&quot;</span><span class="p">),</span>
  <span class="n">cl</span><span class="o">::</span><span class="n">values</span><span class="p">(</span>
   <span class="n">clEnumValN</span><span class="p">(</span><span class="n">Debug</span><span class="p">,</span> <span class="s">&quot;g&quot;</span><span class="p">,</span> <span class="s">&quot;No optimizations, enable debugging&quot;</span><span class="p">),</span>
    <span class="n">clEnumVal</span><span class="p">(</span><span class="n">O1</span>        <span class="p">,</span> <span class="s">&quot;Enable trivial optimizations&quot;</span><span class="p">),</span>
    <span class="n">clEnumVal</span><span class="p">(</span><span class="n">O2</span>        <span class="p">,</span> <span class="s">&quot;Enable default optimizations&quot;</span><span class="p">),</span>
    <span class="n">clEnumVal</span><span class="p">(</span><span class="n">O3</span>        <span class="p">,</span> <span class="s">&quot;Enable expensive optimizations&quot;</span><span class="p">)));</span>

<span class="p">...</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">OptimizationLevel</span> <span class="o">==</span> <span class="n">Debug</span><span class="p">)</span> <span class="n">outputDebugInfo</span><span class="p">(...);</span>
<span class="p">...</span>
</pre></div>
</div>
<p>By using the “<code class="docutils literal"><span class="pre">clEnumValN</span></code>” macro instead of “<code class="docutils literal"><span class="pre">clEnumVal</span></code>”, we can directly
specify the name that the flag should get.  In general a direct mapping is nice,
but sometimes you can’t or don’t want to preserve the mapping, which is when you
would use it.</p>
</div>
<div class="section" id="named-alternatives">
<h3><a class="toc-backref" href="#id13">Named Alternatives</a><a class="headerlink" href="#named-alternatives" title="Permalink to this headline">¶</a></h3>
<p>Another useful argument form is a named alternative style.  We shall use this
style in our compiler to specify different debug levels that can be used.
Instead of each debug level being its own switch, we want to support the
following options, of which only one can be specified at a time:
“<code class="docutils literal"><span class="pre">--debug-level=none</span></code>”, “<code class="docutils literal"><span class="pre">--debug-level=quick</span></code>”,
“<code class="docutils literal"><span class="pre">--debug-level=detailed</span></code>”.  To do this, we use the exact same format as our
optimization level flags, but we also specify an option name.  For this case,
the code looks like this:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">enum</span> <span class="n">DebugLev</span> <span class="p">{</span>
  <span class="n">nodebuginfo</span><span class="p">,</span> <span class="n">quick</span><span class="p">,</span> <span class="n">detailed</span>
<span class="p">};</span>

<span class="c1">// Enable Debug Options to be specified on the command line</span>
<span class="n">cl</span><span class="o">::</span><span class="n">opt</span><span class="o">&lt;</span><span class="n">DebugLev</span><span class="o">&gt;</span> <span class="n">DebugLevel</span><span class="p">(</span><span class="s">&quot;debug_level&quot;</span><span class="p">,</span> <span class="n">cl</span><span class="o">::</span><span class="n">desc</span><span class="p">(</span><span class="s">&quot;Set the debugging level:&quot;</span><span class="p">),</span>
  <span class="n">cl</span><span class="o">::</span><span class="n">values</span><span class="p">(</span>
    <span class="n">clEnumValN</span><span class="p">(</span><span class="n">nodebuginfo</span><span class="p">,</span> <span class="s">&quot;none&quot;</span><span class="p">,</span> <span class="s">&quot;disable debug information&quot;</span><span class="p">),</span>
     <span class="n">clEnumVal</span><span class="p">(</span><span class="n">quick</span><span class="p">,</span>               <span class="s">&quot;enable quick debug information&quot;</span><span class="p">),</span>
     <span class="n">clEnumVal</span><span class="p">(</span><span class="n">detailed</span><span class="p">,</span>            <span class="s">&quot;enable detailed debug information&quot;</span><span class="p">)));</span>
</pre></div>
</div>
<p>This definition defines an enumerated command line variable of type “<code class="docutils literal"><span class="pre">enum</span>
<span class="pre">DebugLev</span></code>”, which works exactly the same way as before.  The difference here is
just the interface exposed to the user of your program and the help output by
the “<code class="docutils literal"><span class="pre">-help</span></code>” option:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">USAGE</span><span class="p">:</span> <span class="n">compiler</span> <span class="p">[</span><span class="n">options</span><span class="p">]</span> <span class="o">&lt;</span><span class="nb">input</span> <span class="n">file</span><span class="o">&gt;</span>

<span class="n">OPTIONS</span><span class="p">:</span>
  <span class="n">Choose</span> <span class="n">optimization</span> <span class="n">level</span><span class="p">:</span>
    <span class="o">-</span><span class="n">g</span>          <span class="o">-</span> <span class="n">No</span> <span class="n">optimizations</span><span class="p">,</span> <span class="n">enable</span> <span class="n">debugging</span>
    <span class="o">-</span><span class="n">O1</span>         <span class="o">-</span> <span class="n">Enable</span> <span class="n">trivial</span> <span class="n">optimizations</span>
    <span class="o">-</span><span class="n">O2</span>         <span class="o">-</span> <span class="n">Enable</span> <span class="n">default</span> <span class="n">optimizations</span>
    <span class="o">-</span><span class="n">O3</span>         <span class="o">-</span> <span class="n">Enable</span> <span class="n">expensive</span> <span class="n">optimizations</span>
  <span class="o">-</span><span class="n">debug_level</span>  <span class="o">-</span> <span class="n">Set</span> <span class="n">the</span> <span class="n">debugging</span> <span class="n">level</span><span class="p">:</span>
    <span class="o">=</span><span class="n">none</span>       <span class="o">-</span> <span class="n">disable</span> <span class="n">debug</span> <span class="n">information</span>
    <span class="o">=</span><span class="n">quick</span>      <span class="o">-</span> <span class="n">enable</span> <span class="n">quick</span> <span class="n">debug</span> <span class="n">information</span>
    <span class="o">=</span><span class="n">detailed</span>   <span class="o">-</span> <span class="n">enable</span> <span class="n">detailed</span> <span class="n">debug</span> <span class="n">information</span>
  <span class="o">-</span><span class="n">f</span>            <span class="o">-</span> <span class="n">Enable</span> <span class="n">binary</span> <span class="n">output</span> <span class="n">on</span> <span class="n">terminals</span>
  <span class="o">-</span><span class="n">help</span>         <span class="o">-</span> <span class="n">display</span> <span class="n">available</span> <span class="n">options</span> <span class="p">(</span><span class="o">-</span><span class="n">help</span><span class="o">-</span><span class="n">hidden</span> <span class="k">for</span> <span class="n">more</span><span class="p">)</span>
  <span class="o">-</span><span class="n">o</span> <span class="o">&lt;</span><span class="n">filename</span><span class="o">&gt;</span> <span class="o">-</span> <span class="n">Specify</span> <span class="n">output</span> <span class="n">filename</span>
  <span class="o">-</span><span class="n">quiet</span>        <span class="o">-</span> <span class="n">Don</span><span class="s1">&#39;t print informational messages</span>
</pre></div>
</div>
<p>Again, the only structural difference between the debug level declaration and
the optimization level declaration is that the debug level declaration includes
an option name (<code class="docutils literal"><span class="pre">&quot;debug_level&quot;</span></code>), which automatically changes how the library
processes the argument.  The CommandLine library supports both forms so that you
can choose the form most appropriate for your application.</p>
</div>
<div class="section" id="parsing-a-list-of-options">
<span id="lists"></span><h3><a class="toc-backref" href="#id14">Parsing a list of options</a><a class="headerlink" href="#parsing-a-list-of-options" title="Permalink to this headline">¶</a></h3>
<p>Now that we have the standard run-of-the-mill argument types out of the way,
lets get a little wild and crazy.  Lets say that we want our optimizer to accept
a <strong>list</strong> of optimizations to perform, allowing duplicates.  For example, we
might want to run: “<code class="docutils literal"><span class="pre">compiler</span> <span class="pre">-dce</span> <span class="pre">-constprop</span> <span class="pre">-inline</span> <span class="pre">-dce</span> <span class="pre">-strip</span></code>”.  In this
case, the order of the arguments and the number of appearances is very
important.  This is what the “<code class="docutils literal"><span class="pre">cl::list</span></code>” template is for.  First, start by
defining an enum of the optimizations that you would like to perform:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">enum</span> <span class="n">Opts</span> <span class="p">{</span>
  <span class="c1">// &#39;inline&#39; is a C++ keyword, so name it &#39;inlining&#39;</span>
  <span class="n">dce</span><span class="p">,</span> <span class="n">constprop</span><span class="p">,</span> <span class="n">inlining</span><span class="p">,</span> <span class="n">strip</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Then define your “<code class="docutils literal"><span class="pre">cl::list</span></code>” variable:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">cl</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">Opts</span><span class="o">&gt;</span> <span class="n">OptimizationList</span><span class="p">(</span><span class="n">cl</span><span class="o">::</span><span class="n">desc</span><span class="p">(</span><span class="s">&quot;Available Optimizations:&quot;</span><span class="p">),</span>
  <span class="n">cl</span><span class="o">::</span><span class="n">values</span><span class="p">(</span>
    <span class="n">clEnumVal</span><span class="p">(</span><span class="n">dce</span>               <span class="p">,</span> <span class="s">&quot;Dead Code Elimination&quot;</span><span class="p">),</span>
    <span class="n">clEnumVal</span><span class="p">(</span><span class="n">constprop</span>         <span class="p">,</span> <span class="s">&quot;Constant Propagation&quot;</span><span class="p">),</span>
   <span class="n">clEnumValN</span><span class="p">(</span><span class="n">inlining</span><span class="p">,</span> <span class="s">&quot;inline&quot;</span><span class="p">,</span> <span class="s">&quot;Procedure Integration&quot;</span><span class="p">),</span>
    <span class="n">clEnumVal</span><span class="p">(</span><span class="n">strip</span>             <span class="p">,</span> <span class="s">&quot;Strip Symbols&quot;</span><span class="p">)));</span>
</pre></div>
</div>
<p>This defines a variable that is conceptually of the type
“<code class="docutils literal"><span class="pre">std::vector&lt;enum</span> <span class="pre">Opts&gt;</span></code>”.  Thus, you can access it with standard vector
methods:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">OptimizationList</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">OptimizationList</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
     <span class="p">...</span>
</pre></div>
</div>
<p>… to iterate through the list of options specified.</p>
<p>Note that the “<code class="docutils literal"><span class="pre">cl::list</span></code>” template is completely general and may be used with
any data types or other arguments that you can use with the “<code class="docutils literal"><span class="pre">cl::opt</span></code>”
template.  One especially useful way to use a list is to capture all of the
positional arguments together if there may be more than one specified.  In the
case of a linker, for example, the linker takes several ‘<code class="docutils literal"><span class="pre">.o</span></code>’ files, and
needs to capture them into a list.  This is naturally specified as:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="p">...</span>
<span class="n">cl</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">InputFilenames</span><span class="p">(</span><span class="n">cl</span><span class="o">::</span><span class="n">Positional</span><span class="p">,</span> <span class="n">cl</span><span class="o">::</span><span class="n">desc</span><span class="p">(</span><span class="s">&quot;&lt;Input files&gt;&quot;</span><span class="p">),</span> <span class="n">cl</span><span class="o">::</span><span class="n">OneOrMore</span><span class="p">);</span>
<span class="p">...</span>
</pre></div>
</div>
<p>This variable works just like a “<code class="docutils literal"><span class="pre">vector&lt;string&gt;</span></code>” object.  As such, accessing
the list is simple, just like above.  In this example, we used the
<a class="reference internal" href="#cl-oneormore">cl::OneOrMore</a> modifier to inform the CommandLine library that it is an error
if the user does not specify any <code class="docutils literal"><span class="pre">.o</span></code> files on our command line.  Again, this
just reduces the amount of checking we have to do.</p>
</div>
<div class="section" id="collecting-options-as-a-set-of-flags">
<h3><a class="toc-backref" href="#id15">Collecting options as a set of flags</a><a class="headerlink" href="#collecting-options-as-a-set-of-flags" title="Permalink to this headline">¶</a></h3>
<p>Instead of collecting sets of options in a list, it is also possible to gather
information for enum values in a <strong>bit vector</strong>.  The representation used by the
<a class="reference internal" href="#cl-bits">cl::bits</a> class is an <code class="docutils literal"><span class="pre">unsigned</span></code> integer.  An enum value is represented by a
0/1 in the enum’s ordinal value bit position. 1 indicating that the enum was
specified, 0 otherwise.  As each specified value is parsed, the resulting enum’s
bit is set in the option’s bit vector:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">bits</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="k">enum</span><span class="p">;</span>
</pre></div>
</div>
<p>Options that are specified multiple times are redundant.  Any instances after
the first are discarded.</p>
<p>Reworking the above list example, we could replace <a class="reference internal" href="#cl-list">cl::list</a> with <a class="reference internal" href="#cl-bits">cl::bits</a>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">cl</span><span class="o">::</span><span class="n">bits</span><span class="o">&lt;</span><span class="n">Opts</span><span class="o">&gt;</span> <span class="n">OptimizationBits</span><span class="p">(</span><span class="n">cl</span><span class="o">::</span><span class="n">desc</span><span class="p">(</span><span class="s">&quot;Available Optimizations:&quot;</span><span class="p">),</span>
  <span class="n">cl</span><span class="o">::</span><span class="n">values</span><span class="p">(</span>
    <span class="n">clEnumVal</span><span class="p">(</span><span class="n">dce</span>               <span class="p">,</span> <span class="s">&quot;Dead Code Elimination&quot;</span><span class="p">),</span>
    <span class="n">clEnumVal</span><span class="p">(</span><span class="n">constprop</span>         <span class="p">,</span> <span class="s">&quot;Constant Propagation&quot;</span><span class="p">),</span>
   <span class="n">clEnumValN</span><span class="p">(</span><span class="n">inlining</span><span class="p">,</span> <span class="s">&quot;inline&quot;</span><span class="p">,</span> <span class="s">&quot;Procedure Integration&quot;</span><span class="p">),</span>
    <span class="n">clEnumVal</span><span class="p">(</span><span class="n">strip</span>             <span class="p">,</span> <span class="s">&quot;Strip Symbols&quot;</span><span class="p">)));</span>
</pre></div>
</div>
<p>To test to see if <code class="docutils literal"><span class="pre">constprop</span></code> was specified, we can use the <code class="docutils literal"><span class="pre">cl:bits::isSet</span></code>
function:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">OptimizationBits</span><span class="p">.</span><span class="n">isSet</span><span class="p">(</span><span class="n">constprop</span><span class="p">))</span> <span class="p">{</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>It’s also possible to get the raw bit vector using the <code class="docutils literal"><span class="pre">cl::bits::getBits</span></code>
function:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">unsigned</span> <span class="n">bits</span> <span class="o">=</span> <span class="n">OptimizationBits</span><span class="p">.</span><span class="n">getBits</span><span class="p">();</span>
</pre></div>
</div>
<p>Finally, if external storage is used, then the location specified must be of
<strong>type</strong> <code class="docutils literal"><span class="pre">unsigned</span></code>. In all other ways a <a class="reference internal" href="#cl-bits">cl::bits</a> option is equivalent to a
<a class="reference internal" href="#cl-list">cl::list</a> option.</p>
</div>
<div class="section" id="adding-freeform-text-to-help-output">
<span id="additional-extra-text"></span><h3><a class="toc-backref" href="#id16">Adding freeform text to help output</a><a class="headerlink" href="#adding-freeform-text-to-help-output" title="Permalink to this headline">¶</a></h3>
<p>As our program grows and becomes more mature, we may decide to put summary
information about what it does into the help output.  The help output is styled
to look similar to a Unix <code class="docutils literal"><span class="pre">man</span></code> page, providing concise information about a
program.  Unix <code class="docutils literal"><span class="pre">man</span></code> pages, however often have a description about what the
program does.  To add this to your CommandLine program, simply pass a third
argument to the <a class="reference internal" href="#cl-parsecommandlineoptions">cl::ParseCommandLineOptions</a> call in main.  This additional
argument is then printed as the overview information for your program, allowing
you to include any additional information that you want.  For example:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">cl</span><span class="o">::</span><span class="n">ParseCommandLineOptions</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="s">&quot; CommandLine compiler example</span><span class="se">\n\n</span><span class="s">&quot;</span>
                              <span class="s">&quot;  This program blah blah blah...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>would yield the help output:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">**</span><span class="n">OVERVIEW</span><span class="p">:</span> <span class="n">CommandLine</span> <span class="n">compiler</span> <span class="n">example</span>

  <span class="n">This</span> <span class="n">program</span> <span class="n">blah</span> <span class="n">blah</span> <span class="n">blah</span><span class="o">...**</span>

<span class="n">USAGE</span><span class="p">:</span> <span class="n">compiler</span> <span class="p">[</span><span class="n">options</span><span class="p">]</span> <span class="o">&lt;</span><span class="nb">input</span> <span class="n">file</span><span class="o">&gt;</span>

<span class="n">OPTIONS</span><span class="p">:</span>
  <span class="o">...</span>
  <span class="o">-</span><span class="n">help</span>             <span class="o">-</span> <span class="n">display</span> <span class="n">available</span> <span class="n">options</span> <span class="p">(</span><span class="o">-</span><span class="n">help</span><span class="o">-</span><span class="n">hidden</span> <span class="k">for</span> <span class="n">more</span><span class="p">)</span>
  <span class="o">-</span><span class="n">o</span> <span class="o">&lt;</span><span class="n">filename</span><span class="o">&gt;</span>     <span class="o">-</span> <span class="n">Specify</span> <span class="n">output</span> <span class="n">filename</span>
</pre></div>
</div>
</div>
<div class="section" id="grouping-options-into-categories">
<span id="id1"></span><h3><a class="toc-backref" href="#id17">Grouping options into categories</a><a class="headerlink" href="#grouping-options-into-categories" title="Permalink to this headline">¶</a></h3>
<p>If our program has a large number of options it may become difficult for users
of our tool to navigate the output of <code class="docutils literal"><span class="pre">-help</span></code>. To alleviate this problem we
can put our options into categories. This can be done by declaring option
categories (<a class="reference internal" href="#cl-optioncategory">cl::OptionCategory</a> objects) and then placing our options into
these categories using the <a class="reference internal" href="#cl-cat">cl::cat</a> option attribute. For example:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">cl</span><span class="o">::</span><span class="n">OptionCategory</span> <span class="n">StageSelectionCat</span><span class="p">(</span><span class="s">&quot;Stage Selection Options&quot;</span><span class="p">,</span>
                                     <span class="s">&quot;These control which stages are run.&quot;</span><span class="p">);</span>

<span class="n">cl</span><span class="o">::</span><span class="n">opt</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">Preprocessor</span><span class="p">(</span><span class="s">&quot;E&quot;</span><span class="p">,</span><span class="n">cl</span><span class="o">::</span><span class="n">desc</span><span class="p">(</span><span class="s">&quot;Run preprocessor stage.&quot;</span><span class="p">),</span>
                           <span class="n">cl</span><span class="o">::</span><span class="n">cat</span><span class="p">(</span><span class="n">StageSelectionCat</span><span class="p">));</span>

<span class="n">cl</span><span class="o">::</span><span class="n">opt</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">NoLink</span><span class="p">(</span><span class="s">&quot;c&quot;</span><span class="p">,</span><span class="n">cl</span><span class="o">::</span><span class="n">desc</span><span class="p">(</span><span class="s">&quot;Run all stages except linking.&quot;</span><span class="p">),</span>
                     <span class="n">cl</span><span class="o">::</span><span class="n">cat</span><span class="p">(</span><span class="n">StageSelectionCat</span><span class="p">));</span>
</pre></div>
</div>
<p>The output of <code class="docutils literal"><span class="pre">-help</span></code> will become categorized if an option category is
declared. The output looks something like</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">OVERVIEW</span><span class="p">:</span> <span class="n">This</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">small</span> <span class="n">program</span> <span class="n">to</span> <span class="n">demo</span> <span class="n">the</span> <span class="n">LLVM</span> <span class="n">CommandLine</span> <span class="n">API</span>
<span class="n">USAGE</span><span class="p">:</span> <span class="n">Sample</span> <span class="p">[</span><span class="n">options</span><span class="p">]</span>

<span class="n">OPTIONS</span><span class="p">:</span>

  <span class="n">General</span> <span class="n">options</span><span class="p">:</span>

    <span class="o">-</span><span class="n">help</span>              <span class="o">-</span> <span class="n">Display</span> <span class="n">available</span> <span class="n">options</span> <span class="p">(</span><span class="o">-</span><span class="n">help</span><span class="o">-</span><span class="n">hidden</span> <span class="k">for</span> <span class="n">more</span><span class="p">)</span>
    <span class="o">-</span><span class="n">help</span><span class="o">-</span><span class="nb">list</span>         <span class="o">-</span> <span class="n">Display</span> <span class="nb">list</span> <span class="n">of</span> <span class="n">available</span> <span class="n">options</span> <span class="p">(</span><span class="o">-</span><span class="n">help</span><span class="o">-</span><span class="nb">list</span><span class="o">-</span><span class="n">hidden</span> <span class="k">for</span> <span class="n">more</span><span class="p">)</span>


  <span class="n">Stage</span> <span class="n">Selection</span> <span class="n">Options</span><span class="p">:</span>
  <span class="n">These</span> <span class="n">control</span> <span class="n">which</span> <span class="n">stages</span> <span class="n">are</span> <span class="n">run</span><span class="o">.</span>

    <span class="o">-</span><span class="n">E</span>                 <span class="o">-</span> <span class="n">Run</span> <span class="n">preprocessor</span> <span class="n">stage</span><span class="o">.</span>
    <span class="o">-</span><span class="n">c</span>                 <span class="o">-</span> <span class="n">Run</span> <span class="nb">all</span> <span class="n">stages</span> <span class="k">except</span> <span class="n">linking</span><span class="o">.</span>
</pre></div>
</div>
<p>In addition to the behaviour of <code class="docutils literal"><span class="pre">-help</span></code> changing when an option category is
declared, the command line option <code class="docutils literal"><span class="pre">-help-list</span></code> becomes visible which will
print the command line options as uncategorized list.</p>
<p>Note that Options that are not explicitly categorized will be placed in the
<code class="docutils literal"><span class="pre">cl::GeneralCategory</span></code> category.</p>
</div>
</div>
<div class="section" id="reference-guide">
<span id="id2"></span><h2><a class="toc-backref" href="#id18">Reference Guide</a><a class="headerlink" href="#reference-guide" title="Permalink to this headline">¶</a></h2>
<p>Now that you know the basics of how to use the CommandLine library, this section
will give you the detailed information you need to tune how command line options
work, as well as information on more “advanced” command line option processing
capabilities.</p>
<div class="section" id="positional-options">
<span id="positional-arguments-section"></span><span id="positional-arguments"></span><span id="positional-argument"></span><span id="positional"></span><span id="id3"></span><h3><a class="toc-backref" href="#id19">Positional Arguments</a><a class="headerlink" href="#positional-options" title="Permalink to this headline">¶</a></h3>
<p>Positional arguments are those arguments that are not named, and are not
specified with a hyphen.  Positional arguments should be used when an option is
specified by its position alone.  For example, the standard Unix <code class="docutils literal"><span class="pre">grep</span></code> tool
takes a regular expression argument, and an optional filename to search through
(which defaults to standard input if a filename is not specified).  Using the
CommandLine library, this would be specified as:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">cl</span><span class="o">::</span><span class="n">opt</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">Regex</span>   <span class="p">(</span><span class="n">cl</span><span class="o">::</span><span class="n">Positional</span><span class="p">,</span> <span class="n">cl</span><span class="o">::</span><span class="n">desc</span><span class="p">(</span><span class="s">&quot;&lt;regular expression&gt;&quot;</span><span class="p">),</span> <span class="n">cl</span><span class="o">::</span><span class="n">Required</span><span class="p">);</span>
<span class="n">cl</span><span class="o">::</span><span class="n">opt</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">Filename</span><span class="p">(</span><span class="n">cl</span><span class="o">::</span><span class="n">Positional</span><span class="p">,</span> <span class="n">cl</span><span class="o">::</span><span class="n">desc</span><span class="p">(</span><span class="s">&quot;&lt;input file&gt;&quot;</span><span class="p">),</span> <span class="n">cl</span><span class="o">::</span><span class="n">init</span><span class="p">(</span><span class="s">&quot;-&quot;</span><span class="p">));</span>
</pre></div>
</div>
<p>Given these two option declarations, the <code class="docutils literal"><span class="pre">-help</span></code> output for our grep
replacement would look like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">USAGE</span><span class="p">:</span> <span class="n">spiffygrep</span> <span class="p">[</span><span class="n">options</span><span class="p">]</span> <span class="o">&lt;</span><span class="n">regular</span> <span class="n">expression</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="nb">input</span> <span class="n">file</span><span class="o">&gt;</span>

<span class="n">OPTIONS</span><span class="p">:</span>
  <span class="o">-</span><span class="n">help</span> <span class="o">-</span> <span class="n">display</span> <span class="n">available</span> <span class="n">options</span> <span class="p">(</span><span class="o">-</span><span class="n">help</span><span class="o">-</span><span class="n">hidden</span> <span class="k">for</span> <span class="n">more</span><span class="p">)</span>
</pre></div>
</div>
<p>… and the resultant program could be used just like the standard <code class="docutils literal"><span class="pre">grep</span></code>
tool.</p>
<p>Positional arguments are sorted by their order of construction.  This means that
command line options will be ordered according to how they are listed in a .cpp
file, but will not have an ordering defined if the positional arguments are
defined in multiple .cpp files.  The fix for this problem is simply to define
all of your positional arguments in one .cpp file.</p>
<div class="section" id="specifying-positional-options-with-hyphens">
<h4><a class="toc-backref" href="#id20">Specifying positional options with hyphens</a><a class="headerlink" href="#specifying-positional-options-with-hyphens" title="Permalink to this headline">¶</a></h4>
<p>Sometimes you may want to specify a value to your positional argument that
starts with a hyphen (for example, searching for ‘<code class="docutils literal"><span class="pre">-foo</span></code>’ in a file).  At
first, you will have trouble doing this, because it will try to find an argument
named ‘<code class="docutils literal"><span class="pre">-foo</span></code>’, and will fail (and single quotes will not save you).  Note
that the system <code class="docutils literal"><span class="pre">grep</span></code> has the same problem:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>$ spiffygrep &#39;-foo&#39; test.txt
Unknown command line argument &#39;-foo&#39;.  Try: spiffygrep -help&#39;

$ grep &#39;-foo&#39; test.txt
grep: illegal option -- f
grep: illegal option -- o
grep: illegal option -- o
Usage: grep -hblcnsviw pattern file . . .
</pre></div>
</div>
<p>The solution for this problem is the same for both your tool and the system
version: use the ‘<code class="docutils literal"><span class="pre">--</span></code>‘ marker.  When the user specifies ‘<code class="docutils literal"><span class="pre">--</span></code>‘ on the
command line, it is telling the program that all options after the ‘<code class="docutils literal"><span class="pre">--</span></code>‘
should be treated as positional arguments, not options.  Thus, we can use it
like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>$ spiffygrep -- -foo test.txt
  ...output...
</pre></div>
</div>
</div>
<div class="section" id="determining-absolute-position-with-getposition">
<h4><a class="toc-backref" href="#id21">Determining absolute position with getPosition()</a><a class="headerlink" href="#determining-absolute-position-with-getposition" title="Permalink to this headline">¶</a></h4>
<p>Sometimes an option can affect or modify the meaning of another option. For
example, consider <code class="docutils literal"><span class="pre">gcc</span></code>’s <code class="docutils literal"><span class="pre">-x</span> <span class="pre">LANG</span></code> option. This tells <code class="docutils literal"><span class="pre">gcc</span></code> to ignore the
suffix of subsequent positional arguments and force the file to be interpreted
as if it contained source code in language <code class="docutils literal"><span class="pre">LANG</span></code>. In order to handle this
properly, you need to know the absolute position of each argument, especially
those in lists, so their interaction(s) can be applied correctly. This is also
useful for options like <code class="docutils literal"><span class="pre">-llibname</span></code> which is actually a positional argument
that starts with a dash.</p>
<p>So, generally, the problem is that you have two <code class="docutils literal"><span class="pre">cl::list</span></code> variables that
interact in some way. To ensure the correct interaction, you can use the
<code class="docutils literal"><span class="pre">cl::list::getPosition(optnum)</span></code> method. This method returns the absolute
position (as found on the command line) of the <code class="docutils literal"><span class="pre">optnum</span></code> item in the
<code class="docutils literal"><span class="pre">cl::list</span></code>.</p>
<p>The idiom for usage is like this:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="n">cl</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">Files</span><span class="p">(</span><span class="n">cl</span><span class="o">::</span><span class="n">Positional</span><span class="p">,</span> <span class="n">cl</span><span class="o">::</span><span class="n">OneOrMore</span><span class="p">);</span>
<span class="k">static</span> <span class="n">cl</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">Libraries</span><span class="p">(</span><span class="s">&quot;l&quot;</span><span class="p">,</span> <span class="n">cl</span><span class="o">::</span><span class="n">ZeroOrMore</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">fileIt</span> <span class="o">=</span> <span class="n">Files</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">libIt</span>  <span class="o">=</span> <span class="n">Libraries</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
  <span class="kt">unsigned</span> <span class="n">libPos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">filePos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span> <span class="mi">1</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">libIt</span> <span class="o">!=</span> <span class="n">Libraries</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="p">)</span>
      <span class="n">libPos</span> <span class="o">=</span> <span class="n">Libraries</span><span class="p">.</span><span class="n">getPosition</span><span class="p">(</span> <span class="n">libIt</span> <span class="o">-</span> <span class="n">Libraries</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="p">);</span>
    <span class="k">else</span>
      <span class="n">libPos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">fileIt</span> <span class="o">!=</span> <span class="n">Files</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="p">)</span>
      <span class="n">filePos</span> <span class="o">=</span> <span class="n">Files</span><span class="p">.</span><span class="n">getPosition</span><span class="p">(</span> <span class="n">fileIt</span> <span class="o">-</span> <span class="n">Files</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="p">);</span>
    <span class="k">else</span>
      <span class="n">filePos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span> <span class="n">filePos</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">libPos</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">filePos</span> <span class="o">&lt;</span> <span class="n">libPos</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
      <span class="c1">// Source File Is next</span>
      <span class="o">++</span><span class="n">fileIt</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span> <span class="n">libPos</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">filePos</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">libPos</span> <span class="o">&lt;</span> <span class="n">filePos</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
      <span class="c1">// Library is next</span>
      <span class="o">++</span><span class="n">libIt</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span>
      <span class="k">break</span><span class="p">;</span> <span class="c1">// we&#39;re done with the list</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note that, for compatibility reasons, the <code class="docutils literal"><span class="pre">cl::opt</span></code> also supports an
<code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">getPosition()</span></code> option that will provide the absolute position of
that option. You can apply the same approach as above with a <code class="docutils literal"><span class="pre">cl::opt</span></code> and a
<code class="docutils literal"><span class="pre">cl::list</span></code> option as you can with two lists.</p>
</div>
<div class="section" id="the-cl-consumeafter-modifier">
<span id="this-section-for-more-information"></span><span id="cl-consumeafter"></span><span id="interpreter-style-options"></span><h4><a class="toc-backref" href="#id22">The <code class="docutils literal"><span class="pre">cl::ConsumeAfter</span></code> modifier</a><a class="headerlink" href="#the-cl-consumeafter-modifier" title="Permalink to this headline">¶</a></h4>
<p>The <code class="docutils literal"><span class="pre">cl::ConsumeAfter</span></code> <a class="reference internal" href="#formatting-option">formatting option</a> is used to construct programs that
use “interpreter style” option processing.  With this style of option
processing, all arguments specified after the last positional argument are
treated as special interpreter arguments that are not interpreted by the command
line argument.</p>
<p>As a concrete example, lets say we are developing a replacement for the standard
Unix Bourne shell (<code class="docutils literal"><span class="pre">/bin/sh</span></code>).  To run <code class="docutils literal"><span class="pre">/bin/sh</span></code>, first you specify options
to the shell itself (like <code class="docutils literal"><span class="pre">-x</span></code> which turns on trace output), then you specify
the name of the script to run, then you specify arguments to the script.  These
arguments to the script are parsed by the Bourne shell command line option
processor, but are not interpreted as options to the shell itself.  Using the
CommandLine library, we would specify this as:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">cl</span><span class="o">::</span><span class="n">opt</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">Script</span><span class="p">(</span><span class="n">cl</span><span class="o">::</span><span class="n">Positional</span><span class="p">,</span> <span class="n">cl</span><span class="o">::</span><span class="n">desc</span><span class="p">(</span><span class="s">&quot;&lt;input script&gt;&quot;</span><span class="p">),</span> <span class="n">cl</span><span class="o">::</span><span class="n">init</span><span class="p">(</span><span class="s">&quot;-&quot;</span><span class="p">));</span>
<span class="n">cl</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span>  <span class="n">Argv</span><span class="p">(</span><span class="n">cl</span><span class="o">::</span><span class="n">ConsumeAfter</span><span class="p">,</span> <span class="n">cl</span><span class="o">::</span><span class="n">desc</span><span class="p">(</span><span class="s">&quot;&lt;program arguments&gt;...&quot;</span><span class="p">));</span>
<span class="n">cl</span><span class="o">::</span><span class="n">opt</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span>    <span class="n">Trace</span><span class="p">(</span><span class="s">&quot;x&quot;</span><span class="p">,</span> <span class="n">cl</span><span class="o">::</span><span class="n">desc</span><span class="p">(</span><span class="s">&quot;Enable trace output&quot;</span><span class="p">));</span>
</pre></div>
</div>
<p>which automatically provides the help output:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">USAGE</span><span class="p">:</span> <span class="n">spiffysh</span> <span class="p">[</span><span class="n">options</span><span class="p">]</span> <span class="o">&lt;</span><span class="nb">input</span> <span class="n">script</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">program</span> <span class="n">arguments</span><span class="o">&gt;...</span>

<span class="n">OPTIONS</span><span class="p">:</span>
  <span class="o">-</span><span class="n">help</span> <span class="o">-</span> <span class="n">display</span> <span class="n">available</span> <span class="n">options</span> <span class="p">(</span><span class="o">-</span><span class="n">help</span><span class="o">-</span><span class="n">hidden</span> <span class="k">for</span> <span class="n">more</span><span class="p">)</span>
  <span class="o">-</span><span class="n">x</span>    <span class="o">-</span> <span class="n">Enable</span> <span class="n">trace</span> <span class="n">output</span>
</pre></div>
</div>
<p>At runtime, if we run our new shell replacement as <code class="docutils literal"><span class="pre">`spiffysh</span> <span class="pre">-x</span> <span class="pre">test.sh</span> <span class="pre">-a</span> <span class="pre">-x</span>
<span class="pre">-y</span> <span class="pre">bar</span></code>’, the <code class="docutils literal"><span class="pre">Trace</span></code> variable will be set to true, the <code class="docutils literal"><span class="pre">Script</span></code> variable
will be set to “<code class="docutils literal"><span class="pre">test.sh</span></code>”, and the <code class="docutils literal"><span class="pre">Argv</span></code> list will contain <code class="docutils literal"><span class="pre">[&quot;-a&quot;,</span> <span class="pre">&quot;-x&quot;,</span>
<span class="pre">&quot;-y&quot;,</span> <span class="pre">&quot;bar&quot;]</span></code>, because they were specified after the last positional argument
(which is the script name).</p>
<p>There are several limitations to when <code class="docutils literal"><span class="pre">cl::ConsumeAfter</span></code> options can be
specified.  For example, only one <code class="docutils literal"><span class="pre">cl::ConsumeAfter</span></code> can be specified per
program, there must be at least one <a class="reference internal" href="#positional-argument">positional argument</a> specified, there must
not be any <a class="reference internal" href="#cl-list">cl::list</a> positional arguments, and the <code class="docutils literal"><span class="pre">cl::ConsumeAfter</span></code> option
should be a <a class="reference internal" href="#cl-list">cl::list</a> option.</p>
</div>
</div>
<div class="section" id="internal-vs-external-storage">
<span id="can-be-changed"></span><span id="id4"></span><h3><a class="toc-backref" href="#id23">Internal vs External Storage</a><a class="headerlink" href="#internal-vs-external-storage" title="Permalink to this headline">¶</a></h3>
<p>By default, all command line options automatically hold the value that they
parse from the command line.  This is very convenient in the common case,
especially when combined with the ability to define command line options in the
files that use them.  This is called the internal storage model.</p>
<p>Sometimes, however, it is nice to separate the command line option processing
code from the storage of the value parsed.  For example, lets say that we have a
‘<code class="docutils literal"><span class="pre">-debug</span></code>’ option that we would like to use to enable debug information across
the entire body of our program.  In this case, the boolean value controlling the
debug code should be globally accessible (in a header file, for example) yet the
command line option processing code should not be exposed to all of these
clients (requiring lots of .cpp files to <code class="docutils literal"><span class="pre">#include</span> <span class="pre">CommandLine.h</span></code>).</p>
<p>To do this, set up your .h file with your option, like this for example:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="c1">// DebugFlag.h - Get access to the &#39;-debug&#39; command line option</span>
<span class="c1">//</span>

<span class="c1">// DebugFlag - This boolean is set to true if the &#39;-debug&#39; command line option</span>
<span class="c1">// is specified.  This should probably not be referenced directly, instead, use</span>
<span class="c1">// the DEBUG macro below.</span>
<span class="c1">//</span>
<span class="k">extern</span> <span class="kt">bool</span> <span class="n">DebugFlag</span><span class="p">;</span>

<span class="c1">// DEBUG macro - This macro should be used by code to emit debug information.</span>
<span class="c1">// In the &#39;-debug&#39; option is specified on the command line, and if this is a</span>
<span class="c1">// debug build, then the code specified as the option to the macro will be</span>
<span class="c1">// executed.  Otherwise it will not be.</span>
<span class="cp">#ifdef NDEBUG</span>
<span class="cp">#define DEBUG(X)</span>
<span class="cp">#else</span>
<span class="cp">#define DEBUG(X) do { if (DebugFlag) { X; } } while (0)</span>
<span class="cp">#endif</span>
</pre></div>
</div>
<p>This allows clients to blissfully use the <code class="docutils literal"><span class="pre">DEBUG()</span></code> macro, or the
<code class="docutils literal"><span class="pre">DebugFlag</span></code> explicitly if they want to.  Now we just need to be able to set
the <code class="docutils literal"><span class="pre">DebugFlag</span></code> boolean when the option is set.  To do this, we pass an
additional argument to our command line argument processor, and we specify where
to fill in with the <a class="reference internal" href="#cl-location">cl::location</a> attribute:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="n">DebugFlag</span><span class="p">;</span>                  <span class="c1">// the actual value</span>
<span class="k">static</span> <span class="n">cl</span><span class="o">::</span><span class="n">opt</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span> <span class="nb">true</span><span class="o">&gt;</span>       <span class="c1">// The parser</span>
<span class="n">Debug</span><span class="p">(</span><span class="s">&quot;debug&quot;</span><span class="p">,</span> <span class="n">cl</span><span class="o">::</span><span class="n">desc</span><span class="p">(</span><span class="s">&quot;Enable debug output&quot;</span><span class="p">),</span> <span class="n">cl</span><span class="o">::</span><span class="n">Hidden</span><span class="p">,</span> <span class="n">cl</span><span class="o">::</span><span class="n">location</span><span class="p">(</span><span class="n">DebugFlag</span><span class="p">));</span>
</pre></div>
</div>
<p>In the above example, we specify “<code class="docutils literal"><span class="pre">true</span></code>” as the second argument to the
<a class="reference internal" href="#cl-opt">cl::opt</a> template, indicating that the template should not maintain a copy of
the value itself.  In addition to this, we specify the <a class="reference internal" href="#cl-location">cl::location</a>
attribute, so that <code class="docutils literal"><span class="pre">DebugFlag</span></code> is automatically set.</p>
</div>
<div class="section" id="option-attributes">
<h3><a class="toc-backref" href="#id24">Option Attributes</a><a class="headerlink" href="#option-attributes" title="Permalink to this headline">¶</a></h3>
<p>This section describes the basic attributes that you can specify on options.</p>
<ul>
<li><p class="first">The option name attribute (which is required for all options, except
<a class="reference internal" href="#positional-options">positional options</a>) specifies what the option name is.  This option is
specified in simple double quotes:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">cl</span><span class="o">::</span><span class="n">opt</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">Quiet</span><span class="p">(</span><span class="s">&quot;quiet&quot;</span><span class="p">);</span>
</pre></div>
</div>
</li>
</ul>
<ul class="simple" id="cl-desc">
<li>The <strong>cl::desc</strong> attribute specifies a description for the option to be
shown in the <code class="docutils literal"><span class="pre">-help</span></code> output for the program. This attribute supports
multi-line descriptions with lines separated by ‘n’.</li>
</ul>
<ul class="simple" id="cl-value-desc">
<li>The <strong>cl::value_desc</strong> attribute specifies a string that can be used to
fine tune the <code class="docutils literal"><span class="pre">-help</span></code> output for a command line option.  Look <a class="reference internal" href="#here">here</a> for an
example.</li>
</ul>
<ul id="cl-init">
<li><p class="first">The <strong>cl::init</strong> attribute specifies an initial value for a <a class="reference internal" href="#scalar">scalar</a>
option.  If this attribute is not specified then the command line option value
defaults to the value created by the default constructor for the
type.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">If you specify both <strong>cl::init</strong> and <strong>cl::location</strong> for an option, you
must specify <strong>cl::location</strong> first, so that when the command-line parser
sees <strong>cl::init</strong>, it knows where to put the initial value. (You will get an
error at runtime if you don’t put them in the right order.)</p>
</div>
</li>
</ul>
<ul class="simple" id="cl-location">
<li>The <strong>cl::location</strong> attribute where to store the value for a parsed command
line option if using external storage.  See the section on <a class="reference internal" href="#internal-vs-external-storage">Internal vs
External Storage</a> for more information.</li>
</ul>
<ul class="simple" id="cl-aliasopt">
<li>The <strong>cl::aliasopt</strong> attribute specifies which option a <a class="reference internal" href="#cl-alias">cl::alias</a> option is
an alias for.</li>
</ul>
<ul id="cl-values">
<li><p class="first">The <strong>cl::values</strong> attribute specifies the string-to-value mapping to be used
by the generic parser.  It takes a list of (option, value, description)
triplets that specify the option name, the value mapped to, and the
description shown in the <code class="docutils literal"><span class="pre">-help</span></code> for the tool.  Because the generic parser
is used most frequently with enum values, two macros are often useful:</p>
<ol class="arabic simple">
<li>The <strong>clEnumVal</strong> macro is used as a nice simple way to specify a triplet
for an enum.  This macro automatically makes the option name be the same as
the enum name.  The first option to the macro is the enum, the second is
the description for the command line option.</li>
<li>The <strong>clEnumValN</strong> macro is used to specify macro options where the option
name doesn’t equal the enum name.  For this macro, the first argument is
the enum value, the second is the flag name, and the second is the
description.</li>
</ol>
<p>You will get a compile time error if you try to use cl::values with a parser
that does not support it.</p>
</li>
</ul>
<ul class="simple" id="cl-multi-val">
<li>The <strong>cl::multi_val</strong> attribute specifies that this option takes has multiple
values (example: <code class="docutils literal"><span class="pre">-sectalign</span> <span class="pre">segname</span> <span class="pre">sectname</span> <span class="pre">sectvalue</span></code>). This attribute
takes one unsigned argument - the number of values for the option. This
attribute is valid only on <code class="docutils literal"><span class="pre">cl::list</span></code> options (and will fail with compile
error if you try to use it with other option types). It is allowed to use all
of the usual modifiers on multi-valued options (besides
<code class="docutils literal"><span class="pre">cl::ValueDisallowed</span></code>, obviously).</li>
</ul>
<ul class="simple" id="cl-cat">
<li>The <strong>cl::cat</strong> attribute specifies the option category that the option
belongs to. The category should be a <a class="reference internal" href="#cl-optioncategory">cl::OptionCategory</a> object.</li>
</ul>
</div>
<div class="section" id="option-modifiers">
<h3><a class="toc-backref" href="#id25">Option Modifiers</a><a class="headerlink" href="#option-modifiers" title="Permalink to this headline">¶</a></h3>
<p>Option modifiers are the flags and expressions that you pass into the
constructors for <a class="reference internal" href="#cl-opt">cl::opt</a> and <a class="reference internal" href="#cl-list">cl::list</a>.  These modifiers give you the
ability to tweak how options are parsed and how <code class="docutils literal"><span class="pre">-help</span></code> output is generated to
fit your application well.</p>
<p>These options fall into five main categories:</p>
<ol class="arabic simple">
<li>Hiding an option from <code class="docutils literal"><span class="pre">-help</span></code> output</li>
<li>Controlling the number of occurrences required and allowed</li>
<li>Controlling whether or not a value must be specified</li>
<li>Controlling other formatting options</li>
<li>Miscellaneous option modifiers</li>
</ol>
<p>It is not possible to specify two options from the same category (you’ll get a
runtime error) to a single option, except for options in the miscellaneous
category.  The CommandLine library specifies defaults for all of these settings
that are the most useful in practice and the most common, which mean that you
usually shouldn’t have to worry about these.</p>
<div class="section" id="hiding-an-option-from-help-output">
<h4><a class="toc-backref" href="#id26">Hiding an option from <code class="docutils literal"><span class="pre">-help</span></code> output</a><a class="headerlink" href="#hiding-an-option-from-help-output" title="Permalink to this headline">¶</a></h4>
<p>The <code class="docutils literal"><span class="pre">cl::NotHidden</span></code>, <code class="docutils literal"><span class="pre">cl::Hidden</span></code>, and <code class="docutils literal"><span class="pre">cl::ReallyHidden</span></code> modifiers are
used to control whether or not an option appears in the <code class="docutils literal"><span class="pre">-help</span></code> and
<code class="docutils literal"><span class="pre">-help-hidden</span></code> output for the compiled program:</p>
<ul class="simple" id="cl-nothidden">
<li>The <strong>cl::NotHidden</strong> modifier (which is the default for <a class="reference internal" href="#cl-opt">cl::opt</a> and
<a class="reference internal" href="#cl-list">cl::list</a> options) indicates the option is to appear in both help
listings.</li>
</ul>
<ul class="simple" id="cl-hidden">
<li>The <strong>cl::Hidden</strong> modifier (which is the default for <a class="reference internal" href="#cl-alias">cl::alias</a> options)
indicates that the option should not appear in the <code class="docutils literal"><span class="pre">-help</span></code> output, but
should appear in the <code class="docutils literal"><span class="pre">-help-hidden</span></code> output.</li>
</ul>
<ul class="simple" id="cl-reallyhidden">
<li>The <strong>cl::ReallyHidden</strong> modifier indicates that the option should not appear
in any help output.</li>
</ul>
</div>
<div class="section" id="controlling-the-number-of-occurrences-required-and-allowed">
<h4><a class="toc-backref" href="#id27">Controlling the number of occurrences required and allowed</a><a class="headerlink" href="#controlling-the-number-of-occurrences-required-and-allowed" title="Permalink to this headline">¶</a></h4>
<p>This group of options is used to control how many time an option is allowed (or
required) to be specified on the command line of your program.  Specifying a
value for this setting allows the CommandLine library to do error checking for
you.</p>
<p>The allowed values for this option group are:</p>
<ul class="simple" id="cl-optional">
<li>The <strong>cl::Optional</strong> modifier (which is the default for the <a class="reference internal" href="#cl-opt">cl::opt</a> and
<a class="reference internal" href="#cl-alias">cl::alias</a> classes) indicates that your program will allow either zero or
one occurrence of the option to be specified.</li>
</ul>
<ul class="simple" id="cl-zeroormore">
<li>The <strong>cl::ZeroOrMore</strong> modifier (which is the default for the <a class="reference internal" href="#cl-list">cl::list</a>
class) indicates that your program will allow the option to be specified zero
or more times.</li>
</ul>
<ul class="simple" id="cl-required">
<li>The <strong>cl::Required</strong> modifier indicates that the specified option must be
specified exactly one time.</li>
</ul>
<ul class="simple" id="cl-oneormore">
<li>The <strong>cl::OneOrMore</strong> modifier indicates that the option must be specified at
least one time.</li>
<li>The <strong>cl::ConsumeAfter</strong> modifier is described in the <a class="reference internal" href="#positional-arguments-section">Positional arguments
section</a>.</li>
</ul>
<p>If an option is not specified, then the value of the option is equal to the
value specified by the <a class="reference internal" href="#cl-init">cl::init</a> attribute.  If the <code class="docutils literal"><span class="pre">cl::init</span></code> attribute is
not specified, the option value is initialized with the default constructor for
the data type.</p>
<p>If an option is specified multiple times for an option of the <a class="reference internal" href="#cl-opt">cl::opt</a> class,
only the last value will be retained.</p>
</div>
<div class="section" id="controlling-whether-or-not-a-value-must-be-specified">
<h4><a class="toc-backref" href="#id28">Controlling whether or not a value must be specified</a><a class="headerlink" href="#controlling-whether-or-not-a-value-must-be-specified" title="Permalink to this headline">¶</a></h4>
<p>This group of options is used to control whether or not the option allows a
value to be present.  In the case of the CommandLine library, a value is either
specified with an equal sign (e.g. ‘<code class="docutils literal"><span class="pre">-index-depth=17</span></code>’) or as a trailing
string (e.g. ‘<code class="docutils literal"><span class="pre">-o</span> <span class="pre">a.out</span></code>’).</p>
<p>The allowed values for this option group are:</p>
<ul class="simple" id="cl-valueoptional">
<li>The <strong>cl::ValueOptional</strong> modifier (which is the default for <code class="docutils literal"><span class="pre">bool</span></code> typed
options) specifies that it is acceptable to have a value, or not.  A boolean
argument can be enabled just by appearing on the command line, or it can have
an explicit ‘<code class="docutils literal"><span class="pre">-foo=true</span></code>’.  If an option is specified with this mode, it is
illegal for the value to be provided without the equal sign.  Therefore
‘<code class="docutils literal"><span class="pre">-foo</span> <span class="pre">true</span></code>’ is illegal.  To get this behavior, you must use
the <a class="reference internal" href="#cl-valuerequired">cl::ValueRequired</a> modifier.</li>
</ul>
<ul class="simple" id="cl-valuerequired">
<li>The <strong>cl::ValueRequired</strong> modifier (which is the default for all other types
except for <a class="reference internal" href="#unnamed-alternatives-using-the-generic-parser">unnamed alternatives using the generic parser</a>) specifies that a
value must be provided.  This mode informs the command line library that if an
option is not provides with an equal sign, that the next argument provided
must be the value.  This allows things like ‘<code class="docutils literal"><span class="pre">-o</span> <span class="pre">a.out</span></code>’ to work.</li>
</ul>
<ul class="simple" id="cl-valuedisallowed">
<li>The <strong>cl::ValueDisallowed</strong> modifier (which is the default for <a class="reference internal" href="#unnamed-alternatives-using-the-generic-parser">unnamed
alternatives using the generic parser</a>) indicates that it is a runtime error
for the user to specify a value.  This can be provided to disallow users from
providing options to boolean options (like ‘<code class="docutils literal"><span class="pre">-foo=true</span></code>’).</li>
</ul>
<p>In general, the default values for this option group work just like you would
want them to.  As mentioned above, you can specify the <a class="reference internal" href="#cl-valuedisallowed">cl::ValueDisallowed</a>
modifier to a boolean argument to restrict your command line parser.  These
options are mostly useful when <a class="reference internal" href="#extending-the-library">extending the library</a>.</p>
</div>
<div class="section" id="controlling-other-formatting-options">
<span id="formatting-option"></span><h4><a class="toc-backref" href="#id29">Controlling other formatting options</a><a class="headerlink" href="#controlling-other-formatting-options" title="Permalink to this headline">¶</a></h4>
<p>The formatting option group is used to specify that the command line option has
special abilities and is otherwise different from other command line arguments.
As usual, you can only specify one of these arguments at most.</p>
<ul class="simple" id="cl-normalformatting">
<li>The <strong>cl::NormalFormatting</strong> modifier (which is the default all options)
specifies that this option is “normal”.</li>
</ul>
<ul class="simple" id="cl-positional">
<li>The <strong>cl::Positional</strong> modifier specifies that this is a positional argument
that does not have a command line option associated with it.  See the
<a class="reference internal" href="#positional-arguments">Positional Arguments</a> section for more information.</li>
<li>The <strong>cl::ConsumeAfter</strong> modifier specifies that this option is used to
capture “interpreter style” arguments.  See <a class="reference internal" href="#this-section-for-more-information">this section for more
information</a>.</li>
</ul>
<span id="prefix"></span><ul class="simple" id="cl-prefix">
<li>The <strong>cl::Prefix</strong> modifier specifies that this option prefixes its value.
With ‘Prefix’ options, the equal sign does not separate the value from the
option name specified. Instead, the value is everything after the prefix,
including any equal sign if present. This is useful for processing odd
arguments like <code class="docutils literal"><span class="pre">-lmalloc</span></code> and <code class="docutils literal"><span class="pre">-L/usr/lib</span></code> in a linker tool or
<code class="docutils literal"><span class="pre">-DNAME=value</span></code> in a compiler tool.  Here, the ‘<code class="docutils literal"><span class="pre">l</span></code>’, ‘<code class="docutils literal"><span class="pre">D</span></code>’ and ‘<code class="docutils literal"><span class="pre">L</span></code>’
options are normal string (or list) options, that have the <strong>cl::Prefix</strong>
modifier added to allow the CommandLine library to recognize them.  Note that
<strong>cl::Prefix</strong> options must not have the <strong>cl::ValueDisallowed</strong> modifier
specified.</li>
</ul>
<span id="grouping"></span><ul class="simple" id="cl-grouping">
<li>The <strong>cl::Grouping</strong> modifier is used to implement Unix-style tools (like
<code class="docutils literal"><span class="pre">ls</span></code>) that have lots of single letter arguments, but only require a single
dash.  For example, the ‘<code class="docutils literal"><span class="pre">ls</span> <span class="pre">-labF</span></code>’ command actually enables four different
options, all of which are single letters.  Note that <strong>cl::Grouping</strong> options
cannot have values.</li>
</ul>
<p>The CommandLine library does not restrict how you use the <strong>cl::Prefix</strong> or
<strong>cl::Grouping</strong> modifiers, but it is possible to specify ambiguous argument
settings.  Thus, it is possible to have multiple letter options that are prefix
or grouping options, and they will still work as designed.</p>
<p>To do this, the CommandLine library uses a greedy algorithm to parse the input
option into (potentially multiple) prefix and grouping options.  The strategy
basically looks like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>parse(string OrigInput) {

1. string input = OrigInput;
2. if (isOption(input)) return getOption(input).parse();  // Normal option
3. while (!isOption(input) &amp;&amp; !input.empty()) input.pop_back();  // Remove the last letter
4. if (input.empty()) return error();  // No matching option
5. if (getOption(input).isPrefix())
     return getOption(input).parse(input);
6. while (!input.empty()) {  // Must be grouping options
     getOption(input).parse();
     OrigInput.erase(OrigInput.begin(), OrigInput.begin()+input.length());
     input = OrigInput;
     while (!isOption(input) &amp;&amp; !input.empty()) input.pop_back();
   }
7. if (!OrigInput.empty()) error();

}
</pre></div>
</div>
</div>
<div class="section" id="miscellaneous-option-modifiers">
<h4><a class="toc-backref" href="#id30">Miscellaneous option modifiers</a><a class="headerlink" href="#miscellaneous-option-modifiers" title="Permalink to this headline">¶</a></h4>
<p>The miscellaneous option modifiers are the only flags where you can specify more
than one flag from the set: they are not mutually exclusive.  These flags
specify boolean properties that modify the option.</p>
<ul class="simple" id="cl-commaseparated">
<li>The <strong>cl::CommaSeparated</strong> modifier indicates that any commas specified for an
option’s value should be used to split the value up into multiple values for
the option.  For example, these two options are equivalent when
<code class="docutils literal"><span class="pre">cl::CommaSeparated</span></code> is specified: “<code class="docutils literal"><span class="pre">-foo=a</span> <span class="pre">-foo=b</span> <span class="pre">-foo=c</span></code>” and
“<code class="docutils literal"><span class="pre">-foo=a,b,c</span></code>”.  This option only makes sense to be used in a case where the
option is allowed to accept one or more values (i.e. it is a <a class="reference internal" href="#cl-list">cl::list</a>
option).</li>
</ul>
<ul class="simple" id="cl-positionaleatsargs">
<li>The <strong>cl::PositionalEatsArgs</strong> modifier (which only applies to positional
arguments, and only makes sense for lists) indicates that positional argument
should consume any strings after it (including strings that start with a “-“)
up until another recognized positional argument.  For example, if you have two
“eating” positional arguments, “<code class="docutils literal"><span class="pre">pos1</span></code>” and “<code class="docutils literal"><span class="pre">pos2</span></code>”, the string “<code class="docutils literal"><span class="pre">-pos1</span>
<span class="pre">-foo</span> <span class="pre">-bar</span> <span class="pre">baz</span> <span class="pre">-pos2</span> <span class="pre">-bork</span></code>” would cause the “<code class="docutils literal"><span class="pre">-foo</span> <span class="pre">-bar</span> <span class="pre">-baz</span></code>” strings to
be applied to the “<code class="docutils literal"><span class="pre">-pos1</span></code>” option and the “<code class="docutils literal"><span class="pre">-bork</span></code>” string to be applied
to the “<code class="docutils literal"><span class="pre">-pos2</span></code>” option.</li>
</ul>
<ul class="simple" id="cl-sink">
<li>The <strong>cl::Sink</strong> modifier is used to handle unknown options. If there is at
least one option with <code class="docutils literal"><span class="pre">cl::Sink</span></code> modifier specified, the parser passes
unrecognized option strings to it as values instead of signaling an error. As
with <code class="docutils literal"><span class="pre">cl::CommaSeparated</span></code>, this modifier only makes sense with a <a class="reference internal" href="#cl-list">cl::list</a>
option.</li>
</ul>
<p>So far, these are the only three miscellaneous option modifiers.</p>
</div>
<div class="section" id="response-files">
<span id="id5"></span><h4><a class="toc-backref" href="#id31">Response files</a><a class="headerlink" href="#response-files" title="Permalink to this headline">¶</a></h4>
<p>Some systems, such as certain variants of Microsoft Windows and some older
Unices have a relatively low limit on command-line length. It is therefore
customary to use the so-called ‘response files’ to circumvent this
restriction. These files are mentioned on the command-line (using the “&#64;file”)
syntax. The program reads these files and inserts the contents into argv,
thereby working around the command-line length limits.</p>
</div>
</div>
<div class="section" id="top-level-classes-and-functions">
<h3><a class="toc-backref" href="#id32">Top-Level Classes and Functions</a><a class="headerlink" href="#top-level-classes-and-functions" title="Permalink to this headline">¶</a></h3>
<p>Despite all of the built-in flexibility, the CommandLine option library really
only consists of one function <a class="reference internal" href="#cl-parsecommandlineoptions">cl::ParseCommandLineOptions</a>) and three main
classes: <a class="reference internal" href="#cl-opt">cl::opt</a>, <a class="reference internal" href="#cl-list">cl::list</a>, and <a class="reference internal" href="#cl-alias">cl::alias</a>.  This section describes
these three classes in detail.</p>
<div class="section" id="the-cl-getregisteredoptions-function">
<span id="cl-getregisteredoptions"></span><h4><a class="toc-backref" href="#id33">The <code class="docutils literal"><span class="pre">cl::getRegisteredOptions</span></code> function</a><a class="headerlink" href="#the-cl-getregisteredoptions-function" title="Permalink to this headline">¶</a></h4>
<p>The <code class="docutils literal"><span class="pre">cl::getRegisteredOptions</span></code> function is designed to give a programmer
access to declared non-positional command line options so that how they appear
in <code class="docutils literal"><span class="pre">-help</span></code> can be modified prior to calling <a class="reference internal" href="#cl-parsecommandlineoptions">cl::ParseCommandLineOptions</a>.
Note this method should not be called during any static initialisation because
it cannot be guaranteed that all options will have been initialised. Hence it
should be called from <code class="docutils literal"><span class="pre">main</span></code>.</p>
<p>This function can be used to gain access to options declared in libraries that
the tool writter may not have direct access to.</p>
<p>The function retrieves a <a class="reference internal" href="ProgrammersManual.html#dss-stringmap"><span class="std std-ref">StringMap</span></a> that maps the option
string (e.g. <code class="docutils literal"><span class="pre">-help</span></code>) to an <code class="docutils literal"><span class="pre">Option*</span></code>.</p>
<p>Here is an example of how the function could be used:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">llvm</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">cl</span><span class="o">::</span><span class="n">OptionCategory</span> <span class="n">AnotherCategory</span><span class="p">(</span><span class="s">&quot;Some options&quot;</span><span class="p">);</span>

  <span class="n">StringMap</span><span class="o">&lt;</span><span class="n">cl</span><span class="o">::</span><span class="n">Option</span><span class="o">*&gt;</span> <span class="o">&amp;</span><span class="n">Map</span> <span class="o">=</span> <span class="n">cl</span><span class="o">::</span><span class="n">getRegisteredOptions</span><span class="p">();</span>

  <span class="c1">//Unhide useful option and put it in a different category</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">Map</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="s">&quot;print-all-options&quot;</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">Map</span><span class="p">[</span><span class="s">&quot;print-all-options&quot;</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">setHiddenFlag</span><span class="p">(</span><span class="n">cl</span><span class="o">::</span><span class="n">NotHidden</span><span class="p">);</span>
  <span class="n">Map</span><span class="p">[</span><span class="s">&quot;print-all-options&quot;</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">setCategory</span><span class="p">(</span><span class="n">AnotherCategory</span><span class="p">);</span>

  <span class="c1">//Hide an option we don&#39;t want to see</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">Map</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="s">&quot;enable-no-infs-fp-math&quot;</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">Map</span><span class="p">[</span><span class="s">&quot;enable-no-infs-fp-math&quot;</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">setHiddenFlag</span><span class="p">(</span><span class="n">cl</span><span class="o">::</span><span class="n">Hidden</span><span class="p">);</span>

  <span class="c1">//Change --version to --show-version</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">Map</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="s">&quot;version&quot;</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">Map</span><span class="p">[</span><span class="s">&quot;version&quot;</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">setArgStr</span><span class="p">(</span><span class="s">&quot;show-version&quot;</span><span class="p">);</span>

  <span class="c1">//Change --help description</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">Map</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="s">&quot;help&quot;</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">Map</span><span class="p">[</span><span class="s">&quot;help&quot;</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">setDescription</span><span class="p">(</span><span class="s">&quot;Shows help&quot;</span><span class="p">);</span>

  <span class="n">cl</span><span class="o">::</span><span class="n">ParseCommandLineOptions</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="s">&quot;This is a small program to demo the LLVM CommandLine API&quot;</span><span class="p">);</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="the-cl-parsecommandlineoptions-function">
<span id="cl-parsecommandlineoptions"></span><h4><a class="toc-backref" href="#id34">The <code class="docutils literal"><span class="pre">cl::ParseCommandLineOptions</span></code> function</a><a class="headerlink" href="#the-cl-parsecommandlineoptions-function" title="Permalink to this headline">¶</a></h4>
<p>The <code class="docutils literal"><span class="pre">cl::ParseCommandLineOptions</span></code> function is designed to be called directly
from <code class="docutils literal"><span class="pre">main</span></code>, and is used to fill in the values of all of the command line
option variables once <code class="docutils literal"><span class="pre">argc</span></code> and <code class="docutils literal"><span class="pre">argv</span></code> are available.</p>
<p>The <code class="docutils literal"><span class="pre">cl::ParseCommandLineOptions</span></code> function requires two parameters (<code class="docutils literal"><span class="pre">argc</span></code>
and <code class="docutils literal"><span class="pre">argv</span></code>), but may also take an optional third parameter which holds
<a class="reference internal" href="#additional-extra-text">additional extra text</a> to emit when the <code class="docutils literal"><span class="pre">-help</span></code> option is invoked.</p>
</div>
<div class="section" id="the-cl-parseenvironmentoptions-function">
<span id="cl-parseenvironmentoptions"></span><h4><a class="toc-backref" href="#id35">The <code class="docutils literal"><span class="pre">cl::ParseEnvironmentOptions</span></code> function</a><a class="headerlink" href="#the-cl-parseenvironmentoptions-function" title="Permalink to this headline">¶</a></h4>
<p>The <code class="docutils literal"><span class="pre">cl::ParseEnvironmentOptions</span></code> function has mostly the same effects as
<a class="reference internal" href="#cl-parsecommandlineoptions">cl::ParseCommandLineOptions</a>, except that it is designed to take values for
options from an environment variable, for those cases in which reading the
command line is not convenient or desired. It fills in the values of all the
command line option variables just like <a class="reference internal" href="#cl-parsecommandlineoptions">cl::ParseCommandLineOptions</a> does.</p>
<p>It takes four parameters: the name of the program (since <code class="docutils literal"><span class="pre">argv</span></code> may not be
available, it can’t just look in <code class="docutils literal"><span class="pre">argv[0]</span></code>), the name of the environment
variable to examine, and the optional <a class="reference internal" href="#additional-extra-text">additional extra text</a> to emit when the
<code class="docutils literal"><span class="pre">-help</span></code> option is invoked.</p>
<p><code class="docutils literal"><span class="pre">cl::ParseEnvironmentOptions</span></code> will break the environment variable’s value up
into words and then process them using <a class="reference internal" href="#cl-parsecommandlineoptions">cl::ParseCommandLineOptions</a>.
<strong>Note:</strong> Currently <code class="docutils literal"><span class="pre">cl::ParseEnvironmentOptions</span></code> does not support quoting, so
an environment variable containing <code class="docutils literal"><span class="pre">-option</span> <span class="pre">&quot;foo</span> <span class="pre">bar&quot;</span></code> will be parsed as three
words, <code class="docutils literal"><span class="pre">-option</span></code>, <code class="docutils literal"><span class="pre">&quot;foo</span></code>, and <code class="docutils literal"><span class="pre">bar&quot;</span></code>, which is different from what you
would get from the shell with the same input.</p>
</div>
<div class="section" id="the-cl-setversionprinter-function">
<h4><a class="toc-backref" href="#id36">The <code class="docutils literal"><span class="pre">cl::SetVersionPrinter</span></code> function</a><a class="headerlink" href="#the-cl-setversionprinter-function" title="Permalink to this headline">¶</a></h4>
<p>The <code class="docutils literal"><span class="pre">cl::SetVersionPrinter</span></code> function is designed to be called directly from
<code class="docutils literal"><span class="pre">main</span></code> and <em>before</em> <code class="docutils literal"><span class="pre">cl::ParseCommandLineOptions</span></code>. Its use is optional. It
simply arranges for a function to be called in response to the <code class="docutils literal"><span class="pre">--version</span></code>
option instead of having the <code class="docutils literal"><span class="pre">CommandLine</span></code> library print out the usual version
string for LLVM. This is useful for programs that are not part of LLVM but wish
to use the <code class="docutils literal"><span class="pre">CommandLine</span></code> facilities. Such programs should just define a small
function that takes no arguments and returns <code class="docutils literal"><span class="pre">void</span></code> and that prints out
whatever version information is appropriate for the program. Pass the address of
that function to <code class="docutils literal"><span class="pre">cl::SetVersionPrinter</span></code> to arrange for it to be called when
the <code class="docutils literal"><span class="pre">--version</span></code> option is given by the user.</p>
</div>
<div class="section" id="the-cl-opt-class">
<span id="scalar"></span><span id="cl-opt"></span><h4><a class="toc-backref" href="#id37">The <code class="docutils literal"><span class="pre">cl::opt</span></code> class</a><a class="headerlink" href="#the-cl-opt-class" title="Permalink to this headline">¶</a></h4>
<p>The <code class="docutils literal"><span class="pre">cl::opt</span></code> class is the class used to represent scalar command line
options, and is the one used most of the time.  It is a templated class which
can take up to three arguments (all except for the first have default values
though):</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">namespace</span> <span class="n">cl</span> <span class="p">{</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">DataType</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">ExternalStorage</span> <span class="o">=</span> <span class="nb">false</span><span class="p">,</span>
            <span class="k">class</span> <span class="nc">ParserClass</span> <span class="o">=</span> <span class="n">parser</span><span class="o">&lt;</span><span class="n">DataType</span><span class="o">&gt;</span> <span class="o">&gt;</span>
  <span class="k">class</span> <span class="nc">opt</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The first template argument specifies what underlying data type the command line
argument is, and is used to select a default parser implementation.  The second
template argument is used to specify whether the option should contain the
storage for the option (the default) or whether external storage should be used
to contain the value parsed for the option (see <a class="reference internal" href="#internal-vs-external-storage">Internal vs External Storage</a>
for more information).</p>
<p>The third template argument specifies which parser to use.  The default value
selects an instantiation of the <code class="docutils literal"><span class="pre">parser</span></code> class based on the underlying data
type of the option.  In general, this default works well for most applications,
so this option is only used when using a <a class="reference internal" href="#custom-parser">custom parser</a>.</p>
</div>
<div class="section" id="the-cl-list-class">
<span id="cl-list"></span><span id="lists-of-arguments"></span><h4><a class="toc-backref" href="#id38">The <code class="docutils literal"><span class="pre">cl::list</span></code> class</a><a class="headerlink" href="#the-cl-list-class" title="Permalink to this headline">¶</a></h4>
<p>The <code class="docutils literal"><span class="pre">cl::list</span></code> class is the class used to represent a list of command line
options.  It too is a templated class which can take up to three arguments:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">namespace</span> <span class="n">cl</span> <span class="p">{</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">DataType</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Storage</span> <span class="o">=</span> <span class="kt">bool</span><span class="p">,</span>
            <span class="k">class</span> <span class="nc">ParserClass</span> <span class="o">=</span> <span class="n">parser</span><span class="o">&lt;</span><span class="n">DataType</span><span class="o">&gt;</span> <span class="o">&gt;</span>
  <span class="k">class</span> <span class="nc">list</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This class works the exact same as the <a class="reference internal" href="#cl-opt">cl::opt</a> class, except that the second
argument is the <strong>type</strong> of the external storage, not a boolean value.  For this
class, the marker type ‘<code class="docutils literal"><span class="pre">bool</span></code>’ is used to indicate that internal storage
should be used.</p>
</div>
<div class="section" id="the-cl-bits-class">
<span id="cl-bits"></span><h4><a class="toc-backref" href="#id39">The <code class="docutils literal"><span class="pre">cl::bits</span></code> class</a><a class="headerlink" href="#the-cl-bits-class" title="Permalink to this headline">¶</a></h4>
<p>The <code class="docutils literal"><span class="pre">cl::bits</span></code> class is the class used to represent a list of command line
options in the form of a bit vector.  It is also a templated class which can
take up to three arguments:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">namespace</span> <span class="n">cl</span> <span class="p">{</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">DataType</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Storage</span> <span class="o">=</span> <span class="kt">bool</span><span class="p">,</span>
            <span class="k">class</span> <span class="nc">ParserClass</span> <span class="o">=</span> <span class="n">parser</span><span class="o">&lt;</span><span class="n">DataType</span><span class="o">&gt;</span> <span class="o">&gt;</span>
  <span class="k">class</span> <span class="nc">bits</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This class works the exact same as the <a class="reference internal" href="#cl-list">cl::list</a> class, except that the second
argument must be of <strong>type</strong> <code class="docutils literal"><span class="pre">unsigned</span></code> if external storage is used.</p>
</div>
<div class="section" id="the-cl-alias-class">
<span id="cl-alias"></span><h4><a class="toc-backref" href="#id40">The <code class="docutils literal"><span class="pre">cl::alias</span></code> class</a><a class="headerlink" href="#the-cl-alias-class" title="Permalink to this headline">¶</a></h4>
<p>The <code class="docutils literal"><span class="pre">cl::alias</span></code> class is a nontemplated class that is used to form aliases for
other arguments.</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">namespace</span> <span class="n">cl</span> <span class="p">{</span>
  <span class="k">class</span> <span class="nc">alias</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="#cl-aliasopt">cl::aliasopt</a> attribute should be used to specify which option this is an
alias for.  Alias arguments default to being <a class="reference internal" href="#cl-hidden">cl::Hidden</a>, and use the aliased
options parser to do the conversion from string to data.</p>
</div>
<div class="section" id="the-cl-extrahelp-class">
<span id="cl-extrahelp"></span><h4><a class="toc-backref" href="#id41">The <code class="docutils literal"><span class="pre">cl::extrahelp</span></code> class</a><a class="headerlink" href="#the-cl-extrahelp-class" title="Permalink to this headline">¶</a></h4>
<p>The <code class="docutils literal"><span class="pre">cl::extrahelp</span></code> class is a nontemplated class that allows extra help text
to be printed out for the <code class="docutils literal"><span class="pre">-help</span></code> option.</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">namespace</span> <span class="n">cl</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="n">extrahelp</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>To use the extrahelp, simply construct one with a <code class="docutils literal"><span class="pre">const</span> <span class="pre">char*</span></code> parameter to
the constructor. The text passed to the constructor will be printed at the
bottom of the help message, verbatim. Note that multiple <code class="docutils literal"><span class="pre">cl::extrahelp</span></code>
<strong>can</strong> be used, but this practice is discouraged. If your tool needs to print
additional help information, put all that help into a single <code class="docutils literal"><span class="pre">cl::extrahelp</span></code>
instance.</p>
<p>For example:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">cl</span><span class="o">::</span><span class="n">extrahelp</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">ADDITIONAL HELP:</span><span class="se">\n\n</span><span class="s">  This is the extra help</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="the-cl-optioncategory-class">
<span id="cl-optioncategory"></span><h4><a class="toc-backref" href="#id42">The <code class="docutils literal"><span class="pre">cl::OptionCategory</span></code> class</a><a class="headerlink" href="#the-cl-optioncategory-class" title="Permalink to this headline">¶</a></h4>
<p>The <code class="docutils literal"><span class="pre">cl::OptionCategory</span></code> class is a simple class for declaring
option categories.</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">namespace</span> <span class="n">cl</span> <span class="p">{</span>
  <span class="k">class</span> <span class="nc">OptionCategory</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>An option category must have a name and optionally a description which are
passed to the constructor as <code class="docutils literal"><span class="pre">const</span> <span class="pre">char*</span></code>.</p>
<p>Note that declaring an option category and associating it with an option before
parsing options (e.g. statically) will change the output of <code class="docutils literal"><span class="pre">-help</span></code> from
uncategorized to categorized. If an option category is declared but not
associated with an option then it will be hidden from the output of <code class="docutils literal"><span class="pre">-help</span></code>
but will be shown in the output of <code class="docutils literal"><span class="pre">-help-hidden</span></code>.</p>
</div>
</div>
<div class="section" id="builtin-parsers">
<span id="discussed-previously"></span><span id="different-parser"></span><h3><a class="toc-backref" href="#id43">Builtin parsers</a><a class="headerlink" href="#builtin-parsers" title="Permalink to this headline">¶</a></h3>
<p>Parsers control how the string value taken from the command line is translated
into a typed value, suitable for use in a C++ program.  By default, the
CommandLine library uses an instance of <code class="docutils literal"><span class="pre">parser&lt;type&gt;</span></code> if the command line
option specifies that it uses values of type ‘<code class="docutils literal"><span class="pre">type</span></code>’.  Because of this,
custom option processing is specified with specializations of the ‘<code class="docutils literal"><span class="pre">parser</span></code>’
class.</p>
<p>The CommandLine library provides the following builtin parser specializations,
which are sufficient for most applications. It can, however, also be extended to
work with new data types and new ways of interpreting the same data.  See the
<a class="reference internal" href="#writing-a-custom-parser">Writing a Custom Parser</a> for more details on this type of library extension.</p>
<span id="enums"></span><ul class="simple" id="cl-parser">
<li>The generic <code class="docutils literal"><span class="pre">parser&lt;t&gt;</span></code> parser can be used to map strings values to any data
type, through the use of the <a class="reference internal" href="#cl-values">cl::values</a> property, which specifies the
mapping information.  The most common use of this parser is for parsing enum
values, which allows you to use the CommandLine library for all of the error
checking to make sure that only valid enum values are specified (as opposed to
accepting arbitrary strings).  Despite this, however, the generic parser class
can be used for any data type.</li>
</ul>
<span id="boolean-flags"></span><ul class="simple" id="bool-parser">
<li>The <strong>parser&lt;bool&gt; specialization</strong> is used to convert boolean strings to a
boolean value.  Currently accepted strings are “<code class="docutils literal"><span class="pre">true</span></code>”, “<code class="docutils literal"><span class="pre">TRUE</span></code>”,
“<code class="docutils literal"><span class="pre">True</span></code>”, “<code class="docutils literal"><span class="pre">1</span></code>”, “<code class="docutils literal"><span class="pre">false</span></code>”, “<code class="docutils literal"><span class="pre">FALSE</span></code>”, “<code class="docutils literal"><span class="pre">False</span></code>”, and “<code class="docutils literal"><span class="pre">0</span></code>”.</li>
<li>The <strong>parser&lt;boolOrDefault&gt; specialization</strong> is used for cases where the value
is boolean, but we also need to know whether the option was specified at all.
boolOrDefault is an enum with 3 values, BOU_UNSET, BOU_TRUE and BOU_FALSE.
This parser accepts the same strings as <strong>“parser&lt;bool&gt;“</strong>.</li>
</ul>
<ul class="simple" id="strings">
<li>The <strong>parser&lt;string&gt; specialization</strong> simply stores the parsed string into the
string value specified.  No conversion or modification of the data is
performed.</li>
</ul>
<span id="integers"></span><ul class="simple" id="int">
<li>The <strong>parser&lt;int&gt; specialization</strong> uses the C <code class="docutils literal"><span class="pre">strtol</span></code> function to parse the
string input.  As such, it will accept a decimal number (with an optional ‘+’
or ‘-‘ prefix) which must start with a non-zero digit.  It accepts octal
numbers, which are identified with a ‘<code class="docutils literal"><span class="pre">0</span></code>’ prefix digit, and hexadecimal
numbers with a prefix of ‘<code class="docutils literal"><span class="pre">0x</span></code>’ or ‘<code class="docutils literal"><span class="pre">0X</span></code>’.</li>
</ul>
<span id="float"></span><span id="doubles"></span><ul class="simple" id="double">
<li>The <strong>parser&lt;double&gt;</strong> and <strong>parser&lt;float&gt; specializations</strong> use the standard
C <code class="docutils literal"><span class="pre">strtod</span></code> function to convert floating point strings into floating point
values.  As such, a broad range of string formats is supported, including
exponential notation (ex: <code class="docutils literal"><span class="pre">1.7e15</span></code>) and properly supports locales.</li>
</ul>
</div>
</div>
<div class="section" id="extending-the-library">
<span id="extension-guide"></span><span id="id6"></span><h2><a class="toc-backref" href="#id44">Extension Guide</a><a class="headerlink" href="#extending-the-library" title="Permalink to this headline">¶</a></h2>
<p>Although the CommandLine library has a lot of functionality built into it
already (as discussed previously), one of its true strengths lie in its
extensibility.  This section discusses how the CommandLine library works under
the covers and illustrates how to do some simple, common, extensions.</p>
<div class="section" id="writing-a-custom-parser">
<span id="custom-parser"></span><span id="custom-parsers"></span><span id="id7"></span><h3><a class="toc-backref" href="#id45">Writing a custom parser</a><a class="headerlink" href="#writing-a-custom-parser" title="Permalink to this headline">¶</a></h3>
<p>One of the simplest and most common extensions is the use of a custom parser.
As <a class="reference internal" href="#discussed-previously">discussed previously</a>, parsers are the portion of the CommandLine library
that turns string input from the user into a particular parsed data type,
validating the input in the process.</p>
<p>There are two ways to use a new parser:</p>
<ol class="arabic">
<li><p class="first">Specialize the <a class="reference internal" href="#cl-parser">cl::parser</a> template for your custom data type.</p>
<p>This approach has the advantage that users of your custom data type will
automatically use your custom parser whenever they define an option with a
value type of your data type.  The disadvantage of this approach is that it
doesn’t work if your fundamental data type is something that is already
supported.</p>
</li>
<li><p class="first">Write an independent class, using it explicitly from options that need it.</p>
<p>This approach works well in situations where you would line to parse an
option using special syntax for a not-very-special data-type.  The drawback
of this approach is that users of your parser have to be aware that they are
using your parser instead of the builtin ones.</p>
</li>
</ol>
<p>To guide the discussion, we will discuss a custom parser that accepts file
sizes, specified with an optional unit after the numeric size.  For example, we
would like to parse “102kb”, “41M”, “1G” into the appropriate integer value.  In
this case, the underlying data type we want to parse into is ‘<code class="docutils literal"><span class="pre">unsigned</span></code>’.  We
choose approach #2 above because we don’t want to make this the default for all
<code class="docutils literal"><span class="pre">unsigned</span></code> options.</p>
<p>To start out, we declare our new <code class="docutils literal"><span class="pre">FileSizeParser</span></code> class:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nl">FileSizeParser</span> <span class="p">:</span> <span class="k">public</span> <span class="n">cl</span><span class="o">::</span><span class="n">parser</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="c1">// parse - Return true on error.</span>
  <span class="kt">bool</span> <span class="n">parse</span><span class="p">(</span><span class="n">cl</span><span class="o">::</span><span class="n">Option</span> <span class="o">&amp;</span><span class="n">O</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">ArgName</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">ArgValue</span><span class="p">,</span>
             <span class="kt">unsigned</span> <span class="o">&amp;</span><span class="n">Val</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Our new class inherits from the <code class="docutils literal"><span class="pre">cl::parser</span></code> template class to fill in
the default, boiler plate code for us.  We give it the data type that we parse
into, the last argument to the <code class="docutils literal"><span class="pre">parse</span></code> method, so that clients of our custom
parser know what object type to pass in to the parse method.  (Here we declare
that we parse into ‘<code class="docutils literal"><span class="pre">unsigned</span></code>’ variables.)</p>
<p>For most purposes, the only method that must be implemented in a custom parser
is the <code class="docutils literal"><span class="pre">parse</span></code> method.  The <code class="docutils literal"><span class="pre">parse</span></code> method is called whenever the option is
invoked, passing in the option itself, the option name, the string to parse, and
a reference to a return value.  If the string to parse is not well-formed, the
parser should output an error message and return true.  Otherwise it should
return false and set ‘<code class="docutils literal"><span class="pre">Val</span></code>’ to the parsed value.  In our example, we
implement <code class="docutils literal"><span class="pre">parse</span></code> as:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="n">FileSizeParser</span><span class="o">::</span><span class="n">parse</span><span class="p">(</span><span class="n">cl</span><span class="o">::</span><span class="n">Option</span> <span class="o">&amp;</span><span class="n">O</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">ArgName</span><span class="p">,</span>
                           <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">Arg</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="o">&amp;</span><span class="n">Val</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ArgStart</span> <span class="o">=</span> <span class="n">Arg</span><span class="p">.</span><span class="n">c_str</span><span class="p">();</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">End</span><span class="p">;</span>

  <span class="c1">// Parse integer part, leaving &#39;End&#39; pointing to the first non-integer char</span>
  <span class="n">Val</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">strtol</span><span class="p">(</span><span class="n">ArgStart</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">End</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

  <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="o">*</span><span class="n">End</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="mi">0</span><span class="o">:</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>   <span class="c1">// No error</span>
    <span class="k">case</span> <span class="sc">&#39;i&#39;</span><span class="o">:</span>               <span class="c1">// Ignore the &#39;i&#39; in KiB if people use that</span>
    <span class="k">case</span> <span class="sc">&#39;b&#39;</span><span class="o">:</span> <span class="k">case</span> <span class="sc">&#39;B&#39;</span><span class="o">:</span>     <span class="c1">// Ignore B suffix</span>
      <span class="k">break</span><span class="p">;</span>

    <span class="k">case</span> <span class="sc">&#39;g&#39;</span><span class="o">:</span> <span class="k">case</span> <span class="sc">&#39;G&#39;</span><span class="o">:</span> <span class="n">Val</span> <span class="o">*=</span> <span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="sc">&#39;m&#39;</span><span class="o">:</span> <span class="k">case</span> <span class="sc">&#39;M&#39;</span><span class="o">:</span> <span class="n">Val</span> <span class="o">*=</span> <span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="p">;</span>      <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="sc">&#39;k&#39;</span><span class="o">:</span> <span class="k">case</span> <span class="sc">&#39;K&#39;</span><span class="o">:</span> <span class="n">Val</span> <span class="o">*=</span> <span class="mi">1024</span><span class="p">;</span>           <span class="k">break</span><span class="p">;</span>

    <span class="k">default</span><span class="o">:</span>
      <span class="c1">// Print an error message if unrecognized character!</span>
      <span class="k">return</span> <span class="n">O</span><span class="p">.</span><span class="n">error</span><span class="p">(</span><span class="s">&quot;&#39;&quot;</span> <span class="o">+</span> <span class="n">Arg</span> <span class="o">+</span> <span class="s">&quot;&#39; value invalid for file size argument!&quot;</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This function implements a very simple parser for the kinds of strings we are
interested in.  Although it has some holes (it allows “<code class="docutils literal"><span class="pre">123KKK</span></code>” for example),
it is good enough for this example.  Note that we use the option itself to print
out the error message (the <code class="docutils literal"><span class="pre">error</span></code> method always returns true) in order to get
a nice error message (shown below).  Now that we have our parser class, we can
use it like this:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="n">cl</span><span class="o">::</span><span class="n">opt</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="n">FileSizeParser</span><span class="o">&gt;</span>
<span class="n">MFS</span><span class="p">(</span><span class="s">&quot;max-file-size&quot;</span><span class="p">,</span> <span class="n">cl</span><span class="o">::</span><span class="n">desc</span><span class="p">(</span><span class="s">&quot;Maximum file size to accept&quot;</span><span class="p">),</span>
    <span class="n">cl</span><span class="o">::</span><span class="n">value_desc</span><span class="p">(</span><span class="s">&quot;size&quot;</span><span class="p">));</span>
</pre></div>
</div>
<p>Which adds this to the output of our program:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">OPTIONS</span><span class="p">:</span>
  <span class="o">-</span><span class="n">help</span>                 <span class="o">-</span> <span class="n">display</span> <span class="n">available</span> <span class="n">options</span> <span class="p">(</span><span class="o">-</span><span class="n">help</span><span class="o">-</span><span class="n">hidden</span> <span class="k">for</span> <span class="n">more</span><span class="p">)</span>
  <span class="o">...</span>
  <span class="o">-</span><span class="nb">max</span><span class="o">-</span><span class="n">file</span><span class="o">-</span><span class="n">size</span><span class="o">=&lt;</span><span class="n">size</span><span class="o">&gt;</span> <span class="o">-</span> <span class="n">Maximum</span> <span class="n">file</span> <span class="n">size</span> <span class="n">to</span> <span class="n">accept</span>
</pre></div>
</div>
<p>And we can test that our parse works correctly now (the test program just prints
out the max-file-size argument value):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>$ ./test
MFS: 0
$ ./test -max-file-size=123MB
MFS: 128974848
$ ./test -max-file-size=3G
MFS: 3221225472
$ ./test -max-file-size=dog
-max-file-size option: &#39;dog&#39; value invalid for file size argument!
</pre></div>
</div>
<p>It looks like it works.  The error message that we get is nice and helpful, and
we seem to accept reasonable file sizes.  This wraps up the “custom parser”
tutorial.</p>
</div>
<div class="section" id="exploiting-external-storage">
<h3><a class="toc-backref" href="#id46">Exploiting external storage</a><a class="headerlink" href="#exploiting-external-storage" title="Permalink to this headline">¶</a></h3>
<p>Several of the LLVM libraries define static <code class="docutils literal"><span class="pre">cl::opt</span></code> instances that will
automatically be included in any program that links with that library.  This is
a feature. However, sometimes it is necessary to know the value of the command
line option outside of the library. In these cases the library does or should
provide an external storage location that is accessible to users of the
library. Examples of this include the <code class="docutils literal"><span class="pre">llvm::DebugFlag</span></code> exported by the
<code class="docutils literal"><span class="pre">lib/Support/Debug.cpp</span></code> file and the <code class="docutils literal"><span class="pre">llvm::TimePassesIsEnabled</span></code> flag
exported by the <code class="docutils literal"><span class="pre">lib/VMCore/PassManager.cpp</span></code> file.</p>
</div>
<div class="section" id="dynamically-adding-command-line-options">
<span id="dynamically-loaded-options"></span><h3><a class="toc-backref" href="#id47">Dynamically adding command line options</a><a class="headerlink" href="#dynamically-adding-command-line-options" title="Permalink to this headline">¶</a></h3>
</div>
</div>
</div>


          </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="CompilerWriterInfo.html" title="Architecture &amp; Platform Information for Compiler Writers"
             >next</a> |</li>
        <li class="right" >
          <a href="CodingStandards.html" title="LLVM Coding Standards"
             >previous</a> |</li>
  <li><a href="http://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="index.html">Documentation</a>&raquo;</li>
 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2003-2019, LLVM Project.
      Last updated on Wed Feb 13 10:08:12 2019 -0800.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.1.
    </div>
  </body>
</html>