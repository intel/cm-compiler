

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>7. Kaleidoscope: Extending the Language: Mutable Variables &#8212; LLVM 6 documentation</title>
    
    <link rel="stylesheet" href="../_static/llvm-theme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '6',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="8. Kaleidoscope: Conclusion and other useful LLVM tidbits" href="OCamlLangImpl8.html" />
    <link rel="prev" title="6. Kaleidoscope: Extending the Language: User-defined Operators" href="OCamlLangImpl6.html" />
<style type="text/css">
  table.right { float: right; margin-left: 20px; }
  table.right td { border: 1px solid #ccc; }
</style>

  </head>
  <body>
<div class="logo">
  <a href="../index.html">
    <img src="../_static/logo.png"
         alt="LLVM Logo" width="250" height="88"/></a>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="OCamlLangImpl8.html" title="8. Kaleidoscope: Conclusion and other useful LLVM tidbits"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="OCamlLangImpl6.html" title="6. Kaleidoscope: Extending the Language: User-defined Operators"
             accesskey="P">previous</a> |</li>
  <li><a href="http://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="../index.html">Documentation</a>&raquo;</li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">LLVM Tutorial: Table of Contents</a> &#187;</li> 
      </ul>
    </div>


    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <div class="section" id="kaleidoscope-extending-the-language-mutable-variables">
<h1>7. Kaleidoscope: Extending the Language: Mutable Variables<a class="headerlink" href="#kaleidoscope-extending-the-language-mutable-variables" title="Permalink to this headline">¶</a></h1>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><a class="reference internal" href="#chapter-7-introduction" id="id2">Chapter 7 Introduction</a></li>
<li><a class="reference internal" href="#why-is-this-a-hard-problem" id="id3">Why is this a hard problem?</a></li>
<li><a class="reference internal" href="#memory-in-llvm" id="id4">Memory in LLVM</a></li>
<li><a class="reference internal" href="#mutable-variables-in-kaleidoscope" id="id5">Mutable Variables in Kaleidoscope</a></li>
<li><a class="reference internal" href="#adjusting-existing-variables-for-mutation" id="id6">Adjusting Existing Variables for Mutation</a></li>
<li><a class="reference internal" href="#new-assignment-operator" id="id7">New Assignment Operator</a></li>
<li><a class="reference internal" href="#user-defined-local-variables" id="id8">User-defined Local Variables</a></li>
<li><a class="reference internal" href="#id1" id="id9">Full Code Listing</a></li>
</ul>
</div>
<div class="section" id="chapter-7-introduction">
<h2><a class="toc-backref" href="#id2">7.1. Chapter 7 Introduction</a><a class="headerlink" href="#chapter-7-introduction" title="Permalink to this headline">¶</a></h2>
<p>Welcome to Chapter 7 of the “<a class="reference external" href="index.html">Implementing a language with
LLVM</a>” tutorial. In chapters 1 through 6, we’ve built a
very respectable, albeit simple, <a class="reference external" href="http://en.wikipedia.org/wiki/Functional_programming">functional programming
language</a>. In our
journey, we learned some parsing techniques, how to build and represent
an AST, how to build LLVM IR, and how to optimize the resultant code as
well as JIT compile it.</p>
<p>While Kaleidoscope is interesting as a functional language, the fact
that it is functional makes it “too easy” to generate LLVM IR for it. In
particular, a functional language makes it very easy to build LLVM IR
directly in <a class="reference external" href="http://en.wikipedia.org/wiki/Static_single_assignment_form">SSA
form</a>.
Since LLVM requires that the input code be in SSA form, this is a very
nice property and it is often unclear to newcomers how to generate code
for an imperative language with mutable variables.</p>
<p>The short (and happy) summary of this chapter is that there is no need
for your front-end to build SSA form: LLVM provides highly tuned and
well tested support for this, though the way it works is a bit
unexpected for some.</p>
</div>
<div class="section" id="why-is-this-a-hard-problem">
<h2><a class="toc-backref" href="#id3">7.2. Why is this a hard problem?</a><a class="headerlink" href="#why-is-this-a-hard-problem" title="Permalink to this headline">¶</a></h2>
<p>To understand why mutable variables cause complexities in SSA
construction, consider this extremely simple C example:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">G</span><span class="p">,</span> <span class="n">H</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">test</span><span class="p">(</span><span class="kt">_Bool</span> <span class="n">Condition</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">X</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Condition</span><span class="p">)</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">G</span><span class="p">;</span>
  <span class="k">else</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">H</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">X</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In this case, we have the variable “X”, whose value depends on the path
executed in the program. Because there are two different possible values
for X before the return instruction, a PHI node is inserted to merge the
two values. The LLVM IR that we want for this example looks like this:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="vg">@G</span> <span class="p">=</span> <span class="k">weak</span> <span class="k">global</span> <span class="k">i32</span> <span class="m">0</span>   <span class="c">; type of @G is i32*</span>
<span class="vg">@H</span> <span class="p">=</span> <span class="k">weak</span> <span class="k">global</span> <span class="k">i32</span> <span class="m">0</span>   <span class="c">; type of @H is i32*</span>

<span class="k">define</span> <span class="k">i32</span> <span class="vg">@test</span><span class="p">(</span><span class="k">i1</span> <span class="nv">%Condition</span><span class="p">)</span> <span class="p">{</span>
<span class="nl">entry:</span>
  <span class="k">br</span> <span class="k">i1</span> <span class="nv">%Condition</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%cond_true</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%cond_false</span>

<span class="nl">cond_true:</span>
  <span class="nv">%X.0</span> <span class="p">=</span> <span class="k">load</span> <span class="k">i32</span><span class="p">*</span> <span class="vg">@G</span>
  <span class="k">br</span> <span class="kt">label</span> <span class="nv">%cond_next</span>

<span class="nl">cond_false:</span>
  <span class="nv">%X.1</span> <span class="p">=</span> <span class="k">load</span> <span class="k">i32</span><span class="p">*</span> <span class="vg">@H</span>
  <span class="k">br</span> <span class="kt">label</span> <span class="nv">%cond_next</span>

<span class="nl">cond_next:</span>
  <span class="nv">%X.2</span> <span class="p">=</span> <span class="k">phi</span> <span class="k">i32</span> <span class="p">[</span> <span class="nv">%X.1</span><span class="p">,</span> <span class="nv">%cond_false</span> <span class="p">],</span> <span class="p">[</span> <span class="nv">%X.0</span><span class="p">,</span> <span class="nv">%cond_true</span> <span class="p">]</span>
  <span class="k">ret</span> <span class="k">i32</span> <span class="nv">%X.2</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In this example, the loads from the G and H global variables are
explicit in the LLVM IR, and they live in the then/else branches of the
if statement (cond_true/cond_false). In order to merge the incoming
values, the X.2 phi node in the cond_next block selects the right value
to use based on where control flow is coming from: if control flow comes
from the cond_false block, X.2 gets the value of X.1. Alternatively, if
control flow comes from cond_true, it gets the value of X.0. The intent
of this chapter is not to explain the details of SSA form. For more
information, see one of the many <a class="reference external" href="http://en.wikipedia.org/wiki/Static_single_assignment_form">online
references</a>.</p>
<p>The question for this article is “who places the phi nodes when lowering
assignments to mutable variables?”. The issue here is that LLVM
<em>requires</em> that its IR be in SSA form: there is no “non-ssa” mode for
it. However, SSA construction requires non-trivial algorithms and data
structures, so it is inconvenient and wasteful for every front-end to
have to reproduce this logic.</p>
</div>
<div class="section" id="memory-in-llvm">
<h2><a class="toc-backref" href="#id4">7.3. Memory in LLVM</a><a class="headerlink" href="#memory-in-llvm" title="Permalink to this headline">¶</a></h2>
<p>The ‘trick’ here is that while LLVM does require all register values to
be in SSA form, it does not require (or permit) memory objects to be in
SSA form. In the example above, note that the loads from G and H are
direct accesses to G and H: they are not renamed or versioned. This
differs from some other compiler systems, which do try to version memory
objects. In LLVM, instead of encoding dataflow analysis of memory into
the LLVM IR, it is handled with <a class="reference external" href="../WritingAnLLVMPass.html">Analysis
Passes</a> which are computed on demand.</p>
<p>With this in mind, the high-level idea is that we want to make a stack
variable (which lives in memory, because it is on the stack) for each
mutable object in a function. To take advantage of this trick, we need
to talk about how LLVM represents stack variables.</p>
<p>In LLVM, all memory accesses are explicit with load/store instructions,
and it is carefully designed not to have (or need) an “address-of”
operator. Notice how the type of the &#64;G/&#64;H global variables is actually
“i32*” even though the variable is defined as “i32”. What this means is
that &#64;G defines <em>space</em> for an i32 in the global data area, but its
<em>name</em> actually refers to the address for that space. Stack variables
work the same way, except that instead of being declared with global
variable definitions, they are declared with the <a class="reference external" href="../LangRef.html#alloca-instruction">LLVM alloca
instruction</a>:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="k">define</span> <span class="k">i32</span> <span class="vg">@example</span><span class="p">()</span> <span class="p">{</span>
<span class="nl">entry:</span>
  <span class="nv">%X</span> <span class="p">=</span> <span class="k">alloca</span> <span class="k">i32</span>           <span class="c">; type of %X is i32*.</span>
  <span class="p">...</span>
  <span class="nv">%tmp</span> <span class="p">=</span> <span class="k">load</span> <span class="k">i32</span><span class="p">*</span> <span class="nv">%X</span>       <span class="c">; load the stack value %X from the stack.</span>
  <span class="nv">%tmp2</span> <span class="p">=</span> <span class="k">add</span> <span class="k">i32</span> <span class="nv">%tmp</span><span class="p">,</span> <span class="m">1</span>   <span class="c">; increment it</span>
  <span class="k">store</span> <span class="k">i32</span> <span class="nv">%tmp2</span><span class="p">,</span> <span class="k">i32</span><span class="p">*</span> <span class="nv">%X</span>  <span class="c">; store it back</span>
  <span class="p">...</span>
</pre></div>
</div>
<p>This code shows an example of how you can declare and manipulate a stack
variable in the LLVM IR. Stack memory allocated with the alloca
instruction is fully general: you can pass the address of the stack slot
to functions, you can store it in other variables, etc. In our example
above, we could rewrite the example to use the alloca technique to avoid
using a PHI node:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="vg">@G</span> <span class="p">=</span> <span class="k">weak</span> <span class="k">global</span> <span class="k">i32</span> <span class="m">0</span>   <span class="c">; type of @G is i32*</span>
<span class="vg">@H</span> <span class="p">=</span> <span class="k">weak</span> <span class="k">global</span> <span class="k">i32</span> <span class="m">0</span>   <span class="c">; type of @H is i32*</span>

<span class="k">define</span> <span class="k">i32</span> <span class="vg">@test</span><span class="p">(</span><span class="k">i1</span> <span class="nv">%Condition</span><span class="p">)</span> <span class="p">{</span>
<span class="nl">entry:</span>
  <span class="nv">%X</span> <span class="p">=</span> <span class="k">alloca</span> <span class="k">i32</span>           <span class="c">; type of %X is i32*.</span>
  <span class="k">br</span> <span class="k">i1</span> <span class="nv">%Condition</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%cond_true</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%cond_false</span>

<span class="nl">cond_true:</span>
  <span class="nv">%X.0</span> <span class="p">=</span> <span class="k">load</span> <span class="k">i32</span><span class="p">*</span> <span class="vg">@G</span>
        <span class="k">store</span> <span class="k">i32</span> <span class="nv">%X.0</span><span class="p">,</span> <span class="k">i32</span><span class="p">*</span> <span class="nv">%X</span>   <span class="c">; Update X</span>
  <span class="k">br</span> <span class="kt">label</span> <span class="nv">%cond_next</span>

<span class="nl">cond_false:</span>
  <span class="nv">%X.1</span> <span class="p">=</span> <span class="k">load</span> <span class="k">i32</span><span class="p">*</span> <span class="vg">@H</span>
        <span class="k">store</span> <span class="k">i32</span> <span class="nv">%X.1</span><span class="p">,</span> <span class="k">i32</span><span class="p">*</span> <span class="nv">%X</span>   <span class="c">; Update X</span>
  <span class="k">br</span> <span class="kt">label</span> <span class="nv">%cond_next</span>

<span class="nl">cond_next:</span>
  <span class="nv">%X.2</span> <span class="p">=</span> <span class="k">load</span> <span class="k">i32</span><span class="p">*</span> <span class="nv">%X</span>       <span class="c">; Read X</span>
  <span class="k">ret</span> <span class="k">i32</span> <span class="nv">%X.2</span>
<span class="p">}</span>
</pre></div>
</div>
<p>With this, we have discovered a way to handle arbitrary mutable
variables without the need to create Phi nodes at all:</p>
<ol class="arabic simple">
<li>Each mutable variable becomes a stack allocation.</li>
<li>Each read of the variable becomes a load from the stack.</li>
<li>Each update of the variable becomes a store to the stack.</li>
<li>Taking the address of a variable just uses the stack address
directly.</li>
</ol>
<p>While this solution has solved our immediate problem, it introduced
another one: we have now apparently introduced a lot of stack traffic
for very simple and common operations, a major performance problem.
Fortunately for us, the LLVM optimizer has a highly-tuned optimization
pass named “mem2reg” that handles this case, promoting allocas like this
into SSA registers, inserting Phi nodes as appropriate. If you run this
example through the pass, for example, you’ll get:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ llvm-as &lt; example.ll <span class="p">|</span> opt -mem2reg <span class="p">|</span> llvm-dis
@G <span class="o">=</span> weak global i32 <span class="m">0</span>
@H <span class="o">=</span> weak global i32 <span class="m">0</span>

define i32 @test<span class="o">(</span>i1 %Condition<span class="o">)</span> <span class="o">{</span>
entry:
  br i1 %Condition, label %cond_true, label %cond_false

cond_true:
  %X.0 <span class="o">=</span> load i32* @G
  br label %cond_next

cond_false:
  %X.1 <span class="o">=</span> load i32* @H
  br label %cond_next

cond_next:
  %X.01 <span class="o">=</span> phi i32 <span class="o">[</span> %X.1, %cond_false <span class="o">]</span>, <span class="o">[</span> %X.0, %cond_true <span class="o">]</span>
  ret i32 %X.01
<span class="o">}</span>
</pre></div>
</div>
<p>The mem2reg pass implements the standard “iterated dominance frontier”
algorithm for constructing SSA form and has a number of optimizations
that speed up (very common) degenerate cases. The mem2reg optimization
pass is the answer to dealing with mutable variables, and we highly
recommend that you depend on it. Note that mem2reg only works on
variables in certain circumstances:</p>
<ol class="arabic simple">
<li>mem2reg is alloca-driven: it looks for allocas and if it can handle
them, it promotes them. It does not apply to global variables or heap
allocations.</li>
<li>mem2reg only looks for alloca instructions in the entry block of the
function. Being in the entry block guarantees that the alloca is only
executed once, which makes analysis simpler.</li>
<li>mem2reg only promotes allocas whose uses are direct loads and stores.
If the address of the stack object is passed to a function, or if any
funny pointer arithmetic is involved, the alloca will not be
promoted.</li>
<li>mem2reg only works on allocas of <a class="reference external" href="../LangRef.html#first-class-types">first
class</a> values (such as pointers,
scalars and vectors), and only if the array size of the allocation is
1 (or missing in the .ll file). mem2reg is not capable of promoting
structs or arrays to registers. Note that the “sroa” pass is
more powerful and can promote structs, “unions”, and arrays in many
cases.</li>
</ol>
<p>All of these properties are easy to satisfy for most imperative
languages, and we’ll illustrate it below with Kaleidoscope. The final
question you may be asking is: should I bother with this nonsense for my
front-end? Wouldn’t it be better if I just did SSA construction
directly, avoiding use of the mem2reg optimization pass? In short, we
strongly recommend that you use this technique for building SSA form,
unless there is an extremely good reason not to. Using this technique
is:</p>
<ul class="simple">
<li>Proven and well tested: clang uses this technique
for local mutable variables. As such, the most common clients of LLVM
are using this to handle a bulk of their variables. You can be sure
that bugs are found fast and fixed early.</li>
<li>Extremely Fast: mem2reg has a number of special cases that make it
fast in common cases as well as fully general. For example, it has
fast-paths for variables that are only used in a single block,
variables that only have one assignment point, good heuristics to
avoid insertion of unneeded phi nodes, etc.</li>
<li>Needed for debug info generation: <a class="reference external" href="../SourceLevelDebugging.html">Debug information in
LLVM</a> relies on having the address of
the variable exposed so that debug info can be attached to it. This
technique dovetails very naturally with this style of debug info.</li>
</ul>
<p>If nothing else, this makes it much easier to get your front-end up and
running, and is very simple to implement. Lets extend Kaleidoscope with
mutable variables now!</p>
</div>
<div class="section" id="mutable-variables-in-kaleidoscope">
<h2><a class="toc-backref" href="#id5">7.4. Mutable Variables in Kaleidoscope</a><a class="headerlink" href="#mutable-variables-in-kaleidoscope" title="Permalink to this headline">¶</a></h2>
<p>Now that we know the sort of problem we want to tackle, lets see what
this looks like in the context of our little Kaleidoscope language.
We’re going to add two features:</p>
<ol class="arabic simple">
<li>The ability to mutate variables with the ‘=’ operator.</li>
<li>The ability to define new variables.</li>
</ol>
<p>While the first item is really what this is about, we only have
variables for incoming arguments as well as for induction variables, and
redefining those only goes so far :). Also, the ability to define new
variables is a useful thing regardless of whether you will be mutating
them. Here’s a motivating example that shows how we could use these:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1"># Define &#39;:&#39; for sequencing: as a low-precedence operator that ignores operands</span>
<span class="c1"># and just returns the RHS.</span>
<span class="k">def</span> <span class="nf">binary</span> <span class="p">:</span> <span class="mi">1</span> <span class="p">(</span><span class="n">x</span> <span class="n">y</span><span class="p">)</span> <span class="n">y</span><span class="p">;</span>

<span class="c1"># Recursive fib, we could do this before.</span>
<span class="k">def</span> <span class="nf">fib</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">)</span> <span class="n">then</span>
    <span class="mi">1</span>
  <span class="k">else</span>
    <span class="n">fib</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">fib</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">2</span><span class="p">);</span>

<span class="c1"># Iterative fib.</span>
<span class="k">def</span> <span class="nf">fibi</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="n">var</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span>
  <span class="p">(</span><span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">x</span> <span class="ow">in</span>
     <span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="p">:</span>
     <span class="n">a</span> <span class="o">=</span> <span class="n">b</span> <span class="p">:</span>
     <span class="n">b</span> <span class="o">=</span> <span class="n">c</span><span class="p">)</span> <span class="p">:</span>
  <span class="n">b</span><span class="p">;</span>

<span class="c1"># Call it.</span>
<span class="n">fibi</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
</pre></div>
</div>
<p>In order to mutate variables, we have to change our existing variables
to use the “alloca trick”. Once we have that, we’ll add our new
operator, then extend Kaleidoscope to support new variable definitions.</p>
</div>
<div class="section" id="adjusting-existing-variables-for-mutation">
<h2><a class="toc-backref" href="#id6">7.5. Adjusting Existing Variables for Mutation</a><a class="headerlink" href="#adjusting-existing-variables-for-mutation" title="Permalink to this headline">¶</a></h2>
<p>The symbol table in Kaleidoscope is managed at code generation time by
the ‘<code class="docutils literal"><span class="pre">named_values</span></code>’ map. This map currently keeps track of the LLVM
“Value*” that holds the double value for the named variable. In order
to support mutation, we need to change this slightly, so that it
<code class="docutils literal"><span class="pre">named_values</span></code> holds the <em>memory location</em> of the variable in
question. Note that this change is a refactoring: it changes the
structure of the code, but does not (by itself) change the behavior of
the compiler. All of these changes are isolated in the Kaleidoscope code
generator.</p>
<p>At this point in Kaleidoscope’s development, it only supports variables
for two things: incoming arguments to functions and the induction
variable of ‘for’ loops. For consistency, we’ll allow mutation of these
variables in addition to other user-defined variables. This means that
these will both need memory locations.</p>
<p>To start our transformation of Kaleidoscope, we’ll change the
<code class="docutils literal"><span class="pre">named_values</span></code> map so that it maps to AllocaInst* instead of Value*.
Once we do this, the C++ compiler will tell us what parts of the code we
need to update:</p>
<p><strong>Note:</strong> the ocaml bindings currently model both <code class="docutils literal"><span class="pre">Value*</span></code>’s and
<code class="docutils literal"><span class="pre">AllocInst*</span></code>’s as <code class="docutils literal"><span class="pre">Llvm.llvalue</span></code>’s, but this may change in the future
to be more type safe.</p>
<div class="highlight-ocaml"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">named_values</span><span class="o">:(</span><span class="kt">string</span><span class="o">,</span> <span class="n">llvalue</span><span class="o">)</span> <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">create</span> <span class="mi">10</span>
</pre></div>
</div>
<p>Also, since we will need to create these alloca’s, we’ll use a helper
function that ensures that the allocas are created in the entry block of
the function:</p>
<div class="highlight-ocaml"><div class="highlight"><pre><span></span><span class="c">(* Create an alloca instruction in the entry block of the function. This</span>
<span class="c"> * is used for mutable variables etc. *)</span>
<span class="k">let</span> <span class="n">create_entry_block_alloca</span> <span class="n">the_function</span> <span class="n">var_name</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">builder</span> <span class="o">=</span> <span class="n">builder_at</span> <span class="o">(</span><span class="n">instr_begin</span> <span class="o">(</span><span class="n">entry_block</span> <span class="n">the_function</span><span class="o">))</span> <span class="k">in</span>
  <span class="n">build_alloca</span> <span class="n">double_type</span> <span class="n">var_name</span> <span class="n">builder</span>
</pre></div>
</div>
<p>This funny looking code creates an <code class="docutils literal"><span class="pre">Llvm.llbuilder</span></code> object that is
pointing at the first instruction of the entry block. It then creates an
alloca with the expected name and returns it. Because all values in
Kaleidoscope are doubles, there is no need to pass in a type to use.</p>
<p>With this in place, the first functionality change we want to make is to
variable references. In our new scheme, variables live on the stack, so
code generating a reference to them actually needs to produce a load
from the stack slot:</p>
<div class="highlight-ocaml"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="k">rec</span> <span class="n">codegen_expr</span> <span class="o">=</span> <span class="k">function</span>
  <span class="o">...</span>
  <span class="o">|</span> <span class="nn">Ast</span><span class="p">.</span><span class="nc">Variable</span> <span class="n">name</span> <span class="o">-&gt;</span>
      <span class="k">let</span> <span class="n">v</span> <span class="o">=</span> <span class="k">try</span> <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">find</span> <span class="n">named_values</span> <span class="n">name</span> <span class="k">with</span>
        <span class="o">|</span> <span class="nc">Not_found</span> <span class="o">-&gt;</span> <span class="k">raise</span> <span class="o">(</span><span class="nc">Error</span> <span class="s2">&quot;unknown variable name&quot;</span><span class="o">)</span>
      <span class="k">in</span>
      <span class="c">(* Load the value. *)</span>
      <span class="n">build_load</span> <span class="n">v</span> <span class="n">name</span> <span class="n">builder</span>
</pre></div>
</div>
<p>As you can see, this is pretty straightforward. Now we need to update
the things that define the variables to set up the alloca. We’ll start
with <code class="docutils literal"><span class="pre">codegen_expr</span> <span class="pre">Ast.For</span> <span class="pre">...</span></code> (see the <a class="reference external" href="#id1">full code listing</a>
for the unabridged code):</p>
<div class="highlight-ocaml"><div class="highlight"><pre><span></span><span class="o">|</span> <span class="nn">Ast</span><span class="p">.</span><span class="nc">For</span> <span class="o">(</span><span class="n">var_name</span><span class="o">,</span> <span class="n">start</span><span class="o">,</span> <span class="n">end_</span><span class="o">,</span> <span class="n">step</span><span class="o">,</span> <span class="n">body</span><span class="o">)</span> <span class="o">-&gt;</span>
    <span class="k">let</span> <span class="n">the_function</span> <span class="o">=</span> <span class="n">block_parent</span> <span class="o">(</span><span class="n">insertion_block</span> <span class="n">builder</span><span class="o">)</span> <span class="k">in</span>

    <span class="c">(* Create an alloca for the variable in the entry block. *)</span>
    <span class="k">let</span> <span class="n">alloca</span> <span class="o">=</span> <span class="n">create_entry_block_alloca</span> <span class="n">the_function</span> <span class="n">var_name</span> <span class="k">in</span>

    <span class="c">(* Emit the start code first, without &#39;variable&#39; in scope. *)</span>
    <span class="k">let</span> <span class="n">start_val</span> <span class="o">=</span> <span class="n">codegen_expr</span> <span class="n">start</span> <span class="k">in</span>

    <span class="c">(* Store the value into the alloca. *)</span>
    <span class="n">ignore</span><span class="o">(</span><span class="n">build_store</span> <span class="n">start_val</span> <span class="n">alloca</span> <span class="n">builder</span><span class="o">);</span>

    <span class="o">...</span>

    <span class="c">(* Within the loop, the variable is defined equal to the PHI node. If it</span>
<span class="c">     * shadows an existing variable, we have to restore it, so save it</span>
<span class="c">     * now. *)</span>
    <span class="k">let</span> <span class="n">old_val</span> <span class="o">=</span>
      <span class="k">try</span> <span class="nc">Some</span> <span class="o">(</span><span class="nn">Hashtbl</span><span class="p">.</span><span class="n">find</span> <span class="n">named_values</span> <span class="n">var_name</span><span class="o">)</span> <span class="k">with</span> <span class="nc">Not_found</span> <span class="o">-&gt;</span> <span class="nc">None</span>
    <span class="k">in</span>
    <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">add</span> <span class="n">named_values</span> <span class="n">var_name</span> <span class="n">alloca</span><span class="o">;</span>

    <span class="o">...</span>

    <span class="c">(* Compute the end condition. *)</span>
    <span class="k">let</span> <span class="n">end_cond</span> <span class="o">=</span> <span class="n">codegen_expr</span> <span class="n">end_</span> <span class="k">in</span>

    <span class="c">(* Reload, increment, and restore the alloca. This handles the case where</span>
<span class="c">     * the body of the loop mutates the variable. *)</span>
    <span class="k">let</span> <span class="n">cur_var</span> <span class="o">=</span> <span class="n">build_load</span> <span class="n">alloca</span> <span class="n">var_name</span> <span class="n">builder</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">next_var</span> <span class="o">=</span> <span class="n">build_add</span> <span class="n">cur_var</span> <span class="n">step_val</span> <span class="s2">&quot;nextvar&quot;</span> <span class="n">builder</span> <span class="k">in</span>
    <span class="n">ignore</span><span class="o">(</span><span class="n">build_store</span> <span class="n">next_var</span> <span class="n">alloca</span> <span class="n">builder</span><span class="o">);</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>This code is virtually identical to the code <a class="reference external" href="OCamlLangImpl5.html#code-generation-for-the-for-loop">before we allowed mutable
variables</a>. The big difference is that
we no longer have to construct a PHI node, and we use load/store to
access the variable as needed.</p>
<p>To support mutable argument variables, we need to also make allocas for
them. The code for this is also pretty simple:</p>
<div class="highlight-ocaml"><div class="highlight"><pre><span></span><span class="c">(* Create an alloca for each argument and register the argument in the symbol</span>
<span class="c"> * table so that references to it will succeed. *)</span>
<span class="k">let</span> <span class="n">create_argument_allocas</span> <span class="n">the_function</span> <span class="n">proto</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">args</span> <span class="o">=</span> <span class="k">match</span> <span class="n">proto</span> <span class="k">with</span>
    <span class="o">|</span> <span class="nn">Ast</span><span class="p">.</span><span class="nc">Prototype</span> <span class="o">(_,</span> <span class="n">args</span><span class="o">)</span> <span class="o">|</span> <span class="nn">Ast</span><span class="p">.</span><span class="nc">BinOpPrototype</span> <span class="o">(_,</span> <span class="n">args</span><span class="o">,</span> <span class="o">_)</span> <span class="o">-&gt;</span> <span class="n">args</span>
  <span class="k">in</span>
  <span class="nn">Array</span><span class="p">.</span><span class="n">iteri</span> <span class="o">(</span><span class="k">fun</span> <span class="n">i</span> <span class="n">ai</span> <span class="o">-&gt;</span>
    <span class="k">let</span> <span class="n">var_name</span> <span class="o">=</span> <span class="n">args</span><span class="o">.(</span><span class="n">i</span><span class="o">)</span> <span class="k">in</span>
    <span class="c">(* Create an alloca for this variable. *)</span>
    <span class="k">let</span> <span class="n">alloca</span> <span class="o">=</span> <span class="n">create_entry_block_alloca</span> <span class="n">the_function</span> <span class="n">var_name</span> <span class="k">in</span>

    <span class="c">(* Store the initial value into the alloca. *)</span>
    <span class="n">ignore</span><span class="o">(</span><span class="n">build_store</span> <span class="n">ai</span> <span class="n">alloca</span> <span class="n">builder</span><span class="o">);</span>

    <span class="c">(* Add arguments to variable symbol table. *)</span>
    <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">add</span> <span class="n">named_values</span> <span class="n">var_name</span> <span class="n">alloca</span><span class="o">;</span>
  <span class="o">)</span> <span class="o">(</span><span class="n">params</span> <span class="n">the_function</span><span class="o">)</span>
</pre></div>
</div>
<p>For each argument, we make an alloca, store the input value to the
function into the alloca, and register the alloca as the memory location
for the argument. This method gets invoked by <code class="docutils literal"><span class="pre">Codegen.codegen_func</span></code>
right after it sets up the entry block for the function.</p>
<p>The final missing piece is adding the mem2reg pass, which allows us to
get good codegen once again:</p>
<div class="highlight-ocaml"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">main</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="o">...</span>
  <span class="k">let</span> <span class="n">the_fpm</span> <span class="o">=</span> <span class="nn">PassManager</span><span class="p">.</span><span class="n">create_function</span> <span class="nn">Codegen</span><span class="p">.</span><span class="n">the_module</span> <span class="k">in</span>

  <span class="c">(* Set up the optimizer pipeline.  Start with registering info about how the</span>
<span class="c">   * target lays out data structures. *)</span>
  <span class="nn">DataLayout</span><span class="p">.</span><span class="n">add</span> <span class="o">(</span><span class="nn">ExecutionEngine</span><span class="p">.</span><span class="n">target_data</span> <span class="n">the_execution_engine</span><span class="o">)</span> <span class="n">the_fpm</span><span class="o">;</span>

  <span class="c">(* Promote allocas to registers. *)</span>
  <span class="n">add_memory_to_register_promotion</span> <span class="n">the_fpm</span><span class="o">;</span>

  <span class="c">(* Do simple &quot;peephole&quot; optimizations and bit-twiddling optzn. *)</span>
  <span class="n">add_instruction_combining</span> <span class="n">the_fpm</span><span class="o">;</span>

  <span class="c">(* reassociate expressions. *)</span>
  <span class="n">add_reassociation</span> <span class="n">the_fpm</span><span class="o">;</span>
</pre></div>
</div>
<p>It is interesting to see what the code looks like before and after the
mem2reg optimization runs. For example, this is the before/after code
for our recursive fib function. Before the optimization:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="k">define</span> <span class="kt">double</span> <span class="vg">@fib</span><span class="p">(</span><span class="kt">double</span> <span class="nv">%x</span><span class="p">)</span> <span class="p">{</span>
<span class="nl">entry:</span>
  <span class="nv">%x1</span> <span class="p">=</span> <span class="k">alloca</span> <span class="kt">double</span>
  <span class="k">store</span> <span class="kt">double</span> <span class="nv">%x</span><span class="p">,</span> <span class="kt">double</span><span class="p">*</span> <span class="nv">%x1</span>
  <span class="nv">%x2</span> <span class="p">=</span> <span class="k">load</span> <span class="kt">double</span><span class="p">*</span> <span class="nv">%x1</span>
  <span class="nv">%cmptmp</span> <span class="p">=</span> <span class="k">fcmp</span> <span class="k">ult</span> <span class="kt">double</span> <span class="nv">%x2</span><span class="p">,</span> <span class="m">3.000000e+00</span>
  <span class="nv">%booltmp</span> <span class="p">=</span> <span class="k">uitofp</span> <span class="k">i1</span> <span class="nv">%cmptmp</span> <span class="k">to</span> <span class="kt">double</span>
  <span class="nv">%ifcond</span> <span class="p">=</span> <span class="k">fcmp</span> <span class="k">one</span> <span class="kt">double</span> <span class="nv">%booltmp</span><span class="p">,</span> <span class="m">0.000000e+00</span>
  <span class="k">br</span> <span class="k">i1</span> <span class="nv">%ifcond</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%then</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%else</span>

<span class="nl">then:</span>    <span class="c">; preds = %entry</span>
  <span class="k">br</span> <span class="kt">label</span> <span class="nv">%ifcont</span>

<span class="nl">else:</span>    <span class="c">; preds = %entry</span>
  <span class="nv">%x3</span> <span class="p">=</span> <span class="k">load</span> <span class="kt">double</span><span class="p">*</span> <span class="nv">%x1</span>
  <span class="nv">%subtmp</span> <span class="p">=</span> <span class="k">fsub</span> <span class="kt">double</span> <span class="nv">%x3</span><span class="p">,</span> <span class="m">1.000000e+00</span>
  <span class="nv">%calltmp</span> <span class="p">=</span> <span class="k">call</span> <span class="kt">double</span> <span class="vg">@fib</span><span class="p">(</span><span class="kt">double</span> <span class="nv">%subtmp</span><span class="p">)</span>
  <span class="nv">%x4</span> <span class="p">=</span> <span class="k">load</span> <span class="kt">double</span><span class="p">*</span> <span class="nv">%x1</span>
  <span class="nv">%subtmp5</span> <span class="p">=</span> <span class="k">fsub</span> <span class="kt">double</span> <span class="nv">%x4</span><span class="p">,</span> <span class="m">2.000000e+00</span>
  <span class="nv">%calltmp6</span> <span class="p">=</span> <span class="k">call</span> <span class="kt">double</span> <span class="vg">@fib</span><span class="p">(</span><span class="kt">double</span> <span class="nv">%subtmp5</span><span class="p">)</span>
  <span class="nv">%addtmp</span> <span class="p">=</span> <span class="k">fadd</span> <span class="kt">double</span> <span class="nv">%calltmp</span><span class="p">,</span> <span class="nv">%calltmp6</span>
  <span class="k">br</span> <span class="kt">label</span> <span class="nv">%ifcont</span>

<span class="nl">ifcont:</span>    <span class="c">; preds = %else, %then</span>
  <span class="nv">%iftmp</span> <span class="p">=</span> <span class="k">phi</span> <span class="kt">double</span> <span class="p">[</span> <span class="m">1.000000e+00</span><span class="p">,</span> <span class="nv">%then</span> <span class="p">],</span> <span class="p">[</span> <span class="nv">%addtmp</span><span class="p">,</span> <span class="nv">%else</span> <span class="p">]</span>
  <span class="k">ret</span> <span class="kt">double</span> <span class="nv">%iftmp</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here there is only one variable (x, the input argument) but you can
still see the extremely simple-minded code generation strategy we are
using. In the entry block, an alloca is created, and the initial input
value is stored into it. Each reference to the variable does a reload
from the stack. Also, note that we didn’t modify the if/then/else
expression, so it still inserts a PHI node. While we could make an
alloca for it, it is actually easier to create a PHI node for it, so we
still just make the PHI.</p>
<p>Here is the code after the mem2reg pass runs:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="k">define</span> <span class="kt">double</span> <span class="vg">@fib</span><span class="p">(</span><span class="kt">double</span> <span class="nv">%x</span><span class="p">)</span> <span class="p">{</span>
<span class="nl">entry:</span>
  <span class="nv">%cmptmp</span> <span class="p">=</span> <span class="k">fcmp</span> <span class="k">ult</span> <span class="kt">double</span> <span class="nv">%x</span><span class="p">,</span> <span class="m">3.000000e+00</span>
  <span class="nv">%booltmp</span> <span class="p">=</span> <span class="k">uitofp</span> <span class="k">i1</span> <span class="nv">%cmptmp</span> <span class="k">to</span> <span class="kt">double</span>
  <span class="nv">%ifcond</span> <span class="p">=</span> <span class="k">fcmp</span> <span class="k">one</span> <span class="kt">double</span> <span class="nv">%booltmp</span><span class="p">,</span> <span class="m">0.000000e+00</span>
  <span class="k">br</span> <span class="k">i1</span> <span class="nv">%ifcond</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%then</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%else</span>

<span class="nl">then:</span>
  <span class="k">br</span> <span class="kt">label</span> <span class="nv">%ifcont</span>

<span class="nl">else:</span>
  <span class="nv">%subtmp</span> <span class="p">=</span> <span class="k">fsub</span> <span class="kt">double</span> <span class="nv">%x</span><span class="p">,</span> <span class="m">1.000000e+00</span>
  <span class="nv">%calltmp</span> <span class="p">=</span> <span class="k">call</span> <span class="kt">double</span> <span class="vg">@fib</span><span class="p">(</span><span class="kt">double</span> <span class="nv">%subtmp</span><span class="p">)</span>
  <span class="nv">%subtmp5</span> <span class="p">=</span> <span class="k">fsub</span> <span class="kt">double</span> <span class="nv">%x</span><span class="p">,</span> <span class="m">2.000000e+00</span>
  <span class="nv">%calltmp6</span> <span class="p">=</span> <span class="k">call</span> <span class="kt">double</span> <span class="vg">@fib</span><span class="p">(</span><span class="kt">double</span> <span class="nv">%subtmp5</span><span class="p">)</span>
  <span class="nv">%addtmp</span> <span class="p">=</span> <span class="k">fadd</span> <span class="kt">double</span> <span class="nv">%calltmp</span><span class="p">,</span> <span class="nv">%calltmp6</span>
  <span class="k">br</span> <span class="kt">label</span> <span class="nv">%ifcont</span>

<span class="nl">ifcont:</span>    <span class="c">; preds = %else, %then</span>
  <span class="nv">%iftmp</span> <span class="p">=</span> <span class="k">phi</span> <span class="kt">double</span> <span class="p">[</span> <span class="m">1.000000e+00</span><span class="p">,</span> <span class="nv">%then</span> <span class="p">],</span> <span class="p">[</span> <span class="nv">%addtmp</span><span class="p">,</span> <span class="nv">%else</span> <span class="p">]</span>
  <span class="k">ret</span> <span class="kt">double</span> <span class="nv">%iftmp</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This is a trivial case for mem2reg, since there are no redefinitions of
the variable. The point of showing this is to calm your tension about
inserting such blatent inefficiencies :).</p>
<p>After the rest of the optimizers run, we get:</p>
<div class="highlight-llvm"><div class="highlight"><pre><span></span><span class="k">define</span> <span class="kt">double</span> <span class="vg">@fib</span><span class="p">(</span><span class="kt">double</span> <span class="nv">%x</span><span class="p">)</span> <span class="p">{</span>
<span class="nl">entry:</span>
  <span class="nv">%cmptmp</span> <span class="p">=</span> <span class="k">fcmp</span> <span class="k">ult</span> <span class="kt">double</span> <span class="nv">%x</span><span class="p">,</span> <span class="m">3.000000e+00</span>
  <span class="nv">%booltmp</span> <span class="p">=</span> <span class="k">uitofp</span> <span class="k">i1</span> <span class="nv">%cmptmp</span> <span class="k">to</span> <span class="kt">double</span>
  <span class="nv">%ifcond</span> <span class="p">=</span> <span class="k">fcmp</span> <span class="k">ueq</span> <span class="kt">double</span> <span class="nv">%booltmp</span><span class="p">,</span> <span class="m">0.000000e+00</span>
  <span class="k">br</span> <span class="k">i1</span> <span class="nv">%ifcond</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%else</span><span class="p">,</span> <span class="kt">label</span> <span class="nv">%ifcont</span>

<span class="nl">else:</span>
  <span class="nv">%subtmp</span> <span class="p">=</span> <span class="k">fsub</span> <span class="kt">double</span> <span class="nv">%x</span><span class="p">,</span> <span class="m">1.000000e+00</span>
  <span class="nv">%calltmp</span> <span class="p">=</span> <span class="k">call</span> <span class="kt">double</span> <span class="vg">@fib</span><span class="p">(</span><span class="kt">double</span> <span class="nv">%subtmp</span><span class="p">)</span>
  <span class="nv">%subtmp5</span> <span class="p">=</span> <span class="k">fsub</span> <span class="kt">double</span> <span class="nv">%x</span><span class="p">,</span> <span class="m">2.000000e+00</span>
  <span class="nv">%calltmp6</span> <span class="p">=</span> <span class="k">call</span> <span class="kt">double</span> <span class="vg">@fib</span><span class="p">(</span><span class="kt">double</span> <span class="nv">%subtmp5</span><span class="p">)</span>
  <span class="nv">%addtmp</span> <span class="p">=</span> <span class="k">fadd</span> <span class="kt">double</span> <span class="nv">%calltmp</span><span class="p">,</span> <span class="nv">%calltmp6</span>
  <span class="k">ret</span> <span class="kt">double</span> <span class="nv">%addtmp</span>

<span class="nl">ifcont:</span>
  <span class="k">ret</span> <span class="kt">double</span> <span class="m">1.000000e+00</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here we see that the simplifycfg pass decided to clone the return
instruction into the end of the ‘else’ block. This allowed it to
eliminate some branches and the PHI node.</p>
<p>Now that all symbol table references are updated to use stack variables,
we’ll add the assignment operator.</p>
</div>
<div class="section" id="new-assignment-operator">
<h2><a class="toc-backref" href="#id7">7.6. New Assignment Operator</a><a class="headerlink" href="#new-assignment-operator" title="Permalink to this headline">¶</a></h2>
<p>With our current framework, adding a new assignment operator is really
simple. We will parse it just like any other binary operator, but handle
it internally (instead of allowing the user to define it). The first
step is to set a precedence:</p>
<div class="highlight-ocaml"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">main</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="c">(* Install standard binary operators.</span>
<span class="c">   * 1 is the lowest precedence. *)</span>
  <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">add</span> <span class="nn">Parser</span><span class="p">.</span><span class="n">binop_precedence</span> <span class="sc">&#39;=&#39;</span> <span class="mi">2</span><span class="o">;</span>
  <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">add</span> <span class="nn">Parser</span><span class="p">.</span><span class="n">binop_precedence</span> <span class="sc">&#39;&lt;&#39;</span> <span class="mi">10</span><span class="o">;</span>
  <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">add</span> <span class="nn">Parser</span><span class="p">.</span><span class="n">binop_precedence</span> <span class="sc">&#39;+&#39;</span> <span class="mi">20</span><span class="o">;</span>
  <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">add</span> <span class="nn">Parser</span><span class="p">.</span><span class="n">binop_precedence</span> <span class="sc">&#39;-&#39;</span> <span class="mi">20</span><span class="o">;</span>
  <span class="o">...</span>
</pre></div>
</div>
<p>Now that the parser knows the precedence of the binary operator, it
takes care of all the parsing and AST generation. We just need to
implement codegen for the assignment operator. This looks like:</p>
<div class="highlight-ocaml"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="k">rec</span> <span class="n">codegen_expr</span> <span class="o">=</span> <span class="k">function</span>
      <span class="k">begin</span> <span class="k">match</span> <span class="n">op</span> <span class="k">with</span>
      <span class="o">|</span> <span class="sc">&#39;=&#39;</span> <span class="o">-&gt;</span>
          <span class="c">(* Special case &#39;=&#39; because we don&#39;t want to emit the LHS as an</span>
<span class="c">           * expression. *)</span>
          <span class="k">let</span> <span class="n">name</span> <span class="o">=</span>
            <span class="k">match</span> <span class="n">lhs</span> <span class="k">with</span>
            <span class="o">|</span> <span class="nn">Ast</span><span class="p">.</span><span class="nc">Variable</span> <span class="n">name</span> <span class="o">-&gt;</span> <span class="n">name</span>
            <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="k">raise</span> <span class="o">(</span><span class="nc">Error</span> <span class="s2">&quot;destination of &#39;=&#39; must be a variable&quot;</span><span class="o">)</span>
          <span class="k">in</span>
</pre></div>
</div>
<p>Unlike the rest of the binary operators, our assignment operator doesn’t
follow the “emit LHS, emit RHS, do computation” model. As such, it is
handled as a special case before the other binary operators are handled.
The other strange thing is that it requires the LHS to be a variable. It
is invalid to have “(x+1) = expr” - only things like “x = expr” are
allowed.</p>
<div class="highlight-ocaml"><div class="highlight"><pre><span></span>    <span class="c">(* Codegen the rhs. *)</span>
    <span class="k">let</span> <span class="n">val_</span> <span class="o">=</span> <span class="n">codegen_expr</span> <span class="n">rhs</span> <span class="k">in</span>

    <span class="c">(* Lookup the name. *)</span>
    <span class="k">let</span> <span class="n">variable</span> <span class="o">=</span> <span class="k">try</span> <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">find</span> <span class="n">named_values</span> <span class="n">name</span> <span class="k">with</span>
    <span class="o">|</span> <span class="nc">Not_found</span> <span class="o">-&gt;</span> <span class="k">raise</span> <span class="o">(</span><span class="nc">Error</span> <span class="s2">&quot;unknown variable name&quot;</span><span class="o">)</span>
    <span class="k">in</span>
    <span class="n">ignore</span><span class="o">(</span><span class="n">build_store</span> <span class="n">val_</span> <span class="n">variable</span> <span class="n">builder</span><span class="o">);</span>
    <span class="n">val_</span>
<span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span>
      <span class="o">...</span>
</pre></div>
</div>
<p>Once we have the variable, codegen’ing the assignment is
straightforward: we emit the RHS of the assignment, create a store, and
return the computed value. Returning a value allows for chained
assignments like “X = (Y = Z)”.</p>
<p>Now that we have an assignment operator, we can mutate loop variables
and arguments. For example, we can now run code like this:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1"># Function to print a double.</span>
<span class="n">extern</span> <span class="n">printd</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

<span class="c1"># Define &#39;:&#39; for sequencing: as a low-precedence operator that ignores operands</span>
<span class="c1"># and just returns the RHS.</span>
<span class="k">def</span> <span class="nf">binary</span> <span class="p">:</span> <span class="mi">1</span> <span class="p">(</span><span class="n">x</span> <span class="n">y</span><span class="p">)</span> <span class="n">y</span><span class="p">;</span>

<span class="k">def</span> <span class="nf">test</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="n">printd</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">:</span>
  <span class="n">x</span> <span class="o">=</span> <span class="mi">4</span> <span class="p">:</span>
  <span class="n">printd</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

<span class="n">test</span><span class="p">(</span><span class="mi">123</span><span class="p">);</span>
</pre></div>
</div>
<p>When run, this example prints “123” and then “4”, showing that we did
actually mutate the value! Okay, we have now officially implemented our
goal: getting this to work requires SSA construction in the general
case. However, to be really useful, we want the ability to define our
own local variables, lets add this next!</p>
</div>
<div class="section" id="user-defined-local-variables">
<h2><a class="toc-backref" href="#id8">7.7. User-defined Local Variables</a><a class="headerlink" href="#user-defined-local-variables" title="Permalink to this headline">¶</a></h2>
<p>Adding var/in is just like any other other extensions we made to
Kaleidoscope: we extend the lexer, the parser, the AST and the code
generator. The first step for adding our new ‘var/in’ construct is to
extend the lexer. As before, this is pretty trivial, the code looks like
this:</p>
<div class="highlight-ocaml"><div class="highlight"><pre><span></span><span class="k">type</span> <span class="n">token</span> <span class="o">=</span>
  <span class="o">...</span>
  <span class="c">(* var definition *)</span>
  <span class="o">|</span> <span class="nn">Var</span>

<span class="p">...</span>

<span class="n">and</span> <span class="n">lex_ident</span> <span class="n">buffer</span> <span class="o">=</span> <span class="n">parser</span>
      <span class="o">...</span>
      <span class="o">|</span> <span class="s2">&quot;in&quot;</span> <span class="o">-&gt;</span> <span class="o">[&lt;</span> <span class="k">&#39;</span><span class="nn">Token</span><span class="p">.</span><span class="nc">In</span><span class="o">;</span> <span class="n">stream</span> <span class="o">&gt;]</span>
      <span class="o">|</span> <span class="s2">&quot;binary&quot;</span> <span class="o">-&gt;</span> <span class="o">[&lt;</span> <span class="k">&#39;</span><span class="nn">Token</span><span class="p">.</span><span class="nc">Binary</span><span class="o">;</span> <span class="n">stream</span> <span class="o">&gt;]</span>
      <span class="o">|</span> <span class="s2">&quot;unary&quot;</span> <span class="o">-&gt;</span> <span class="o">[&lt;</span> <span class="k">&#39;</span><span class="nn">Token</span><span class="p">.</span><span class="nc">Unary</span><span class="o">;</span> <span class="n">stream</span> <span class="o">&gt;]</span>
      <span class="o">|</span> <span class="s2">&quot;var&quot;</span> <span class="o">-&gt;</span> <span class="o">[&lt;</span> <span class="k">&#39;</span><span class="nn">Token</span><span class="p">.</span><span class="nc">Var</span><span class="o">;</span> <span class="n">stream</span> <span class="o">&gt;]</span>
      <span class="o">...</span>
</pre></div>
</div>
<p>The next step is to define the AST node that we will construct. For
var/in, it looks like this:</p>
<div class="highlight-ocaml"><div class="highlight"><pre><span></span><span class="k">type</span> <span class="n">expr</span> <span class="o">=</span>
  <span class="o">...</span>
  <span class="c">(* variant for var/in. *)</span>
  <span class="o">|</span> <span class="nc">Var</span> <span class="k">of</span> <span class="o">(</span><span class="kt">string</span> <span class="o">*</span> <span class="n">expr</span> <span class="n">option</span><span class="o">)</span> <span class="kt">array</span> <span class="o">*</span> <span class="n">expr</span>
  <span class="o">...</span>
</pre></div>
</div>
<p>var/in allows a list of names to be defined all at once, and each name
can optionally have an initializer value. As such, we capture this
information in the VarNames vector. Also, var/in has a body, this body
is allowed to access the variables defined by the var/in.</p>
<p>With this in place, we can define the parser pieces. The first thing we
do is add it as a primary expression:</p>
<div class="highlight-ocaml"><div class="highlight"><pre><span></span><span class="c">(* primary</span>
<span class="c"> *   ::= identifier</span>
<span class="c"> *   ::= numberexpr</span>
<span class="c"> *   ::= parenexpr</span>
<span class="c"> *   ::= ifexpr</span>
<span class="c"> *   ::= forexpr</span>
<span class="c"> *   ::= varexpr *)</span>
<span class="k">let</span> <span class="k">rec</span> <span class="n">parse_primary</span> <span class="o">=</span> <span class="n">parser</span>
  <span class="o">...</span>
  <span class="c">(* varexpr</span>
<span class="c">   *   ::= &#39;var&#39; identifier (&#39;=&#39; expression?</span>
<span class="c">   *             (&#39;,&#39; identifier (&#39;=&#39; expression)?)* &#39;in&#39; expression *)</span>
  <span class="o">|</span> <span class="o">[&lt;</span> <span class="k">&#39;</span><span class="nn">Token</span><span class="p">.</span><span class="nc">Var</span><span class="o">;</span>
       <span class="c">(* At least one variable name is required. *)</span>
       <span class="k">&#39;</span><span class="nn">Token</span><span class="p">.</span><span class="nc">Ident</span> <span class="n">id</span> <span class="o">??</span> <span class="s2">&quot;expected identifier after var&quot;</span><span class="o">;</span>
       <span class="n">init</span><span class="o">=</span><span class="n">parse_var_init</span><span class="o">;</span>
       <span class="n">var_names</span><span class="o">=</span><span class="n">parse_var_names</span> <span class="o">[(</span><span class="n">id</span><span class="o">,</span> <span class="n">init</span><span class="o">)];</span>
       <span class="c">(* At this point, we have to have &#39;in&#39;. *)</span>
       <span class="k">&#39;</span><span class="nn">Token</span><span class="p">.</span><span class="nc">In</span> <span class="o">??</span> <span class="s2">&quot;expected &#39;in&#39; keyword after &#39;var&#39;&quot;</span><span class="o">;</span>
       <span class="n">body</span><span class="o">=</span><span class="n">parse_expr</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span>
      <span class="nn">Ast</span><span class="p">.</span><span class="nc">Var</span> <span class="o">(</span><span class="nn">Array</span><span class="p">.</span><span class="n">of_list</span> <span class="o">(</span><span class="nn">List</span><span class="p">.</span><span class="n">rev</span> <span class="n">var_names</span><span class="o">),</span> <span class="n">body</span><span class="o">)</span>

<span class="o">...</span>

<span class="ow">and</span> <span class="n">parse_var_init</span> <span class="o">=</span> <span class="n">parser</span>
  <span class="c">(* read in the optional initializer. *)</span>
  <span class="o">|</span> <span class="o">[&lt;</span> <span class="k">&#39;</span><span class="nn">Token</span><span class="p">.</span><span class="nc">Kwd</span> <span class="sc">&#39;=&#39;</span><span class="o">;</span> <span class="n">e</span><span class="o">=</span><span class="n">parse_expr</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span> <span class="nc">Some</span> <span class="n">e</span>
  <span class="o">|</span> <span class="o">[&lt;</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span> <span class="nc">None</span>

<span class="ow">and</span> <span class="n">parse_var_names</span> <span class="n">accumulator</span> <span class="o">=</span> <span class="n">parser</span>
  <span class="o">|</span> <span class="o">[&lt;</span> <span class="k">&#39;</span><span class="nn">Token</span><span class="p">.</span><span class="nc">Kwd</span> <span class="sc">&#39;,&#39;</span><span class="o">;</span>
       <span class="k">&#39;</span><span class="nn">Token</span><span class="p">.</span><span class="nc">Ident</span> <span class="n">id</span> <span class="o">??</span> <span class="s2">&quot;expected identifier list after var&quot;</span><span class="o">;</span>
       <span class="n">init</span><span class="o">=</span><span class="n">parse_var_init</span><span class="o">;</span>
       <span class="n">e</span><span class="o">=</span><span class="n">parse_var_names</span> <span class="o">((</span><span class="n">id</span><span class="o">,</span> <span class="n">init</span><span class="o">)</span> <span class="o">::</span> <span class="n">accumulator</span><span class="o">)</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span> <span class="n">e</span>
  <span class="o">|</span> <span class="o">[&lt;</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span> <span class="n">accumulator</span>
</pre></div>
</div>
<p>Now that we can parse and represent the code, we need to support
emission of LLVM IR for it. This code starts out with:</p>
<div class="highlight-ocaml"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="k">rec</span> <span class="n">codegen_expr</span> <span class="o">=</span> <span class="k">function</span>
  <span class="o">...</span>
  <span class="o">|</span> <span class="nn">Ast</span><span class="p">.</span><span class="nc">Var</span> <span class="o">(</span><span class="n">var_names</span><span class="o">,</span> <span class="n">body</span><span class="o">)</span>
      <span class="k">let</span> <span class="n">old_bindings</span> <span class="o">=</span> <span class="n">ref</span> <span class="bp">[]</span> <span class="k">in</span>

      <span class="k">let</span> <span class="n">the_function</span> <span class="o">=</span> <span class="n">block_parent</span> <span class="o">(</span><span class="n">insertion_block</span> <span class="n">builder</span><span class="o">)</span> <span class="k">in</span>

      <span class="c">(* Register all variables and emit their initializer. *)</span>
      <span class="nn">Array</span><span class="p">.</span><span class="n">iter</span> <span class="o">(</span><span class="k">fun</span> <span class="o">(</span><span class="n">var_name</span><span class="o">,</span> <span class="n">init</span><span class="o">)</span> <span class="o">-&gt;</span>
</pre></div>
</div>
<p>Basically it loops over all the variables, installing them one at a
time. For each variable we put into the symbol table, we remember the
previous value that we replace in OldBindings.</p>
<div class="highlight-ocaml"><div class="highlight"><pre><span></span>  <span class="c">(* Emit the initializer before adding the variable to scope, this</span>
<span class="c">   * prevents the initializer from referencing the variable itself, and</span>
<span class="c">   * permits stuff like this:</span>
<span class="c">   *   var a = 1 in</span>
<span class="c">   *     var a = a in ...   # refers to outer &#39;a&#39;. *)</span>
  <span class="k">let</span> <span class="n">init_val</span> <span class="o">=</span>
    <span class="k">match</span> <span class="n">init</span> <span class="k">with</span>
    <span class="o">|</span> <span class="nc">Some</span> <span class="n">init</span> <span class="o">-&gt;</span> <span class="n">codegen_expr</span> <span class="n">init</span>
    <span class="c">(* If not specified, use 0.0. *)</span>
    <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="n">const_float</span> <span class="n">double_type</span> <span class="mi">0</span><span class="o">.</span><span class="mi">0</span>
  <span class="k">in</span>

  <span class="k">let</span> <span class="n">alloca</span> <span class="o">=</span> <span class="n">create_entry_block_alloca</span> <span class="n">the_function</span> <span class="n">var_name</span> <span class="k">in</span>
  <span class="n">ignore</span><span class="o">(</span><span class="n">build_store</span> <span class="n">init_val</span> <span class="n">alloca</span> <span class="n">builder</span><span class="o">);</span>

  <span class="c">(* Remember the old variable binding so that we can restore the binding</span>
<span class="c">   * when we unrecurse. *)</span>

  <span class="k">begin</span>
    <span class="k">try</span>
      <span class="k">let</span> <span class="n">old_value</span> <span class="o">=</span> <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">find</span> <span class="n">named_values</span> <span class="n">var_name</span> <span class="k">in</span>
      <span class="n">old_bindings</span> <span class="o">:=</span> <span class="o">(</span><span class="n">var_name</span><span class="o">,</span> <span class="n">old_value</span><span class="o">)</span> <span class="o">::</span> <span class="o">!</span><span class="n">old_bindings</span><span class="o">;</span>
    <span class="k">with</span> <span class="nc">Not_found</span> <span class="o">&gt;</span> <span class="bp">()</span>
  <span class="k">end</span><span class="o">;</span>

  <span class="c">(* Remember this binding. *)</span>
  <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">add</span> <span class="n">named_values</span> <span class="n">var_name</span> <span class="n">alloca</span><span class="o">;</span>
<span class="o">)</span> <span class="n">var_names</span><span class="o">;</span>
</pre></div>
</div>
<p>There are more comments here than code. The basic idea is that we emit
the initializer, create the alloca, then update the symbol table to
point to it. Once all the variables are installed in the symbol table,
we evaluate the body of the var/in expression:</p>
<div class="highlight-ocaml"><div class="highlight"><pre><span></span><span class="c">(* Codegen the body, now that all vars are in scope. *)</span>
<span class="k">let</span> <span class="n">body_val</span> <span class="o">=</span> <span class="n">codegen_expr</span> <span class="n">body</span> <span class="k">in</span>
</pre></div>
</div>
<p>Finally, before returning, we restore the previous variable bindings:</p>
<div class="highlight-ocaml"><div class="highlight"><pre><span></span><span class="c">(* Pop all our variables from scope. *)</span>
<span class="nn">List</span><span class="p">.</span><span class="n">iter</span> <span class="o">(</span><span class="k">fun</span> <span class="o">(</span><span class="n">var_name</span><span class="o">,</span> <span class="n">old_value</span><span class="o">)</span> <span class="o">-&gt;</span>
  <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">add</span> <span class="n">named_values</span> <span class="n">var_name</span> <span class="n">old_value</span>
<span class="o">)</span> <span class="o">!</span><span class="n">old_bindings</span><span class="o">;</span>

<span class="c">(* Return the body computation. *)</span>
<span class="n">body_val</span>
</pre></div>
</div>
<p>The end result of all of this is that we get properly scoped variable
definitions, and we even (trivially) allow mutation of them :).</p>
<p>With this, we completed what we set out to do. Our nice iterative fib
example from the intro compiles and runs just fine. The mem2reg pass
optimizes all of our stack variables into SSA registers, inserting PHI
nodes where needed, and our front-end remains simple: no “iterated
dominance frontier” computation anywhere in sight.</p>
</div>
<div class="section" id="id1">
<h2><a class="toc-backref" href="#id9">7.8. Full Code Listing</a><a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<p>Here is the complete code listing for our running example, enhanced with
mutable variables and var/in support. To build this example, use:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span><span class="c1"># Compile</span>
ocamlbuild toy.byte
<span class="c1"># Run</span>
./toy.byte
</pre></div>
</div>
<p>Here is the code:</p>
<dl class="docutils">
<dt>_tags:</dt>
<dd><div class="first last highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="p">{</span><span class="n">lexer</span><span class="p">,</span><span class="n">parser</span><span class="p">}</span><span class="o">.</span><span class="n">ml</span><span class="o">&gt;</span><span class="p">:</span> <span class="n">use_camlp4</span><span class="p">,</span> <span class="n">pp</span><span class="p">(</span><span class="n">camlp4of</span><span class="p">)</span>
<span class="o">&lt;*.</span><span class="p">{</span><span class="n">byte</span><span class="p">,</span><span class="n">native</span><span class="p">}</span><span class="o">&gt;</span><span class="p">:</span> <span class="n">g</span><span class="o">++</span><span class="p">,</span> <span class="n">use_llvm</span><span class="p">,</span> <span class="n">use_llvm_analysis</span>
<span class="o">&lt;*.</span><span class="p">{</span><span class="n">byte</span><span class="p">,</span><span class="n">native</span><span class="p">}</span><span class="o">&gt;</span><span class="p">:</span> <span class="n">use_llvm_executionengine</span><span class="p">,</span> <span class="n">use_llvm_target</span>
<span class="o">&lt;*.</span><span class="p">{</span><span class="n">byte</span><span class="p">,</span><span class="n">native</span><span class="p">}</span><span class="o">&gt;</span><span class="p">:</span> <span class="n">use_llvm_scalar_opts</span><span class="p">,</span> <span class="n">use_bindings</span>
</pre></div>
</div>
</dd>
<dt>myocamlbuild.ml:</dt>
<dd><div class="first last highlight-ocaml"><div class="highlight"><pre><span></span><span class="k">open</span> <span class="nc">Ocamlbuild_plugin</span><span class="o">;;</span>

<span class="n">ocaml_lib</span> <span class="o">~</span><span class="n">extern</span><span class="o">:</span><span class="bp">true</span> <span class="s2">&quot;llvm&quot;</span><span class="o">;;</span>
<span class="n">ocaml_lib</span> <span class="o">~</span><span class="n">extern</span><span class="o">:</span><span class="bp">true</span> <span class="s2">&quot;llvm_analysis&quot;</span><span class="o">;;</span>
<span class="n">ocaml_lib</span> <span class="o">~</span><span class="n">extern</span><span class="o">:</span><span class="bp">true</span> <span class="s2">&quot;llvm_executionengine&quot;</span><span class="o">;;</span>
<span class="n">ocaml_lib</span> <span class="o">~</span><span class="n">extern</span><span class="o">:</span><span class="bp">true</span> <span class="s2">&quot;llvm_target&quot;</span><span class="o">;;</span>
<span class="n">ocaml_lib</span> <span class="o">~</span><span class="n">extern</span><span class="o">:</span><span class="bp">true</span> <span class="s2">&quot;llvm_scalar_opts&quot;</span><span class="o">;;</span>

<span class="n">flag</span> <span class="o">[</span><span class="s2">&quot;link&quot;</span><span class="o">;</span> <span class="s2">&quot;ocaml&quot;</span><span class="o">;</span> <span class="s2">&quot;g++&quot;</span><span class="o">]</span> <span class="o">(</span><span class="nc">S</span><span class="o">[</span><span class="nc">A</span><span class="s2">&quot;-cc&quot;</span><span class="o">;</span> <span class="nc">A</span><span class="s2">&quot;g++&quot;</span><span class="o">;</span> <span class="nc">A</span><span class="s2">&quot;-cclib&quot;</span><span class="o">;</span> <span class="nc">A</span><span class="s2">&quot;-rdynamic&quot;</span><span class="o">]);;</span>
<span class="n">dep</span> <span class="o">[</span><span class="s2">&quot;link&quot;</span><span class="o">;</span> <span class="s2">&quot;ocaml&quot;</span><span class="o">;</span> <span class="s2">&quot;use_bindings&quot;</span><span class="o">]</span> <span class="o">[</span><span class="s2">&quot;bindings.o&quot;</span><span class="o">];;</span>
</pre></div>
</div>
</dd>
<dt>token.ml:</dt>
<dd><div class="first last highlight-ocaml"><div class="highlight"><pre><span></span><span class="c">(*===----------------------------------------------------------------------===</span>
<span class="c"> * Lexer Tokens</span>
<span class="c"> *===----------------------------------------------------------------------===*)</span>

<span class="c">(* The lexer returns these &#39;Kwd&#39; if it is an unknown character, otherwise one of</span>
<span class="c"> * these others for known things. *)</span>
<span class="k">type</span> <span class="n">token</span> <span class="o">=</span>
  <span class="c">(* commands *)</span>
  <span class="o">|</span> <span class="nc">Def</span> <span class="o">|</span> <span class="nc">Extern</span>

  <span class="c">(* primary *)</span>
  <span class="o">|</span> <span class="nc">Ident</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="nc">Number</span> <span class="k">of</span> <span class="kt">float</span>

  <span class="c">(* unknown *)</span>
  <span class="o">|</span> <span class="nc">Kwd</span> <span class="k">of</span> <span class="kt">char</span>

  <span class="c">(* control *)</span>
  <span class="o">|</span> <span class="nc">If</span> <span class="o">|</span> <span class="nc">Then</span> <span class="o">|</span> <span class="nc">Else</span>
  <span class="o">|</span> <span class="nc">For</span> <span class="o">|</span> <span class="nc">In</span>

  <span class="c">(* operators *)</span>
  <span class="o">|</span> <span class="nc">Binary</span> <span class="o">|</span> <span class="nc">Unary</span>

  <span class="c">(* var definition *)</span>
  <span class="o">|</span> <span class="nc">Var</span>
</pre></div>
</div>
</dd>
<dt>lexer.ml:</dt>
<dd><div class="first last highlight-ocaml"><div class="highlight"><pre><span></span><span class="c">(*===----------------------------------------------------------------------===</span>
<span class="c"> * Lexer</span>
<span class="c"> *===----------------------------------------------------------------------===*)</span>

<span class="k">let</span> <span class="k">rec</span> <span class="n">lex</span> <span class="o">=</span> <span class="n">parser</span>
  <span class="c">(* Skip any whitespace. *)</span>
  <span class="o">|</span> <span class="o">[&lt;</span> <span class="k">&#39;</span> <span class="o">(</span><span class="sc">&#39; &#39;</span> <span class="o">|</span> <span class="sc">&#39;\n&#39;</span> <span class="o">|</span> <span class="sc">&#39;\r&#39;</span> <span class="o">|</span> <span class="sc">&#39;\t&#39;</span><span class="o">);</span> <span class="n">stream</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span> <span class="n">lex</span> <span class="n">stream</span>

  <span class="c">(* identifier: [a-zA-Z][a-zA-Z0-9] *)</span>
  <span class="o">|</span> <span class="o">[&lt;</span> <span class="k">&#39;</span> <span class="o">(</span><span class="sc">&#39;A&#39;</span> <span class="o">..</span> <span class="sc">&#39;Z&#39;</span> <span class="o">|</span> <span class="sc">&#39;a&#39;</span> <span class="o">..</span> <span class="sc">&#39;z&#39;</span> <span class="k">as</span> <span class="n">c</span><span class="o">);</span> <span class="n">stream</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span>
      <span class="k">let</span> <span class="n">buffer</span> <span class="o">=</span> <span class="nn">Buffer</span><span class="p">.</span><span class="n">create</span> <span class="mi">1</span> <span class="k">in</span>
      <span class="nn">Buffer</span><span class="p">.</span><span class="n">add_char</span> <span class="n">buffer</span> <span class="n">c</span><span class="o">;</span>
      <span class="n">lex_ident</span> <span class="n">buffer</span> <span class="n">stream</span>

  <span class="c">(* number: [0-9.]+ *)</span>
  <span class="o">|</span> <span class="o">[&lt;</span> <span class="k">&#39;</span> <span class="o">(</span><span class="sc">&#39;0&#39;</span> <span class="o">..</span> <span class="sc">&#39;9&#39;</span> <span class="k">as</span> <span class="n">c</span><span class="o">);</span> <span class="n">stream</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span>
      <span class="k">let</span> <span class="n">buffer</span> <span class="o">=</span> <span class="nn">Buffer</span><span class="p">.</span><span class="n">create</span> <span class="mi">1</span> <span class="k">in</span>
      <span class="nn">Buffer</span><span class="p">.</span><span class="n">add_char</span> <span class="n">buffer</span> <span class="n">c</span><span class="o">;</span>
      <span class="n">lex_number</span> <span class="n">buffer</span> <span class="n">stream</span>

  <span class="c">(* Comment until end of line. *)</span>
  <span class="o">|</span> <span class="o">[&lt;</span> <span class="k">&#39;</span> <span class="o">(</span><span class="sc">&#39;#&#39;</span><span class="o">);</span> <span class="n">stream</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span>
      <span class="n">lex_comment</span> <span class="n">stream</span>

  <span class="c">(* Otherwise, just return the character as its ascii value. *)</span>
  <span class="o">|</span> <span class="o">[&lt;</span> <span class="k">&#39;</span><span class="n">c</span><span class="o">;</span> <span class="n">stream</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span>
      <span class="o">[&lt;</span> <span class="k">&#39;</span><span class="nn">Token</span><span class="p">.</span><span class="nc">Kwd</span> <span class="n">c</span><span class="o">;</span> <span class="n">lex</span> <span class="n">stream</span> <span class="o">&gt;]</span>

  <span class="c">(* end of stream. *)</span>
  <span class="o">|</span> <span class="o">[&lt;</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span> <span class="o">[&lt;</span> <span class="o">&gt;]</span>

<span class="ow">and</span> <span class="n">lex_number</span> <span class="n">buffer</span> <span class="o">=</span> <span class="n">parser</span>
  <span class="o">|</span> <span class="o">[&lt;</span> <span class="k">&#39;</span> <span class="o">(</span><span class="sc">&#39;0&#39;</span> <span class="o">..</span> <span class="sc">&#39;9&#39;</span> <span class="o">|</span> <span class="sc">&#39;.&#39;</span> <span class="k">as</span> <span class="n">c</span><span class="o">);</span> <span class="n">stream</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span>
      <span class="nn">Buffer</span><span class="p">.</span><span class="n">add_char</span> <span class="n">buffer</span> <span class="n">c</span><span class="o">;</span>
      <span class="n">lex_number</span> <span class="n">buffer</span> <span class="n">stream</span>
  <span class="o">|</span> <span class="o">[&lt;</span> <span class="n">stream</span><span class="o">=</span><span class="n">lex</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span>
      <span class="o">[&lt;</span> <span class="k">&#39;</span><span class="nn">Token</span><span class="p">.</span><span class="nc">Number</span> <span class="o">(</span><span class="n">float_of_string</span> <span class="o">(</span><span class="nn">Buffer</span><span class="p">.</span><span class="n">contents</span> <span class="n">buffer</span><span class="o">));</span> <span class="n">stream</span> <span class="o">&gt;]</span>

<span class="ow">and</span> <span class="n">lex_ident</span> <span class="n">buffer</span> <span class="o">=</span> <span class="n">parser</span>
  <span class="o">|</span> <span class="o">[&lt;</span> <span class="k">&#39;</span> <span class="o">(</span><span class="sc">&#39;A&#39;</span> <span class="o">..</span> <span class="sc">&#39;Z&#39;</span> <span class="o">|</span> <span class="sc">&#39;a&#39;</span> <span class="o">..</span> <span class="sc">&#39;z&#39;</span> <span class="o">|</span> <span class="sc">&#39;0&#39;</span> <span class="o">..</span> <span class="sc">&#39;9&#39;</span> <span class="k">as</span> <span class="n">c</span><span class="o">);</span> <span class="n">stream</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span>
      <span class="nn">Buffer</span><span class="p">.</span><span class="n">add_char</span> <span class="n">buffer</span> <span class="n">c</span><span class="o">;</span>
      <span class="n">lex_ident</span> <span class="n">buffer</span> <span class="n">stream</span>
  <span class="o">|</span> <span class="o">[&lt;</span> <span class="n">stream</span><span class="o">=</span><span class="n">lex</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span>
      <span class="k">match</span> <span class="nn">Buffer</span><span class="p">.</span><span class="n">contents</span> <span class="n">buffer</span> <span class="k">with</span>
      <span class="o">|</span> <span class="s2">&quot;def&quot;</span> <span class="o">-&gt;</span> <span class="o">[&lt;</span> <span class="k">&#39;</span><span class="nn">Token</span><span class="p">.</span><span class="nc">Def</span><span class="o">;</span> <span class="n">stream</span> <span class="o">&gt;]</span>
      <span class="o">|</span> <span class="s2">&quot;extern&quot;</span> <span class="o">-&gt;</span> <span class="o">[&lt;</span> <span class="k">&#39;</span><span class="nn">Token</span><span class="p">.</span><span class="nc">Extern</span><span class="o">;</span> <span class="n">stream</span> <span class="o">&gt;]</span>
      <span class="o">|</span> <span class="s2">&quot;if&quot;</span> <span class="o">-&gt;</span> <span class="o">[&lt;</span> <span class="k">&#39;</span><span class="nn">Token</span><span class="p">.</span><span class="nc">If</span><span class="o">;</span> <span class="n">stream</span> <span class="o">&gt;]</span>
      <span class="o">|</span> <span class="s2">&quot;then&quot;</span> <span class="o">-&gt;</span> <span class="o">[&lt;</span> <span class="k">&#39;</span><span class="nn">Token</span><span class="p">.</span><span class="nc">Then</span><span class="o">;</span> <span class="n">stream</span> <span class="o">&gt;]</span>
      <span class="o">|</span> <span class="s2">&quot;else&quot;</span> <span class="o">-&gt;</span> <span class="o">[&lt;</span> <span class="k">&#39;</span><span class="nn">Token</span><span class="p">.</span><span class="nc">Else</span><span class="o">;</span> <span class="n">stream</span> <span class="o">&gt;]</span>
      <span class="o">|</span> <span class="s2">&quot;for&quot;</span> <span class="o">-&gt;</span> <span class="o">[&lt;</span> <span class="k">&#39;</span><span class="nn">Token</span><span class="p">.</span><span class="nc">For</span><span class="o">;</span> <span class="n">stream</span> <span class="o">&gt;]</span>
      <span class="o">|</span> <span class="s2">&quot;in&quot;</span> <span class="o">-&gt;</span> <span class="o">[&lt;</span> <span class="k">&#39;</span><span class="nn">Token</span><span class="p">.</span><span class="nc">In</span><span class="o">;</span> <span class="n">stream</span> <span class="o">&gt;]</span>
      <span class="o">|</span> <span class="s2">&quot;binary&quot;</span> <span class="o">-&gt;</span> <span class="o">[&lt;</span> <span class="k">&#39;</span><span class="nn">Token</span><span class="p">.</span><span class="nc">Binary</span><span class="o">;</span> <span class="n">stream</span> <span class="o">&gt;]</span>
      <span class="o">|</span> <span class="s2">&quot;unary&quot;</span> <span class="o">-&gt;</span> <span class="o">[&lt;</span> <span class="k">&#39;</span><span class="nn">Token</span><span class="p">.</span><span class="nc">Unary</span><span class="o">;</span> <span class="n">stream</span> <span class="o">&gt;]</span>
      <span class="o">|</span> <span class="s2">&quot;var&quot;</span> <span class="o">-&gt;</span> <span class="o">[&lt;</span> <span class="k">&#39;</span><span class="nn">Token</span><span class="p">.</span><span class="nc">Var</span><span class="o">;</span> <span class="n">stream</span> <span class="o">&gt;]</span>
      <span class="o">|</span> <span class="n">id</span> <span class="o">-&gt;</span> <span class="o">[&lt;</span> <span class="k">&#39;</span><span class="nn">Token</span><span class="p">.</span><span class="nc">Ident</span> <span class="n">id</span><span class="o">;</span> <span class="n">stream</span> <span class="o">&gt;]</span>

<span class="ow">and</span> <span class="n">lex_comment</span> <span class="o">=</span> <span class="n">parser</span>
  <span class="o">|</span> <span class="o">[&lt;</span> <span class="k">&#39;</span> <span class="o">(</span><span class="sc">&#39;\n&#39;</span><span class="o">);</span> <span class="n">stream</span><span class="o">=</span><span class="n">lex</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span> <span class="n">stream</span>
  <span class="o">|</span> <span class="o">[&lt;</span> <span class="k">&#39;</span><span class="n">c</span><span class="o">;</span> <span class="n">e</span><span class="o">=</span><span class="n">lex_comment</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span> <span class="n">e</span>
  <span class="o">|</span> <span class="o">[&lt;</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span> <span class="o">[&lt;</span> <span class="o">&gt;]</span>
</pre></div>
</div>
</dd>
<dt>ast.ml:</dt>
<dd><div class="first last highlight-ocaml"><div class="highlight"><pre><span></span><span class="c">(*===----------------------------------------------------------------------===</span>
<span class="c"> * Abstract Syntax Tree (aka Parse Tree)</span>
<span class="c"> *===----------------------------------------------------------------------===*)</span>

<span class="c">(* expr - Base type for all expression nodes. *)</span>
<span class="k">type</span> <span class="n">expr</span> <span class="o">=</span>
  <span class="c">(* variant for numeric literals like &quot;1.0&quot;. *)</span>
  <span class="o">|</span> <span class="nc">Number</span> <span class="k">of</span> <span class="kt">float</span>

  <span class="c">(* variant for referencing a variable, like &quot;a&quot;. *)</span>
  <span class="o">|</span> <span class="nc">Variable</span> <span class="k">of</span> <span class="kt">string</span>

  <span class="c">(* variant for a unary operator. *)</span>
  <span class="o">|</span> <span class="nc">Unary</span> <span class="k">of</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">expr</span>

  <span class="c">(* variant for a binary operator. *)</span>
  <span class="o">|</span> <span class="nc">Binary</span> <span class="k">of</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">expr</span> <span class="o">*</span> <span class="n">expr</span>

  <span class="c">(* variant for function calls. *)</span>
  <span class="o">|</span> <span class="nc">Call</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">*</span> <span class="n">expr</span> <span class="kt">array</span>

  <span class="c">(* variant for if/then/else. *)</span>
  <span class="o">|</span> <span class="nc">If</span> <span class="k">of</span> <span class="n">expr</span> <span class="o">*</span> <span class="n">expr</span> <span class="o">*</span> <span class="n">expr</span>

  <span class="c">(* variant for for/in. *)</span>
  <span class="o">|</span> <span class="nc">For</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">*</span> <span class="n">expr</span> <span class="o">*</span> <span class="n">expr</span> <span class="o">*</span> <span class="n">expr</span> <span class="n">option</span> <span class="o">*</span> <span class="n">expr</span>

  <span class="c">(* variant for var/in. *)</span>
  <span class="o">|</span> <span class="nc">Var</span> <span class="k">of</span> <span class="o">(</span><span class="kt">string</span> <span class="o">*</span> <span class="n">expr</span> <span class="n">option</span><span class="o">)</span> <span class="kt">array</span> <span class="o">*</span> <span class="n">expr</span>

<span class="c">(* proto - This type represents the &quot;prototype&quot; for a function, which captures</span>
<span class="c"> * its name, and its argument names (thus implicitly the number of arguments the</span>
<span class="c"> * function takes). *)</span>
<span class="k">type</span> <span class="n">proto</span> <span class="o">=</span>
  <span class="o">|</span> <span class="nc">Prototype</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">*</span> <span class="kt">string</span> <span class="kt">array</span>
  <span class="o">|</span> <span class="nc">BinOpPrototype</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">*</span> <span class="kt">string</span> <span class="kt">array</span> <span class="o">*</span> <span class="kt">int</span>

<span class="c">(* func - This type represents a function definition itself. *)</span>
<span class="k">type</span> <span class="n">func</span> <span class="o">=</span> <span class="nc">Function</span> <span class="k">of</span> <span class="n">proto</span> <span class="o">*</span> <span class="n">expr</span>
</pre></div>
</div>
</dd>
<dt>parser.ml:</dt>
<dd><div class="first last highlight-ocaml"><div class="highlight"><pre><span></span><span class="c">(*===---------------------------------------------------------------------===</span>
<span class="c"> * Parser</span>
<span class="c"> *===---------------------------------------------------------------------===*)</span>

<span class="c">(* binop_precedence - This holds the precedence for each binary operator that is</span>
<span class="c"> * defined *)</span>
<span class="k">let</span> <span class="n">binop_precedence</span><span class="o">:(</span><span class="kt">char</span><span class="o">,</span> <span class="kt">int</span><span class="o">)</span> <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">create</span> <span class="mi">10</span>

<span class="c">(* precedence - Get the precedence of the pending binary operator token. *)</span>
<span class="k">let</span> <span class="n">precedence</span> <span class="n">c</span> <span class="o">=</span> <span class="k">try</span> <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">find</span> <span class="n">binop_precedence</span> <span class="n">c</span> <span class="k">with</span> <span class="nc">Not_found</span> <span class="o">-&gt;</span> <span class="o">-</span><span class="mi">1</span>

<span class="c">(* primary</span>
<span class="c"> *   ::= identifier</span>
<span class="c"> *   ::= numberexpr</span>
<span class="c"> *   ::= parenexpr</span>
<span class="c"> *   ::= ifexpr</span>
<span class="c"> *   ::= forexpr</span>
<span class="c"> *   ::= varexpr *)</span>
<span class="k">let</span> <span class="k">rec</span> <span class="n">parse_primary</span> <span class="o">=</span> <span class="n">parser</span>
  <span class="c">(* numberexpr ::= number *)</span>
  <span class="o">|</span> <span class="o">[&lt;</span> <span class="k">&#39;</span><span class="nn">Token</span><span class="p">.</span><span class="nc">Number</span> <span class="n">n</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span> <span class="nn">Ast</span><span class="p">.</span><span class="nc">Number</span> <span class="n">n</span>

  <span class="c">(* parenexpr ::= &#39;(&#39; expression &#39;)&#39; *)</span>
  <span class="o">|</span> <span class="o">[&lt;</span> <span class="k">&#39;</span><span class="nn">Token</span><span class="p">.</span><span class="nc">Kwd</span> <span class="sc">&#39;(&#39;</span><span class="o">;</span> <span class="n">e</span><span class="o">=</span><span class="n">parse_expr</span><span class="o">;</span> <span class="k">&#39;</span><span class="nn">Token</span><span class="p">.</span><span class="nc">Kwd</span> <span class="sc">&#39;)&#39;</span> <span class="o">??</span> <span class="s2">&quot;expected &#39;)&#39;&quot;</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span> <span class="n">e</span>

  <span class="c">(* identifierexpr</span>
<span class="c">   *   ::= identifier</span>
<span class="c">   *   ::= identifier &#39;(&#39; argumentexpr &#39;)&#39; *)</span>
  <span class="o">|</span> <span class="o">[&lt;</span> <span class="k">&#39;</span><span class="nn">Token</span><span class="p">.</span><span class="nc">Ident</span> <span class="n">id</span><span class="o">;</span> <span class="n">stream</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span>
      <span class="k">let</span> <span class="k">rec</span> <span class="n">parse_args</span> <span class="n">accumulator</span> <span class="o">=</span> <span class="n">parser</span>
        <span class="o">|</span> <span class="o">[&lt;</span> <span class="n">e</span><span class="o">=</span><span class="n">parse_expr</span><span class="o">;</span> <span class="n">stream</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span>
            <span class="k">begin</span> <span class="n">parser</span>
              <span class="o">|</span> <span class="o">[&lt;</span> <span class="k">&#39;</span><span class="nn">Token</span><span class="p">.</span><span class="nc">Kwd</span> <span class="sc">&#39;,&#39;</span><span class="o">;</span> <span class="n">e</span><span class="o">=</span><span class="n">parse_args</span> <span class="o">(</span><span class="n">e</span> <span class="o">::</span> <span class="n">accumulator</span><span class="o">)</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span> <span class="n">e</span>
              <span class="o">|</span> <span class="o">[&lt;</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span> <span class="n">e</span> <span class="o">::</span> <span class="n">accumulator</span>
            <span class="k">end</span> <span class="n">stream</span>
        <span class="o">|</span> <span class="o">[&lt;</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span> <span class="n">accumulator</span>
      <span class="k">in</span>
      <span class="k">let</span> <span class="k">rec</span> <span class="n">parse_ident</span> <span class="n">id</span> <span class="o">=</span> <span class="n">parser</span>
        <span class="c">(* Call. *)</span>
        <span class="o">|</span> <span class="o">[&lt;</span> <span class="k">&#39;</span><span class="nn">Token</span><span class="p">.</span><span class="nc">Kwd</span> <span class="sc">&#39;(&#39;</span><span class="o">;</span>
             <span class="n">args</span><span class="o">=</span><span class="n">parse_args</span> <span class="bp">[]</span><span class="o">;</span>
             <span class="k">&#39;</span><span class="nn">Token</span><span class="p">.</span><span class="nc">Kwd</span> <span class="sc">&#39;)&#39;</span> <span class="o">??</span> <span class="s2">&quot;expected &#39;)&#39;&quot;</span><span class="o">&gt;]</span> <span class="o">-&gt;</span>
            <span class="nn">Ast</span><span class="p">.</span><span class="nc">Call</span> <span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="nn">Array</span><span class="p">.</span><span class="n">of_list</span> <span class="o">(</span><span class="nn">List</span><span class="p">.</span><span class="n">rev</span> <span class="n">args</span><span class="o">))</span>

        <span class="c">(* Simple variable ref. *)</span>
        <span class="o">|</span> <span class="o">[&lt;</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span> <span class="nn">Ast</span><span class="p">.</span><span class="nc">Variable</span> <span class="n">id</span>
      <span class="k">in</span>
      <span class="n">parse_ident</span> <span class="n">id</span> <span class="n">stream</span>

  <span class="c">(* ifexpr ::= &#39;if&#39; expr &#39;then&#39; expr &#39;else&#39; expr *)</span>
  <span class="o">|</span> <span class="o">[&lt;</span> <span class="k">&#39;</span><span class="nn">Token</span><span class="p">.</span><span class="nc">If</span><span class="o">;</span> <span class="n">c</span><span class="o">=</span><span class="n">parse_expr</span><span class="o">;</span>
       <span class="k">&#39;</span><span class="nn">Token</span><span class="p">.</span><span class="nc">Then</span> <span class="o">??</span> <span class="s2">&quot;expected &#39;then&#39;&quot;</span><span class="o">;</span> <span class="n">t</span><span class="o">=</span><span class="n">parse_expr</span><span class="o">;</span>
       <span class="k">&#39;</span><span class="nn">Token</span><span class="p">.</span><span class="nc">Else</span> <span class="o">??</span> <span class="s2">&quot;expected &#39;else&#39;&quot;</span><span class="o">;</span> <span class="n">e</span><span class="o">=</span><span class="n">parse_expr</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span>
      <span class="nn">Ast</span><span class="p">.</span><span class="nc">If</span> <span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">t</span><span class="o">,</span> <span class="n">e</span><span class="o">)</span>

  <span class="c">(* forexpr</span>
<span class="c">        ::= &#39;for&#39; identifier &#39;=&#39; expr &#39;,&#39; expr (&#39;,&#39; expr)? &#39;in&#39; expression *)</span>
  <span class="o">|</span> <span class="o">[&lt;</span> <span class="k">&#39;</span><span class="nn">Token</span><span class="p">.</span><span class="nc">For</span><span class="o">;</span>
       <span class="k">&#39;</span><span class="nn">Token</span><span class="p">.</span><span class="nc">Ident</span> <span class="n">id</span> <span class="o">??</span> <span class="s2">&quot;expected identifier after for&quot;</span><span class="o">;</span>
       <span class="k">&#39;</span><span class="nn">Token</span><span class="p">.</span><span class="nc">Kwd</span> <span class="sc">&#39;=&#39;</span> <span class="o">??</span> <span class="s2">&quot;expected &#39;=&#39; after for&quot;</span><span class="o">;</span>
       <span class="n">stream</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span>
      <span class="k">begin</span> <span class="n">parser</span>
        <span class="o">|</span> <span class="o">[&lt;</span>
             <span class="n">start</span><span class="o">=</span><span class="n">parse_expr</span><span class="o">;</span>
             <span class="k">&#39;</span><span class="nn">Token</span><span class="p">.</span><span class="nc">Kwd</span> <span class="sc">&#39;,&#39;</span> <span class="o">??</span> <span class="s2">&quot;expected &#39;,&#39; after for&quot;</span><span class="o">;</span>
             <span class="n">end_</span><span class="o">=</span><span class="n">parse_expr</span><span class="o">;</span>
             <span class="n">stream</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span>
            <span class="k">let</span> <span class="n">step</span> <span class="o">=</span>
              <span class="k">begin</span> <span class="n">parser</span>
              <span class="o">|</span> <span class="o">[&lt;</span> <span class="k">&#39;</span><span class="nn">Token</span><span class="p">.</span><span class="nc">Kwd</span> <span class="sc">&#39;,&#39;</span><span class="o">;</span> <span class="n">step</span><span class="o">=</span><span class="n">parse_expr</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span> <span class="nc">Some</span> <span class="n">step</span>
              <span class="o">|</span> <span class="o">[&lt;</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span> <span class="nc">None</span>
              <span class="k">end</span> <span class="n">stream</span>
            <span class="k">in</span>
            <span class="k">begin</span> <span class="n">parser</span>
            <span class="o">|</span> <span class="o">[&lt;</span> <span class="k">&#39;</span><span class="nn">Token</span><span class="p">.</span><span class="nc">In</span><span class="o">;</span> <span class="n">body</span><span class="o">=</span><span class="n">parse_expr</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span>
                <span class="nn">Ast</span><span class="p">.</span><span class="nc">For</span> <span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="n">start</span><span class="o">,</span> <span class="n">end_</span><span class="o">,</span> <span class="n">step</span><span class="o">,</span> <span class="n">body</span><span class="o">)</span>
            <span class="o">|</span> <span class="o">[&lt;</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span>
                <span class="k">raise</span> <span class="o">(</span><span class="nn">Stream</span><span class="p">.</span><span class="nc">Error</span> <span class="s2">&quot;expected &#39;in&#39; after for&quot;</span><span class="o">)</span>
            <span class="k">end</span> <span class="n">stream</span>
        <span class="o">|</span> <span class="o">[&lt;</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span>
            <span class="k">raise</span> <span class="o">(</span><span class="nn">Stream</span><span class="p">.</span><span class="nc">Error</span> <span class="s2">&quot;expected &#39;=&#39; after for&quot;</span><span class="o">)</span>
      <span class="k">end</span> <span class="n">stream</span>

  <span class="c">(* varexpr</span>
<span class="c">   *   ::= &#39;var&#39; identifier (&#39;=&#39; expression?</span>
<span class="c">   *             (&#39;,&#39; identifier (&#39;=&#39; expression)?)* &#39;in&#39; expression *)</span>
  <span class="o">|</span> <span class="o">[&lt;</span> <span class="k">&#39;</span><span class="nn">Token</span><span class="p">.</span><span class="nc">Var</span><span class="o">;</span>
       <span class="c">(* At least one variable name is required. *)</span>
       <span class="k">&#39;</span><span class="nn">Token</span><span class="p">.</span><span class="nc">Ident</span> <span class="n">id</span> <span class="o">??</span> <span class="s2">&quot;expected identifier after var&quot;</span><span class="o">;</span>
       <span class="n">init</span><span class="o">=</span><span class="n">parse_var_init</span><span class="o">;</span>
       <span class="n">var_names</span><span class="o">=</span><span class="n">parse_var_names</span> <span class="o">[(</span><span class="n">id</span><span class="o">,</span> <span class="n">init</span><span class="o">)];</span>
       <span class="c">(* At this point, we have to have &#39;in&#39;. *)</span>
       <span class="k">&#39;</span><span class="nn">Token</span><span class="p">.</span><span class="nc">In</span> <span class="o">??</span> <span class="s2">&quot;expected &#39;in&#39; keyword after &#39;var&#39;&quot;</span><span class="o">;</span>
       <span class="n">body</span><span class="o">=</span><span class="n">parse_expr</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span>
      <span class="nn">Ast</span><span class="p">.</span><span class="nc">Var</span> <span class="o">(</span><span class="nn">Array</span><span class="p">.</span><span class="n">of_list</span> <span class="o">(</span><span class="nn">List</span><span class="p">.</span><span class="n">rev</span> <span class="n">var_names</span><span class="o">),</span> <span class="n">body</span><span class="o">)</span>

  <span class="o">|</span> <span class="o">[&lt;</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span> <span class="k">raise</span> <span class="o">(</span><span class="nn">Stream</span><span class="p">.</span><span class="nc">Error</span> <span class="s2">&quot;unknown token when expecting an expression.&quot;</span><span class="o">)</span>

<span class="c">(* unary</span>
<span class="c"> *   ::= primary</span>
<span class="c"> *   ::= &#39;!&#39; unary *)</span>
<span class="ow">and</span> <span class="n">parse_unary</span> <span class="o">=</span> <span class="n">parser</span>
  <span class="c">(* If this is a unary operator, read it. *)</span>
  <span class="o">|</span> <span class="o">[&lt;</span> <span class="k">&#39;</span><span class="nn">Token</span><span class="p">.</span><span class="nc">Kwd</span> <span class="n">op</span> <span class="k">when</span> <span class="n">op</span> <span class="o">!=</span> <span class="sc">&#39;(&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">op</span> <span class="o">!=</span> <span class="sc">&#39;)&#39;</span><span class="o">;</span> <span class="n">operand</span><span class="o">=</span><span class="n">parse_expr</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span>
      <span class="nn">Ast</span><span class="p">.</span><span class="nc">Unary</span> <span class="o">(</span><span class="n">op</span><span class="o">,</span> <span class="n">operand</span><span class="o">)</span>

  <span class="c">(* If the current token is not an operator, it must be a primary expr. *)</span>
  <span class="o">|</span> <span class="o">[&lt;</span> <span class="n">stream</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span> <span class="n">parse_primary</span> <span class="n">stream</span>

<span class="c">(* binoprhs</span>
<span class="c"> *   ::= (&#39;+&#39; primary)* *)</span>
<span class="ow">and</span> <span class="n">parse_bin_rhs</span> <span class="n">expr_prec</span> <span class="n">lhs</span> <span class="n">stream</span> <span class="o">=</span>
  <span class="k">match</span> <span class="nn">Stream</span><span class="p">.</span><span class="n">peek</span> <span class="n">stream</span> <span class="k">with</span>
  <span class="c">(* If this is a binop, find its precedence. *)</span>
  <span class="o">|</span> <span class="nc">Some</span> <span class="o">(</span><span class="nn">Token</span><span class="p">.</span><span class="nc">Kwd</span> <span class="n">c</span><span class="o">)</span> <span class="k">when</span> <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">mem</span> <span class="n">binop_precedence</span> <span class="n">c</span> <span class="o">-&gt;</span>
      <span class="k">let</span> <span class="n">token_prec</span> <span class="o">=</span> <span class="n">precedence</span> <span class="n">c</span> <span class="k">in</span>

      <span class="c">(* If this is a binop that binds at least as tightly as the current binop,</span>
<span class="c">       * consume it, otherwise we are done. *)</span>
      <span class="k">if</span> <span class="n">token_prec</span> <span class="o">&lt;</span> <span class="n">expr_prec</span> <span class="k">then</span> <span class="n">lhs</span> <span class="k">else</span> <span class="k">begin</span>
        <span class="c">(* Eat the binop. *)</span>
        <span class="nn">Stream</span><span class="p">.</span><span class="n">junk</span> <span class="n">stream</span><span class="o">;</span>

        <span class="c">(* Parse the primary expression after the binary operator. *)</span>
        <span class="k">let</span> <span class="n">rhs</span> <span class="o">=</span> <span class="n">parse_unary</span> <span class="n">stream</span> <span class="k">in</span>

        <span class="c">(* Okay, we know this is a binop. *)</span>
        <span class="k">let</span> <span class="n">rhs</span> <span class="o">=</span>
          <span class="k">match</span> <span class="nn">Stream</span><span class="p">.</span><span class="n">peek</span> <span class="n">stream</span> <span class="k">with</span>
          <span class="o">|</span> <span class="nc">Some</span> <span class="o">(</span><span class="nn">Token</span><span class="p">.</span><span class="nc">Kwd</span> <span class="n">c2</span><span class="o">)</span> <span class="o">-&gt;</span>
              <span class="c">(* If BinOp binds less tightly with rhs than the operator after</span>
<span class="c">               * rhs, let the pending operator take rhs as its lhs. *)</span>
              <span class="k">let</span> <span class="n">next_prec</span> <span class="o">=</span> <span class="n">precedence</span> <span class="n">c2</span> <span class="k">in</span>
              <span class="k">if</span> <span class="n">token_prec</span> <span class="o">&lt;</span> <span class="n">next_prec</span>
              <span class="k">then</span> <span class="n">parse_bin_rhs</span> <span class="o">(</span><span class="n">token_prec</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">rhs</span> <span class="n">stream</span>
              <span class="k">else</span> <span class="n">rhs</span>
          <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="n">rhs</span>
        <span class="k">in</span>

        <span class="c">(* Merge lhs/rhs. *)</span>
        <span class="k">let</span> <span class="n">lhs</span> <span class="o">=</span> <span class="nn">Ast</span><span class="p">.</span><span class="nc">Binary</span> <span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">lhs</span><span class="o">,</span> <span class="n">rhs</span><span class="o">)</span> <span class="k">in</span>
        <span class="n">parse_bin_rhs</span> <span class="n">expr_prec</span> <span class="n">lhs</span> <span class="n">stream</span>
      <span class="k">end</span>
  <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="n">lhs</span>

<span class="ow">and</span> <span class="n">parse_var_init</span> <span class="o">=</span> <span class="n">parser</span>
  <span class="c">(* read in the optional initializer. *)</span>
  <span class="o">|</span> <span class="o">[&lt;</span> <span class="k">&#39;</span><span class="nn">Token</span><span class="p">.</span><span class="nc">Kwd</span> <span class="sc">&#39;=&#39;</span><span class="o">;</span> <span class="n">e</span><span class="o">=</span><span class="n">parse_expr</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span> <span class="nc">Some</span> <span class="n">e</span>
  <span class="o">|</span> <span class="o">[&lt;</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span> <span class="nc">None</span>

<span class="ow">and</span> <span class="n">parse_var_names</span> <span class="n">accumulator</span> <span class="o">=</span> <span class="n">parser</span>
  <span class="o">|</span> <span class="o">[&lt;</span> <span class="k">&#39;</span><span class="nn">Token</span><span class="p">.</span><span class="nc">Kwd</span> <span class="sc">&#39;,&#39;</span><span class="o">;</span>
       <span class="k">&#39;</span><span class="nn">Token</span><span class="p">.</span><span class="nc">Ident</span> <span class="n">id</span> <span class="o">??</span> <span class="s2">&quot;expected identifier list after var&quot;</span><span class="o">;</span>
       <span class="n">init</span><span class="o">=</span><span class="n">parse_var_init</span><span class="o">;</span>
       <span class="n">e</span><span class="o">=</span><span class="n">parse_var_names</span> <span class="o">((</span><span class="n">id</span><span class="o">,</span> <span class="n">init</span><span class="o">)</span> <span class="o">::</span> <span class="n">accumulator</span><span class="o">)</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span> <span class="n">e</span>
  <span class="o">|</span> <span class="o">[&lt;</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span> <span class="n">accumulator</span>

<span class="c">(* expression</span>
<span class="c"> *   ::= primary binoprhs *)</span>
<span class="ow">and</span> <span class="n">parse_expr</span> <span class="o">=</span> <span class="n">parser</span>
  <span class="o">|</span> <span class="o">[&lt;</span> <span class="n">lhs</span><span class="o">=</span><span class="n">parse_unary</span><span class="o">;</span> <span class="n">stream</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span> <span class="n">parse_bin_rhs</span> <span class="mi">0</span> <span class="n">lhs</span> <span class="n">stream</span>

<span class="c">(* prototype</span>
<span class="c"> *   ::= id &#39;(&#39; id* &#39;)&#39;</span>
<span class="c"> *   ::= binary LETTER number? (id, id)</span>
<span class="c"> *   ::= unary LETTER number? (id) *)</span>
<span class="k">let</span> <span class="n">parse_prototype</span> <span class="o">=</span>
  <span class="k">let</span> <span class="k">rec</span> <span class="n">parse_args</span> <span class="n">accumulator</span> <span class="o">=</span> <span class="n">parser</span>
    <span class="o">|</span> <span class="o">[&lt;</span> <span class="k">&#39;</span><span class="nn">Token</span><span class="p">.</span><span class="nc">Ident</span> <span class="n">id</span><span class="o">;</span> <span class="n">e</span><span class="o">=</span><span class="n">parse_args</span> <span class="o">(</span><span class="n">id</span><span class="o">::</span><span class="n">accumulator</span><span class="o">)</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span> <span class="n">e</span>
    <span class="o">|</span> <span class="o">[&lt;</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span> <span class="n">accumulator</span>
  <span class="k">in</span>
  <span class="k">let</span> <span class="n">parse_operator</span> <span class="o">=</span> <span class="n">parser</span>
    <span class="o">|</span> <span class="o">[&lt;</span> <span class="k">&#39;</span><span class="nn">Token</span><span class="p">.</span><span class="nc">Unary</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span> <span class="s2">&quot;unary&quot;</span><span class="o">,</span> <span class="mi">1</span>
    <span class="o">|</span> <span class="o">[&lt;</span> <span class="k">&#39;</span><span class="nn">Token</span><span class="p">.</span><span class="nc">Binary</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span> <span class="s2">&quot;binary&quot;</span><span class="o">,</span> <span class="mi">2</span>
  <span class="k">in</span>
  <span class="k">let</span> <span class="n">parse_binary_precedence</span> <span class="o">=</span> <span class="n">parser</span>
    <span class="o">|</span> <span class="o">[&lt;</span> <span class="k">&#39;</span><span class="nn">Token</span><span class="p">.</span><span class="nc">Number</span> <span class="n">n</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span> <span class="n">int_of_float</span> <span class="n">n</span>
    <span class="o">|</span> <span class="o">[&lt;</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span> <span class="mi">30</span>
  <span class="k">in</span>
  <span class="n">parser</span>
  <span class="o">|</span> <span class="o">[&lt;</span> <span class="k">&#39;</span><span class="nn">Token</span><span class="p">.</span><span class="nc">Ident</span> <span class="n">id</span><span class="o">;</span>
       <span class="k">&#39;</span><span class="nn">Token</span><span class="p">.</span><span class="nc">Kwd</span> <span class="sc">&#39;(&#39;</span> <span class="o">??</span> <span class="s2">&quot;expected &#39;(&#39; in prototype&quot;</span><span class="o">;</span>
       <span class="n">args</span><span class="o">=</span><span class="n">parse_args</span> <span class="bp">[]</span><span class="o">;</span>
       <span class="k">&#39;</span><span class="nn">Token</span><span class="p">.</span><span class="nc">Kwd</span> <span class="sc">&#39;)&#39;</span> <span class="o">??</span> <span class="s2">&quot;expected &#39;)&#39; in prototype&quot;</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span>
      <span class="c">(* success. *)</span>
      <span class="nn">Ast</span><span class="p">.</span><span class="nc">Prototype</span> <span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="nn">Array</span><span class="p">.</span><span class="n">of_list</span> <span class="o">(</span><span class="nn">List</span><span class="p">.</span><span class="n">rev</span> <span class="n">args</span><span class="o">))</span>
  <span class="o">|</span> <span class="o">[&lt;</span> <span class="o">(</span><span class="n">prefix</span><span class="o">,</span> <span class="n">kind</span><span class="o">)=</span><span class="n">parse_operator</span><span class="o">;</span>
       <span class="k">&#39;</span><span class="nn">Token</span><span class="p">.</span><span class="nc">Kwd</span> <span class="n">op</span> <span class="o">??</span> <span class="s2">&quot;expected an operator&quot;</span><span class="o">;</span>
       <span class="c">(* Read the precedence if present. *)</span>
       <span class="n">binary_precedence</span><span class="o">=</span><span class="n">parse_binary_precedence</span><span class="o">;</span>
       <span class="k">&#39;</span><span class="nn">Token</span><span class="p">.</span><span class="nc">Kwd</span> <span class="sc">&#39;(&#39;</span> <span class="o">??</span> <span class="s2">&quot;expected &#39;(&#39; in prototype&quot;</span><span class="o">;</span>
        <span class="n">args</span><span class="o">=</span><span class="n">parse_args</span> <span class="bp">[]</span><span class="o">;</span>
       <span class="k">&#39;</span><span class="nn">Token</span><span class="p">.</span><span class="nc">Kwd</span> <span class="sc">&#39;)&#39;</span> <span class="o">??</span> <span class="s2">&quot;expected &#39;)&#39; in prototype&quot;</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span>
      <span class="k">let</span> <span class="n">name</span> <span class="o">=</span> <span class="n">prefix</span> <span class="o">^</span> <span class="o">(</span><span class="nn">String</span><span class="p">.</span><span class="n">make</span> <span class="mi">1</span> <span class="n">op</span><span class="o">)</span> <span class="k">in</span>
      <span class="k">let</span> <span class="n">args</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">of_list</span> <span class="o">(</span><span class="nn">List</span><span class="p">.</span><span class="n">rev</span> <span class="n">args</span><span class="o">)</span> <span class="k">in</span>

      <span class="c">(* Verify right number of arguments for operator. *)</span>
      <span class="k">if</span> <span class="nn">Array</span><span class="p">.</span><span class="n">length</span> <span class="n">args</span> <span class="o">!=</span> <span class="n">kind</span>
      <span class="k">then</span> <span class="k">raise</span> <span class="o">(</span><span class="nn">Stream</span><span class="p">.</span><span class="nc">Error</span> <span class="s2">&quot;invalid number of operands for operator&quot;</span><span class="o">)</span>
      <span class="k">else</span>
        <span class="k">if</span> <span class="n">kind</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">then</span>
          <span class="nn">Ast</span><span class="p">.</span><span class="nc">Prototype</span> <span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">args</span><span class="o">)</span>
        <span class="k">else</span>
          <span class="nn">Ast</span><span class="p">.</span><span class="nc">BinOpPrototype</span> <span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">args</span><span class="o">,</span> <span class="n">binary_precedence</span><span class="o">)</span>
  <span class="o">|</span> <span class="o">[&lt;</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span>
      <span class="k">raise</span> <span class="o">(</span><span class="nn">Stream</span><span class="p">.</span><span class="nc">Error</span> <span class="s2">&quot;expected function name in prototype&quot;</span><span class="o">)</span>

<span class="c">(* definition ::= &#39;def&#39; prototype expression *)</span>
<span class="k">let</span> <span class="n">parse_definition</span> <span class="o">=</span> <span class="n">parser</span>
  <span class="o">|</span> <span class="o">[&lt;</span> <span class="k">&#39;</span><span class="nn">Token</span><span class="p">.</span><span class="nc">Def</span><span class="o">;</span> <span class="n">p</span><span class="o">=</span><span class="n">parse_prototype</span><span class="o">;</span> <span class="n">e</span><span class="o">=</span><span class="n">parse_expr</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span>
      <span class="nn">Ast</span><span class="p">.</span><span class="nc">Function</span> <span class="o">(</span><span class="n">p</span><span class="o">,</span> <span class="n">e</span><span class="o">)</span>

<span class="c">(* toplevelexpr ::= expression *)</span>
<span class="k">let</span> <span class="n">parse_toplevel</span> <span class="o">=</span> <span class="n">parser</span>
  <span class="o">|</span> <span class="o">[&lt;</span> <span class="n">e</span><span class="o">=</span><span class="n">parse_expr</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span>
      <span class="c">(* Make an anonymous proto. *)</span>
      <span class="nn">Ast</span><span class="p">.</span><span class="nc">Function</span> <span class="o">(</span><span class="nn">Ast</span><span class="p">.</span><span class="nc">Prototype</span> <span class="o">(</span><span class="s2">&quot;&quot;</span><span class="o">,</span> <span class="o">[||]),</span> <span class="n">e</span><span class="o">)</span>

<span class="c">(*  external ::= &#39;extern&#39; prototype *)</span>
<span class="k">let</span> <span class="n">parse_extern</span> <span class="o">=</span> <span class="n">parser</span>
  <span class="o">|</span> <span class="o">[&lt;</span> <span class="k">&#39;</span><span class="nn">Token</span><span class="p">.</span><span class="nc">Extern</span><span class="o">;</span> <span class="n">e</span><span class="o">=</span><span class="n">parse_prototype</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span> <span class="n">e</span>
</pre></div>
</div>
</dd>
<dt>codegen.ml:</dt>
<dd><div class="first last highlight-ocaml"><div class="highlight"><pre><span></span><span class="c">(*===----------------------------------------------------------------------===</span>
<span class="c"> * Code Generation</span>
<span class="c"> *===----------------------------------------------------------------------===*)</span>

<span class="k">open</span> <span class="nc">Llvm</span>

<span class="k">exception</span> <span class="nc">Error</span> <span class="k">of</span> <span class="kt">string</span>

<span class="k">let</span> <span class="n">context</span> <span class="o">=</span> <span class="n">global_context</span> <span class="bp">()</span>
<span class="k">let</span> <span class="n">the_module</span> <span class="o">=</span> <span class="n">create_module</span> <span class="n">context</span> <span class="s2">&quot;my cool jit&quot;</span>
<span class="k">let</span> <span class="n">builder</span> <span class="o">=</span> <span class="n">builder</span> <span class="n">context</span>
<span class="k">let</span> <span class="n">named_values</span><span class="o">:(</span><span class="kt">string</span><span class="o">,</span> <span class="n">llvalue</span><span class="o">)</span> <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">create</span> <span class="mi">10</span>
<span class="k">let</span> <span class="n">double_type</span> <span class="o">=</span> <span class="n">double_type</span> <span class="n">context</span>

<span class="c">(* Create an alloca instruction in the entry block of the function. This</span>
<span class="c"> * is used for mutable variables etc. *)</span>
<span class="k">let</span> <span class="n">create_entry_block_alloca</span> <span class="n">the_function</span> <span class="n">var_name</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">builder</span> <span class="o">=</span> <span class="n">builder_at</span> <span class="n">context</span> <span class="o">(</span><span class="n">instr_begin</span> <span class="o">(</span><span class="n">entry_block</span> <span class="n">the_function</span><span class="o">))</span> <span class="k">in</span>
  <span class="n">build_alloca</span> <span class="n">double_type</span> <span class="n">var_name</span> <span class="n">builder</span>

<span class="k">let</span> <span class="k">rec</span> <span class="n">codegen_expr</span> <span class="o">=</span> <span class="k">function</span>
  <span class="o">|</span> <span class="nn">Ast</span><span class="p">.</span><span class="nc">Number</span> <span class="n">n</span> <span class="o">-&gt;</span> <span class="n">const_float</span> <span class="n">double_type</span> <span class="n">n</span>
  <span class="o">|</span> <span class="nn">Ast</span><span class="p">.</span><span class="nc">Variable</span> <span class="n">name</span> <span class="o">-&gt;</span>
      <span class="k">let</span> <span class="n">v</span> <span class="o">=</span> <span class="k">try</span> <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">find</span> <span class="n">named_values</span> <span class="n">name</span> <span class="k">with</span>
        <span class="o">|</span> <span class="nc">Not_found</span> <span class="o">-&gt;</span> <span class="k">raise</span> <span class="o">(</span><span class="nc">Error</span> <span class="s2">&quot;unknown variable name&quot;</span><span class="o">)</span>
      <span class="k">in</span>
      <span class="c">(* Load the value. *)</span>
      <span class="n">build_load</span> <span class="n">v</span> <span class="n">name</span> <span class="n">builder</span>
  <span class="o">|</span> <span class="nn">Ast</span><span class="p">.</span><span class="nc">Unary</span> <span class="o">(</span><span class="n">op</span><span class="o">,</span> <span class="n">operand</span><span class="o">)</span> <span class="o">-&gt;</span>
      <span class="k">let</span> <span class="n">operand</span> <span class="o">=</span> <span class="n">codegen_expr</span> <span class="n">operand</span> <span class="k">in</span>
      <span class="k">let</span> <span class="n">callee</span> <span class="o">=</span> <span class="s2">&quot;unary&quot;</span> <span class="o">^</span> <span class="o">(</span><span class="nn">String</span><span class="p">.</span><span class="n">make</span> <span class="mi">1</span> <span class="n">op</span><span class="o">)</span> <span class="k">in</span>
      <span class="k">let</span> <span class="n">callee</span> <span class="o">=</span>
        <span class="k">match</span> <span class="n">lookup_function</span> <span class="n">callee</span> <span class="n">the_module</span> <span class="k">with</span>
        <span class="o">|</span> <span class="nc">Some</span> <span class="n">callee</span> <span class="o">-&gt;</span> <span class="n">callee</span>
        <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="k">raise</span> <span class="o">(</span><span class="nc">Error</span> <span class="s2">&quot;unknown unary operator&quot;</span><span class="o">)</span>
      <span class="k">in</span>
      <span class="n">build_call</span> <span class="n">callee</span> <span class="o">[|</span><span class="n">operand</span><span class="o">|]</span> <span class="s2">&quot;unop&quot;</span> <span class="n">builder</span>
  <span class="o">|</span> <span class="nn">Ast</span><span class="p">.</span><span class="nc">Binary</span> <span class="o">(</span><span class="n">op</span><span class="o">,</span> <span class="n">lhs</span><span class="o">,</span> <span class="n">rhs</span><span class="o">)</span> <span class="o">-&gt;</span>
      <span class="k">begin</span> <span class="k">match</span> <span class="n">op</span> <span class="k">with</span>
      <span class="o">|</span> <span class="sc">&#39;=&#39;</span> <span class="o">-&gt;</span>
          <span class="c">(* Special case &#39;=&#39; because we don&#39;t want to emit the LHS as an</span>
<span class="c">           * expression. *)</span>
          <span class="k">let</span> <span class="n">name</span> <span class="o">=</span>
            <span class="k">match</span> <span class="n">lhs</span> <span class="k">with</span>
            <span class="o">|</span> <span class="nn">Ast</span><span class="p">.</span><span class="nc">Variable</span> <span class="n">name</span> <span class="o">-&gt;</span> <span class="n">name</span>
            <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="k">raise</span> <span class="o">(</span><span class="nc">Error</span> <span class="s2">&quot;destination of &#39;=&#39; must be a variable&quot;</span><span class="o">)</span>
          <span class="k">in</span>

          <span class="c">(* Codegen the rhs. *)</span>
          <span class="k">let</span> <span class="n">val_</span> <span class="o">=</span> <span class="n">codegen_expr</span> <span class="n">rhs</span> <span class="k">in</span>

          <span class="c">(* Lookup the name. *)</span>
          <span class="k">let</span> <span class="n">variable</span> <span class="o">=</span> <span class="k">try</span> <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">find</span> <span class="n">named_values</span> <span class="n">name</span> <span class="k">with</span>
          <span class="o">|</span> <span class="nc">Not_found</span> <span class="o">-&gt;</span> <span class="k">raise</span> <span class="o">(</span><span class="nc">Error</span> <span class="s2">&quot;unknown variable name&quot;</span><span class="o">)</span>
          <span class="k">in</span>
          <span class="n">ignore</span><span class="o">(</span><span class="n">build_store</span> <span class="n">val_</span> <span class="n">variable</span> <span class="n">builder</span><span class="o">);</span>
          <span class="n">val_</span>
      <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span>
          <span class="k">let</span> <span class="n">lhs_val</span> <span class="o">=</span> <span class="n">codegen_expr</span> <span class="n">lhs</span> <span class="k">in</span>
          <span class="k">let</span> <span class="n">rhs_val</span> <span class="o">=</span> <span class="n">codegen_expr</span> <span class="n">rhs</span> <span class="k">in</span>
          <span class="k">begin</span>
            <span class="k">match</span> <span class="n">op</span> <span class="k">with</span>
            <span class="o">|</span> <span class="sc">&#39;+&#39;</span> <span class="o">-&gt;</span> <span class="n">build_add</span> <span class="n">lhs_val</span> <span class="n">rhs_val</span> <span class="s2">&quot;addtmp&quot;</span> <span class="n">builder</span>
            <span class="o">|</span> <span class="sc">&#39;-&#39;</span> <span class="o">-&gt;</span> <span class="n">build_sub</span> <span class="n">lhs_val</span> <span class="n">rhs_val</span> <span class="s2">&quot;subtmp&quot;</span> <span class="n">builder</span>
            <span class="o">|</span> <span class="sc">&#39;*&#39;</span> <span class="o">-&gt;</span> <span class="n">build_mul</span> <span class="n">lhs_val</span> <span class="n">rhs_val</span> <span class="s2">&quot;multmp&quot;</span> <span class="n">builder</span>
            <span class="o">|</span> <span class="sc">&#39;&lt;&#39;</span> <span class="o">-&gt;</span>
                <span class="c">(* Convert bool 0/1 to double 0.0 or 1.0 *)</span>
                <span class="k">let</span> <span class="n">i</span> <span class="o">=</span> <span class="n">build_fcmp</span> <span class="nn">Fcmp</span><span class="p">.</span><span class="nc">Ult</span> <span class="n">lhs_val</span> <span class="n">rhs_val</span> <span class="s2">&quot;cmptmp&quot;</span> <span class="n">builder</span> <span class="k">in</span>
                <span class="n">build_uitofp</span> <span class="n">i</span> <span class="n">double_type</span> <span class="s2">&quot;booltmp&quot;</span> <span class="n">builder</span>
            <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span>
                <span class="c">(* If it wasn&#39;t a builtin binary operator, it must be a user defined</span>
<span class="c">                 * one. Emit a call to it. *)</span>
                <span class="k">let</span> <span class="n">callee</span> <span class="o">=</span> <span class="s2">&quot;binary&quot;</span> <span class="o">^</span> <span class="o">(</span><span class="nn">String</span><span class="p">.</span><span class="n">make</span> <span class="mi">1</span> <span class="n">op</span><span class="o">)</span> <span class="k">in</span>
                <span class="k">let</span> <span class="n">callee</span> <span class="o">=</span>
                  <span class="k">match</span> <span class="n">lookup_function</span> <span class="n">callee</span> <span class="n">the_module</span> <span class="k">with</span>
                  <span class="o">|</span> <span class="nc">Some</span> <span class="n">callee</span> <span class="o">-&gt;</span> <span class="n">callee</span>
                  <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="k">raise</span> <span class="o">(</span><span class="nc">Error</span> <span class="s2">&quot;binary operator not found!&quot;</span><span class="o">)</span>
                <span class="k">in</span>
                <span class="n">build_call</span> <span class="n">callee</span> <span class="o">[|</span><span class="n">lhs_val</span><span class="o">;</span> <span class="n">rhs_val</span><span class="o">|]</span> <span class="s2">&quot;binop&quot;</span> <span class="n">builder</span>
          <span class="k">end</span>
      <span class="k">end</span>
  <span class="o">|</span> <span class="nn">Ast</span><span class="p">.</span><span class="nc">Call</span> <span class="o">(</span><span class="n">callee</span><span class="o">,</span> <span class="n">args</span><span class="o">)</span> <span class="o">-&gt;</span>
      <span class="c">(* Look up the name in the module table. *)</span>
      <span class="k">let</span> <span class="n">callee</span> <span class="o">=</span>
        <span class="k">match</span> <span class="n">lookup_function</span> <span class="n">callee</span> <span class="n">the_module</span> <span class="k">with</span>
        <span class="o">|</span> <span class="nc">Some</span> <span class="n">callee</span> <span class="o">-&gt;</span> <span class="n">callee</span>
        <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="k">raise</span> <span class="o">(</span><span class="nc">Error</span> <span class="s2">&quot;unknown function referenced&quot;</span><span class="o">)</span>
      <span class="k">in</span>
      <span class="k">let</span> <span class="n">params</span> <span class="o">=</span> <span class="n">params</span> <span class="n">callee</span> <span class="k">in</span>

      <span class="c">(* If argument mismatch error. *)</span>
      <span class="k">if</span> <span class="nn">Array</span><span class="p">.</span><span class="n">length</span> <span class="n">params</span> <span class="o">==</span> <span class="nn">Array</span><span class="p">.</span><span class="n">length</span> <span class="n">args</span> <span class="k">then</span> <span class="bp">()</span> <span class="k">else</span>
        <span class="k">raise</span> <span class="o">(</span><span class="nc">Error</span> <span class="s2">&quot;incorrect # arguments passed&quot;</span><span class="o">);</span>
      <span class="k">let</span> <span class="n">args</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">map</span> <span class="n">codegen_expr</span> <span class="n">args</span> <span class="k">in</span>
      <span class="n">build_call</span> <span class="n">callee</span> <span class="n">args</span> <span class="s2">&quot;calltmp&quot;</span> <span class="n">builder</span>
  <span class="o">|</span> <span class="nn">Ast</span><span class="p">.</span><span class="nc">If</span> <span class="o">(</span><span class="n">cond</span><span class="o">,</span> <span class="n">then_</span><span class="o">,</span> <span class="n">else_</span><span class="o">)</span> <span class="o">-&gt;</span>
      <span class="k">let</span> <span class="n">cond</span> <span class="o">=</span> <span class="n">codegen_expr</span> <span class="n">cond</span> <span class="k">in</span>

      <span class="c">(* Convert condition to a bool by comparing equal to 0.0 *)</span>
      <span class="k">let</span> <span class="n">zero</span> <span class="o">=</span> <span class="n">const_float</span> <span class="n">double_type</span> <span class="mi">0</span><span class="o">.</span><span class="mi">0</span> <span class="k">in</span>
      <span class="k">let</span> <span class="n">cond_val</span> <span class="o">=</span> <span class="n">build_fcmp</span> <span class="nn">Fcmp</span><span class="p">.</span><span class="nc">One</span> <span class="n">cond</span> <span class="n">zero</span> <span class="s2">&quot;ifcond&quot;</span> <span class="n">builder</span> <span class="k">in</span>

      <span class="c">(* Grab the first block so that we might later add the conditional branch</span>
<span class="c">       * to it at the end of the function. *)</span>
      <span class="k">let</span> <span class="n">start_bb</span> <span class="o">=</span> <span class="n">insertion_block</span> <span class="n">builder</span> <span class="k">in</span>
      <span class="k">let</span> <span class="n">the_function</span> <span class="o">=</span> <span class="n">block_parent</span> <span class="n">start_bb</span> <span class="k">in</span>

      <span class="k">let</span> <span class="n">then_bb</span> <span class="o">=</span> <span class="n">append_block</span> <span class="n">context</span> <span class="s2">&quot;then&quot;</span> <span class="n">the_function</span> <span class="k">in</span>

      <span class="c">(* Emit &#39;then&#39; value. *)</span>
      <span class="n">position_at_end</span> <span class="n">then_bb</span> <span class="n">builder</span><span class="o">;</span>
      <span class="k">let</span> <span class="n">then_val</span> <span class="o">=</span> <span class="n">codegen_expr</span> <span class="n">then_</span> <span class="k">in</span>

      <span class="c">(* Codegen of &#39;then&#39; can change the current block, update then_bb for the</span>
<span class="c">       * phi. We create a new name because one is used for the phi node, and the</span>
<span class="c">       * other is used for the conditional branch. *)</span>
      <span class="k">let</span> <span class="n">new_then_bb</span> <span class="o">=</span> <span class="n">insertion_block</span> <span class="n">builder</span> <span class="k">in</span>

      <span class="c">(* Emit &#39;else&#39; value. *)</span>
      <span class="k">let</span> <span class="n">else_bb</span> <span class="o">=</span> <span class="n">append_block</span> <span class="n">context</span> <span class="s2">&quot;else&quot;</span> <span class="n">the_function</span> <span class="k">in</span>
      <span class="n">position_at_end</span> <span class="n">else_bb</span> <span class="n">builder</span><span class="o">;</span>
      <span class="k">let</span> <span class="n">else_val</span> <span class="o">=</span> <span class="n">codegen_expr</span> <span class="n">else_</span> <span class="k">in</span>

      <span class="c">(* Codegen of &#39;else&#39; can change the current block, update else_bb for the</span>
<span class="c">       * phi. *)</span>
      <span class="k">let</span> <span class="n">new_else_bb</span> <span class="o">=</span> <span class="n">insertion_block</span> <span class="n">builder</span> <span class="k">in</span>

      <span class="c">(* Emit merge block. *)</span>
      <span class="k">let</span> <span class="n">merge_bb</span> <span class="o">=</span> <span class="n">append_block</span> <span class="n">context</span> <span class="s2">&quot;ifcont&quot;</span> <span class="n">the_function</span> <span class="k">in</span>
      <span class="n">position_at_end</span> <span class="n">merge_bb</span> <span class="n">builder</span><span class="o">;</span>
      <span class="k">let</span> <span class="n">incoming</span> <span class="o">=</span> <span class="o">[(</span><span class="n">then_val</span><span class="o">,</span> <span class="n">new_then_bb</span><span class="o">);</span> <span class="o">(</span><span class="n">else_val</span><span class="o">,</span> <span class="n">new_else_bb</span><span class="o">)]</span> <span class="k">in</span>
      <span class="k">let</span> <span class="n">phi</span> <span class="o">=</span> <span class="n">build_phi</span> <span class="n">incoming</span> <span class="s2">&quot;iftmp&quot;</span> <span class="n">builder</span> <span class="k">in</span>

      <span class="c">(* Return to the start block to add the conditional branch. *)</span>
      <span class="n">position_at_end</span> <span class="n">start_bb</span> <span class="n">builder</span><span class="o">;</span>
      <span class="n">ignore</span> <span class="o">(</span><span class="n">build_cond_br</span> <span class="n">cond_val</span> <span class="n">then_bb</span> <span class="n">else_bb</span> <span class="n">builder</span><span class="o">);</span>

      <span class="c">(* Set a unconditional branch at the end of the &#39;then&#39; block and the</span>
<span class="c">       * &#39;else&#39; block to the &#39;merge&#39; block. *)</span>
      <span class="n">position_at_end</span> <span class="n">new_then_bb</span> <span class="n">builder</span><span class="o">;</span> <span class="n">ignore</span> <span class="o">(</span><span class="n">build_br</span> <span class="n">merge_bb</span> <span class="n">builder</span><span class="o">);</span>
      <span class="n">position_at_end</span> <span class="n">new_else_bb</span> <span class="n">builder</span><span class="o">;</span> <span class="n">ignore</span> <span class="o">(</span><span class="n">build_br</span> <span class="n">merge_bb</span> <span class="n">builder</span><span class="o">);</span>

      <span class="c">(* Finally, set the builder to the end of the merge block. *)</span>
      <span class="n">position_at_end</span> <span class="n">merge_bb</span> <span class="n">builder</span><span class="o">;</span>

      <span class="n">phi</span>
  <span class="o">|</span> <span class="nn">Ast</span><span class="p">.</span><span class="nc">For</span> <span class="o">(</span><span class="n">var_name</span><span class="o">,</span> <span class="n">start</span><span class="o">,</span> <span class="n">end_</span><span class="o">,</span> <span class="n">step</span><span class="o">,</span> <span class="n">body</span><span class="o">)</span> <span class="o">-&gt;</span>
      <span class="c">(* Output this as:</span>
<span class="c">       *   var = alloca double</span>
<span class="c">       *   ...</span>
<span class="c">       *   start = startexpr</span>
<span class="c">       *   store start -&gt; var</span>
<span class="c">       *   goto loop</span>
<span class="c">       * loop:</span>
<span class="c">       *   ...</span>
<span class="c">       *   bodyexpr</span>
<span class="c">       *   ...</span>
<span class="c">       * loopend:</span>
<span class="c">       *   step = stepexpr</span>
<span class="c">       *   endcond = endexpr</span>
<span class="c">       *</span>
<span class="c">       *   curvar = load var</span>
<span class="c">       *   nextvar = curvar + step</span>
<span class="c">       *   store nextvar -&gt; var</span>
<span class="c">       *   br endcond, loop, endloop</span>
<span class="c">       * outloop: *)</span>

      <span class="k">let</span> <span class="n">the_function</span> <span class="o">=</span> <span class="n">block_parent</span> <span class="o">(</span><span class="n">insertion_block</span> <span class="n">builder</span><span class="o">)</span> <span class="k">in</span>

      <span class="c">(* Create an alloca for the variable in the entry block. *)</span>
      <span class="k">let</span> <span class="n">alloca</span> <span class="o">=</span> <span class="n">create_entry_block_alloca</span> <span class="n">the_function</span> <span class="n">var_name</span> <span class="k">in</span>

      <span class="c">(* Emit the start code first, without &#39;variable&#39; in scope. *)</span>
      <span class="k">let</span> <span class="n">start_val</span> <span class="o">=</span> <span class="n">codegen_expr</span> <span class="n">start</span> <span class="k">in</span>

      <span class="c">(* Store the value into the alloca. *)</span>
      <span class="n">ignore</span><span class="o">(</span><span class="n">build_store</span> <span class="n">start_val</span> <span class="n">alloca</span> <span class="n">builder</span><span class="o">);</span>

      <span class="c">(* Make the new basic block for the loop header, inserting after current</span>
<span class="c">       * block. *)</span>
      <span class="k">let</span> <span class="n">loop_bb</span> <span class="o">=</span> <span class="n">append_block</span> <span class="n">context</span> <span class="s2">&quot;loop&quot;</span> <span class="n">the_function</span> <span class="k">in</span>

      <span class="c">(* Insert an explicit fall through from the current block to the</span>
<span class="c">       * loop_bb. *)</span>
      <span class="n">ignore</span> <span class="o">(</span><span class="n">build_br</span> <span class="n">loop_bb</span> <span class="n">builder</span><span class="o">);</span>

      <span class="c">(* Start insertion in loop_bb. *)</span>
      <span class="n">position_at_end</span> <span class="n">loop_bb</span> <span class="n">builder</span><span class="o">;</span>

      <span class="c">(* Within the loop, the variable is defined equal to the PHI node. If it</span>
<span class="c">       * shadows an existing variable, we have to restore it, so save it</span>
<span class="c">       * now. *)</span>
      <span class="k">let</span> <span class="n">old_val</span> <span class="o">=</span>
        <span class="k">try</span> <span class="nc">Some</span> <span class="o">(</span><span class="nn">Hashtbl</span><span class="p">.</span><span class="n">find</span> <span class="n">named_values</span> <span class="n">var_name</span><span class="o">)</span> <span class="k">with</span> <span class="nc">Not_found</span> <span class="o">-&gt;</span> <span class="nc">None</span>
      <span class="k">in</span>
      <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">add</span> <span class="n">named_values</span> <span class="n">var_name</span> <span class="n">alloca</span><span class="o">;</span>

      <span class="c">(* Emit the body of the loop.  This, like any other expr, can change the</span>
<span class="c">       * current BB.  Note that we ignore the value computed by the body, but</span>
<span class="c">       * don&#39;t allow an error *)</span>
      <span class="n">ignore</span> <span class="o">(</span><span class="n">codegen_expr</span> <span class="n">body</span><span class="o">);</span>

      <span class="c">(* Emit the step value. *)</span>
      <span class="k">let</span> <span class="n">step_val</span> <span class="o">=</span>
        <span class="k">match</span> <span class="n">step</span> <span class="k">with</span>
        <span class="o">|</span> <span class="nc">Some</span> <span class="n">step</span> <span class="o">-&gt;</span> <span class="n">codegen_expr</span> <span class="n">step</span>
        <span class="c">(* If not specified, use 1.0. *)</span>
        <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="n">const_float</span> <span class="n">double_type</span> <span class="mi">1</span><span class="o">.</span><span class="mi">0</span>
      <span class="k">in</span>

      <span class="c">(* Compute the end condition. *)</span>
      <span class="k">let</span> <span class="n">end_cond</span> <span class="o">=</span> <span class="n">codegen_expr</span> <span class="n">end_</span> <span class="k">in</span>

      <span class="c">(* Reload, increment, and restore the alloca. This handles the case where</span>
<span class="c">       * the body of the loop mutates the variable. *)</span>
      <span class="k">let</span> <span class="n">cur_var</span> <span class="o">=</span> <span class="n">build_load</span> <span class="n">alloca</span> <span class="n">var_name</span> <span class="n">builder</span> <span class="k">in</span>
      <span class="k">let</span> <span class="n">next_var</span> <span class="o">=</span> <span class="n">build_add</span> <span class="n">cur_var</span> <span class="n">step_val</span> <span class="s2">&quot;nextvar&quot;</span> <span class="n">builder</span> <span class="k">in</span>
      <span class="n">ignore</span><span class="o">(</span><span class="n">build_store</span> <span class="n">next_var</span> <span class="n">alloca</span> <span class="n">builder</span><span class="o">);</span>

      <span class="c">(* Convert condition to a bool by comparing equal to 0.0. *)</span>
      <span class="k">let</span> <span class="n">zero</span> <span class="o">=</span> <span class="n">const_float</span> <span class="n">double_type</span> <span class="mi">0</span><span class="o">.</span><span class="mi">0</span> <span class="k">in</span>
      <span class="k">let</span> <span class="n">end_cond</span> <span class="o">=</span> <span class="n">build_fcmp</span> <span class="nn">Fcmp</span><span class="p">.</span><span class="nc">One</span> <span class="n">end_cond</span> <span class="n">zero</span> <span class="s2">&quot;loopcond&quot;</span> <span class="n">builder</span> <span class="k">in</span>

      <span class="c">(* Create the &quot;after loop&quot; block and insert it. *)</span>
      <span class="k">let</span> <span class="n">after_bb</span> <span class="o">=</span> <span class="n">append_block</span> <span class="n">context</span> <span class="s2">&quot;afterloop&quot;</span> <span class="n">the_function</span> <span class="k">in</span>

      <span class="c">(* Insert the conditional branch into the end of loop_end_bb. *)</span>
      <span class="n">ignore</span> <span class="o">(</span><span class="n">build_cond_br</span> <span class="n">end_cond</span> <span class="n">loop_bb</span> <span class="n">after_bb</span> <span class="n">builder</span><span class="o">);</span>

      <span class="c">(* Any new code will be inserted in after_bb. *)</span>
      <span class="n">position_at_end</span> <span class="n">after_bb</span> <span class="n">builder</span><span class="o">;</span>

      <span class="c">(* Restore the unshadowed variable. *)</span>
      <span class="k">begin</span> <span class="k">match</span> <span class="n">old_val</span> <span class="k">with</span>
      <span class="o">|</span> <span class="nc">Some</span> <span class="n">old_val</span> <span class="o">-&gt;</span> <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">add</span> <span class="n">named_values</span> <span class="n">var_name</span> <span class="n">old_val</span>
      <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="bp">()</span>
      <span class="k">end</span><span class="o">;</span>

      <span class="c">(* for expr always returns 0.0. *)</span>
      <span class="n">const_null</span> <span class="n">double_type</span>
  <span class="o">|</span> <span class="nn">Ast</span><span class="p">.</span><span class="nc">Var</span> <span class="o">(</span><span class="n">var_names</span><span class="o">,</span> <span class="n">body</span><span class="o">)</span> <span class="o">-&gt;</span>
      <span class="k">let</span> <span class="n">old_bindings</span> <span class="o">=</span> <span class="n">ref</span> <span class="bp">[]</span> <span class="k">in</span>

      <span class="k">let</span> <span class="n">the_function</span> <span class="o">=</span> <span class="n">block_parent</span> <span class="o">(</span><span class="n">insertion_block</span> <span class="n">builder</span><span class="o">)</span> <span class="k">in</span>

      <span class="c">(* Register all variables and emit their initializer. *)</span>
      <span class="nn">Array</span><span class="p">.</span><span class="n">iter</span> <span class="o">(</span><span class="k">fun</span> <span class="o">(</span><span class="n">var_name</span><span class="o">,</span> <span class="n">init</span><span class="o">)</span> <span class="o">-&gt;</span>
        <span class="c">(* Emit the initializer before adding the variable to scope, this</span>
<span class="c">         * prevents the initializer from referencing the variable itself, and</span>
<span class="c">         * permits stuff like this:</span>
<span class="c">         *   var a = 1 in</span>
<span class="c">         *     var a = a in ...   # refers to outer &#39;a&#39;. *)</span>
        <span class="k">let</span> <span class="n">init_val</span> <span class="o">=</span>
          <span class="k">match</span> <span class="n">init</span> <span class="k">with</span>
          <span class="o">|</span> <span class="nc">Some</span> <span class="n">init</span> <span class="o">-&gt;</span> <span class="n">codegen_expr</span> <span class="n">init</span>
          <span class="c">(* If not specified, use 0.0. *)</span>
          <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="n">const_float</span> <span class="n">double_type</span> <span class="mi">0</span><span class="o">.</span><span class="mi">0</span>
        <span class="k">in</span>

        <span class="k">let</span> <span class="n">alloca</span> <span class="o">=</span> <span class="n">create_entry_block_alloca</span> <span class="n">the_function</span> <span class="n">var_name</span> <span class="k">in</span>
        <span class="n">ignore</span><span class="o">(</span><span class="n">build_store</span> <span class="n">init_val</span> <span class="n">alloca</span> <span class="n">builder</span><span class="o">);</span>

        <span class="c">(* Remember the old variable binding so that we can restore the binding</span>
<span class="c">         * when we unrecurse. *)</span>
        <span class="k">begin</span>
          <span class="k">try</span>
            <span class="k">let</span> <span class="n">old_value</span> <span class="o">=</span> <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">find</span> <span class="n">named_values</span> <span class="n">var_name</span> <span class="k">in</span>
            <span class="n">old_bindings</span> <span class="o">:=</span> <span class="o">(</span><span class="n">var_name</span><span class="o">,</span> <span class="n">old_value</span><span class="o">)</span> <span class="o">::</span> <span class="o">!</span><span class="n">old_bindings</span><span class="o">;</span>
          <span class="k">with</span> <span class="nc">Not_found</span> <span class="o">-&gt;</span> <span class="bp">()</span>
        <span class="k">end</span><span class="o">;</span>

        <span class="c">(* Remember this binding. *)</span>
        <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">add</span> <span class="n">named_values</span> <span class="n">var_name</span> <span class="n">alloca</span><span class="o">;</span>
      <span class="o">)</span> <span class="n">var_names</span><span class="o">;</span>

      <span class="c">(* Codegen the body, now that all vars are in scope. *)</span>
      <span class="k">let</span> <span class="n">body_val</span> <span class="o">=</span> <span class="n">codegen_expr</span> <span class="n">body</span> <span class="k">in</span>

      <span class="c">(* Pop all our variables from scope. *)</span>
      <span class="nn">List</span><span class="p">.</span><span class="n">iter</span> <span class="o">(</span><span class="k">fun</span> <span class="o">(</span><span class="n">var_name</span><span class="o">,</span> <span class="n">old_value</span><span class="o">)</span> <span class="o">-&gt;</span>
        <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">add</span> <span class="n">named_values</span> <span class="n">var_name</span> <span class="n">old_value</span>
      <span class="o">)</span> <span class="o">!</span><span class="n">old_bindings</span><span class="o">;</span>

      <span class="c">(* Return the body computation. *)</span>
      <span class="n">body_val</span>

<span class="k">let</span> <span class="n">codegen_proto</span> <span class="o">=</span> <span class="k">function</span>
  <span class="o">|</span> <span class="nn">Ast</span><span class="p">.</span><span class="nc">Prototype</span> <span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">args</span><span class="o">)</span> <span class="o">|</span> <span class="nn">Ast</span><span class="p">.</span><span class="nc">BinOpPrototype</span> <span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">args</span><span class="o">,</span> <span class="o">_)</span> <span class="o">-&gt;</span>
      <span class="c">(* Make the function type: double(double,double) etc. *)</span>
      <span class="k">let</span> <span class="n">doubles</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">make</span> <span class="o">(</span><span class="nn">Array</span><span class="p">.</span><span class="n">length</span> <span class="n">args</span><span class="o">)</span> <span class="n">double_type</span> <span class="k">in</span>
      <span class="k">let</span> <span class="n">ft</span> <span class="o">=</span> <span class="n">function_type</span> <span class="n">double_type</span> <span class="n">doubles</span> <span class="k">in</span>
      <span class="k">let</span> <span class="n">f</span> <span class="o">=</span>
        <span class="k">match</span> <span class="n">lookup_function</span> <span class="n">name</span> <span class="n">the_module</span> <span class="k">with</span>
        <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="n">declare_function</span> <span class="n">name</span> <span class="n">ft</span> <span class="n">the_module</span>

        <span class="c">(* If &#39;f&#39; conflicted, there was already something named &#39;name&#39;. If it</span>
<span class="c">         * has a body, don&#39;t allow redefinition or reextern. *)</span>
        <span class="o">|</span> <span class="nc">Some</span> <span class="n">f</span> <span class="o">-&gt;</span>
            <span class="c">(* If &#39;f&#39; already has a body, reject this. *)</span>
            <span class="k">if</span> <span class="n">block_begin</span> <span class="n">f</span> <span class="o">&lt;&gt;</span> <span class="nc">At_end</span> <span class="n">f</span> <span class="k">then</span>
              <span class="k">raise</span> <span class="o">(</span><span class="nc">Error</span> <span class="s2">&quot;redefinition of function&quot;</span><span class="o">);</span>

            <span class="c">(* If &#39;f&#39; took a different number of arguments, reject. *)</span>
            <span class="k">if</span> <span class="n">element_type</span> <span class="o">(</span><span class="n">type_of</span> <span class="n">f</span><span class="o">)</span> <span class="o">&lt;&gt;</span> <span class="n">ft</span> <span class="k">then</span>
              <span class="k">raise</span> <span class="o">(</span><span class="nc">Error</span> <span class="s2">&quot;redefinition of function with different # args&quot;</span><span class="o">);</span>
            <span class="n">f</span>
      <span class="k">in</span>

      <span class="c">(* Set names for all arguments. *)</span>
      <span class="nn">Array</span><span class="p">.</span><span class="n">iteri</span> <span class="o">(</span><span class="k">fun</span> <span class="n">i</span> <span class="n">a</span> <span class="o">-&gt;</span>
        <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="n">args</span><span class="o">.(</span><span class="n">i</span><span class="o">)</span> <span class="k">in</span>
        <span class="n">set_value_name</span> <span class="n">n</span> <span class="n">a</span><span class="o">;</span>
        <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">add</span> <span class="n">named_values</span> <span class="n">n</span> <span class="n">a</span><span class="o">;</span>
      <span class="o">)</span> <span class="o">(</span><span class="n">params</span> <span class="n">f</span><span class="o">);</span>
      <span class="n">f</span>

<span class="c">(* Create an alloca for each argument and register the argument in the symbol</span>
<span class="c"> * table so that references to it will succeed. *)</span>
<span class="k">let</span> <span class="n">create_argument_allocas</span> <span class="n">the_function</span> <span class="n">proto</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">args</span> <span class="o">=</span> <span class="k">match</span> <span class="n">proto</span> <span class="k">with</span>
    <span class="o">|</span> <span class="nn">Ast</span><span class="p">.</span><span class="nc">Prototype</span> <span class="o">(_,</span> <span class="n">args</span><span class="o">)</span> <span class="o">|</span> <span class="nn">Ast</span><span class="p">.</span><span class="nc">BinOpPrototype</span> <span class="o">(_,</span> <span class="n">args</span><span class="o">,</span> <span class="o">_)</span> <span class="o">-&gt;</span> <span class="n">args</span>
  <span class="k">in</span>
  <span class="nn">Array</span><span class="p">.</span><span class="n">iteri</span> <span class="o">(</span><span class="k">fun</span> <span class="n">i</span> <span class="n">ai</span> <span class="o">-&gt;</span>
    <span class="k">let</span> <span class="n">var_name</span> <span class="o">=</span> <span class="n">args</span><span class="o">.(</span><span class="n">i</span><span class="o">)</span> <span class="k">in</span>
    <span class="c">(* Create an alloca for this variable. *)</span>
    <span class="k">let</span> <span class="n">alloca</span> <span class="o">=</span> <span class="n">create_entry_block_alloca</span> <span class="n">the_function</span> <span class="n">var_name</span> <span class="k">in</span>

    <span class="c">(* Store the initial value into the alloca. *)</span>
    <span class="n">ignore</span><span class="o">(</span><span class="n">build_store</span> <span class="n">ai</span> <span class="n">alloca</span> <span class="n">builder</span><span class="o">);</span>

    <span class="c">(* Add arguments to variable symbol table. *)</span>
    <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">add</span> <span class="n">named_values</span> <span class="n">var_name</span> <span class="n">alloca</span><span class="o">;</span>
  <span class="o">)</span> <span class="o">(</span><span class="n">params</span> <span class="n">the_function</span><span class="o">)</span>

<span class="k">let</span> <span class="n">codegen_func</span> <span class="n">the_fpm</span> <span class="o">=</span> <span class="k">function</span>
  <span class="o">|</span> <span class="nn">Ast</span><span class="p">.</span><span class="nc">Function</span> <span class="o">(</span><span class="n">proto</span><span class="o">,</span> <span class="n">body</span><span class="o">)</span> <span class="o">-&gt;</span>
      <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">clear</span> <span class="n">named_values</span><span class="o">;</span>
      <span class="k">let</span> <span class="n">the_function</span> <span class="o">=</span> <span class="n">codegen_proto</span> <span class="n">proto</span> <span class="k">in</span>

      <span class="c">(* If this is an operator, install it. *)</span>
      <span class="k">begin</span> <span class="k">match</span> <span class="n">proto</span> <span class="k">with</span>
      <span class="o">|</span> <span class="nn">Ast</span><span class="p">.</span><span class="nc">BinOpPrototype</span> <span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">args</span><span class="o">,</span> <span class="n">prec</span><span class="o">)</span> <span class="o">-&gt;</span>
          <span class="k">let</span> <span class="n">op</span> <span class="o">=</span> <span class="n">name</span><span class="o">.[</span><span class="nn">String</span><span class="p">.</span><span class="n">length</span> <span class="n">name</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="k">in</span>
          <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">add</span> <span class="nn">Parser</span><span class="p">.</span><span class="n">binop_precedence</span> <span class="n">op</span> <span class="n">prec</span><span class="o">;</span>
      <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="bp">()</span>
      <span class="k">end</span><span class="o">;</span>

      <span class="c">(* Create a new basic block to start insertion into. *)</span>
      <span class="k">let</span> <span class="n">bb</span> <span class="o">=</span> <span class="n">append_block</span> <span class="n">context</span> <span class="s2">&quot;entry&quot;</span> <span class="n">the_function</span> <span class="k">in</span>
      <span class="n">position_at_end</span> <span class="n">bb</span> <span class="n">builder</span><span class="o">;</span>

      <span class="k">try</span>
        <span class="c">(* Add all arguments to the symbol table and create their allocas. *)</span>
        <span class="n">create_argument_allocas</span> <span class="n">the_function</span> <span class="n">proto</span><span class="o">;</span>

        <span class="k">let</span> <span class="n">ret_val</span> <span class="o">=</span> <span class="n">codegen_expr</span> <span class="n">body</span> <span class="k">in</span>

        <span class="c">(* Finish off the function. *)</span>
        <span class="k">let</span> <span class="o">_</span> <span class="o">=</span> <span class="n">build_ret</span> <span class="n">ret_val</span> <span class="n">builder</span> <span class="k">in</span>

        <span class="c">(* Validate the generated code, checking for consistency. *)</span>
        <span class="nn">Llvm_analysis</span><span class="p">.</span><span class="n">assert_valid_function</span> <span class="n">the_function</span><span class="o">;</span>

        <span class="c">(* Optimize the function. *)</span>
        <span class="k">let</span> <span class="o">_</span> <span class="o">=</span> <span class="nn">PassManager</span><span class="p">.</span><span class="n">run_function</span> <span class="n">the_function</span> <span class="n">the_fpm</span> <span class="k">in</span>

        <span class="n">the_function</span>
      <span class="k">with</span> <span class="n">e</span> <span class="o">-&gt;</span>
        <span class="n">delete_function</span> <span class="n">the_function</span><span class="o">;</span>
        <span class="k">raise</span> <span class="n">e</span>
</pre></div>
</div>
</dd>
<dt>toplevel.ml:</dt>
<dd><div class="first last highlight-ocaml"><div class="highlight"><pre><span></span><span class="c">(*===----------------------------------------------------------------------===</span>
<span class="c"> * Top-Level parsing and JIT Driver</span>
<span class="c"> *===----------------------------------------------------------------------===*)</span>

<span class="k">open</span> <span class="nc">Llvm</span>
<span class="k">open</span> <span class="nc">Llvm_executionengine</span>

<span class="c">(* top ::= definition | external | expression | &#39;;&#39; *)</span>
<span class="k">let</span> <span class="k">rec</span> <span class="n">main_loop</span> <span class="n">the_fpm</span> <span class="n">the_execution_engine</span> <span class="n">stream</span> <span class="o">=</span>
  <span class="k">match</span> <span class="nn">Stream</span><span class="p">.</span><span class="n">peek</span> <span class="n">stream</span> <span class="k">with</span>
  <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="bp">()</span>

  <span class="c">(* ignore top-level semicolons. *)</span>
  <span class="o">|</span> <span class="nc">Some</span> <span class="o">(</span><span class="nn">Token</span><span class="p">.</span><span class="nc">Kwd</span> <span class="sc">&#39;;&#39;</span><span class="o">)</span> <span class="o">-&gt;</span>
      <span class="nn">Stream</span><span class="p">.</span><span class="n">junk</span> <span class="n">stream</span><span class="o">;</span>
      <span class="n">main_loop</span> <span class="n">the_fpm</span> <span class="n">the_execution_engine</span> <span class="n">stream</span>

  <span class="o">|</span> <span class="nc">Some</span> <span class="n">token</span> <span class="o">-&gt;</span>
      <span class="k">begin</span>
        <span class="k">try</span> <span class="k">match</span> <span class="n">token</span> <span class="k">with</span>
        <span class="o">|</span> <span class="nn">Token</span><span class="p">.</span><span class="nc">Def</span> <span class="o">-&gt;</span>
            <span class="k">let</span> <span class="n">e</span> <span class="o">=</span> <span class="nn">Parser</span><span class="p">.</span><span class="n">parse_definition</span> <span class="n">stream</span> <span class="k">in</span>
            <span class="n">print_endline</span> <span class="s2">&quot;parsed a function definition.&quot;</span><span class="o">;</span>
            <span class="n">dump_value</span> <span class="o">(</span><span class="nn">Codegen</span><span class="p">.</span><span class="n">codegen_func</span> <span class="n">the_fpm</span> <span class="n">e</span><span class="o">);</span>
        <span class="o">|</span> <span class="nn">Token</span><span class="p">.</span><span class="nc">Extern</span> <span class="o">-&gt;</span>
            <span class="k">let</span> <span class="n">e</span> <span class="o">=</span> <span class="nn">Parser</span><span class="p">.</span><span class="n">parse_extern</span> <span class="n">stream</span> <span class="k">in</span>
            <span class="n">print_endline</span> <span class="s2">&quot;parsed an extern.&quot;</span><span class="o">;</span>
            <span class="n">dump_value</span> <span class="o">(</span><span class="nn">Codegen</span><span class="p">.</span><span class="n">codegen_proto</span> <span class="n">e</span><span class="o">);</span>
        <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span>
            <span class="c">(* Evaluate a top-level expression into an anonymous function. *)</span>
            <span class="k">let</span> <span class="n">e</span> <span class="o">=</span> <span class="nn">Parser</span><span class="p">.</span><span class="n">parse_toplevel</span> <span class="n">stream</span> <span class="k">in</span>
            <span class="n">print_endline</span> <span class="s2">&quot;parsed a top-level expr&quot;</span><span class="o">;</span>
            <span class="k">let</span> <span class="n">the_function</span> <span class="o">=</span> <span class="nn">Codegen</span><span class="p">.</span><span class="n">codegen_func</span> <span class="n">the_fpm</span> <span class="n">e</span> <span class="k">in</span>
            <span class="n">dump_value</span> <span class="n">the_function</span><span class="o">;</span>

            <span class="c">(* JIT the function, returning a function pointer. *)</span>
            <span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="nn">ExecutionEngine</span><span class="p">.</span><span class="n">run_function</span> <span class="n">the_function</span> <span class="o">[||]</span>
              <span class="n">the_execution_engine</span> <span class="k">in</span>

            <span class="n">print_string</span> <span class="s2">&quot;Evaluated to &quot;</span><span class="o">;</span>
            <span class="n">print_float</span> <span class="o">(</span><span class="nn">GenericValue</span><span class="p">.</span><span class="n">as_float</span> <span class="nn">Codegen</span><span class="p">.</span><span class="n">double_type</span> <span class="n">result</span><span class="o">);</span>
            <span class="n">print_newline</span> <span class="bp">()</span><span class="o">;</span>
        <span class="k">with</span> <span class="nn">Stream</span><span class="p">.</span><span class="nc">Error</span> <span class="n">s</span> <span class="o">|</span> <span class="nn">Codegen</span><span class="p">.</span><span class="nc">Error</span> <span class="n">s</span> <span class="o">-&gt;</span>
          <span class="c">(* Skip token for error recovery. *)</span>
          <span class="nn">Stream</span><span class="p">.</span><span class="n">junk</span> <span class="n">stream</span><span class="o">;</span>
          <span class="n">print_endline</span> <span class="n">s</span><span class="o">;</span>
      <span class="k">end</span><span class="o">;</span>
      <span class="n">print_string</span> <span class="s2">&quot;ready&gt; &quot;</span><span class="o">;</span> <span class="n">flush</span> <span class="n">stdout</span><span class="o">;</span>
      <span class="n">main_loop</span> <span class="n">the_fpm</span> <span class="n">the_execution_engine</span> <span class="n">stream</span>
</pre></div>
</div>
</dd>
<dt>toy.ml:</dt>
<dd><div class="first last highlight-ocaml"><div class="highlight"><pre><span></span><span class="c">(*===----------------------------------------------------------------------===</span>
<span class="c"> * Main driver code.</span>
<span class="c"> *===----------------------------------------------------------------------===*)</span>

<span class="k">open</span> <span class="nc">Llvm</span>
<span class="k">open</span> <span class="nc">Llvm_executionengine</span>
<span class="k">open</span> <span class="nc">Llvm_target</span>
<span class="k">open</span> <span class="nc">Llvm_scalar_opts</span>

<span class="k">let</span> <span class="n">main</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="n">ignore</span> <span class="o">(</span><span class="n">initialize_native_target</span> <span class="bp">()</span><span class="o">);</span>

  <span class="c">(* Install standard binary operators.</span>
<span class="c">   * 1 is the lowest precedence. *)</span>
  <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">add</span> <span class="nn">Parser</span><span class="p">.</span><span class="n">binop_precedence</span> <span class="sc">&#39;=&#39;</span> <span class="mi">2</span><span class="o">;</span>
  <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">add</span> <span class="nn">Parser</span><span class="p">.</span><span class="n">binop_precedence</span> <span class="sc">&#39;&lt;&#39;</span> <span class="mi">10</span><span class="o">;</span>
  <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">add</span> <span class="nn">Parser</span><span class="p">.</span><span class="n">binop_precedence</span> <span class="sc">&#39;+&#39;</span> <span class="mi">20</span><span class="o">;</span>
  <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">add</span> <span class="nn">Parser</span><span class="p">.</span><span class="n">binop_precedence</span> <span class="sc">&#39;-&#39;</span> <span class="mi">20</span><span class="o">;</span>
  <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">add</span> <span class="nn">Parser</span><span class="p">.</span><span class="n">binop_precedence</span> <span class="sc">&#39;*&#39;</span> <span class="mi">40</span><span class="o">;</span>    <span class="c">(* highest. *)</span>

  <span class="c">(* Prime the first token. *)</span>
  <span class="n">print_string</span> <span class="s2">&quot;ready&gt; &quot;</span><span class="o">;</span> <span class="n">flush</span> <span class="n">stdout</span><span class="o">;</span>
  <span class="k">let</span> <span class="n">stream</span> <span class="o">=</span> <span class="nn">Lexer</span><span class="p">.</span><span class="n">lex</span> <span class="o">(</span><span class="nn">Stream</span><span class="p">.</span><span class="n">of_channel</span> <span class="n">stdin</span><span class="o">)</span> <span class="k">in</span>

  <span class="c">(* Create the JIT. *)</span>
  <span class="k">let</span> <span class="n">the_execution_engine</span> <span class="o">=</span> <span class="nn">ExecutionEngine</span><span class="p">.</span><span class="n">create</span> <span class="nn">Codegen</span><span class="p">.</span><span class="n">the_module</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">the_fpm</span> <span class="o">=</span> <span class="nn">PassManager</span><span class="p">.</span><span class="n">create_function</span> <span class="nn">Codegen</span><span class="p">.</span><span class="n">the_module</span> <span class="k">in</span>

  <span class="c">(* Set up the optimizer pipeline.  Start with registering info about how the</span>
<span class="c">   * target lays out data structures. *)</span>
  <span class="nn">DataLayout</span><span class="p">.</span><span class="n">add</span> <span class="o">(</span><span class="nn">ExecutionEngine</span><span class="p">.</span><span class="n">target_data</span> <span class="n">the_execution_engine</span><span class="o">)</span> <span class="n">the_fpm</span><span class="o">;</span>

  <span class="c">(* Promote allocas to registers. *)</span>
  <span class="n">add_memory_to_register_promotion</span> <span class="n">the_fpm</span><span class="o">;</span>

  <span class="c">(* Do simple &quot;peephole&quot; optimizations and bit-twiddling optzn. *)</span>
  <span class="n">add_instruction_combination</span> <span class="n">the_fpm</span><span class="o">;</span>

  <span class="c">(* reassociate expressions. *)</span>
  <span class="n">add_reassociation</span> <span class="n">the_fpm</span><span class="o">;</span>

  <span class="c">(* Eliminate Common SubExpressions. *)</span>
  <span class="n">add_gvn</span> <span class="n">the_fpm</span><span class="o">;</span>

  <span class="c">(* Simplify the control flow graph (deleting unreachable blocks, etc). *)</span>
  <span class="n">add_cfg_simplification</span> <span class="n">the_fpm</span><span class="o">;</span>

  <span class="n">ignore</span> <span class="o">(</span><span class="nn">PassManager</span><span class="p">.</span><span class="n">initialize</span> <span class="n">the_fpm</span><span class="o">);</span>

  <span class="c">(* Run the main &quot;interpreter loop&quot; now. *)</span>
  <span class="nn">Toplevel</span><span class="p">.</span><span class="n">main_loop</span> <span class="n">the_fpm</span> <span class="n">the_execution_engine</span> <span class="n">stream</span><span class="o">;</span>

  <span class="c">(* Print out all the generated code. *)</span>
  <span class="n">dump_module</span> <span class="nn">Codegen</span><span class="p">.</span><span class="n">the_module</span>
<span class="o">;;</span>

<span class="n">main</span> <span class="bp">()</span>
</pre></div>
</div>
</dd>
<dt>bindings.c</dt>
<dd><div class="first last highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>

<span class="cm">/* putchard - putchar that takes a double and returns 0. */</span>
<span class="k">extern</span> <span class="kt">double</span> <span class="nf">putchard</span><span class="p">(</span><span class="kt">double</span> <span class="n">X</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">putchar</span><span class="p">((</span><span class="kt">char</span><span class="p">)</span><span class="n">X</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* printd - printf that takes a double prints it as &quot;%f\n&quot;, returning 0. */</span>
<span class="k">extern</span> <span class="kt">double</span> <span class="nf">printd</span><span class="p">(</span><span class="kt">double</span> <span class="n">X</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">X</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</dd>
</dl>
<p><a class="reference external" href="OCamlLangImpl8.html">Next: Conclusion and other useful LLVM tidbits</a></p>
</div>
</div>


          </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="OCamlLangImpl8.html" title="8. Kaleidoscope: Conclusion and other useful LLVM tidbits"
             >next</a> |</li>
        <li class="right" >
          <a href="OCamlLangImpl6.html" title="6. Kaleidoscope: Extending the Language: User-defined Operators"
             >previous</a> |</li>
  <li><a href="http://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="../index.html">Documentation</a>&raquo;</li>

          <li class="nav-item nav-item-1"><a href="index.html" >LLVM Tutorial: Table of Contents</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2003-2019, LLVM Project.
      Last updated on Wed Feb 13 10:08:12 2019 -0800.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.1.
    </div>
  </body>
</html>