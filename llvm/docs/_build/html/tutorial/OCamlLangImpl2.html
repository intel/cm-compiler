

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>2. Kaleidoscope: Implementing a Parser and AST &#8212; LLVM 6 documentation</title>
    
    <link rel="stylesheet" href="../_static/llvm-theme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '6',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="3. Kaleidoscope: Code generation to LLVM IR" href="OCamlLangImpl3.html" />
    <link rel="prev" title="1. Kaleidoscope: Tutorial Introduction and the Lexer" href="OCamlLangImpl1.html" />
<style type="text/css">
  table.right { float: right; margin-left: 20px; }
  table.right td { border: 1px solid #ccc; }
</style>

  </head>
  <body>
<div class="logo">
  <a href="../index.html">
    <img src="../_static/logo.png"
         alt="LLVM Logo" width="250" height="88"/></a>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="OCamlLangImpl3.html" title="3. Kaleidoscope: Code generation to LLVM IR"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="OCamlLangImpl1.html" title="1. Kaleidoscope: Tutorial Introduction and the Lexer"
             accesskey="P">previous</a> |</li>
  <li><a href="http://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="../index.html">Documentation</a>&raquo;</li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">LLVM Tutorial: Table of Contents</a> &#187;</li> 
      </ul>
    </div>


    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <div class="section" id="kaleidoscope-implementing-a-parser-and-ast">
<h1>2. Kaleidoscope: Implementing a Parser and AST<a class="headerlink" href="#kaleidoscope-implementing-a-parser-and-ast" title="Permalink to this headline">¶</a></h1>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><a class="reference internal" href="#chapter-2-introduction" id="id2">Chapter 2 Introduction</a></li>
<li><a class="reference internal" href="#the-abstract-syntax-tree-ast" id="id3">The Abstract Syntax Tree (AST)</a></li>
<li><a class="reference internal" href="#parser-basics" id="id4">Parser Basics</a></li>
<li><a class="reference internal" href="#basic-expression-parsing" id="id5">Basic Expression Parsing</a></li>
<li><a class="reference internal" href="#binary-expression-parsing" id="id6">Binary Expression Parsing</a></li>
<li><a class="reference internal" href="#parsing-the-rest" id="id7">Parsing the Rest</a></li>
<li><a class="reference internal" href="#the-driver" id="id8">The Driver</a></li>
<li><a class="reference internal" href="#conclusions" id="id9">Conclusions</a></li>
<li><a class="reference internal" href="#full-code-listing" id="id10">Full Code Listing</a></li>
</ul>
</div>
<div class="section" id="chapter-2-introduction">
<h2><a class="toc-backref" href="#id2">2.1. Chapter 2 Introduction</a><a class="headerlink" href="#chapter-2-introduction" title="Permalink to this headline">¶</a></h2>
<p>Welcome to Chapter 2 of the “<a class="reference external" href="index.html">Implementing a language with LLVM in
Objective Caml</a>” tutorial. This chapter shows you how to
use the lexer, built in <a class="reference external" href="OCamlLangImpl1.html">Chapter 1</a>, to build a
full <a class="reference external" href="http://en.wikipedia.org/wiki/Parsing">parser</a> for our
Kaleidoscope language. Once we have a parser, we’ll define and build an
<a class="reference external" href="http://en.wikipedia.org/wiki/Abstract_syntax_tree">Abstract Syntax
Tree</a> (AST).</p>
<p>The parser we will build uses a combination of <a class="reference external" href="http://en.wikipedia.org/wiki/Recursive_descent_parser">Recursive Descent
Parsing</a> and
<a class="reference external" href="http://en.wikipedia.org/wiki/Operator-precedence_parser">Operator-Precedence
Parsing</a> to
parse the Kaleidoscope language (the latter for binary expressions and
the former for everything else). Before we get to parsing though, lets
talk about the output of the parser: the Abstract Syntax Tree.</p>
</div>
<div class="section" id="the-abstract-syntax-tree-ast">
<h2><a class="toc-backref" href="#id3">2.2. The Abstract Syntax Tree (AST)</a><a class="headerlink" href="#the-abstract-syntax-tree-ast" title="Permalink to this headline">¶</a></h2>
<p>The AST for a program captures its behavior in such a way that it is
easy for later stages of the compiler (e.g. code generation) to
interpret. We basically want one object for each construct in the
language, and the AST should closely model the language. In
Kaleidoscope, we have expressions, a prototype, and a function object.
We’ll start with expressions first:</p>
<div class="highlight-ocaml"><div class="highlight"><pre><span></span><span class="c">(* expr - Base type for all expression nodes. *)</span>
<span class="k">type</span> <span class="n">expr</span> <span class="o">=</span>
  <span class="c">(* variant for numeric literals like &quot;1.0&quot;. *)</span>
  <span class="o">|</span> <span class="nc">Number</span> <span class="k">of</span> <span class="kt">float</span>
</pre></div>
</div>
<p>The code above shows the definition of the base ExprAST class and one
subclass which we use for numeric literals. The important thing to note
about this code is that the Number variant captures the numeric value of
the literal as an instance variable. This allows later phases of the
compiler to know what the stored numeric value is.</p>
<p>Right now we only create the AST, so there are no useful functions on
them. It would be very easy to add a function to pretty print the code,
for example. Here are the other expression AST node definitions that
we’ll use in the basic form of the Kaleidoscope language:</p>
<div class="highlight-ocaml"><div class="highlight"><pre><span></span><span class="c">(* variant for referencing a variable, like &quot;a&quot;. *)</span>
<span class="o">|</span> <span class="nc">Variable</span> <span class="k">of</span> <span class="kt">string</span>

<span class="c">(* variant for a binary operator. *)</span>
<span class="o">|</span> <span class="nc">Binary</span> <span class="k">of</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">expr</span> <span class="o">*</span> <span class="n">expr</span>

<span class="c">(* variant for function calls. *)</span>
<span class="o">|</span> <span class="nc">Call</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">*</span> <span class="n">expr</span> <span class="kt">array</span>
</pre></div>
</div>
<p>This is all (intentionally) rather straight-forward: variables capture
the variable name, binary operators capture their opcode (e.g. ‘+’), and
calls capture a function name as well as a list of any argument
expressions. One thing that is nice about our AST is that it captures
the language features without talking about the syntax of the language.
Note that there is no discussion about precedence of binary operators,
lexical structure, etc.</p>
<p>For our basic language, these are all of the expression nodes we’ll
define. Because it doesn’t have conditional control flow, it isn’t
Turing-complete; we’ll fix that in a later installment. The two things
we need next are a way to talk about the interface to a function, and a
way to talk about functions themselves:</p>
<div class="highlight-ocaml"><div class="highlight"><pre><span></span><span class="c">(* proto - This type represents the &quot;prototype&quot; for a function, which captures</span>
<span class="c"> * its name, and its argument names (thus implicitly the number of arguments the</span>
<span class="c"> * function takes). *)</span>
<span class="k">type</span> <span class="n">proto</span> <span class="o">=</span> <span class="nc">Prototype</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">*</span> <span class="kt">string</span> <span class="kt">array</span>

<span class="c">(* func - This type represents a function definition itself. *)</span>
<span class="k">type</span> <span class="n">func</span> <span class="o">=</span> <span class="nc">Function</span> <span class="k">of</span> <span class="n">proto</span> <span class="o">*</span> <span class="n">expr</span>
</pre></div>
</div>
<p>In Kaleidoscope, functions are typed with just a count of their
arguments. Since all values are double precision floating point, the
type of each argument doesn’t need to be stored anywhere. In a more
aggressive and realistic language, the “expr” variants would probably
have a type field.</p>
<p>With this scaffolding, we can now talk about parsing expressions and
function bodies in Kaleidoscope.</p>
</div>
<div class="section" id="parser-basics">
<h2><a class="toc-backref" href="#id4">2.3. Parser Basics</a><a class="headerlink" href="#parser-basics" title="Permalink to this headline">¶</a></h2>
<p>Now that we have an AST to build, we need to define the parser code to
build it. The idea here is that we want to parse something like “x+y”
(which is returned as three tokens by the lexer) into an AST that could
be generated with calls like this:</p>
<div class="highlight-ocaml"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="nc">Variable</span> <span class="s2">&quot;x&quot;</span> <span class="k">in</span>
<span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="nc">Variable</span> <span class="s2">&quot;y&quot;</span> <span class="k">in</span>
<span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="nc">Binary</span> <span class="o">(</span><span class="sc">&#39;+&#39;</span><span class="o">,</span> <span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="k">in</span>
<span class="o">...</span>
</pre></div>
</div>
<p>The error handling routines make use of the builtin <code class="docutils literal"><span class="pre">Stream.Failure</span></code>
and <code class="docutils literal"><span class="pre">Stream.Error``s.</span> <span class="pre">``Stream.Failure</span></code> is raised when the parser is
unable to find any matching token in the first position of a pattern.
<code class="docutils literal"><span class="pre">Stream.Error</span></code> is raised when the first token matches, but the rest do
not. The error recovery in our parser will not be the best and is not
particular user-friendly, but it will be enough for our tutorial. These
exceptions make it easier to handle errors in routines that have various
return types.</p>
<p>With these basic types and exceptions, we can implement the first piece
of our grammar: numeric literals.</p>
</div>
<div class="section" id="basic-expression-parsing">
<h2><a class="toc-backref" href="#id5">2.4. Basic Expression Parsing</a><a class="headerlink" href="#basic-expression-parsing" title="Permalink to this headline">¶</a></h2>
<p>We start with numeric literals, because they are the simplest to
process. For each production in our grammar, we’ll define a function
which parses that production. We call this class of expressions
“primary” expressions, for reasons that will become more clear <a class="reference external" href="OCamlLangImpl6.html#user-defined-unary-operators">later in
the tutorial</a>. In order to parse an
arbitrary primary expression, we need to determine what sort of
expression it is. For numeric literals, we have:</p>
<div class="highlight-ocaml"><div class="highlight"><pre><span></span><span class="c">(* primary</span>
<span class="c"> *   ::= identifier</span>
<span class="c"> *   ::= numberexpr</span>
<span class="c"> *   ::= parenexpr *)</span>
<span class="n">parse_primary</span> <span class="o">=</span> <span class="n">parser</span>
  <span class="c">(* numberexpr ::= number *)</span>
  <span class="o">|</span> <span class="o">[&lt;</span> <span class="k">&#39;</span><span class="nn">Token</span><span class="p">.</span><span class="nc">Number</span> <span class="n">n</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span> <span class="nn">Ast</span><span class="p">.</span><span class="nc">Number</span> <span class="n">n</span>
</pre></div>
</div>
<p>This routine is very simple: it expects to be called when the current
token is a <code class="docutils literal"><span class="pre">Token.Number</span></code> token. It takes the current number value,
creates a <code class="docutils literal"><span class="pre">Ast.Number</span></code> node, advances the lexer to the next token, and
finally returns.</p>
<p>There are some interesting aspects to this. The most important one is
that this routine eats all of the tokens that correspond to the
production and returns the lexer buffer with the next token (which is
not part of the grammar production) ready to go. This is a fairly
standard way to go for recursive descent parsers. For a better example,
the parenthesis operator is defined like this:</p>
<div class="highlight-ocaml"><div class="highlight"><pre><span></span><span class="c">(* parenexpr ::= &#39;(&#39; expression &#39;)&#39; *)</span>
<span class="o">|</span> <span class="o">[&lt;</span> <span class="k">&#39;</span><span class="nn">Token</span><span class="p">.</span><span class="nc">Kwd</span> <span class="sc">&#39;(&#39;</span><span class="o">;</span> <span class="n">e</span><span class="o">=</span><span class="n">parse_expr</span><span class="o">;</span> <span class="k">&#39;</span><span class="nn">Token</span><span class="p">.</span><span class="nc">Kwd</span> <span class="sc">&#39;)&#39;</span> <span class="o">??</span> <span class="s2">&quot;expected &#39;)&#39;&quot;</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span> <span class="n">e</span>
</pre></div>
</div>
<p>This function illustrates a number of interesting things about the
parser:</p>
<p>1) It shows how we use the <code class="docutils literal"><span class="pre">Stream.Error</span></code> exception. When called, this
function expects that the current token is a ‘(‘ token, but after
parsing the subexpression, it is possible that there is no ‘)’ waiting.
For example, if the user types in “(4 x” instead of “(4)”, the parser
should emit an error. Because errors can occur, the parser needs a way
to indicate that they happened. In our parser, we use the camlp4
shortcut syntax <code class="docutils literal"><span class="pre">token</span> <span class="pre">??</span> <span class="pre">&quot;parse</span> <span class="pre">error&quot;</span></code>, where if the token before
the <code class="docutils literal"><span class="pre">??</span></code> does not match, then <code class="docutils literal"><span class="pre">Stream.Error</span> <span class="pre">&quot;parse</span> <span class="pre">error&quot;</span></code> will be
raised.</p>
<p>2) Another interesting aspect of this function is that it uses recursion
by calling <code class="docutils literal"><span class="pre">Parser.parse_primary</span></code> (we will soon see that
<code class="docutils literal"><span class="pre">Parser.parse_primary</span></code> can call <code class="docutils literal"><span class="pre">Parser.parse_primary</span></code>). This is
powerful because it allows us to handle recursive grammars, and keeps
each production very simple. Note that parentheses do not cause
construction of AST nodes themselves. While we could do it this way, the
most important role of parentheses are to guide the parser and provide
grouping. Once the parser constructs the AST, parentheses are not
needed.</p>
<p>The next simple production is for handling variable references and
function calls:</p>
<div class="highlight-ocaml"><div class="highlight"><pre><span></span><span class="c">(* identifierexpr</span>
<span class="c"> *   ::= identifier</span>
<span class="c"> *   ::= identifier &#39;(&#39; argumentexpr &#39;)&#39; *)</span>
<span class="o">|</span> <span class="o">[&lt;</span> <span class="k">&#39;</span><span class="nn">Token</span><span class="p">.</span><span class="nc">Ident</span> <span class="n">id</span><span class="o">;</span> <span class="n">stream</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span>
    <span class="k">let</span> <span class="k">rec</span> <span class="n">parse_args</span> <span class="n">accumulator</span> <span class="o">=</span> <span class="n">parser</span>
      <span class="o">|</span> <span class="o">[&lt;</span> <span class="n">e</span><span class="o">=</span><span class="n">parse_expr</span><span class="o">;</span> <span class="n">stream</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span>
          <span class="k">begin</span> <span class="n">parser</span>
            <span class="o">|</span> <span class="o">[&lt;</span> <span class="k">&#39;</span><span class="nn">Token</span><span class="p">.</span><span class="nc">Kwd</span> <span class="sc">&#39;,&#39;</span><span class="o">;</span> <span class="n">e</span><span class="o">=</span><span class="n">parse_args</span> <span class="o">(</span><span class="n">e</span> <span class="o">::</span> <span class="n">accumulator</span><span class="o">)</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span> <span class="n">e</span>
            <span class="o">|</span> <span class="o">[&lt;</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span> <span class="n">e</span> <span class="o">::</span> <span class="n">accumulator</span>
          <span class="k">end</span> <span class="n">stream</span>
      <span class="o">|</span> <span class="o">[&lt;</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span> <span class="n">accumulator</span>
    <span class="k">in</span>
    <span class="k">let</span> <span class="k">rec</span> <span class="n">parse_ident</span> <span class="n">id</span> <span class="o">=</span> <span class="n">parser</span>
      <span class="c">(* Call. *)</span>
      <span class="o">|</span> <span class="o">[&lt;</span> <span class="k">&#39;</span><span class="nn">Token</span><span class="p">.</span><span class="nc">Kwd</span> <span class="sc">&#39;(&#39;</span><span class="o">;</span>
           <span class="n">args</span><span class="o">=</span><span class="n">parse_args</span> <span class="bp">[]</span><span class="o">;</span>
           <span class="k">&#39;</span><span class="nn">Token</span><span class="p">.</span><span class="nc">Kwd</span> <span class="sc">&#39;)&#39;</span> <span class="o">??</span> <span class="s2">&quot;expected &#39;)&#39;&quot;</span><span class="o">&gt;]</span> <span class="o">-&gt;</span>
          <span class="nn">Ast</span><span class="p">.</span><span class="nc">Call</span> <span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="nn">Array</span><span class="p">.</span><span class="n">of_list</span> <span class="o">(</span><span class="nn">List</span><span class="p">.</span><span class="n">rev</span> <span class="n">args</span><span class="o">))</span>

      <span class="c">(* Simple variable ref. *)</span>
      <span class="o">|</span> <span class="o">[&lt;</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span> <span class="nn">Ast</span><span class="p">.</span><span class="nc">Variable</span> <span class="n">id</span>
    <span class="k">in</span>
    <span class="n">parse_ident</span> <span class="n">id</span> <span class="n">stream</span>
</pre></div>
</div>
<p>This routine follows the same style as the other routines. (It expects
to be called if the current token is a <code class="docutils literal"><span class="pre">Token.Ident</span></code> token). It also
has recursion and error handling. One interesting aspect of this is that
it uses <em>look-ahead</em> to determine if the current identifier is a stand
alone variable reference or if it is a function call expression. It
handles this by checking to see if the token after the identifier is a
‘(‘ token, constructing either a <code class="docutils literal"><span class="pre">Ast.Variable</span></code> or <code class="docutils literal"><span class="pre">Ast.Call</span></code> node
as appropriate.</p>
<p>We finish up by raising an exception if we received a token we didn’t
expect:</p>
<div class="highlight-ocaml"><div class="highlight"><pre><span></span><span class="o">|</span> <span class="o">[&lt;</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span> <span class="k">raise</span> <span class="o">(</span><span class="nn">Stream</span><span class="p">.</span><span class="nc">Error</span> <span class="s2">&quot;unknown token when expecting an expression.&quot;</span><span class="o">)</span>
</pre></div>
</div>
<p>Now that basic expressions are handled, we need to handle binary
expressions. They are a bit more complex.</p>
</div>
<div class="section" id="binary-expression-parsing">
<h2><a class="toc-backref" href="#id6">2.5. Binary Expression Parsing</a><a class="headerlink" href="#binary-expression-parsing" title="Permalink to this headline">¶</a></h2>
<p>Binary expressions are significantly harder to parse because they are
often ambiguous. For example, when given the string “x+y*z”, the parser
can choose to parse it as either “(x+y)*z” or “x+(y*z)”. With common
definitions from mathematics, we expect the later parse, because “*”
(multiplication) has higher <em>precedence</em> than “+” (addition).</p>
<p>There are many ways to handle this, but an elegant and efficient way is
to use <a class="reference external" href="http://en.wikipedia.org/wiki/Operator-precedence_parser">Operator-Precedence
Parsing</a>.
This parsing technique uses the precedence of binary operators to guide
recursion. To start with, we need a table of precedences:</p>
<div class="highlight-ocaml"><div class="highlight"><pre><span></span><span class="c">(* binop_precedence - This holds the precedence for each binary operator that is</span>
<span class="c"> * defined *)</span>
<span class="k">let</span> <span class="n">binop_precedence</span><span class="o">:(</span><span class="kt">char</span><span class="o">,</span> <span class="kt">int</span><span class="o">)</span> <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">create</span> <span class="mi">10</span>

<span class="c">(* precedence - Get the precedence of the pending binary operator token. *)</span>
<span class="k">let</span> <span class="n">precedence</span> <span class="n">c</span> <span class="o">=</span> <span class="k">try</span> <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">find</span> <span class="n">binop_precedence</span> <span class="n">c</span> <span class="k">with</span> <span class="nc">Not_found</span> <span class="o">-&gt;</span> <span class="o">-</span><span class="mi">1</span>

<span class="o">...</span>

<span class="k">let</span> <span class="n">main</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="c">(* Install standard binary operators.</span>
<span class="c">   * 1 is the lowest precedence. *)</span>
  <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">add</span> <span class="nn">Parser</span><span class="p">.</span><span class="n">binop_precedence</span> <span class="sc">&#39;&lt;&#39;</span> <span class="mi">10</span><span class="o">;</span>
  <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">add</span> <span class="nn">Parser</span><span class="p">.</span><span class="n">binop_precedence</span> <span class="sc">&#39;+&#39;</span> <span class="mi">20</span><span class="o">;</span>
  <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">add</span> <span class="nn">Parser</span><span class="p">.</span><span class="n">binop_precedence</span> <span class="sc">&#39;-&#39;</span> <span class="mi">20</span><span class="o">;</span>
  <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">add</span> <span class="nn">Parser</span><span class="p">.</span><span class="n">binop_precedence</span> <span class="sc">&#39;*&#39;</span> <span class="mi">40</span><span class="o">;</span>    <span class="c">(* highest. *)</span>
  <span class="o">...</span>
</pre></div>
</div>
<p>For the basic form of Kaleidoscope, we will only support 4 binary
operators (this can obviously be extended by you, our brave and intrepid
reader). The <code class="docutils literal"><span class="pre">Parser.precedence</span></code> function returns the precedence for
the current token, or -1 if the token is not a binary operator. Having a
<code class="docutils literal"><span class="pre">Hashtbl.t</span></code> makes it easy to add new operators and makes it clear that
the algorithm doesn’t depend on the specific operators involved, but it
would be easy enough to eliminate the <code class="docutils literal"><span class="pre">Hashtbl.t</span></code> and do the
comparisons in the <code class="docutils literal"><span class="pre">Parser.precedence</span></code> function. (Or just use a
fixed-size array).</p>
<p>With the helper above defined, we can now start parsing binary
expressions. The basic idea of operator precedence parsing is to break
down an expression with potentially ambiguous binary operators into
pieces. Consider, for example, the expression “a+b+(c+d)*e*f+g”.
Operator precedence parsing considers this as a stream of primary
expressions separated by binary operators. As such, it will first parse
the leading primary expression “a”, then it will see the pairs [+, b]
[+, (c+d)] [*, e] [*, f] and [+, g]. Note that because parentheses are
primary expressions, the binary expression parser doesn’t need to worry
about nested subexpressions like (c+d) at all.</p>
<p>To start, an expression is a primary expression potentially followed by
a sequence of [binop,primaryexpr] pairs:</p>
<div class="highlight-ocaml"><div class="highlight"><pre><span></span><span class="c">(* expression</span>
<span class="c"> *   ::= primary binoprhs *)</span>
<span class="ow">and</span> <span class="n">parse_expr</span> <span class="o">=</span> <span class="n">parser</span>
  <span class="o">|</span> <span class="o">[&lt;</span> <span class="n">lhs</span><span class="o">=</span><span class="n">parse_primary</span><span class="o">;</span> <span class="n">stream</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span> <span class="n">parse_bin_rhs</span> <span class="mi">0</span> <span class="n">lhs</span> <span class="n">stream</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">Parser.parse_bin_rhs</span></code> is the function that parses the sequence of
pairs for us. It takes a precedence and a pointer to an expression for
the part that has been parsed so far. Note that “x” is a perfectly valid
expression: As such, “binoprhs” is allowed to be empty, in which case it
returns the expression that is passed into it. In our example above, the
code passes the expression for “a” into <code class="docutils literal"><span class="pre">Parser.parse_bin_rhs</span></code> and the
current token is “+”.</p>
<p>The precedence value passed into <code class="docutils literal"><span class="pre">Parser.parse_bin_rhs</span></code> indicates the
<em>minimal operator precedence</em> that the function is allowed to eat. For
example, if the current pair stream is [+, x] and
<code class="docutils literal"><span class="pre">Parser.parse_bin_rhs</span></code> is passed in a precedence of 40, it will not
consume any tokens (because the precedence of ‘+’ is only 20). With this
in mind, <code class="docutils literal"><span class="pre">Parser.parse_bin_rhs</span></code> starts with:</p>
<div class="highlight-ocaml"><div class="highlight"><pre><span></span><span class="c">(* binoprhs</span>
<span class="c"> *   ::= (&#39;+&#39; primary)* *)</span>
<span class="ow">and</span> <span class="n">parse_bin_rhs</span> <span class="n">expr_prec</span> <span class="n">lhs</span> <span class="n">stream</span> <span class="o">=</span>
  <span class="k">match</span> <span class="nn">Stream</span><span class="p">.</span><span class="n">peek</span> <span class="n">stream</span> <span class="k">with</span>
  <span class="c">(* If this is a binop, find its precedence. *)</span>
  <span class="o">|</span> <span class="nc">Some</span> <span class="o">(</span><span class="nn">Token</span><span class="p">.</span><span class="nc">Kwd</span> <span class="n">c</span><span class="o">)</span> <span class="k">when</span> <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">mem</span> <span class="n">binop_precedence</span> <span class="n">c</span> <span class="o">-&gt;</span>
      <span class="k">let</span> <span class="n">token_prec</span> <span class="o">=</span> <span class="n">precedence</span> <span class="n">c</span> <span class="k">in</span>

      <span class="c">(* If this is a binop that binds at least as tightly as the current binop,</span>
<span class="c">       * consume it, otherwise we are done. *)</span>
      <span class="k">if</span> <span class="n">token_prec</span> <span class="o">&lt;</span> <span class="n">expr_prec</span> <span class="k">then</span> <span class="n">lhs</span> <span class="k">else</span> <span class="k">begin</span>
</pre></div>
</div>
<p>This code gets the precedence of the current token and checks to see if
if is too low. Because we defined invalid tokens to have a precedence of
-1, this check implicitly knows that the pair-stream ends when the token
stream runs out of binary operators. If this check succeeds, we know
that the token is a binary operator and that it will be included in this
expression:</p>
<div class="highlight-ocaml"><div class="highlight"><pre><span></span><span class="c">(* Eat the binop. *)</span>
<span class="nn">Stream</span><span class="p">.</span><span class="n">junk</span> <span class="n">stream</span><span class="o">;</span>

<span class="c">(* Parse the primary expression after the binary operator *)</span>
<span class="k">let</span> <span class="n">rhs</span> <span class="o">=</span> <span class="n">parse_primary</span> <span class="n">stream</span> <span class="k">in</span>

<span class="c">(* Okay, we know this is a binop. *)</span>
<span class="k">let</span> <span class="n">rhs</span> <span class="o">=</span>
  <span class="k">match</span> <span class="nn">Stream</span><span class="p">.</span><span class="n">peek</span> <span class="n">stream</span> <span class="k">with</span>
  <span class="o">|</span> <span class="nc">Some</span> <span class="o">(</span><span class="nn">Token</span><span class="p">.</span><span class="nc">Kwd</span> <span class="n">c2</span><span class="o">)</span> <span class="o">-&gt;</span>
</pre></div>
</div>
<p>As such, this code eats (and remembers) the binary operator and then
parses the primary expression that follows. This builds up the whole
pair, the first of which is [+, b] for the running example.</p>
<p>Now that we parsed the left-hand side of an expression and one pair of
the RHS sequence, we have to decide which way the expression associates.
In particular, we could have “(a+b) binop unparsed” or “a + (b binop
unparsed)”. To determine this, we look ahead at “binop” to determine its
precedence and compare it to BinOp’s precedence (which is ‘+’ in this
case):</p>
<div class="highlight-ocaml"><div class="highlight"><pre><span></span><span class="c">(* If BinOp binds less tightly with rhs than the operator after</span>
<span class="c"> * rhs, let the pending operator take rhs as its lhs. *)</span>
<span class="k">let</span> <span class="n">next_prec</span> <span class="o">=</span> <span class="n">precedence</span> <span class="n">c2</span> <span class="k">in</span>
<span class="k">if</span> <span class="n">token_prec</span> <span class="o">&lt;</span> <span class="n">next_prec</span>
</pre></div>
</div>
<p>If the precedence of the binop to the right of “RHS” is lower or equal
to the precedence of our current operator, then we know that the
parentheses associate as “(a+b) binop …”. In our example, the current
operator is “+” and the next operator is “+”, we know that they have the
same precedence. In this case we’ll create the AST node for “a+b”, and
then continue parsing:</p>
<div class="highlight-ocaml"><div class="highlight"><pre><span></span>    <span class="o">...</span> <span class="k">if</span> <span class="n">body</span> <span class="n">omitted</span> <span class="o">...</span>
  <span class="k">in</span>

  <span class="c">(* Merge lhs/rhs. *)</span>
  <span class="k">let</span> <span class="n">lhs</span> <span class="o">=</span> <span class="nn">Ast</span><span class="p">.</span><span class="nc">Binary</span> <span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">lhs</span><span class="o">,</span> <span class="n">rhs</span><span class="o">)</span> <span class="k">in</span>
  <span class="n">parse_bin_rhs</span> <span class="n">expr_prec</span> <span class="n">lhs</span> <span class="n">stream</span>
<span class="k">end</span>
</pre></div>
</div>
<p>In our example above, this will turn “a+b+” into “(a+b)” and execute the
next iteration of the loop, with “+” as the current token. The code
above will eat, remember, and parse “(c+d)” as the primary expression,
which makes the current pair equal to [+, (c+d)]. It will then evaluate
the ‘if’ conditional above with “*” as the binop to the right of the
primary. In this case, the precedence of “*” is higher than the
precedence of “+” so the if condition will be entered.</p>
<p>The critical question left here is “how can the if condition parse the
right hand side in full”? In particular, to build the AST correctly for
our example, it needs to get all of “(c+d)*e*f” as the RHS expression
variable. The code to do this is surprisingly simple (code from the
above two blocks duplicated for context):</p>
<div class="highlight-ocaml"><div class="highlight"><pre><span></span>    <span class="k">match</span> <span class="nn">Stream</span><span class="p">.</span><span class="n">peek</span> <span class="n">stream</span> <span class="k">with</span>
    <span class="o">|</span> <span class="nc">Some</span> <span class="o">(</span><span class="nn">Token</span><span class="p">.</span><span class="nc">Kwd</span> <span class="n">c2</span><span class="o">)</span> <span class="o">-&gt;</span>
        <span class="c">(* If BinOp binds less tightly with rhs than the operator after</span>
<span class="c">         * rhs, let the pending operator take rhs as its lhs. *)</span>
        <span class="k">if</span> <span class="n">token_prec</span> <span class="o">&lt;</span> <span class="n">precedence</span> <span class="n">c2</span>
        <span class="k">then</span> <span class="n">parse_bin_rhs</span> <span class="o">(</span><span class="n">token_prec</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">rhs</span> <span class="n">stream</span>
        <span class="k">else</span> <span class="n">rhs</span>
    <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="n">rhs</span>
  <span class="k">in</span>

  <span class="c">(* Merge lhs/rhs. *)</span>
  <span class="k">let</span> <span class="n">lhs</span> <span class="o">=</span> <span class="nn">Ast</span><span class="p">.</span><span class="nc">Binary</span> <span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">lhs</span><span class="o">,</span> <span class="n">rhs</span><span class="o">)</span> <span class="k">in</span>
  <span class="n">parse_bin_rhs</span> <span class="n">expr_prec</span> <span class="n">lhs</span> <span class="n">stream</span>
<span class="k">end</span>
</pre></div>
</div>
<p>At this point, we know that the binary operator to the RHS of our
primary has higher precedence than the binop we are currently parsing.
As such, we know that any sequence of pairs whose operators are all
higher precedence than “+” should be parsed together and returned as
“RHS”. To do this, we recursively invoke the <code class="docutils literal"><span class="pre">Parser.parse_bin_rhs</span></code>
function specifying “token_prec+1” as the minimum precedence required
for it to continue. In our example above, this will cause it to return
the AST node for “(c+d)*e*f” as RHS, which is then set as the RHS of
the ‘+’ expression.</p>
<p>Finally, on the next iteration of the while loop, the “+g” piece is
parsed and added to the AST. With this little bit of code (14
non-trivial lines), we correctly handle fully general binary expression
parsing in a very elegant way. This was a whirlwind tour of this code,
and it is somewhat subtle. I recommend running through it with a few
tough examples to see how it works.</p>
<p>This wraps up handling of expressions. At this point, we can point the
parser at an arbitrary token stream and build an expression from it,
stopping at the first token that is not part of the expression. Next up
we need to handle function definitions, etc.</p>
</div>
<div class="section" id="parsing-the-rest">
<h2><a class="toc-backref" href="#id7">2.6. Parsing the Rest</a><a class="headerlink" href="#parsing-the-rest" title="Permalink to this headline">¶</a></h2>
<p>The next thing missing is handling of function prototypes. In
Kaleidoscope, these are used both for ‘extern’ function declarations as
well as function body definitions. The code to do this is
straight-forward and not very interesting (once you’ve survived
expressions):</p>
<div class="highlight-ocaml"><div class="highlight"><pre><span></span><span class="c">(* prototype</span>
<span class="c"> *   ::= id &#39;(&#39; id* &#39;)&#39; *)</span>
<span class="k">let</span> <span class="n">parse_prototype</span> <span class="o">=</span>
  <span class="k">let</span> <span class="k">rec</span> <span class="n">parse_args</span> <span class="n">accumulator</span> <span class="o">=</span> <span class="n">parser</span>
    <span class="o">|</span> <span class="o">[&lt;</span> <span class="k">&#39;</span><span class="nn">Token</span><span class="p">.</span><span class="nc">Ident</span> <span class="n">id</span><span class="o">;</span> <span class="n">e</span><span class="o">=</span><span class="n">parse_args</span> <span class="o">(</span><span class="n">id</span><span class="o">::</span><span class="n">accumulator</span><span class="o">)</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span> <span class="n">e</span>
    <span class="o">|</span> <span class="o">[&lt;</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span> <span class="n">accumulator</span>
  <span class="k">in</span>

  <span class="n">parser</span>
  <span class="o">|</span> <span class="o">[&lt;</span> <span class="k">&#39;</span><span class="nn">Token</span><span class="p">.</span><span class="nc">Ident</span> <span class="n">id</span><span class="o">;</span>
       <span class="k">&#39;</span><span class="nn">Token</span><span class="p">.</span><span class="nc">Kwd</span> <span class="sc">&#39;(&#39;</span> <span class="o">??</span> <span class="s2">&quot;expected &#39;(&#39; in prototype&quot;</span><span class="o">;</span>
       <span class="n">args</span><span class="o">=</span><span class="n">parse_args</span> <span class="bp">[]</span><span class="o">;</span>
       <span class="k">&#39;</span><span class="nn">Token</span><span class="p">.</span><span class="nc">Kwd</span> <span class="sc">&#39;)&#39;</span> <span class="o">??</span> <span class="s2">&quot;expected &#39;)&#39; in prototype&quot;</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span>
      <span class="c">(* success. *)</span>
      <span class="nn">Ast</span><span class="p">.</span><span class="nc">Prototype</span> <span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="nn">Array</span><span class="p">.</span><span class="n">of_list</span> <span class="o">(</span><span class="nn">List</span><span class="p">.</span><span class="n">rev</span> <span class="n">args</span><span class="o">))</span>

  <span class="o">|</span> <span class="o">[&lt;</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span>
      <span class="k">raise</span> <span class="o">(</span><span class="nn">Stream</span><span class="p">.</span><span class="nc">Error</span> <span class="s2">&quot;expected function name in prototype&quot;</span><span class="o">)</span>
</pre></div>
</div>
<p>Given this, a function definition is very simple, just a prototype plus
an expression to implement the body:</p>
<div class="highlight-ocaml"><div class="highlight"><pre><span></span><span class="c">(* definition ::= &#39;def&#39; prototype expression *)</span>
<span class="k">let</span> <span class="n">parse_definition</span> <span class="o">=</span> <span class="n">parser</span>
  <span class="o">|</span> <span class="o">[&lt;</span> <span class="k">&#39;</span><span class="nn">Token</span><span class="p">.</span><span class="nc">Def</span><span class="o">;</span> <span class="n">p</span><span class="o">=</span><span class="n">parse_prototype</span><span class="o">;</span> <span class="n">e</span><span class="o">=</span><span class="n">parse_expr</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span>
      <span class="nn">Ast</span><span class="p">.</span><span class="nc">Function</span> <span class="o">(</span><span class="n">p</span><span class="o">,</span> <span class="n">e</span><span class="o">)</span>
</pre></div>
</div>
<p>In addition, we support ‘extern’ to declare functions like ‘sin’ and
‘cos’ as well as to support forward declaration of user functions. These
‘extern’s are just prototypes with no body:</p>
<div class="highlight-ocaml"><div class="highlight"><pre><span></span><span class="c">(*  external ::= &#39;extern&#39; prototype *)</span>
<span class="k">let</span> <span class="n">parse_extern</span> <span class="o">=</span> <span class="n">parser</span>
  <span class="o">|</span> <span class="o">[&lt;</span> <span class="k">&#39;</span><span class="nn">Token</span><span class="p">.</span><span class="nc">Extern</span><span class="o">;</span> <span class="n">e</span><span class="o">=</span><span class="n">parse_prototype</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span> <span class="n">e</span>
</pre></div>
</div>
<p>Finally, we’ll also let the user type in arbitrary top-level expressions
and evaluate them on the fly. We will handle this by defining anonymous
nullary (zero argument) functions for them:</p>
<div class="highlight-ocaml"><div class="highlight"><pre><span></span><span class="c">(* toplevelexpr ::= expression *)</span>
<span class="k">let</span> <span class="n">parse_toplevel</span> <span class="o">=</span> <span class="n">parser</span>
  <span class="o">|</span> <span class="o">[&lt;</span> <span class="n">e</span><span class="o">=</span><span class="n">parse_expr</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span>
      <span class="c">(* Make an anonymous proto. *)</span>
      <span class="nn">Ast</span><span class="p">.</span><span class="nc">Function</span> <span class="o">(</span><span class="nn">Ast</span><span class="p">.</span><span class="nc">Prototype</span> <span class="o">(</span><span class="s2">&quot;&quot;</span><span class="o">,</span> <span class="o">[||]),</span> <span class="n">e</span><span class="o">)</span>
</pre></div>
</div>
<p>Now that we have all the pieces, let’s build a little driver that will
let us actually <em>execute</em> this code we’ve built!</p>
</div>
<div class="section" id="the-driver">
<h2><a class="toc-backref" href="#id8">2.7. The Driver</a><a class="headerlink" href="#the-driver" title="Permalink to this headline">¶</a></h2>
<p>The driver for this simply invokes all of the parsing pieces with a
top-level dispatch loop. There isn’t much interesting here, so I’ll just
include the top-level loop. See <a class="reference external" href="#full-code-listing">below</a> for full code in the
“Top-Level Parsing” section.</p>
<div class="highlight-ocaml"><div class="highlight"><pre><span></span><span class="c">(* top ::= definition | external | expression | &#39;;&#39; *)</span>
<span class="k">let</span> <span class="k">rec</span> <span class="n">main_loop</span> <span class="n">stream</span> <span class="o">=</span>
  <span class="k">match</span> <span class="nn">Stream</span><span class="p">.</span><span class="n">peek</span> <span class="n">stream</span> <span class="k">with</span>
  <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="bp">()</span>

  <span class="c">(* ignore top-level semicolons. *)</span>
  <span class="o">|</span> <span class="nc">Some</span> <span class="o">(</span><span class="nn">Token</span><span class="p">.</span><span class="nc">Kwd</span> <span class="sc">&#39;;&#39;</span><span class="o">)</span> <span class="o">-&gt;</span>
      <span class="nn">Stream</span><span class="p">.</span><span class="n">junk</span> <span class="n">stream</span><span class="o">;</span>
      <span class="n">main_loop</span> <span class="n">stream</span>

  <span class="o">|</span> <span class="nc">Some</span> <span class="n">token</span> <span class="o">-&gt;</span>
      <span class="k">begin</span>
        <span class="k">try</span> <span class="k">match</span> <span class="n">token</span> <span class="k">with</span>
        <span class="o">|</span> <span class="nn">Token</span><span class="p">.</span><span class="nc">Def</span> <span class="o">-&gt;</span>
            <span class="n">ignore</span><span class="o">(</span><span class="nn">Parser</span><span class="p">.</span><span class="n">parse_definition</span> <span class="n">stream</span><span class="o">);</span>
            <span class="n">print_endline</span> <span class="s2">&quot;parsed a function definition.&quot;</span><span class="o">;</span>
        <span class="o">|</span> <span class="nn">Token</span><span class="p">.</span><span class="nc">Extern</span> <span class="o">-&gt;</span>
            <span class="n">ignore</span><span class="o">(</span><span class="nn">Parser</span><span class="p">.</span><span class="n">parse_extern</span> <span class="n">stream</span><span class="o">);</span>
            <span class="n">print_endline</span> <span class="s2">&quot;parsed an extern.&quot;</span><span class="o">;</span>
        <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span>
            <span class="c">(* Evaluate a top-level expression into an anonymous function. *)</span>
            <span class="n">ignore</span><span class="o">(</span><span class="nn">Parser</span><span class="p">.</span><span class="n">parse_toplevel</span> <span class="n">stream</span><span class="o">);</span>
            <span class="n">print_endline</span> <span class="s2">&quot;parsed a top-level expr&quot;</span><span class="o">;</span>
        <span class="k">with</span> <span class="nn">Stream</span><span class="p">.</span><span class="nc">Error</span> <span class="n">s</span> <span class="o">-&gt;</span>
          <span class="c">(* Skip token for error recovery. *)</span>
          <span class="nn">Stream</span><span class="p">.</span><span class="n">junk</span> <span class="n">stream</span><span class="o">;</span>
          <span class="n">print_endline</span> <span class="n">s</span><span class="o">;</span>
      <span class="k">end</span><span class="o">;</span>
      <span class="n">print_string</span> <span class="s2">&quot;ready&gt; &quot;</span><span class="o">;</span> <span class="n">flush</span> <span class="n">stdout</span><span class="o">;</span>
      <span class="n">main_loop</span> <span class="n">stream</span>
</pre></div>
</div>
<p>The most interesting part of this is that we ignore top-level
semicolons. Why is this, you ask? The basic reason is that if you type
“4 + 5” at the command line, the parser doesn’t know whether that is the
end of what you will type or not. For example, on the next line you
could type “def foo…” in which case 4+5 is the end of a top-level
expression. Alternatively you could type “* 6”, which would continue
the expression. Having top-level semicolons allows you to type “4+5;”,
and the parser will know you are done.</p>
</div>
<div class="section" id="conclusions">
<h2><a class="toc-backref" href="#id9">2.8. Conclusions</a><a class="headerlink" href="#conclusions" title="Permalink to this headline">¶</a></h2>
<p>With just under 300 lines of commented code (240 lines of non-comment,
non-blank code), we fully defined our minimal language, including a
lexer, parser, and AST builder. With this done, the executable will
validate Kaleidoscope code and tell us if it is grammatically invalid.
For example, here is a sample interaction:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ ./toy.byte
ready&gt; def foo<span class="o">(</span>x y<span class="o">)</span> x+foo<span class="o">(</span>y, <span class="m">4</span>.0<span class="o">)</span><span class="p">;</span>
Parsed a <span class="k">function</span> definition.
ready&gt; def foo<span class="o">(</span>x y<span class="o">)</span> x+y y<span class="p">;</span>
Parsed a <span class="k">function</span> definition.
Parsed a top-level expr
ready&gt; def foo<span class="o">(</span>x y<span class="o">)</span> x+y <span class="o">)</span><span class="p">;</span>
Parsed a <span class="k">function</span> definition.
Error: unknown token when expecting an expression
ready&gt; extern sin<span class="o">(</span>a<span class="o">)</span><span class="p">;</span>
ready&gt; Parsed an extern
ready&gt; ^D
$
</pre></div>
</div>
<p>There is a lot of room for extension here. You can define new AST nodes,
extend the language in many ways, etc. In the <a class="reference external" href="OCamlLangImpl3.html">next
installment</a>, we will describe how to generate
LLVM Intermediate Representation (IR) from the AST.</p>
</div>
<div class="section" id="full-code-listing">
<h2><a class="toc-backref" href="#id10">2.9. Full Code Listing</a><a class="headerlink" href="#full-code-listing" title="Permalink to this headline">¶</a></h2>
<p>Here is the complete code listing for this and the previous chapter.
Note that it is fully self-contained: you don’t need LLVM or any
external libraries at all for this. (Besides the ocaml standard
libraries, of course.) To build this, just compile with:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span><span class="c1"># Compile</span>
ocamlbuild toy.byte
<span class="c1"># Run</span>
./toy.byte
</pre></div>
</div>
<p>Here is the code:</p>
<dl class="docutils">
<dt>_tags:</dt>
<dd><div class="first last highlight-default"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="p">{</span><span class="n">lexer</span><span class="p">,</span><span class="n">parser</span><span class="p">}</span><span class="o">.</span><span class="n">ml</span><span class="o">&gt;</span><span class="p">:</span> <span class="n">use_camlp4</span><span class="p">,</span> <span class="n">pp</span><span class="p">(</span><span class="n">camlp4of</span><span class="p">)</span>
</pre></div>
</div>
</dd>
<dt>token.ml:</dt>
<dd><div class="first last highlight-ocaml"><div class="highlight"><pre><span></span><span class="c">(*===----------------------------------------------------------------------===</span>
<span class="c"> * Lexer Tokens</span>
<span class="c"> *===----------------------------------------------------------------------===*)</span>

<span class="c">(* The lexer returns these &#39;Kwd&#39; if it is an unknown character, otherwise one of</span>
<span class="c"> * these others for known things. *)</span>
<span class="k">type</span> <span class="n">token</span> <span class="o">=</span>
  <span class="c">(* commands *)</span>
  <span class="o">|</span> <span class="nc">Def</span> <span class="o">|</span> <span class="nc">Extern</span>

  <span class="c">(* primary *)</span>
  <span class="o">|</span> <span class="nc">Ident</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">|</span> <span class="nc">Number</span> <span class="k">of</span> <span class="kt">float</span>

  <span class="c">(* unknown *)</span>
  <span class="o">|</span> <span class="nc">Kwd</span> <span class="k">of</span> <span class="kt">char</span>
</pre></div>
</div>
</dd>
<dt>lexer.ml:</dt>
<dd><div class="first last highlight-ocaml"><div class="highlight"><pre><span></span><span class="c">(*===----------------------------------------------------------------------===</span>
<span class="c"> * Lexer</span>
<span class="c"> *===----------------------------------------------------------------------===*)</span>

<span class="k">let</span> <span class="k">rec</span> <span class="n">lex</span> <span class="o">=</span> <span class="n">parser</span>
  <span class="c">(* Skip any whitespace. *)</span>
  <span class="o">|</span> <span class="o">[&lt;</span> <span class="k">&#39;</span> <span class="o">(</span><span class="sc">&#39; &#39;</span> <span class="o">|</span> <span class="sc">&#39;\n&#39;</span> <span class="o">|</span> <span class="sc">&#39;\r&#39;</span> <span class="o">|</span> <span class="sc">&#39;\t&#39;</span><span class="o">);</span> <span class="n">stream</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span> <span class="n">lex</span> <span class="n">stream</span>

  <span class="c">(* identifier: [a-zA-Z][a-zA-Z0-9] *)</span>
  <span class="o">|</span> <span class="o">[&lt;</span> <span class="k">&#39;</span> <span class="o">(</span><span class="sc">&#39;A&#39;</span> <span class="o">..</span> <span class="sc">&#39;Z&#39;</span> <span class="o">|</span> <span class="sc">&#39;a&#39;</span> <span class="o">..</span> <span class="sc">&#39;z&#39;</span> <span class="k">as</span> <span class="n">c</span><span class="o">);</span> <span class="n">stream</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span>
      <span class="k">let</span> <span class="n">buffer</span> <span class="o">=</span> <span class="nn">Buffer</span><span class="p">.</span><span class="n">create</span> <span class="mi">1</span> <span class="k">in</span>
      <span class="nn">Buffer</span><span class="p">.</span><span class="n">add_char</span> <span class="n">buffer</span> <span class="n">c</span><span class="o">;</span>
      <span class="n">lex_ident</span> <span class="n">buffer</span> <span class="n">stream</span>

  <span class="c">(* number: [0-9.]+ *)</span>
  <span class="o">|</span> <span class="o">[&lt;</span> <span class="k">&#39;</span> <span class="o">(</span><span class="sc">&#39;0&#39;</span> <span class="o">..</span> <span class="sc">&#39;9&#39;</span> <span class="k">as</span> <span class="n">c</span><span class="o">);</span> <span class="n">stream</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span>
      <span class="k">let</span> <span class="n">buffer</span> <span class="o">=</span> <span class="nn">Buffer</span><span class="p">.</span><span class="n">create</span> <span class="mi">1</span> <span class="k">in</span>
      <span class="nn">Buffer</span><span class="p">.</span><span class="n">add_char</span> <span class="n">buffer</span> <span class="n">c</span><span class="o">;</span>
      <span class="n">lex_number</span> <span class="n">buffer</span> <span class="n">stream</span>

  <span class="c">(* Comment until end of line. *)</span>
  <span class="o">|</span> <span class="o">[&lt;</span> <span class="k">&#39;</span> <span class="o">(</span><span class="sc">&#39;#&#39;</span><span class="o">);</span> <span class="n">stream</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span>
      <span class="n">lex_comment</span> <span class="n">stream</span>

  <span class="c">(* Otherwise, just return the character as its ascii value. *)</span>
  <span class="o">|</span> <span class="o">[&lt;</span> <span class="k">&#39;</span><span class="n">c</span><span class="o">;</span> <span class="n">stream</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span>
      <span class="o">[&lt;</span> <span class="k">&#39;</span><span class="nn">Token</span><span class="p">.</span><span class="nc">Kwd</span> <span class="n">c</span><span class="o">;</span> <span class="n">lex</span> <span class="n">stream</span> <span class="o">&gt;]</span>

  <span class="c">(* end of stream. *)</span>
  <span class="o">|</span> <span class="o">[&lt;</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span> <span class="o">[&lt;</span> <span class="o">&gt;]</span>

<span class="ow">and</span> <span class="n">lex_number</span> <span class="n">buffer</span> <span class="o">=</span> <span class="n">parser</span>
  <span class="o">|</span> <span class="o">[&lt;</span> <span class="k">&#39;</span> <span class="o">(</span><span class="sc">&#39;0&#39;</span> <span class="o">..</span> <span class="sc">&#39;9&#39;</span> <span class="o">|</span> <span class="sc">&#39;.&#39;</span> <span class="k">as</span> <span class="n">c</span><span class="o">);</span> <span class="n">stream</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span>
      <span class="nn">Buffer</span><span class="p">.</span><span class="n">add_char</span> <span class="n">buffer</span> <span class="n">c</span><span class="o">;</span>
      <span class="n">lex_number</span> <span class="n">buffer</span> <span class="n">stream</span>
  <span class="o">|</span> <span class="o">[&lt;</span> <span class="n">stream</span><span class="o">=</span><span class="n">lex</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span>
      <span class="o">[&lt;</span> <span class="k">&#39;</span><span class="nn">Token</span><span class="p">.</span><span class="nc">Number</span> <span class="o">(</span><span class="n">float_of_string</span> <span class="o">(</span><span class="nn">Buffer</span><span class="p">.</span><span class="n">contents</span> <span class="n">buffer</span><span class="o">));</span> <span class="n">stream</span> <span class="o">&gt;]</span>

<span class="ow">and</span> <span class="n">lex_ident</span> <span class="n">buffer</span> <span class="o">=</span> <span class="n">parser</span>
  <span class="o">|</span> <span class="o">[&lt;</span> <span class="k">&#39;</span> <span class="o">(</span><span class="sc">&#39;A&#39;</span> <span class="o">..</span> <span class="sc">&#39;Z&#39;</span> <span class="o">|</span> <span class="sc">&#39;a&#39;</span> <span class="o">..</span> <span class="sc">&#39;z&#39;</span> <span class="o">|</span> <span class="sc">&#39;0&#39;</span> <span class="o">..</span> <span class="sc">&#39;9&#39;</span> <span class="k">as</span> <span class="n">c</span><span class="o">);</span> <span class="n">stream</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span>
      <span class="nn">Buffer</span><span class="p">.</span><span class="n">add_char</span> <span class="n">buffer</span> <span class="n">c</span><span class="o">;</span>
      <span class="n">lex_ident</span> <span class="n">buffer</span> <span class="n">stream</span>
  <span class="o">|</span> <span class="o">[&lt;</span> <span class="n">stream</span><span class="o">=</span><span class="n">lex</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span>
      <span class="k">match</span> <span class="nn">Buffer</span><span class="p">.</span><span class="n">contents</span> <span class="n">buffer</span> <span class="k">with</span>
      <span class="o">|</span> <span class="s2">&quot;def&quot;</span> <span class="o">-&gt;</span> <span class="o">[&lt;</span> <span class="k">&#39;</span><span class="nn">Token</span><span class="p">.</span><span class="nc">Def</span><span class="o">;</span> <span class="n">stream</span> <span class="o">&gt;]</span>
      <span class="o">|</span> <span class="s2">&quot;extern&quot;</span> <span class="o">-&gt;</span> <span class="o">[&lt;</span> <span class="k">&#39;</span><span class="nn">Token</span><span class="p">.</span><span class="nc">Extern</span><span class="o">;</span> <span class="n">stream</span> <span class="o">&gt;]</span>
      <span class="o">|</span> <span class="n">id</span> <span class="o">-&gt;</span> <span class="o">[&lt;</span> <span class="k">&#39;</span><span class="nn">Token</span><span class="p">.</span><span class="nc">Ident</span> <span class="n">id</span><span class="o">;</span> <span class="n">stream</span> <span class="o">&gt;]</span>

<span class="ow">and</span> <span class="n">lex_comment</span> <span class="o">=</span> <span class="n">parser</span>
  <span class="o">|</span> <span class="o">[&lt;</span> <span class="k">&#39;</span> <span class="o">(</span><span class="sc">&#39;\n&#39;</span><span class="o">);</span> <span class="n">stream</span><span class="o">=</span><span class="n">lex</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span> <span class="n">stream</span>
  <span class="o">|</span> <span class="o">[&lt;</span> <span class="k">&#39;</span><span class="n">c</span><span class="o">;</span> <span class="n">e</span><span class="o">=</span><span class="n">lex_comment</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span> <span class="n">e</span>
  <span class="o">|</span> <span class="o">[&lt;</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span> <span class="o">[&lt;</span> <span class="o">&gt;]</span>
</pre></div>
</div>
</dd>
<dt>ast.ml:</dt>
<dd><div class="first last highlight-ocaml"><div class="highlight"><pre><span></span><span class="c">(*===----------------------------------------------------------------------===</span>
<span class="c"> * Abstract Syntax Tree (aka Parse Tree)</span>
<span class="c"> *===----------------------------------------------------------------------===*)</span>

<span class="c">(* expr - Base type for all expression nodes. *)</span>
<span class="k">type</span> <span class="n">expr</span> <span class="o">=</span>
  <span class="c">(* variant for numeric literals like &quot;1.0&quot;. *)</span>
  <span class="o">|</span> <span class="nc">Number</span> <span class="k">of</span> <span class="kt">float</span>

  <span class="c">(* variant for referencing a variable, like &quot;a&quot;. *)</span>
  <span class="o">|</span> <span class="nc">Variable</span> <span class="k">of</span> <span class="kt">string</span>

  <span class="c">(* variant for a binary operator. *)</span>
  <span class="o">|</span> <span class="nc">Binary</span> <span class="k">of</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">expr</span> <span class="o">*</span> <span class="n">expr</span>

  <span class="c">(* variant for function calls. *)</span>
  <span class="o">|</span> <span class="nc">Call</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">*</span> <span class="n">expr</span> <span class="kt">array</span>

<span class="c">(* proto - This type represents the &quot;prototype&quot; for a function, which captures</span>
<span class="c"> * its name, and its argument names (thus implicitly the number of arguments the</span>
<span class="c"> * function takes). *)</span>
<span class="k">type</span> <span class="n">proto</span> <span class="o">=</span> <span class="nc">Prototype</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">*</span> <span class="kt">string</span> <span class="kt">array</span>

<span class="c">(* func - This type represents a function definition itself. *)</span>
<span class="k">type</span> <span class="n">func</span> <span class="o">=</span> <span class="nc">Function</span> <span class="k">of</span> <span class="n">proto</span> <span class="o">*</span> <span class="n">expr</span>
</pre></div>
</div>
</dd>
<dt>parser.ml:</dt>
<dd><div class="first last highlight-ocaml"><div class="highlight"><pre><span></span><span class="c">(*===---------------------------------------------------------------------===</span>
<span class="c"> * Parser</span>
<span class="c"> *===---------------------------------------------------------------------===*)</span>

<span class="c">(* binop_precedence - This holds the precedence for each binary operator that is</span>
<span class="c"> * defined *)</span>
<span class="k">let</span> <span class="n">binop_precedence</span><span class="o">:(</span><span class="kt">char</span><span class="o">,</span> <span class="kt">int</span><span class="o">)</span> <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">create</span> <span class="mi">10</span>

<span class="c">(* precedence - Get the precedence of the pending binary operator token. *)</span>
<span class="k">let</span> <span class="n">precedence</span> <span class="n">c</span> <span class="o">=</span> <span class="k">try</span> <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">find</span> <span class="n">binop_precedence</span> <span class="n">c</span> <span class="k">with</span> <span class="nc">Not_found</span> <span class="o">-&gt;</span> <span class="o">-</span><span class="mi">1</span>

<span class="c">(* primary</span>
<span class="c"> *   ::= identifier</span>
<span class="c"> *   ::= numberexpr</span>
<span class="c"> *   ::= parenexpr *)</span>
<span class="k">let</span> <span class="k">rec</span> <span class="n">parse_primary</span> <span class="o">=</span> <span class="n">parser</span>
  <span class="c">(* numberexpr ::= number *)</span>
  <span class="o">|</span> <span class="o">[&lt;</span> <span class="k">&#39;</span><span class="nn">Token</span><span class="p">.</span><span class="nc">Number</span> <span class="n">n</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span> <span class="nn">Ast</span><span class="p">.</span><span class="nc">Number</span> <span class="n">n</span>

  <span class="c">(* parenexpr ::= &#39;(&#39; expression &#39;)&#39; *)</span>
  <span class="o">|</span> <span class="o">[&lt;</span> <span class="k">&#39;</span><span class="nn">Token</span><span class="p">.</span><span class="nc">Kwd</span> <span class="sc">&#39;(&#39;</span><span class="o">;</span> <span class="n">e</span><span class="o">=</span><span class="n">parse_expr</span><span class="o">;</span> <span class="k">&#39;</span><span class="nn">Token</span><span class="p">.</span><span class="nc">Kwd</span> <span class="sc">&#39;)&#39;</span> <span class="o">??</span> <span class="s2">&quot;expected &#39;)&#39;&quot;</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span> <span class="n">e</span>

  <span class="c">(* identifierexpr</span>
<span class="c">   *   ::= identifier</span>
<span class="c">   *   ::= identifier &#39;(&#39; argumentexpr &#39;)&#39; *)</span>
  <span class="o">|</span> <span class="o">[&lt;</span> <span class="k">&#39;</span><span class="nn">Token</span><span class="p">.</span><span class="nc">Ident</span> <span class="n">id</span><span class="o">;</span> <span class="n">stream</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span>
      <span class="k">let</span> <span class="k">rec</span> <span class="n">parse_args</span> <span class="n">accumulator</span> <span class="o">=</span> <span class="n">parser</span>
        <span class="o">|</span> <span class="o">[&lt;</span> <span class="n">e</span><span class="o">=</span><span class="n">parse_expr</span><span class="o">;</span> <span class="n">stream</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span>
            <span class="k">begin</span> <span class="n">parser</span>
              <span class="o">|</span> <span class="o">[&lt;</span> <span class="k">&#39;</span><span class="nn">Token</span><span class="p">.</span><span class="nc">Kwd</span> <span class="sc">&#39;,&#39;</span><span class="o">;</span> <span class="n">e</span><span class="o">=</span><span class="n">parse_args</span> <span class="o">(</span><span class="n">e</span> <span class="o">::</span> <span class="n">accumulator</span><span class="o">)</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span> <span class="n">e</span>
              <span class="o">|</span> <span class="o">[&lt;</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span> <span class="n">e</span> <span class="o">::</span> <span class="n">accumulator</span>
            <span class="k">end</span> <span class="n">stream</span>
        <span class="o">|</span> <span class="o">[&lt;</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span> <span class="n">accumulator</span>
      <span class="k">in</span>
      <span class="k">let</span> <span class="k">rec</span> <span class="n">parse_ident</span> <span class="n">id</span> <span class="o">=</span> <span class="n">parser</span>
        <span class="c">(* Call. *)</span>
        <span class="o">|</span> <span class="o">[&lt;</span> <span class="k">&#39;</span><span class="nn">Token</span><span class="p">.</span><span class="nc">Kwd</span> <span class="sc">&#39;(&#39;</span><span class="o">;</span>
             <span class="n">args</span><span class="o">=</span><span class="n">parse_args</span> <span class="bp">[]</span><span class="o">;</span>
             <span class="k">&#39;</span><span class="nn">Token</span><span class="p">.</span><span class="nc">Kwd</span> <span class="sc">&#39;)&#39;</span> <span class="o">??</span> <span class="s2">&quot;expected &#39;)&#39;&quot;</span><span class="o">&gt;]</span> <span class="o">-&gt;</span>
            <span class="nn">Ast</span><span class="p">.</span><span class="nc">Call</span> <span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="nn">Array</span><span class="p">.</span><span class="n">of_list</span> <span class="o">(</span><span class="nn">List</span><span class="p">.</span><span class="n">rev</span> <span class="n">args</span><span class="o">))</span>

        <span class="c">(* Simple variable ref. *)</span>
        <span class="o">|</span> <span class="o">[&lt;</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span> <span class="nn">Ast</span><span class="p">.</span><span class="nc">Variable</span> <span class="n">id</span>
      <span class="k">in</span>
      <span class="n">parse_ident</span> <span class="n">id</span> <span class="n">stream</span>

  <span class="o">|</span> <span class="o">[&lt;</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span> <span class="k">raise</span> <span class="o">(</span><span class="nn">Stream</span><span class="p">.</span><span class="nc">Error</span> <span class="s2">&quot;unknown token when expecting an expression.&quot;</span><span class="o">)</span>

<span class="c">(* binoprhs</span>
<span class="c"> *   ::= (&#39;+&#39; primary)* *)</span>
<span class="ow">and</span> <span class="n">parse_bin_rhs</span> <span class="n">expr_prec</span> <span class="n">lhs</span> <span class="n">stream</span> <span class="o">=</span>
  <span class="k">match</span> <span class="nn">Stream</span><span class="p">.</span><span class="n">peek</span> <span class="n">stream</span> <span class="k">with</span>
  <span class="c">(* If this is a binop, find its precedence. *)</span>
  <span class="o">|</span> <span class="nc">Some</span> <span class="o">(</span><span class="nn">Token</span><span class="p">.</span><span class="nc">Kwd</span> <span class="n">c</span><span class="o">)</span> <span class="k">when</span> <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">mem</span> <span class="n">binop_precedence</span> <span class="n">c</span> <span class="o">-&gt;</span>
      <span class="k">let</span> <span class="n">token_prec</span> <span class="o">=</span> <span class="n">precedence</span> <span class="n">c</span> <span class="k">in</span>

      <span class="c">(* If this is a binop that binds at least as tightly as the current binop,</span>
<span class="c">       * consume it, otherwise we are done. *)</span>
      <span class="k">if</span> <span class="n">token_prec</span> <span class="o">&lt;</span> <span class="n">expr_prec</span> <span class="k">then</span> <span class="n">lhs</span> <span class="k">else</span> <span class="k">begin</span>
        <span class="c">(* Eat the binop. *)</span>
        <span class="nn">Stream</span><span class="p">.</span><span class="n">junk</span> <span class="n">stream</span><span class="o">;</span>

        <span class="c">(* Parse the primary expression after the binary operator. *)</span>
        <span class="k">let</span> <span class="n">rhs</span> <span class="o">=</span> <span class="n">parse_primary</span> <span class="n">stream</span> <span class="k">in</span>

        <span class="c">(* Okay, we know this is a binop. *)</span>
        <span class="k">let</span> <span class="n">rhs</span> <span class="o">=</span>
          <span class="k">match</span> <span class="nn">Stream</span><span class="p">.</span><span class="n">peek</span> <span class="n">stream</span> <span class="k">with</span>
          <span class="o">|</span> <span class="nc">Some</span> <span class="o">(</span><span class="nn">Token</span><span class="p">.</span><span class="nc">Kwd</span> <span class="n">c2</span><span class="o">)</span> <span class="o">-&gt;</span>
              <span class="c">(* If BinOp binds less tightly with rhs than the operator after</span>
<span class="c">               * rhs, let the pending operator take rhs as its lhs. *)</span>
              <span class="k">let</span> <span class="n">next_prec</span> <span class="o">=</span> <span class="n">precedence</span> <span class="n">c2</span> <span class="k">in</span>
              <span class="k">if</span> <span class="n">token_prec</span> <span class="o">&lt;</span> <span class="n">next_prec</span>
              <span class="k">then</span> <span class="n">parse_bin_rhs</span> <span class="o">(</span><span class="n">token_prec</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">rhs</span> <span class="n">stream</span>
              <span class="k">else</span> <span class="n">rhs</span>
          <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="n">rhs</span>
        <span class="k">in</span>

        <span class="c">(* Merge lhs/rhs. *)</span>
        <span class="k">let</span> <span class="n">lhs</span> <span class="o">=</span> <span class="nn">Ast</span><span class="p">.</span><span class="nc">Binary</span> <span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">lhs</span><span class="o">,</span> <span class="n">rhs</span><span class="o">)</span> <span class="k">in</span>
        <span class="n">parse_bin_rhs</span> <span class="n">expr_prec</span> <span class="n">lhs</span> <span class="n">stream</span>
      <span class="k">end</span>
  <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="n">lhs</span>

<span class="c">(* expression</span>
<span class="c"> *   ::= primary binoprhs *)</span>
<span class="ow">and</span> <span class="n">parse_expr</span> <span class="o">=</span> <span class="n">parser</span>
  <span class="o">|</span> <span class="o">[&lt;</span> <span class="n">lhs</span><span class="o">=</span><span class="n">parse_primary</span><span class="o">;</span> <span class="n">stream</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span> <span class="n">parse_bin_rhs</span> <span class="mi">0</span> <span class="n">lhs</span> <span class="n">stream</span>

<span class="c">(* prototype</span>
<span class="c"> *   ::= id &#39;(&#39; id* &#39;)&#39; *)</span>
<span class="k">let</span> <span class="n">parse_prototype</span> <span class="o">=</span>
  <span class="k">let</span> <span class="k">rec</span> <span class="n">parse_args</span> <span class="n">accumulator</span> <span class="o">=</span> <span class="n">parser</span>
    <span class="o">|</span> <span class="o">[&lt;</span> <span class="k">&#39;</span><span class="nn">Token</span><span class="p">.</span><span class="nc">Ident</span> <span class="n">id</span><span class="o">;</span> <span class="n">e</span><span class="o">=</span><span class="n">parse_args</span> <span class="o">(</span><span class="n">id</span><span class="o">::</span><span class="n">accumulator</span><span class="o">)</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span> <span class="n">e</span>
    <span class="o">|</span> <span class="o">[&lt;</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span> <span class="n">accumulator</span>
  <span class="k">in</span>

  <span class="n">parser</span>
  <span class="o">|</span> <span class="o">[&lt;</span> <span class="k">&#39;</span><span class="nn">Token</span><span class="p">.</span><span class="nc">Ident</span> <span class="n">id</span><span class="o">;</span>
       <span class="k">&#39;</span><span class="nn">Token</span><span class="p">.</span><span class="nc">Kwd</span> <span class="sc">&#39;(&#39;</span> <span class="o">??</span> <span class="s2">&quot;expected &#39;(&#39; in prototype&quot;</span><span class="o">;</span>
       <span class="n">args</span><span class="o">=</span><span class="n">parse_args</span> <span class="bp">[]</span><span class="o">;</span>
       <span class="k">&#39;</span><span class="nn">Token</span><span class="p">.</span><span class="nc">Kwd</span> <span class="sc">&#39;)&#39;</span> <span class="o">??</span> <span class="s2">&quot;expected &#39;)&#39; in prototype&quot;</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span>
      <span class="c">(* success. *)</span>
      <span class="nn">Ast</span><span class="p">.</span><span class="nc">Prototype</span> <span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="nn">Array</span><span class="p">.</span><span class="n">of_list</span> <span class="o">(</span><span class="nn">List</span><span class="p">.</span><span class="n">rev</span> <span class="n">args</span><span class="o">))</span>

  <span class="o">|</span> <span class="o">[&lt;</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span>
      <span class="k">raise</span> <span class="o">(</span><span class="nn">Stream</span><span class="p">.</span><span class="nc">Error</span> <span class="s2">&quot;expected function name in prototype&quot;</span><span class="o">)</span>

<span class="c">(* definition ::= &#39;def&#39; prototype expression *)</span>
<span class="k">let</span> <span class="n">parse_definition</span> <span class="o">=</span> <span class="n">parser</span>
  <span class="o">|</span> <span class="o">[&lt;</span> <span class="k">&#39;</span><span class="nn">Token</span><span class="p">.</span><span class="nc">Def</span><span class="o">;</span> <span class="n">p</span><span class="o">=</span><span class="n">parse_prototype</span><span class="o">;</span> <span class="n">e</span><span class="o">=</span><span class="n">parse_expr</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span>
      <span class="nn">Ast</span><span class="p">.</span><span class="nc">Function</span> <span class="o">(</span><span class="n">p</span><span class="o">,</span> <span class="n">e</span><span class="o">)</span>

<span class="c">(* toplevelexpr ::= expression *)</span>
<span class="k">let</span> <span class="n">parse_toplevel</span> <span class="o">=</span> <span class="n">parser</span>
  <span class="o">|</span> <span class="o">[&lt;</span> <span class="n">e</span><span class="o">=</span><span class="n">parse_expr</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span>
      <span class="c">(* Make an anonymous proto. *)</span>
      <span class="nn">Ast</span><span class="p">.</span><span class="nc">Function</span> <span class="o">(</span><span class="nn">Ast</span><span class="p">.</span><span class="nc">Prototype</span> <span class="o">(</span><span class="s2">&quot;&quot;</span><span class="o">,</span> <span class="o">[||]),</span> <span class="n">e</span><span class="o">)</span>

<span class="c">(*  external ::= &#39;extern&#39; prototype *)</span>
<span class="k">let</span> <span class="n">parse_extern</span> <span class="o">=</span> <span class="n">parser</span>
  <span class="o">|</span> <span class="o">[&lt;</span> <span class="k">&#39;</span><span class="nn">Token</span><span class="p">.</span><span class="nc">Extern</span><span class="o">;</span> <span class="n">e</span><span class="o">=</span><span class="n">parse_prototype</span> <span class="o">&gt;]</span> <span class="o">-&gt;</span> <span class="n">e</span>
</pre></div>
</div>
</dd>
<dt>toplevel.ml:</dt>
<dd><div class="first last highlight-ocaml"><div class="highlight"><pre><span></span><span class="c">(*===----------------------------------------------------------------------===</span>
<span class="c"> * Top-Level parsing and JIT Driver</span>
<span class="c"> *===----------------------------------------------------------------------===*)</span>

<span class="c">(* top ::= definition | external | expression | &#39;;&#39; *)</span>
<span class="k">let</span> <span class="k">rec</span> <span class="n">main_loop</span> <span class="n">stream</span> <span class="o">=</span>
  <span class="k">match</span> <span class="nn">Stream</span><span class="p">.</span><span class="n">peek</span> <span class="n">stream</span> <span class="k">with</span>
  <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="bp">()</span>

  <span class="c">(* ignore top-level semicolons. *)</span>
  <span class="o">|</span> <span class="nc">Some</span> <span class="o">(</span><span class="nn">Token</span><span class="p">.</span><span class="nc">Kwd</span> <span class="sc">&#39;;&#39;</span><span class="o">)</span> <span class="o">-&gt;</span>
      <span class="nn">Stream</span><span class="p">.</span><span class="n">junk</span> <span class="n">stream</span><span class="o">;</span>
      <span class="n">main_loop</span> <span class="n">stream</span>

  <span class="o">|</span> <span class="nc">Some</span> <span class="n">token</span> <span class="o">-&gt;</span>
      <span class="k">begin</span>
        <span class="k">try</span> <span class="k">match</span> <span class="n">token</span> <span class="k">with</span>
        <span class="o">|</span> <span class="nn">Token</span><span class="p">.</span><span class="nc">Def</span> <span class="o">-&gt;</span>
            <span class="n">ignore</span><span class="o">(</span><span class="nn">Parser</span><span class="p">.</span><span class="n">parse_definition</span> <span class="n">stream</span><span class="o">);</span>
            <span class="n">print_endline</span> <span class="s2">&quot;parsed a function definition.&quot;</span><span class="o">;</span>
        <span class="o">|</span> <span class="nn">Token</span><span class="p">.</span><span class="nc">Extern</span> <span class="o">-&gt;</span>
            <span class="n">ignore</span><span class="o">(</span><span class="nn">Parser</span><span class="p">.</span><span class="n">parse_extern</span> <span class="n">stream</span><span class="o">);</span>
            <span class="n">print_endline</span> <span class="s2">&quot;parsed an extern.&quot;</span><span class="o">;</span>
        <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span>
            <span class="c">(* Evaluate a top-level expression into an anonymous function. *)</span>
            <span class="n">ignore</span><span class="o">(</span><span class="nn">Parser</span><span class="p">.</span><span class="n">parse_toplevel</span> <span class="n">stream</span><span class="o">);</span>
            <span class="n">print_endline</span> <span class="s2">&quot;parsed a top-level expr&quot;</span><span class="o">;</span>
        <span class="k">with</span> <span class="nn">Stream</span><span class="p">.</span><span class="nc">Error</span> <span class="n">s</span> <span class="o">-&gt;</span>
          <span class="c">(* Skip token for error recovery. *)</span>
          <span class="nn">Stream</span><span class="p">.</span><span class="n">junk</span> <span class="n">stream</span><span class="o">;</span>
          <span class="n">print_endline</span> <span class="n">s</span><span class="o">;</span>
      <span class="k">end</span><span class="o">;</span>
      <span class="n">print_string</span> <span class="s2">&quot;ready&gt; &quot;</span><span class="o">;</span> <span class="n">flush</span> <span class="n">stdout</span><span class="o">;</span>
      <span class="n">main_loop</span> <span class="n">stream</span>
</pre></div>
</div>
</dd>
<dt>toy.ml:</dt>
<dd><div class="first last highlight-ocaml"><div class="highlight"><pre><span></span><span class="c">(*===----------------------------------------------------------------------===</span>
<span class="c"> * Main driver code.</span>
<span class="c"> *===----------------------------------------------------------------------===*)</span>

<span class="k">let</span> <span class="n">main</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="c">(* Install standard binary operators.</span>
<span class="c">   * 1 is the lowest precedence. *)</span>
  <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">add</span> <span class="nn">Parser</span><span class="p">.</span><span class="n">binop_precedence</span> <span class="sc">&#39;&lt;&#39;</span> <span class="mi">10</span><span class="o">;</span>
  <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">add</span> <span class="nn">Parser</span><span class="p">.</span><span class="n">binop_precedence</span> <span class="sc">&#39;+&#39;</span> <span class="mi">20</span><span class="o">;</span>
  <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">add</span> <span class="nn">Parser</span><span class="p">.</span><span class="n">binop_precedence</span> <span class="sc">&#39;-&#39;</span> <span class="mi">20</span><span class="o">;</span>
  <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">add</span> <span class="nn">Parser</span><span class="p">.</span><span class="n">binop_precedence</span> <span class="sc">&#39;*&#39;</span> <span class="mi">40</span><span class="o">;</span>    <span class="c">(* highest. *)</span>

  <span class="c">(* Prime the first token. *)</span>
  <span class="n">print_string</span> <span class="s2">&quot;ready&gt; &quot;</span><span class="o">;</span> <span class="n">flush</span> <span class="n">stdout</span><span class="o">;</span>
  <span class="k">let</span> <span class="n">stream</span> <span class="o">=</span> <span class="nn">Lexer</span><span class="p">.</span><span class="n">lex</span> <span class="o">(</span><span class="nn">Stream</span><span class="p">.</span><span class="n">of_channel</span> <span class="n">stdin</span><span class="o">)</span> <span class="k">in</span>

  <span class="c">(* Run the main &quot;interpreter loop&quot; now. *)</span>
  <span class="nn">Toplevel</span><span class="p">.</span><span class="n">main_loop</span> <span class="n">stream</span><span class="o">;</span>
<span class="o">;;</span>

<span class="n">main</span> <span class="bp">()</span>
</pre></div>
</div>
</dd>
</dl>
<p><a class="reference external" href="OCamlLangImpl3.html">Next: Implementing Code Generation to LLVM IR</a></p>
</div>
</div>


          </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="OCamlLangImpl3.html" title="3. Kaleidoscope: Code generation to LLVM IR"
             >next</a> |</li>
        <li class="right" >
          <a href="OCamlLangImpl1.html" title="1. Kaleidoscope: Tutorial Introduction and the Lexer"
             >previous</a> |</li>
  <li><a href="http://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="../index.html">Documentation</a>&raquo;</li>

          <li class="nav-item nav-item-1"><a href="index.html" >LLVM Tutorial: Table of Contents</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2003-2019, LLVM Project.
      Last updated on Wed Feb 13 10:08:12 2019 -0800.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.1.
    </div>
  </body>
</html>