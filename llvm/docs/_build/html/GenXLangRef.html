

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>LLVM IR for the GenX backend &#8212; LLVM 6 documentation</title>
    
    <link rel="stylesheet" href="_static/llvm-theme.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '6',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="LLVM Code Coverage Mapping Format" href="CoverageMappingFormat.html" />
    <link rel="prev" title="GenX backend design" href="GenXDesign.html" />
<style type="text/css">
  table.right { float: right; margin-left: 20px; }
  table.right td { border: 1px solid #ccc; }
</style>

  </head>
  <body>
<div class="logo">
  <a href="index.html">
    <img src="_static/logo.png"
         alt="LLVM Logo" width="250" height="88"/></a>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="CoverageMappingFormat.html" title="LLVM Code Coverage Mapping Format"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="GenXDesign.html" title="GenX backend design"
             accesskey="P">previous</a> |</li>
  <li><a href="http://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="index.html">Documentation</a>&raquo;</li>

          <li class="nav-item nav-item-1"><a href="GenXIndex.html" accesskey="U">GenX backend documentation</a> &#187;</li> 
      </ul>
    </div>


    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <div class="section" id="llvm-ir-for-the-genx-backend">
<h1>LLVM IR for the GenX backend<a class="headerlink" href="#llvm-ir-for-the-genx-backend" title="Permalink to this headline">¶</a></h1>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><a class="reference internal" href="#introduction" id="id3">Introduction</a></li>
<li><a class="reference internal" href="#llvm-ir-representation-of-eu-code" id="id4">LLVM IR representation of EU code</a><ul>
<li><a class="reference internal" href="#whole-thread-representation" id="id5">Whole thread representation</a></li>
<li><a class="reference internal" href="#linkage" id="id6">Linkage</a></li>
<li><a class="reference internal" href="#kernel-information" id="id7">Kernel information</a></li>
<li><a class="reference internal" href="#types" id="id8">Types</a></li>
<li><a class="reference internal" href="#arithmetic-logic-operator" id="id9">Arithmetic/logic operator</a></li>
<li><a class="reference internal" href="#load-and-store" id="id10">Load and store</a></li>
</ul>
</li>
<li><a class="reference internal" href="#vector-regions" id="id11">Vector regions</a><ul>
<li><a class="reference internal" href="#introduction-to-region-based-addressing" id="id12">Introduction to region-based addressing</a><ul>
<li><a class="reference internal" href="#d-region" id="id13">1D region</a></li>
<li><a class="reference internal" href="#id1" id="id14">2D region</a></li>
<li><a class="reference internal" href="#notes" id="id15">Notes</a></li>
</ul>
</li>
<li><a class="reference internal" href="#region-access-in-llvm-ir" id="id16">Region access in LLVM IR</a><ul>
<li><a class="reference internal" href="#reading-a-region" id="id17">Reading a region</a></li>
<li><a class="reference internal" href="#writing-a-region" id="id18">Writing a region</a></li>
<li><a class="reference internal" href="#the-mask-operand" id="id19">The mask operand</a></li>
<li><a class="reference internal" href="#single-element-region" id="id20">Single element region</a></li>
<li><a class="reference internal" href="#the-parent-width-operand" id="id21">The parent width operand</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#predicates-and-predication" id="id22">Predicates and predication</a></li>
<li><a class="reference internal" href="#non-genx-intrinsics" id="id23">Non-GenX intrinsics</a></li>
<li><a class="reference internal" href="#genx-intrinsics" id="id24">GenX intrinsics</a><ul>
<li><a class="reference internal" href="#region-element-access-intrinsics" id="id25">Region/element access intrinsics</a><ul>
<li><a class="reference internal" href="#llvm-genx-rdregion-read-a-region-direct-or-single-indirect" id="id26"><code class="docutils literal"><span class="pre">llvm.genx.rdregion*</span></code> : read a region, direct or single-indirect</a></li>
<li><a class="reference internal" href="#llvm-genx-wrregion-write-a-region-direct-or-single-indirect" id="id27"><code class="docutils literal"><span class="pre">llvm.genx.wrregion*</span></code> : write a region, direct or single-indirect</a></li>
<li><a class="reference internal" href="#llvm-genx-vstore-store-a-vector-value-into-memory" id="id28"><code class="docutils literal"><span class="pre">llvm.genx.vstore</span></code> : store a vector value into memory</a></li>
<li><a class="reference internal" href="#llvm-genx-vload-load-a-vector-value-from-memory" id="id29"><code class="docutils literal"><span class="pre">llvm.genx.vload</span></code> : load a vector value from memory</a></li>
</ul>
</li>
<li><a class="reference internal" href="#alu-type-conversion-intrinsics" id="id30">ALU type conversion intrinsics</a><ul>
<li><a class="reference internal" href="#llvm-genx-fptosi-sat-convert-floating-point-to-signed-integer-with-saturate" id="id31"><code class="docutils literal"><span class="pre">llvm.genx.fptosi.sat</span></code> : convert floating point to signed integer with saturate</a></li>
<li><a class="reference internal" href="#llvm-genx-fptoui-sat-convert-floating-point-to-unsigned-integer-with-saturate" id="id32"><code class="docutils literal"><span class="pre">llvm.genx.fptoui.sat</span></code> : convert floating point to unsigned integer with saturate</a></li>
<li><a class="reference internal" href="#llvm-genx-sat-floating-point-saturate" id="id33"><code class="docutils literal"><span class="pre">llvm.genx.sat</span></code> : floating point saturate</a></li>
<li><a class="reference internal" href="#llvm-genx-trunc-sat-integer-truncation-with-saturation" id="id34"><code class="docutils literal"><span class="pre">llvm.genx.*trunc.sat</span></code> : integer truncation with saturation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#modifier-intrinsics" id="id35">Modifier intrinsics</a><ul>
<li><a class="reference internal" href="#llvm-genx-abs-take-absolute-value" id="id36"><code class="docutils literal"><span class="pre">llvm.genx.abs*</span></code> : take absolute value</a></li>
</ul>
</li>
<li><a class="reference internal" href="#boolean-reduction-intrinsics" id="id37">Boolean reduction intrinsics</a><ul>
<li><a class="reference internal" href="#llvm-genx-all-true-if-all-input-elements-are-true" id="id38"><code class="docutils literal"><span class="pre">llvm.genx.all</span></code> : true if all input elements are true</a></li>
<li><a class="reference internal" href="#llvm-genx-any-true-if-any-input-element-is-true" id="id39"><code class="docutils literal"><span class="pre">llvm.genx.any</span></code> : true if any input element is true</a></li>
</ul>
</li>
<li><a class="reference internal" href="#simd-control-flow-intrinsics" id="id40">SIMD control flow intrinsics</a><ul>
<li><a class="reference internal" href="#the-bspec-model" id="id41">The BSpec model</a></li>
<li><a class="reference internal" href="#the-llvm-ir-model" id="id42">The LLVM IR model</a></li>
<li><a class="reference internal" href="#llvm-genx-simdcf-goto-goto-instruction" id="id43"><code class="docutils literal"><span class="pre">llvm.genx.simdcf.goto</span></code> : goto instruction</a></li>
<li><a class="reference internal" href="#llvm-genx-simdcf-join-join-instruction" id="id44"><code class="docutils literal"><span class="pre">llvm.genx.simdcf.join</span></code> : join instruction</a></li>
</ul>
</li>
<li><a class="reference internal" href="#alu-intrinsics" id="id45">ALU intrinsics</a><ul>
<li><a class="reference internal" href="#add" id="id46">add</a></li>
<li><a class="reference internal" href="#llvm-genx-add-sat-add-instruction-with-saturation" id="id47"><code class="docutils literal"><span class="pre">llvm.genx.*add.sat</span></code> : add instruction with saturation</a></li>
<li><a class="reference internal" href="#addc" id="id48">addc</a></li>
<li><a class="reference internal" href="#asr" id="id49">asr</a></li>
<li><a class="reference internal" href="#llvm-genx-avg-integer-averaging-no-saturation" id="id50"><code class="docutils literal"><span class="pre">llvm.genx.*avg</span></code> : integer averaging, no saturation</a></li>
<li><a class="reference internal" href="#llvm-genx-avg-sat-integer-averaging-with-saturation" id="id51"><code class="docutils literal"><span class="pre">llvm.genx.*avg.sat</span></code> : integer averaging with saturation</a></li>
<li><a class="reference internal" href="#llvm-genx-bfe-bitfield-extract" id="id52"><code class="docutils literal"><span class="pre">llvm.genx.*bfe</span></code> : bitfield extract</a></li>
<li><a class="reference internal" href="#llvm-genx-bfi-bitfield-insert" id="id53"><code class="docutils literal"><span class="pre">llvm.genx.bfi</span></code> : bitfield insert</a></li>
<li><a class="reference internal" href="#llvm-genx-bfrev-reverse-bits" id="id54"><code class="docutils literal"><span class="pre">llvm.genx.bfrev</span></code> : reverse bits</a></li>
<li><a class="reference internal" href="#llvm-genx-cbit-count-set-bits" id="id55"><code class="docutils literal"><span class="pre">llvm.genx.cbit</span></code> : count set bits</a></li>
<li><a class="reference internal" href="#cmp" id="id56">cmp</a></li>
<li><a class="reference internal" href="#llvm-genx-cos-cos-instruction" id="id57"><code class="docutils literal"><span class="pre">llvm.genx.cos</span></code> : cos instruction</a></li>
<li><a class="reference internal" href="#div" id="id58">div</a></li>
<li><a class="reference internal" href="#llvm-genx-ieee-div-divide-ieee-variant" id="id59"><code class="docutils literal"><span class="pre">llvm.genx.ieee.div</span></code> : Divide, IEEE variant</a></li>
<li><a class="reference internal" href="#llvm-genx-dp2-dp2-instruction-dot-product-on-groups-of-4-elements" id="id60"><code class="docutils literal"><span class="pre">llvm.genx.dp2</span></code> : dp2 instruction (dot product on groups of 4 elements)</a></li>
<li><a class="reference internal" href="#llvm-genx-dp3-dp3-instruction-dot-product-on-groups-of-3-elements" id="id61"><code class="docutils literal"><span class="pre">llvm.genx.dp3</span></code> : dp3 instruction (dot product on groups of 3 elements)</a></li>
<li><a class="reference internal" href="#llvm-genx-dp4-dp4-instruction-dot-product-on-groups-of-4-elements" id="id62"><code class="docutils literal"><span class="pre">llvm.genx.dp4</span></code> : dp4 instruction (dot product on groups of 4 elements)</a></li>
<li><a class="reference internal" href="#llvm-genx-dph-dph-instruction-dot-product-homogenous" id="id63"><code class="docutils literal"><span class="pre">llvm.genx.dph</span></code> : dph instruction (dot product homogenous)</a></li>
<li><a class="reference internal" href="#llvm-genx-exp-base-2-exponent" id="id64"><code class="docutils literal"><span class="pre">llvm.genx.exp</span></code> : base 2 exponent</a></li>
<li><a class="reference internal" href="#llvm-genx-fbh-find-bit-high" id="id65"><code class="docutils literal"><span class="pre">llvm.genx.*fbh</span></code> : find bit high</a></li>
<li><a class="reference internal" href="#llvm-genx-fbl-find-bit-low" id="id66"><code class="docutils literal"><span class="pre">llvm.genx.fbl</span></code> : find bit low</a></li>
<li><a class="reference internal" href="#llvm-genx-frc-fractional-part" id="id67"><code class="docutils literal"><span class="pre">llvm.genx.frc</span></code> : fractional part</a></li>
<li><a class="reference internal" href="#llvm-genx-inv-reciprocal" id="id68"><code class="docutils literal"><span class="pre">llvm.genx.inv</span></code> : reciprocal</a></li>
<li><a class="reference internal" href="#llvm-genx-line-linear-equation" id="id69"><code class="docutils literal"><span class="pre">llvm.genx.line</span></code> : linear equation</a></li>
<li><a class="reference internal" href="#llvm-genx-log-base-2-logarithm" id="id70"><code class="docutils literal"><span class="pre">llvm.genx.log</span></code> : base 2 logarithm</a></li>
<li><a class="reference internal" href="#llvm-genx-lrp-linear-interpolation" id="id71"><code class="docutils literal"><span class="pre">llvm.genx.lrp</span></code> : linear interpolation</a></li>
<li><a class="reference internal" href="#llvm-genx-lzd-leading-zero-detection" id="id72"><code class="docutils literal"><span class="pre">llvm.genx.lzd</span></code> : leading zero detection</a></li>
<li><a class="reference internal" href="#llvm-genx-mad-mad-instruction-no-saturation" id="id73"><code class="docutils literal"><span class="pre">llvm.genx.*mad</span></code> : mad instruction, no saturation</a></li>
<li><a class="reference internal" href="#llvm-genx-mad-sat-mad-instruction-with-saturation" id="id74"><code class="docutils literal"><span class="pre">llvm.genx.*mad.sat</span></code> : mad instruction with saturation</a></li>
<li><a class="reference internal" href="#llvm-genx-max-max-instruction" id="id75"><code class="docutils literal"><span class="pre">llvm.genx.*max</span></code> : max instruction</a></li>
<li><a class="reference internal" href="#llvm-genx-min-min-instruction" id="id76"><code class="docutils literal"><span class="pre">llvm.genx.*min</span></code> : min instruction</a></li>
<li><a class="reference internal" href="#mod" id="id77">mod</a></li>
<li><a class="reference internal" href="#mul" id="id78">mul</a></li>
<li><a class="reference internal" href="#llvm-genx-mul-mul-instruction-no-saturation" id="id79"><code class="docutils literal"><span class="pre">llvm.genx.*mul</span></code> : mul instruction, no saturation</a></li>
<li><a class="reference internal" href="#llvm-genx-mul-sat-mul-instruction-with-saturation" id="id80"><code class="docutils literal"><span class="pre">llvm.genx.*mul.sat</span></code> : mul instruction with saturation</a></li>
<li><a class="reference internal" href="#llvm-genx-mulh-mulh-instruction-no-saturation" id="id81"><code class="docutils literal"><span class="pre">llvm.genx.*mulh</span></code> : mulh instruction, no saturation</a></li>
<li><a class="reference internal" href="#not" id="id82">not</a></li>
<li><a class="reference internal" href="#or" id="id83">or</a></li>
<li><a class="reference internal" href="#llvm-genx-pln-plane-equation" id="id84"><code class="docutils literal"><span class="pre">llvm.genx.pln</span></code> : plane equation</a></li>
<li><a class="reference internal" href="#llvm-genx-pow-power" id="id85"><code class="docutils literal"><span class="pre">llvm.genx.pow</span></code> : power</a></li>
<li><a class="reference internal" href="#llvm-genx-rndd-round-down" id="id86"><code class="docutils literal"><span class="pre">llvm.genx.rndd</span></code> : round down</a></li>
<li><a class="reference internal" href="#llvm-genx-rnde-round-to-even" id="id87"><code class="docutils literal"><span class="pre">llvm.genx.rnde</span></code> : round to even</a></li>
<li><a class="reference internal" href="#llvm-genx-rndu-round-up" id="id88"><code class="docutils literal"><span class="pre">llvm.genx.rndu</span></code> : round up</a></li>
<li><a class="reference internal" href="#llvm-genx-rndz-round-to-zero" id="id89"><code class="docutils literal"><span class="pre">llvm.genx.rndz</span></code> : round to zero</a></li>
<li><a class="reference internal" href="#llvm-genx-rsqrt-reciprocal-square-root" id="id90"><code class="docutils literal"><span class="pre">llvm.genx.rsqrt</span></code> : reciprocal square root</a></li>
<li><a class="reference internal" href="#llvm-genx-sad2-two-wide-sum-of-absolute-differences" id="id91"><code class="docutils literal"><span class="pre">llvm.genx.*sad2</span></code> : two-wide sum of absolute differences</a></li>
<li><a class="reference internal" href="#llvm-genx-sad2add-two-wide-sum-of-absolute-differences-and-add" id="id92"><code class="docutils literal"><span class="pre">llvm.genx.*sad2add</span></code> : two-wide sum of absolute differences and add</a></li>
<li><a class="reference internal" href="#llvm-genx-sad2add-sat-two-wide-sum-of-absolute-differences-and-add-saturated" id="id93"><code class="docutils literal"><span class="pre">llvm.genx.*sad2add.sat</span></code> : two-wide sum of absolute differences and add, saturated</a></li>
<li><a class="reference internal" href="#llvm-genx-shl-shl-instruction-no-saturation" id="id94"><code class="docutils literal"><span class="pre">llvm.genx.*shl</span></code> : shl instruction, no saturation</a></li>
<li><a class="reference internal" href="#llvm-genx-shl-sat-shl-instruction-with-saturation" id="id95"><code class="docutils literal"><span class="pre">llvm.genx.*shl.sat</span></code> : shl instruction with saturation</a></li>
<li><a class="reference internal" href="#shr" id="id96">shr</a></li>
<li><a class="reference internal" href="#llvm-genx-sin-reciprocal-square-root" id="id97"><code class="docutils literal"><span class="pre">llvm.genx.sin</span></code> : reciprocal square root</a></li>
<li><a class="reference internal" href="#llvm-genx-sqrt-reciprocal-square-root" id="id98"><code class="docutils literal"><span class="pre">llvm.genx.sqrt</span></code> : reciprocal square root</a></li>
<li><a class="reference internal" href="#llvm-genx-ieee-sqrt-reciprocal-square-root-ieee-variant" id="id99"><code class="docutils literal"><span class="pre">llvm.genx.ieee.sqrt</span></code> : reciprocal square root, IEEE variant</a></li>
<li><a class="reference internal" href="#subb" id="id100">subb</a></li>
<li><a class="reference internal" href="#xor" id="id101">xor</a></li>
</ul>
</li>
<li><a class="reference internal" href="#visa-reserved-register-intrinsics" id="id102">vISA reserved register intrinsics</a><ul>
<li><a class="reference internal" href="#llvm-genx-thread-read-thread-id-register" id="id103"><code class="docutils literal"><span class="pre">llvm.genx.thread.*</span></code> : read thread ID register</a></li>
<li><a class="reference internal" href="#llvm-genx-group-id-read-group-id-register" id="id104"><code class="docutils literal"><span class="pre">llvm.genx.group.id.*</span></code> : read group ID register</a></li>
<li><a class="reference internal" href="#llvm-genx-timestamp-read-visa-v11-timestamp" id="id105"><code class="docutils literal"><span class="pre">llvm.genx.timestamp</span></code> : read vISA v11 (%timestamp)</a></li>
<li><a class="reference internal" href="#llvm-genx-r0-read-visa-v12-r0" id="id106"><code class="docutils literal"><span class="pre">llvm.genx.r0</span></code> : read vISA v12 (%r0)</a></li>
<li><a class="reference internal" href="#llvm-genx-sr0-read-visa-v18-sr0" id="id107"><code class="docutils literal"><span class="pre">llvm.genx.sr0</span></code> : read vISA v18 (%sr0)</a></li>
<li><a class="reference internal" href="#llvm-genx-get-color-read-color-value-of-the-thread-origin" id="id108"><code class="docutils literal"><span class="pre">llvm.genx.get.color</span></code> : read color value of the thread origin</a></li>
<li><a class="reference internal" href="#llvm-genx-get-hwid-read-hw-id-value" id="id109"><code class="docutils literal"><span class="pre">llvm.genx.get.hwid</span></code> : read hw_id value</a></li>
<li><a class="reference internal" href="#llvm-genx-set-pause-set-the-pause-register-v11-4" id="id110"><code class="docutils literal"><span class="pre">llvm.genx.set.pause</span></code> : set the pause register (v11.4)</a></li>
<li><a class="reference internal" href="#llvm-genx-dummy-mov-insert-a-dummy-mov-to-v0" id="id111"><code class="docutils literal"><span class="pre">llvm.genx.dummy.mov</span></code> : insert a dummy mov to v0</a></li>
</ul>
</li>
<li><a class="reference internal" href="#shared-function-intrinsics" id="id112">Shared function intrinsics</a><ul>
<li><a class="reference internal" href="#llvm-genx-dword-atomic-dword-atomic-with-binary-operator" id="id113"><code class="docutils literal"><span class="pre">llvm.genx.dword.atomic.*</span></code> : dword atomic with binary operator</a></li>
<li><a class="reference internal" href="#llvm-genx-dword-atomic-dword-atomic-with-fmin-fmax-operation" id="id114"><code class="docutils literal"><span class="pre">llvm.genx.dword.atomic.*</span></code> : dword atomic with fmin/fmax operation</a></li>
<li><a class="reference internal" href="#llvm-genx-dword-atomic-dword-atomic-with-inc-dec-operation" id="id115"><code class="docutils literal"><span class="pre">llvm.genx.dword.atomic.*</span></code> : dword atomic with inc/dec operation</a></li>
<li><a class="reference internal" href="#llvm-genx-dword-atomic-cmpxchg-visa-dword-atomic-cmpxchg-instruction" id="id116"><code class="docutils literal"><span class="pre">llvm.genx.dword.atomic.cmpxchg</span></code> : vISA DWORD_ATOMIC CMPXCHG instruction</a></li>
<li><a class="reference internal" href="#llvm-genx-dword-atomic-fcmpwr-visa-dword-atomic-fcmpwr-instruction" id="id117"><code class="docutils literal"><span class="pre">llvm.genx.dword.atomic.fcmpwr</span></code> : vISA DWORD_ATOMIC FCMPWR instruction</a></li>
<li><a class="reference internal" href="#llvm-genx-typed-atomic-atomic-typed-with-binary-operator" id="id118"><code class="docutils literal"><span class="pre">llvm.genx.typed.atomic.*</span></code> : atomic typed with binary operator</a></li>
<li><a class="reference internal" href="#llvm-genx-typed-atomic-atomic-typed-with-fmin-fmax-operation" id="id119"><code class="docutils literal"><span class="pre">llvm.genx.typed.atomic.*</span></code> : atomic typed with fmin/fmax operation</a></li>
<li><a class="reference internal" href="#llvm-genx-typed-atomic-atomic-typed-with-inc-dec-operation" id="id120"><code class="docutils literal"><span class="pre">llvm.genx.typed.atomic.*</span></code> : atomic typed with inc/dec operation</a></li>
<li><a class="reference internal" href="#llvm-genx-typed-atomic-cmpxchg-visa-typed-atomic-cmpxchg-instruction" id="id121"><code class="docutils literal"><span class="pre">llvm.genx.typed.atomic.cmpxchg</span></code> : vISA TYPED_ATOMIC CMPXCHG instruction</a></li>
<li><a class="reference internal" href="#llvm-genx-typed-atomic-fcmpwr-visa-typed-atomic-fcmpwr-instruction" id="id122"><code class="docutils literal"><span class="pre">llvm.genx.typed.atomic.fcmpwr</span></code> : vISA TYPED_ATOMIC FCMPWR instruction</a></li>
<li><a class="reference internal" href="#llvm-genx-gather-orig-visa-gather-instruction" id="id123"><code class="docutils literal"><span class="pre">llvm.genx.gather.orig</span></code> : vISA GATHER instruction</a></li>
<li><a class="reference internal" href="#llvm-genx-gather-scaled-visa-gather-scaled-instruction" id="id124"><code class="docutils literal"><span class="pre">llvm.genx.gather.scaled</span></code> : vISA GATHER_SCALED instruction</a></li>
<li><a class="reference internal" href="#llvm-genx-gather4-orig-visa-gather4-instruction" id="id125"><code class="docutils literal"><span class="pre">llvm.genx.gather4.orig</span></code> : vISA GATHER4 instruction</a></li>
<li><a class="reference internal" href="#llvm-genx-gather4-scaled-visa-gather4-scaled-instruction" id="id126"><code class="docutils literal"><span class="pre">llvm.genx.gather4.scaled</span></code> : vISA GATHER4_SCALED instruction</a></li>
<li><a class="reference internal" href="#llvm-genx-gather4-typed-visa-gather4-typed-instruction" id="id127"><code class="docutils literal"><span class="pre">llvm.genx.gather4.typed</span></code> : vISA GATHER4_TYPED instruction</a></li>
<li><a class="reference internal" href="#llvm-genx-media-ld-visa-media-ld-instruction" id="id128"><code class="docutils literal"><span class="pre">llvm.genx.media.ld</span></code> : vISA MEDIA_LD instruction</a></li>
<li><a class="reference internal" href="#llvm-genx-media-st-visa-media-st-instruction" id="id129"><code class="docutils literal"><span class="pre">llvm.genx.media.st</span></code> : vISA MEDIA_ST instruction</a></li>
<li><a class="reference internal" href="#llvm-genx-oword-ld-oword-load-instruction" id="id130"><code class="docutils literal"><span class="pre">llvm.genx.oword.ld*</span></code> : oword load instruction</a></li>
<li><a class="reference internal" href="#llvm-genx-oword-st-visa-oword-st-instruction" id="id131"><code class="docutils literal"><span class="pre">llvm.genx.oword.st</span></code> : vISA OWORD_ST instruction</a></li>
<li><a class="reference internal" href="#llvm-genx-scatter-orig-visa-scatter-instruction" id="id132"><code class="docutils literal"><span class="pre">llvm.genx.scatter.orig</span></code> : vISA SCATTER instruction</a></li>
<li><a class="reference internal" href="#llvm-genx-scatter-scaled-visa-scatter-scaled-instruction" id="id133"><code class="docutils literal"><span class="pre">llvm.genx.scatter.scaled</span></code> : vISA SCATTER_SCALED instruction</a></li>
<li><a class="reference internal" href="#llvm-genx-scatter4-orig-visa-scatter4-instruction" id="id134"><code class="docutils literal"><span class="pre">llvm.genx.scatter4.orig</span></code> : vISA SCATTER4 instruction</a></li>
<li><a class="reference internal" href="#llvm-genx-scatter4-scaled-visa-scatter4-scaled-instruction" id="id135"><code class="docutils literal"><span class="pre">llvm.genx.scatter4.scaled</span></code> : vISA SCATTER4_SCALED instruction</a></li>
<li><a class="reference internal" href="#llvm-genx-scatter4-typed-visa-scatter4-typed-instruction" id="id136"><code class="docutils literal"><span class="pre">llvm.genx.scatter4.typed</span></code> : vISA SCATTER4_TYPED instruction</a></li>
<li><a class="reference internal" href="#llvm-genx-transpose-ld-visa-transpose-ld-instruction" id="id137"><code class="docutils literal"><span class="pre">llvm.genx.transpose.ld</span></code> : vISA TRANSPOSE_LD instruction</a></li>
<li><a class="reference internal" href="#llvm-genx-untyped-atomic-visa-untyped-atomic-with-binary-operator" id="id138"><code class="docutils literal"><span class="pre">llvm.genx.untyped.atomic.*</span></code> : vISA UNTYPED_ATOMIC with binary operator</a></li>
<li><a class="reference internal" href="#llvm-genx-untyped-atomic-visa-untyped-atomic-with-inc-dec" id="id139"><code class="docutils literal"><span class="pre">llvm.genx.untyped.atomic.*</span></code> : vISA UNTYPED_ATOMIC with inc/dec</a></li>
<li><a class="reference internal" href="#llvm-genx-untyped-atomic-cmpxchg-visa-untyped-atomic-cmpxchg-instruction" id="id140"><code class="docutils literal"><span class="pre">llvm.genx.untyped.atomic.cmpxchg</span></code> : vISA UNTYPED_ATOMIC CMPXCHG instruction</a></li>
<li><a class="reference internal" href="#llvm-genx-svm-block-ld-visa-svm-block-ld-instruction" id="id141"><code class="docutils literal"><span class="pre">llvm.genx.svm.block.ld*</span></code> : vISA SVM BLOCK_LD instruction</a></li>
<li><a class="reference internal" href="#llvm-genx-svm-block-st-visa-svm-block-st-instruction" id="id142"><code class="docutils literal"><span class="pre">llvm.genx.svm.block.st</span></code> : vISA SVM BLOCK_ST instruction</a></li>
<li><a class="reference internal" href="#llvm-genx-svm-gather-visa-svm-gather-instruction" id="id143"><code class="docutils literal"><span class="pre">llvm.genx.svm.gather</span></code> : vISA SVM GATHER instruction</a></li>
<li><a class="reference internal" href="#llvm-genx-svm-gather4-scaled-visa-svm-gather4-scaled-instruction" id="id144"><code class="docutils literal"><span class="pre">llvm.genx.svm.gather4.scaled</span></code> : vISA SVM GATHER4_SCALED instruction</a></li>
<li><a class="reference internal" href="#llvm-genx-svm-scatter-visa-svm-scatter-instruction" id="id145"><code class="docutils literal"><span class="pre">llvm.genx.svm.scatter</span></code> : vISA SVM SCATTER instruction</a></li>
<li><a class="reference internal" href="#llvm-genx-svm-scatter4-scaled-visa-svm-scatter4-scaled-instruction" id="id146"><code class="docutils literal"><span class="pre">llvm.genx.svm.scatter4.scaled</span></code> : vISA SVM SCATTER4_SCALED instruction</a></li>
<li><a class="reference internal" href="#llvm-genx-svm-atomic-visa-svm-atomic-with-binary-operator" id="id147"><code class="docutils literal"><span class="pre">llvm.genx.svm.atomic.*</span></code> : vISA SVM_ATOMIC with binary operator</a></li>
<li><a class="reference internal" href="#llvm-genx-svm-atomic-visa-svm-atomic-with-inc-dec" id="id148"><code class="docutils literal"><span class="pre">llvm.genx.svm.atomic.*</span></code> : vISA SVM_ATOMIC with inc/dec</a></li>
<li><a class="reference internal" href="#llvm-genx-svm-atomic-cmpxchg-visa-svm-atomic-cmpxchg-instruction" id="id149"><code class="docutils literal"><span class="pre">llvm.genx.svm.atomic.cmpxchg</span></code> : vISA SVM_ATOMIC CMPXCHG instruction</a></li>
<li><a class="reference internal" href="#id2" id="id150"><code class="docutils literal"><span class="pre">llvm.genx.svm.atomic.*</span></code> : vISA SVM_ATOMIC with binary operator</a></li>
<li><a class="reference internal" href="#llvm-genx-svm-atomic-fcmpwr-visa-svm-atomic-fcmpwr-instruction" id="id151"><code class="docutils literal"><span class="pre">llvm.genx.svm.atomic.fcmpwr</span></code> : vISA SVM_ATOMIC FCMPWR instruction</a></li>
<li><a class="reference internal" href="#llvm-genx-load-visa-load-sampler-load-instruction" id="id152"><code class="docutils literal"><span class="pre">llvm.genx.load</span></code> : vISA LOAD (sampler load) instruction</a></li>
<li><a class="reference internal" href="#llvm-genx-sample-visa-sample-instruction" id="id153"><code class="docutils literal"><span class="pre">llvm.genx.sample</span></code> : vISA SAMPLE instruction</a></li>
<li><a class="reference internal" href="#llvm-genx-sample-unorm-visa-sample-unorm-instruction" id="id154"><code class="docutils literal"><span class="pre">llvm.genx.sample.unorm</span></code> : vISA SAMPLE_UNORM instruction</a></li>
<li><a class="reference internal" href="#llvm-genx-3d-sample-visa-3d-sample-instruction" id="id155"><code class="docutils literal"><span class="pre">llvm.genx.3d.sample</span></code> : vISA 3D_SAMPLE instruction</a></li>
<li><a class="reference internal" href="#llvm-genx-3d-load-visa-3d-load-instruction" id="id156"><code class="docutils literal"><span class="pre">llvm.genx.3d.load</span></code> : vISA 3D_LOAD instruction</a></li>
<li><a class="reference internal" href="#llvm-genx-avs-visa-avs-instruction" id="id157"><code class="docutils literal"><span class="pre">llvm.genx.avs</span></code> : vISA AVS instruction</a></li>
<li><a class="reference internal" href="#llvm-genx-barrier-visa-barrier-instruction" id="id158"><code class="docutils literal"><span class="pre">llvm.genx.barrier</span></code> : vISA BARRIER instruction</a></li>
<li><a class="reference internal" href="#llvm-genx-sbarrier-visa-sbarrier-instruction" id="id159"><code class="docutils literal"><span class="pre">llvm.genx.sbarrier</span></code> : vISA SBARRIER instruction</a></li>
<li><a class="reference internal" href="#llvm-genx-cache-flush-visa-cache-flush-instruction" id="id160"><code class="docutils literal"><span class="pre">llvm.genx.cache.flush</span></code> : vISA CACHE_FLUSH instruction</a></li>
<li><a class="reference internal" href="#llvm-genx-fence-visa-fence-instruction" id="id161"><code class="docutils literal"><span class="pre">llvm.genx.fence</span></code> : vISA FENCE instruction</a></li>
<li><a class="reference internal" href="#llvm-genx-wait-visa-wait-instruction" id="id162"><code class="docutils literal"><span class="pre">llvm.genx.wait</span></code> : vISA WAIT instruction</a></li>
<li><a class="reference internal" href="#llvm-genx-yield-visa-yield-instruction" id="id163"><code class="docutils literal"><span class="pre">llvm.genx.yield</span></code> : vISA YIELD instruction</a></li>
<li><a class="reference internal" href="#llvm-genx-raw-send-visa-raw-send-instruction" id="id164"><code class="docutils literal"><span class="pre">llvm.genx.raw.send</span></code> : vISA RAW_SEND instruction</a></li>
<li><a class="reference internal" href="#llvm-genx-raw-send-noresult-visa-raw-send-instruction-with-no-result" id="id165"><code class="docutils literal"><span class="pre">llvm.genx.raw.send.noresult</span></code> : vISA RAW_SEND instruction with no result</a></li>
<li><a class="reference internal" href="#llvm-genx-raw-sends-visa-raw-sends-instruction" id="id166"><code class="docutils literal"><span class="pre">llvm.genx.raw.sends</span></code> : vISA RAW_SENDS instruction</a></li>
<li><a class="reference internal" href="#llvm-genx-raw-sends-noresult-visa-raw-sends-instruction-with-no-result" id="id167"><code class="docutils literal"><span class="pre">llvm.genx.raw.sends.noresult</span></code> : vISA RAW_SENDS instruction with no result</a><ul>
<li><a class="reference internal" href="#video-analytics-instrinsics" id="id168">Video Analytics Instrinsics</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-genx-va-convolve2d-visa-va-2d-convolve-instruction" id="id169"><code class="docutils literal"><span class="pre">llvm.genx.va.convolve2d</span></code> vISA VA 2d Convolve instruction</a></li>
<li><a class="reference internal" href="#llvm-genx-va-hdc-convolve2d-visa-va-hdc-2d-convolve-instruction" id="id170"><code class="docutils literal"><span class="pre">llvm.genx.va.hdc.convolve2d</span></code> vISA VA HDC 2d Convolve instruction</a></li>
<li><a class="reference internal" href="#llvm-genx-va-erode-visa-va-erode-instruction" id="id171"><code class="docutils literal"><span class="pre">llvm.genx.va.erode</span></code> vISA VA Erode instruction</a></li>
<li><a class="reference internal" href="#llvm-genx-va-hdc-erode-visa-va-hdc-erode-instruction" id="id172"><code class="docutils literal"><span class="pre">llvm.genx.va.hdc.erode</span></code> vISA VA HDC Erode instruction</a></li>
<li><a class="reference internal" href="#llvm-genx-va-dilate-visa-va-dilate-instruction" id="id173"><code class="docutils literal"><span class="pre">llvm.genx.va.dilate</span></code> vISA VA Dilate instruction</a></li>
<li><a class="reference internal" href="#llvm-genx-va-hdc-dilate-visa-va-hdc-dilate-instruction" id="id174"><code class="docutils literal"><span class="pre">llvm.genx.va.hdc.dilate</span></code> vISA VA HDC Dilate instruction</a></li>
<li><a class="reference internal" href="#llvm-genx-va-minmax-visa-minmax-instruction" id="id175"><code class="docutils literal"><span class="pre">llvm.genx.va.minmax</span></code> vISA MinMax instruction</a></li>
<li><a class="reference internal" href="#llvm-genx-va-minmax-filter-visa-minmax-filter-instruction" id="id176"><code class="docutils literal"><span class="pre">llvm.genx.va.minmax.filter</span></code> vISA MinMax Filter instruction</a></li>
<li><a class="reference internal" href="#llvm-genx-va-hdc-minmax-filter-visa-hdc-minmax-filter-instruction" id="id177"><code class="docutils literal"><span class="pre">llvm.genx.va.hdc.minmax.filter</span></code> vISA HDC MinMax Filter instruction</a></li>
<li><a class="reference internal" href="#llvm-genx-va-bool-centroid-visa-boolean-centroid-instruction" id="id178"><code class="docutils literal"><span class="pre">llvm.genx.va.bool.centroid</span></code> vISA Boolean Centroid instruction</a></li>
<li><a class="reference internal" href="#llvm-genx-va-centroid-visa-centroid-instruction" id="id179"><code class="docutils literal"><span class="pre">llvm.genx.va.centroid</span></code> vISA Centroid instruction</a></li>
<li><a class="reference internal" href="#llvm-genx-va-1d-convolve-horizontal-visa-1d-convolve-horizontal-instruction" id="id180"><code class="docutils literal"><span class="pre">llvm.genx.va.1d.convolve.horizontal</span></code> vISA 1d convolve horizontal instruction</a></li>
<li><a class="reference internal" href="#llvm-genx-va-hdc-1d-convolve-horizontal-visa-hdc-1d-convolve-horizontal-instruction" id="id181"><code class="docutils literal"><span class="pre">llvm.genx.va.hdc.1d.convolve.horizontal</span></code> vISA HDC 1d convolve horizontal instruction</a></li>
<li><a class="reference internal" href="#llvm-genx-va-1d-convolve-vertical-visa-1d-convolve-vertical-instruction" id="id182"><code class="docutils literal"><span class="pre">llvm.genx.va.1d.convolve.vertical</span></code> vISA 1d convolve vertical instruction</a></li>
<li><a class="reference internal" href="#llvm-genx-va-hdc-1d-convolve-vertical-visa-hdc-1d-convolve-vertical-instruction" id="id183"><code class="docutils literal"><span class="pre">llvm.genx.va.hdc.1d.convolve.vertical</span></code> vISA HDC 1d convolve vertical instruction</a></li>
<li><a class="reference internal" href="#llvm-genx-va-1pixel-convolve-visa-1-pixel-convolve-instruction" id="id184"><code class="docutils literal"><span class="pre">llvm.genx.va.1pixel.convolve</span></code> vISA 1 Pixel Convolve instruction</a></li>
<li><a class="reference internal" href="#llvm-genx-va-hdc-1pixel-convolve-visa-hdc-1-pixel-convolve-instruction" id="id185"><code class="docutils literal"><span class="pre">llvm.genx.va.hdc.1pixel.convolve</span></code> vISA HDC 1 Pixel Convolve instruction</a></li>
<li><a class="reference internal" href="#llvm-genx-va-1pixel-convolve-1x1mode-visa-1-pixel-convolve-1x1-mode-instruction" id="id186"><code class="docutils literal"><span class="pre">llvm.genx.va.1pixel.convolve.1x1mode</span></code> vISA 1 Pixel Convolve (1x1 mode) instruction</a></li>
<li><a class="reference internal" href="#llvm-genx-va-lbp-creation-visa-lbp-creation-instruction" id="id187"><code class="docutils literal"><span class="pre">llvm.genx.va.lbp.creation</span></code> vISA LBP Creation instruction</a></li>
<li><a class="reference internal" href="#llvm-genx-va-hdc-lbp-creation-visa-hdc-lbp-creation-instruction" id="id188"><code class="docutils literal"><span class="pre">llvm.genx.va.hdc.lbp.creation</span></code> vISA HDC LBP Creation instruction</a></li>
<li><a class="reference internal" href="#llvm-genx-va-lbp-correlation-visa-lbp-correlation-instruction" id="id189"><code class="docutils literal"><span class="pre">llvm.genx.va.lbp.correlation</span></code> vISA LBP Correlation instruction</a></li>
<li><a class="reference internal" href="#llvm-genx-va-hdc-lbp-correlation-visa-hdc-lbp-correlation-instruction" id="id190"><code class="docutils literal"><span class="pre">llvm.genx.va.hdc.lbp.correlation</span></code> vISA HDC LBP Correlation instruction</a></li>
<li><a class="reference internal" href="#llvm-genx-va-correlation-search-visa-correlation-search-instruction" id="id191"><code class="docutils literal"><span class="pre">llvm.genx.va.correlation.search</span></code> vISA Correlation Search instruction</a></li>
<li><a class="reference internal" href="#llvm-genx-va-flood-fill-visa-flood-fill-instruction" id="id192"><code class="docutils literal"><span class="pre">llvm.genx.va.flood.fill</span></code> vISA Flood Fill instruction</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="introduction">
<h2><a class="toc-backref" href="#id3">Introduction</a><a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>The GenX backend accepts
<a class="reference internal" href="LangRef.html"><span class="doc">LLVM intermediate representation</span></a>
with certain restrictions, and with additional GenX-specific intrinsics.</p>
</div>
<div class="section" id="llvm-ir-representation-of-eu-code">
<h2><a class="toc-backref" href="#id4">LLVM IR representation of EU code</a><a class="headerlink" href="#llvm-ir-representation-of-eu-code" title="Permalink to this headline">¶</a></h2>
<div class="section" id="whole-thread-representation">
<h3><a class="toc-backref" href="#id5">Whole thread representation</a><a class="headerlink" href="#whole-thread-representation" title="Permalink to this headline">¶</a></h3>
<p>When using LLVM with the GenX backend, the LLVM IR represents execution on a
whole EU thread. This is distinct from IGC and Beignet (the OpenCL compiler for
the Intel open source driver), in which the LLVM IR represents just a single
work item, and a later stage of the compiler after LLVM IR parallelizes that
into simd4,8,16 or 32.</p>
<p>The GenX backend thus gives more flexibility for a client that needs full
control over what is executed in the EU thread for one of these reasons:</p>
<ol class="arabic simple">
<li>the compiler needs to expose that control in the language (like CM);</li>
<li>the compiler wants to do some parallelization, but in a more
flexible way (e.g. different SIMD width for different parts of the code).
This could be done as an LLVM pass before reaching the GenX backend, or
it could be done even before reaching LLVM;</li>
<li>the compiler wants to expose “cross lane” functionality, where an algorithm
can be executed in parallel within a single EU thread, but the separate lanes
need to access each other’s data at some points.</li>
</ol>
</div>
<div class="section" id="linkage">
<h3><a class="toc-backref" href="#id6">Linkage</a><a class="headerlink" href="#linkage" title="Permalink to this headline">¶</a></h3>
<p>A kernel is represented by a function with <code class="docutils literal"><span class="pre">dllexport</span></code> linkage.</p>
<p>A non-kernel function is represented by a function with <code class="docutils literal"><span class="pre">public</span></code> linkage.</p>
<p>A subroutine is represented by a function with <code class="docutils literal"><span class="pre">internal</span></code> linkage. A subroutine
is allowed to be accessed from multiple kernels and non-kernel functions; the
GenX backend clones such a subroutine so it appears with each kernel and function
that uses it in the vISA.</p>
<p>No other linkage is supported.</p>
<p>Global variables are not supported. (The CM compiler has its own CMABI pass that
works around this by passing such variable into and out of any subroutine that
uses it.)</p>
</div>
<div class="section" id="kernel-information">
<h3><a class="toc-backref" href="#id7">Kernel information</a><a class="headerlink" href="#kernel-information" title="Permalink to this headline">¶</a></h3>
<p>The genx.kernels named metadata node contains a metadata node
for each kernel, containing:</p>
<ul class="simple">
<li>0: reference to Function</li>
<li>1: kernel name</li>
<li>2: asm name</li>
<li>3: kernel argument kinds (i32 for each kernel argument)</li>
<li>4: slm size in bytes</li>
<li>5: kernel argument offsets (i32 for each kernel argument)</li>
</ul>
</div>
<div class="section" id="types">
<h3><a class="toc-backref" href="#id8">Types</a><a class="headerlink" href="#types" title="Permalink to this headline">¶</a></h3>
<p>Only fundamental types that correspond to Gen types are allowed:</p>
<ul class="simple">
<li>i1 for predicate</li>
<li>i8 for b/ub</li>
<li>i16 for w/uw</li>
<li>half for hf</li>
<li>i32 for d/ud</li>
<li>float for f</li>
<li>i64 for q/uq</li>
<li>double for df</li>
</ul>
<p>Arbitrary size vectors of these types are allowed.</p>
</div>
<div class="section" id="arithmetic-logic-operator">
<h3><a class="toc-backref" href="#id9">Arithmetic/logic operator</a><a class="headerlink" href="#arithmetic-logic-operator" title="Permalink to this headline">¶</a></h3>
<p>There is no vector width restriction on operands and result of an
arithmetic/logic operator.</p>
<p>Where the operands and result have the same type, and no saturation is
required, the corresponding LLVM IR instruction can be used, for example
<code class="docutils literal"><span class="pre">add</span></code>.</p>
<p>A floating point operation where saturation is required is represented by
the LLVM IR instruction followed by the <code class="docutils literal"><span class="pre">llvm.genx.sat</span></code> intrinsic.</p>
<p>For an integer operation, vISA allows the operands to have one type
and the result to have a different type. This is represented by an intrinsic,
typically with signed/unsigned variants and variants with saturation.
Saturation cannot be represented by a separate intrinsic as for floating
point, because the intermediate result in the EU’s ALU has one more bit
than the execution size.</p>
<p>An intrinsic is also required where the operator does not have an LLVM IR
instruction equivalent, such as <code class="docutils literal"><span class="pre">min</span></code>.</p>
</div>
<div class="section" id="load-and-store">
<h3><a class="toc-backref" href="#id10">Load and store</a><a class="headerlink" href="#load-and-store" title="Permalink to this headline">¶</a></h3>
<p>Load and store instructions are allowed only to load/store from/to a static
alloca, i.e. ones that are removed by a mem2reg pass.</p>
</div>
</div>
<div class="section" id="vector-regions">
<h2><a class="toc-backref" href="#id11">Vector regions</a><a class="headerlink" href="#vector-regions" title="Permalink to this headline">¶</a></h2>
<div class="section" id="introduction-to-region-based-addressing">
<h3><a class="toc-backref" href="#id12">Introduction to region-based addressing</a><a class="headerlink" href="#introduction-to-region-based-addressing" title="Permalink to this headline">¶</a></h3>
<p>The Gen hardware, and thus vISA, provide the ability for a vector operand of an
instruction to be a region within a register.</p>
<div class="section" id="d-region">
<h4><a class="toc-backref" href="#id13">1D region</a><a class="headerlink" href="#d-region" title="Permalink to this headline">¶</a></h4>
<p>A 1D region has the following parameters:</p>
<ul class="simple">
<li>The execution size is the number of elements in the region. This is
determined by the instruction in which the operand appears.</li>
<li>The horizontal stride (sometimes called just the stride) is the number of
elements to step between each element of the region. This is 1 for a
contiguous region, but can take other values, including 0 (in a source
operand only) to splat the same scalar value across the whole operand.</li>
<li>The start index indicates which element within the register is the start of
the region.</li>
</ul>
<p>The stride must be a constant. The start index can be a variable (giving an indirect operand).</p>
<p>Here is a simple contiguous 1D region (yellow), with execution size 4, stride 1
and start index 3, in a register with 8 elements:</p>
<img alt="_images/GenXLangRef_region_example1.png" src="_images/GenXLangRef_region_example1.png" />
<p>Here is a non-contiguous 1D region, with execution size 4, stride 2 and start
index 3, in a register with 16 elements:</p>
<img alt="_images/GenXLangRef_region_example2.png" src="_images/GenXLangRef_region_example2.png" />
</div>
<div class="section" id="id1">
<h4><a class="toc-backref" href="#id14">2D region</a><a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h4>
<p>A 2D region has multiple rows where each row is a 1D region. It has the following parameters:</p>
<ul class="simple">
<li>The execution size is the number of elements in the region. This is
determined by the instruction in which the operand appears.</li>
<li>The vertical stride (or vstride) is the number of elements to step between
the start of one row and the start of the next row. It can be 0 (in a source
operand only) to repeat the same row multiple times.</li>
<li>The width is the number of elements per row.</li>
<li>The horizontal stride (or stride) is the number of elements to step between
each element of the region within a row. This is 1 for a contiguous row, but
can take other values, including 0 (in a source operand only) to splat the
same scalar value across the whole row.</li>
<li>The start index indicates which element within the register is the start of
the region.</li>
</ul>
<p>The vstride, width and stride must be a constant. The start index can be a scalar variable (giving an indirect operand) or a vector variable with an element per row of the region (giving a multi-indirect operand).</p>
<p>Here is a 2D region with contiguous rows, with:</p>
<ul class="simple">
<li>execution size 8 (the number of elements in the region)</li>
<li>vstride 8 (the step between the start of one row (3) and the start of the next (11)</li>
<li>width 4 (the number of elements in a row)</li>
<li>stride 1 (the step between each element in a row)</li>
<li>start index 3</li>
</ul>
<img alt="_images/GenXLangRef_region_example3.png" src="_images/GenXLangRef_region_example3.png" />
<p>Here is a 2D region with:</p>
<ul class="simple">
<li>execution size 9 (the number of elements in the region)</li>
<li>vstride 7 (the step between the start of one row (8) and the start of the next (15)</li>
<li>width 3 (the number of elements in a row)</li>
<li>stride 3 (the step between each element in a row)</li>
<li>start index 8</li>
</ul>
<img alt="_images/GenXLangRef_region_example4.png" src="_images/GenXLangRef_region_example4.png" />
</div>
<div class="section" id="notes">
<h4><a class="toc-backref" href="#id15">Notes</a><a class="headerlink" href="#notes" title="Permalink to this headline">¶</a></h4>
<p>Some points that arise from these examples:</p>
<ul class="simple">
<li>The execution size must be a multiple of the width. Execution size divided by
width is the number of rows in a 2D region. If the number of rows is 1, then
it is a 1D region.</li>
<li>Gen and vISA only support powers of two within certain limits for the region
parameters other than start index. Also 2D regions are allowed only in a
source operand. But source languages like CM using regions do not have these
restrictions, and the compiler needs to allow for the more general case.</li>
<li>The matrix representation shown in the last two examples is not a property of
the register from/into which the region is read/written. Rather, it is a
property of the region parameters. We show a matrix whose width is the
vstride of the region. In the last example, the register is not even a
multiple of vstride number of elements, so we have some left-over elements at
the bottom.</li>
</ul>
</div>
</div>
<div class="section" id="region-access-in-llvm-ir">
<h3><a class="toc-backref" href="#id16">Region access in LLVM IR</a><a class="headerlink" href="#region-access-in-llvm-ir" title="Permalink to this headline">¶</a></h3>
<p>Region access is represented in LLVM IR by intrinsics with the same region
parameters as above. The representation is close to the hardware capabilities,
but:</p>
<ul class="simple">
<li>The vISA/hardware restrictions on the region parameters being powers of 2
within certain ranges are not initially imposed. The GenX backend includes a
legalization pass that imposes these restrictions, and other gen-specific
ones such as not being allowed to cross 2 GRF boundaries and not being
allowed a 2D region as a destination, by splitting up region accesses.</li>
<li>There is an extra <em>parent width</em> region parameter used for optimizations
when the GenX backend collapses and legalizes region accesses.</li>
<li>To make the parent width parameter effective when a variable start index is
involved, a compiler frontend should compile a 2D region access as two
separate accesses, one for the rows and one for the columns within the rows.</li>
</ul>
<p>The restriction still needs to be imposed that the region is entirely contained
within the vector it is being read from or written to, otherwise undefined
behavior ensues at runtime.</p>
<div class="section" id="reading-a-region">
<h4><a class="toc-backref" href="#id17">Reading a region</a><a class="headerlink" href="#reading-a-region" title="Permalink to this headline">¶</a></h4>
<p>Reading a region, that is extracting certain elements from a vector to make a
new smaller vector, is represented by the <code class="docutils literal"><span class="pre">llvm.genx.rdregioni</span></code> or
<code class="docutils literal"><span class="pre">llvm.genx.rdregionf</span></code> intrinsic. (There are integer and fp variants simply
because the tablegen language for declaring an overloaded intrinsic does not
allow an “any scalar or vector type”.</p>
<p>The operands to this intrinsic are:</p>
<ul class="simple">
<li>the vector being read from;</li>
<li>vstride (ignored for a 1D region, that is width == execution size);</li>
<li>width;</li>
<li>stride;</li>
<li>start index;</li>
<li>parent width (see below).</li>
</ul>
<p>The execution
size is implied by the vector width of the return value of the intrinsic call.</p>
<p>The vstride, width and stride are expressed in elements. But the start index is
expressed in bytes, as this is what the hardware does in the variable index
case.</p>
<p>A read from the first example region from above:</p>
<img alt="_images/GenXLangRef_region_example1.png" src="_images/GenXLangRef_region_example1.png" />
<p>is represented by the following LLVM IR (assuming the start index is constant, and the element type is i32):</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>%v1 = &lt;8 x i32&gt; something
%region1 = call &lt;4 x i32&gt; @llvm.genx.rdregioni.v4i32.v8i32(&lt;8 x i32&gt; %v1, i32 0, i32 4, i32 1, i16 12, i32 undef)
</pre></div>
</div>
<p>The vstride is set to 0, but is ignored because it is a 1D region.</p>
<p>The width is 4 (elements) and the stride is 1.</p>
<p>The start index is 12, but remember this is in bytes, so it means 3 elements. (The elements have type i32.)</p>
<p>A read from the fourth example region from above:</p>
<img alt="_images/GenXLangRef_region_example2.png" src="_images/GenXLangRef_region_example2.png" />
<p>is represented by this LLVM IR (assuming constant start index and i32 element
type):</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>%v2 = &lt;30 x i32&gt; something
%region2 = call &lt;9 x i32&gt; @llvm.genx.rdregioni.v9i32.v30i32(&lt;30 x i32&gt; %v2, i32 7, i32 3, i32 2, i16 32)
</pre></div>
</div>
<p>With:</p>
<ul class="simple">
<li>execution size 9 (the number of elements in the region)</li>
<li>vstride 7 (the step between the start of one row (8) and the start of the next (15)</li>
<li>width 3 (the number of elements in a row)</li>
<li>stride 3 (the step between each element in a row)</li>
<li>start index 32 bytes, which is 8 elements.</li>
</ul>
<p>The diagram above shows the input vector %v2 as a matrix of width 7 with two elements left over in a partial row. This 7 is not a property of the input vector value, which is just a vector (LLVM IR does not represent matrices). Instead it is the vstride of the region we are reading.</p>
</div>
<div class="section" id="writing-a-region">
<h4><a class="toc-backref" href="#id18">Writing a region</a><a class="headerlink" href="#writing-a-region" title="Permalink to this headline">¶</a></h4>
<p>Writing a region, that is inserting the elements of a vector into certain
positions of another vector, yielding a new value for the latter vector,
is represented by the <code class="docutils literal"><span class="pre">llvm.genx.wrregioni</span></code> or
<code class="docutils literal"><span class="pre">llvm.genx.wrregionf</span></code> intrinsic. (There are integer and fp variants simply
because the tablegen language for declaring an overloaded intrinsic does not
allow an “any scalar or vector type”.</p>
<p>In SSA, each value is defined exactly once. Since we are representing a vector
value as an LLVM IR value, the only way of representing a write to a region,
which is a partial write, is for the operation to take the old value of the
vector as an input, and to return the updated value of the vector. It is then up to
the GenX backend to ensure that the two values are allocated to the same register.</p>
<p>The operands to this intrinsic are:</p>
<ul class="simple">
<li>the “old value” of the vector being written into;</li>
<li>the “new value”, that is, the vector or scalar value to write into the region;</li>
<li>vstride;</li>
<li>width;</li>
<li>stride;</li>
<li>start index;</li>
<li>parent width (see below);</li>
<li>mask.</li>
</ul>
<p>The execution size is the vector width of the “new value” input.
For a 1D region (width == execution size), vstride is ignored.</p>
<p>As above in llvm.genx.rdregion, the vstride, width and stride are expressed in
elements, but the start index is expressed in bytes.</p>
<p>Using the same two example regions as above in llvm.genx.rdregion:</p>
<img alt="_images/GenXLangRef_region_example1.png" src="_images/GenXLangRef_region_example1.png" />
<p>Writing the elements of %region3 into the region in %v3, generating a new value %v3.new is represented by:</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>%v3 = &lt;8 x i32&gt; something
%region3 = &lt;4 x i32&gt; something
%v3.new = call &lt;8 x i32&gt; @llvm.genx.wrregion.v8i32.v4i32.i1(&lt;8 x i32&gt; %v3, &lt;4 x i32&gt; %region3, i32 0, i32 4, i32 1, i16 12, i32 undef, i1 1)
</pre></div>
</div>
<p>The .v8i32.v4i32.i1 decoration on the intrinsic name arises from LLVM’s
intrinsic overloading mechanism. The v8i32 is the type of the return value, and
the v4i32 is the type of the value being written in to the region. The i1 is
the type of the mask operand; see below.</p>
<p>The vstride is set to 0, but is ignored because it is a 1D region.</p>
<p>The width is 4 (elements) and the stride is 1.</p>
<p>The start index is 12, but remember this is in bytes, so it means 3 elements. (The elements have type i32.)</p>
<img alt="_images/GenXLangRef_region_example4.png" src="_images/GenXLangRef_region_example4.png" />
<p>Writing the elements of %region4 into the region in %v4, generating a new value %v4.new is represented by:</p>
<div class="highlight-text"><div class="highlight"><pre><span></span>%v4 = &lt;30 x i32&gt; something
%region4 = &lt;9 x i32&gt; something
%v4.new = call &lt;30 x i32&gt; @llvm.genx.wrregion.v30i32.v9i32.i1(&lt;30 x i32&gt; %v4, &lt;9 x i32&gt; %region4, i32 7, i32 3, i32 2, i16 32, i32 undef, i1 1)
</pre></div>
</div>
<p>With:</p>
<ul class="simple">
<li>execution size 9 (the number of elements in the region)</li>
<li>vstride 7 (the step between the start of one row (8) and the start of the next (15)</li>
<li>width 3 (the number of elements in a row)</li>
<li>stride 3 (the step between each element in a row)</li>
<li>start index 32 bytes, which is 8 elements.</li>
</ul>
</div>
<div class="section" id="the-mask-operand">
<h4><a class="toc-backref" href="#id19">The mask operand</a><a class="headerlink" href="#the-mask-operand" title="Permalink to this headline">¶</a></h4>
<p>The wrregion* intrinsics have an extra mask operand. This is used to control
which elements in the region are actually written, for use in predication and
SIMD control flow.</p>
<p>Most generally, the mask operand is a vector of i1 with the same vector width
as the value being written in to the region, and it is variable. If any element
of the mask is 0, the corresponding element of the value is not written in to
the region, leaving that element unchanged.</p>
<p>The most common case, used when there is no predication, is that the mask is all
ones. As a shorthand, this is represented by a single constant i1 value of 1,
rather than the whole vector.</p>
</div>
<div class="section" id="single-element-region">
<h4><a class="toc-backref" href="#id20">Single element region</a><a class="headerlink" href="#single-element-region" title="Permalink to this headline">¶</a></h4>
<p>A single element could be a scalar value or a 1-vector. It is convenient to
allow both in LLVM IR, because CM allows both as distinct types.</p>
<p>The rdregion and wrregion intrinsics are defined such that
a single element region can be represented as either a scalar or a 1-vector.
However, for the scalar case, it is recommended to use the LLVM IR instructions
extractelement and insertelement instead, as core LLVM optimizations understand
them.</p>
</div>
<div class="section" id="the-parent-width-operand">
<h4><a class="toc-backref" href="#id21">The parent width operand</a><a class="headerlink" href="#the-parent-width-operand" title="Permalink to this headline">¶</a></h4>
<p>For a 2D region, certain parts of the GenX backend can optimize better if it is
known that a row of the region cannot cross certain boundaries:</p>
<ul class="simple">
<li>Collapsing two 2D regions is possible only if it is known that a row of the
inner 2D region cannot cross a row boundary of the outer 2D region.</li>
<li>Knowing that a row of a 2D region cannot cross a GRF boundary can help to
avoid splitting it up so much in legalization.</li>
</ul>
<p>For a region with a constant start index, this can all be calculated from the
start index and region parameters. For a region with a variable start index,
the <em>parent width</em> operand is set to value N to make a statement
that the semantics of the language being compiled say that a row of the region
cannot cross a multiple of N boundary.</p>
</div>
</div>
</div>
<div class="section" id="predicates-and-predication">
<h2><a class="toc-backref" href="#id22">Predicates and predication</a><a class="headerlink" href="#predicates-and-predication" title="Permalink to this headline">¶</a></h2>
<p>Certain vector operations can be <em>predicated</em>, that is, a vector of i1
predicate controls whether the corresponding element of the operation is
written into its result element.</p>
<p>LLVM IR already has <code class="docutils literal"><span class="pre">select</span></code> with a vector condition.</p>
<p>As outlined above, the wrregion intrinsics have a mask operand. If a bit is
not set in the mask, then the corresponding element of the “new value” input
is not written into the result.</p>
<p>The intrinsics corresponding to predicated send messages (e.g. gather), and
the raw send intrinsics, have a predicate operand.</p>
</div>
<div class="section" id="non-genx-intrinsics">
<h2><a class="toc-backref" href="#id23">Non-GenX intrinsics</a><a class="headerlink" href="#non-genx-intrinsics" title="Permalink to this headline">¶</a></h2>
<p>In general the GenX backend does not implement non-GenX intrinsics, with the
following exceptions:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">llvm.uadd.with.overflow</span></code> – the GenX backend does not implement the other
arithmetic-with-overflow intrinsics, but I found a case where LLVM was
transforming a CM program to use this one, so I had to implement it.</li>
<li><code class="docutils literal"><span class="pre">llvm.fma</span></code> – this intrinsic is generated in the GenXPatternMatch pass,
but I think the GenX backend would be able to cope with it being in the IR
already.</li>
</ul>
</div>
<div class="section" id="genx-intrinsics">
<h2><a class="toc-backref" href="#id24">GenX intrinsics</a><a class="headerlink" href="#genx-intrinsics" title="Permalink to this headline">¶</a></h2>
<div class="section" id="region-element-access-intrinsics">
<h3><a class="toc-backref" href="#id25">Region/element access intrinsics</a><a class="headerlink" href="#region-element-access-intrinsics" title="Permalink to this headline">¶</a></h3>
<div class="section" id="llvm-genx-rdregion-read-a-region-direct-or-single-indirect">
<h4><a class="toc-backref" href="#id26"><code class="docutils literal"><span class="pre">llvm.genx.rdregion*</span></code> : read a region, direct or single-indirect</a><a class="headerlink" href="#llvm-genx-rdregion-read-a-region-direct-or-single-indirect" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">llvm.genx.rdregioni</span></code> : integer element type (not i1)</li>
<li><code class="docutils literal"><span class="pre">llvm.genx.rdregionf</span></code> : fp element type</li>
<li>arg0: vector to read region out of</li>
<li>arg1: i32 vstride in elements, constant</li>
<li>arg2: i32 width in elements, constant</li>
<li>arg3: i32 stride in elements, constant</li>
<li>arg4: i16 or vXi16 offset in bytes</li>
<li>arg5: i32 parent width, constant, ignored if offset is constant</li>
<li>Return value: the region extracted</li>
</ul>
<p>The return type must be a vector with the same element type as the input
vector, and number of elements giving the total size of the region.
A scalar can be used instead of a 1-vector.</p>
<p>There are two variants, an integer one and an fp one, because the
intrinsic declaration language does not let us declare the return type
as any scalar or vector int or fp type.</p>
<p>The element type must be an integral power of two number of bytes up to
and including 8 bytes in size, thus one of i8, i16, i32, i64, half,
float, double. In particular i1 is not allowed.
The width must be non-zero and must divide the total size evenly.</p>
<p>There is no requirement on vstride, width, stride or total size being
a power of two or having any maximum.</p>
<p>The offset in bytes arg can be i16 or vector of i16. If a vector, then
its vector width must be the height of the region, i.e. the total
size of the region divided by the width.</p>
<p>The parent width arg is ignored if the offset arg is constant. If the
offset arg is variable, then a non-undef parent width is a statement
that the value of offset is such that a row of the region does not
cross a multiple of parent width boundary. This is used by the backend
to determine whether the region can be collapsed into another region.</p>
</div>
<div class="section" id="llvm-genx-wrregion-write-a-region-direct-or-single-indirect">
<h4><a class="toc-backref" href="#id27"><code class="docutils literal"><span class="pre">llvm.genx.wrregion*</span></code> : write a region, direct or single-indirect</a><a class="headerlink" href="#llvm-genx-wrregion-write-a-region-direct-or-single-indirect" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">llvm.genx.wrregioni</span></code> : integer element type (not i1)</li>
<li><code class="docutils literal"><span class="pre">llvm.genx.wrregionf</span></code> : fp element type</li>
<li>arg0: vector to write region in to</li>
<li>arg1: subvector or scalar to write into the region</li>
<li>arg2: i32 vstride in elements, constant</li>
<li>arg3: i32 width in elements, constant</li>
<li>arg4: i32 stride in elements, constant</li>
<li>arg5: i16 or vXi16 offset in bytes</li>
<li>arg6: i32 parent width, constant, ignored if offset is constant</li>
<li>arg7: vector of i1 mask, or scalar i1</li>
<li>Return value: the updated vector with the region modified</li>
</ul>
<p>The return type must be a vector with the same type as the arg0 vector.
The arg1 subvector must have the same element type as the arg0 vector
and be no larger. Arg1 can be a scalar if the number of elements in
the subregion is 1.</p>
<p>There are two variants, an integer one and an fp one, because the
intrinsic declaration language does not let us declare the arg1 type
as any scalar or vector int or fp type.</p>
<p>The element type must be an integral power of two number of bytes up to
and including 8 bytes in size, thus one of i8, i16, i32, i64, half,
float, double. In particular i1 is not allowed.
The width must be non-zero and must divide the total size evenly.</p>
<p>The arg7 mask is a vector of booleans, exactly as wide as the
arg1 subvector, such that an element of the subvector is written into
its place in the vector only if the corresponding element of the mask
is true.
Alternatively, arg7 can be a single i1 constant with value 1,
meaning that the wrregion is unconditional.</p>
<p>There is no requirement on vstride, width, stride or total size being
a power of two or having any maximum.</p>
<p>The offset in bytes arg can be i16 or vector of i16. If a vector, then
its vector width must be the height of the region, i.e. the total
size of the region divided by the width.</p>
<p>After lowering, the arg1 subvector to write can be a scalar of the same
type as an element of arg0, indicating that the region has one element.
(Lowering lowers an insertelement to this type of wrregion.)</p>
<p>The parent width arg is ignored if the offset arg is constant. If the
offset arg is variable, then a non-undef parent width is a statement
that the value of offset is such that a row of the region does not
cross a multiple of parent width boundary. This is used by the backend
to determine whether the region can be collapsed into another region.</p>
</div>
<div class="section" id="llvm-genx-vstore-store-a-vector-value-into-memory">
<h4><a class="toc-backref" href="#id28"><code class="docutils literal"><span class="pre">llvm.genx.vstore</span></code> : store a vector value into memory</a><a class="headerlink" href="#llvm-genx-vstore-store-a-vector-value-into-memory" title="Permalink to this headline">¶</a></h4>
<p>This intrinsic has the exact semantics of an llvm store instruction.
It is designed for reading and writing a pass-by-reference argument
and it stops llvm optimizations from optimizing away accesses to the
pass-by-reference arguments.</p>
<ul class="simple">
<li>arg0: the memory to be accessed</li>
</ul>
</div>
<div class="section" id="llvm-genx-vload-load-a-vector-value-from-memory">
<h4><a class="toc-backref" href="#id29"><code class="docutils literal"><span class="pre">llvm.genx.vload</span></code> : load a vector value from memory</a><a class="headerlink" href="#llvm-genx-vload-load-a-vector-value-from-memory" title="Permalink to this headline">¶</a></h4>
<p>This intrinsic has the exact semantics of an llvm load instruction.
It is designed for reading and writing a pass-by-reference argument
and it stops llvm optimizations from optimizing away accesses to the
pass-by-reference arguments.</p>
<ul class="simple">
<li>arg0: the memory to be accessed</li>
<li>Return value: the vector value read</li>
</ul>
</div>
</div>
<div class="section" id="alu-type-conversion-intrinsics">
<h3><a class="toc-backref" href="#id30">ALU type conversion intrinsics</a><a class="headerlink" href="#alu-type-conversion-intrinsics" title="Permalink to this headline">¶</a></h3>
<div class="section" id="llvm-genx-fptosi-sat-convert-floating-point-to-signed-integer-with-saturate">
<h4><a class="toc-backref" href="#id31"><code class="docutils literal"><span class="pre">llvm.genx.fptosi.sat</span></code> : convert floating point to signed integer with saturate</a><a class="headerlink" href="#llvm-genx-fptosi-sat-convert-floating-point-to-signed-integer-with-saturate" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>arg0: value to saturate, any scalar or vector floating point type</li>
<li><dl class="first docutils">
<dt>Return value: converted value, any scalar or vector integer type</dt>
<dd>(treated as signed) with same vector width as arg0</dd>
</dl>
</li>
</ul>
</div>
<div class="section" id="llvm-genx-fptoui-sat-convert-floating-point-to-unsigned-integer-with-saturate">
<h4><a class="toc-backref" href="#id32"><code class="docutils literal"><span class="pre">llvm.genx.fptoui.sat</span></code> : convert floating point to unsigned integer with saturate</a><a class="headerlink" href="#llvm-genx-fptoui-sat-convert-floating-point-to-unsigned-integer-with-saturate" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>arg0: value to saturate, any scalar or vector floating point type</li>
<li><dl class="first docutils">
<dt>Return value: converted value, any scalar or vector integer type</dt>
<dd>(treated as unsigned) with same vector width as arg0</dd>
</dl>
</li>
</ul>
</div>
<div class="section" id="llvm-genx-sat-floating-point-saturate">
<h4><a class="toc-backref" href="#id33"><code class="docutils literal"><span class="pre">llvm.genx.sat</span></code> : floating point saturate</a><a class="headerlink" href="#llvm-genx-sat-floating-point-saturate" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>arg0: value to saturate, any scalar or vector floating point type</li>
<li>Return value: saturated value, same type as arg0</li>
</ul>
<p>We represent floating point saturation by simply calling this intrinsic
on the result of a floating point operation. This works because the
value before saturation fits in the same type.</p>
<p>We do not have an equivalent for integer saturation, because the
before-saturation value needs a bigger integer type than the result.
Instead, any integer operation that supports saturation needs an
intrinsic for the saturating variant.</p>
</div>
<div class="section" id="llvm-genx-trunc-sat-integer-truncation-with-saturation">
<h4><a class="toc-backref" href="#id34"><code class="docutils literal"><span class="pre">llvm.genx.*trunc.sat</span></code> : integer truncation with saturation</a><a class="headerlink" href="#llvm-genx-trunc-sat-integer-truncation-with-saturation" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">llvm.genx.sstrunc.sat</span></code> : signed result, signed operand</li>
<li><code class="docutils literal"><span class="pre">llvm.genx.sutrunc.sat</span></code> : signed result, unsigned operand</li>
<li><code class="docutils literal"><span class="pre">llvm.genx.ustrunc.sat</span></code> : unsigned result, signed operand</li>
<li><code class="docutils literal"><span class="pre">llvm.genx.uutrunc.sat</span></code> : unsigned result, unsigned operand</li>
<li>arg0: value to truncate, any scalar or vector integer type</li>
<li><dl class="first docutils">
<dt>Return value: truncated value, any scalar or vector integer type</dt>
<dd>with same vector width as arg0</dd>
</dl>
</li>
</ul>
</div>
</div>
<div class="section" id="modifier-intrinsics">
<h3><a class="toc-backref" href="#id35">Modifier intrinsics</a><a class="headerlink" href="#modifier-intrinsics" title="Permalink to this headline">¶</a></h3>
<p>Abs is the only source modifier that is represented
by an intrinsic; neg(x) uses 0-x, and not(x) uses x^-1.</p>
<div class="section" id="llvm-genx-abs-take-absolute-value">
<h4><a class="toc-backref" href="#id36"><code class="docutils literal"><span class="pre">llvm.genx.abs*</span></code> : take absolute value</a><a class="headerlink" href="#llvm-genx-abs-take-absolute-value" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">llvm.genx.absf</span></code> : abs modifier for fp</li>
<li><code class="docutils literal"><span class="pre">llvm.genx.absi</span></code> : abs modifier for integer</li>
<li>arg0: input value, scalar/vector</li>
<li>Return value: result, same type</li>
</ul>
</div>
</div>
<div class="section" id="boolean-reduction-intrinsics">
<h3><a class="toc-backref" href="#id37">Boolean reduction intrinsics</a><a class="headerlink" href="#boolean-reduction-intrinsics" title="Permalink to this headline">¶</a></h3>
<div class="section" id="llvm-genx-all-true-if-all-input-elements-are-true">
<h4><a class="toc-backref" href="#id38"><code class="docutils literal"><span class="pre">llvm.genx.all</span></code> : true if all input elements are true</a><a class="headerlink" href="#llvm-genx-all-true-if-all-input-elements-are-true" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>arg0: input value: v*i1</li>
<li>Return value: i1 result</li>
</ul>
</div>
<div class="section" id="llvm-genx-any-true-if-any-input-element-is-true">
<h4><a class="toc-backref" href="#id39"><code class="docutils literal"><span class="pre">llvm.genx.any</span></code> : true if any input element is true</a><a class="headerlink" href="#llvm-genx-any-true-if-any-input-element-is-true" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>arg0: input value: v*i1</li>
<li>Return value: i1 result</li>
</ul>
</div>
</div>
<div class="section" id="simd-control-flow-intrinsics">
<h3><a class="toc-backref" href="#id40">SIMD control flow intrinsics</a><a class="headerlink" href="#simd-control-flow-intrinsics" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal"><span class="pre">goto</span></code> and <code class="docutils literal"><span class="pre">join</span></code> instructions are represented by <code class="docutils literal"><span class="pre">llvm.genx.simdcf.goto</span></code>
and <code class="docutils literal"><span class="pre">llvm.genx.simdcf.join</span></code> intrinsics.</p>
<div class="section" id="the-bspec-model">
<h4><a class="toc-backref" href="#id41">The BSpec model</a><a class="headerlink" href="#the-bspec-model" title="Permalink to this headline">¶</a></h4>
<p>The BSpec defines SIMD control flow in terms of each of the 32 channels
having a PcIP (per-channel instruction pointer), which determines where a
disabled channel will be re-enabled:</p>
<ul>
<li><p class="first">A goto has two targets, UIP (update IP) and JIP (join IP).</p>
<ul>
<li><p class="first">A (forward) goto evaluates its vector condition, and, for each channel
that is enabled and the condition is true, it sets the channel’s PcIP to
UIP, to mark that the channel is disabled until execution reaches the
join instruction at UIP. If, after disabling channels in this way, no
channels are left enabled, then execution jumps to JIP.</p>
<p>UIP and JIP may be different, as there may be channels already disabled
from an earlier goto with their PcIPs set to an earlier point than the
present goto’s UIP. So JIP needs to be set to the earliest point that
a channel could have its PcIP pointing at.</p>
</li>
<li><p class="first">There is also a backward goto variant for use in a conditional loop
back edge (end of a do..while loop). It works the same as a forward goto
over an unconditional jump back to the top of the loop.</p>
</li>
</ul>
</li>
<li><p class="first">A join has one target, JIP. It reenables all channels that have PcIP set
to this join. If there are still no channels enabled, it jumps to JIP.</p>
</li>
<li><p class="first">Each instruction’s register write-back is gated by which channels are
enabled, unless the instruction has a nomask bit set. This is in addition
to optionally being gated by a predicate.</p>
</li>
<li><p class="first">The action of the channel enable mask (and predicate) in a send depends
on the shared function. Some (e.g. gather and scatter) have the expected
semantics where disabled channels do not participate in the memory read/write,
and (in the case of a read) do not update that channel’s result.</p>
</li>
</ul>
<p>This scheme allows arbitrarily unstructured SIMD control flow. For it to work
and guarantee convergence, it is sufficient (not sure if it is necessary)
for there to be a linear chain of join points, and each goto/join’s UIP and
JIP are forward in the chain, and JIPs are set correctly so it is not possible
for execution to “miss out” a join point where a channel should have been
enabled. (As above, a backward goto is handled in this
model by being considered a forward goto over a backward unconditional jump.)</p>
<p>In Gen code, this linear chain of join points does not actually have to be in
program order, as long as the join point order with forward UIP and JIP is
derivable.</p>
<p>In vISA, the linear chain of join points does have to be in program order.
vISA does not encode the JIP of a goto/join; instead it derives it itself.
Also, vISA uses whether a goto’s target is before or after to encode whether
it is a conditional loop backedge branch.</p>
</div>
<div class="section" id="the-llvm-ir-model">
<h4><a class="toc-backref" href="#id42">The LLVM IR model</a><a class="headerlink" href="#the-llvm-ir-model" title="Permalink to this headline">¶</a></h4>
<p>The model we use in LLVM IR is very similar to the above.</p>
<p>The PcIP (per-channel instruction pointer) is replaced by:</p>
<ul class="simple">
<li>a global (in the function) EM (execution mask), with each channel having a
bit that is 1 when the channel is enabled;</li>
<li>each join point has a RM (resume mask), with each channel having a bit
that is 1 if the channel is disabled and due to be re-enabled when execution
reaches that join point.</li>
</ul>
<p>A goto is represented by the <code class="docutils literal"><span class="pre">llvm.genx.simdcf.goto</span></code> intrinsic. Its
inputs are the current EM value, the current RM value for its UIP, and the
vector condition. Its results are the updated EM value, the updated RM
value for its UIP, and a scalar bool that says whether all channels are now
disabled and execution should branch to the JIP. This last result is then
(usually) used in a standard LLVM conditional <code class="docutils literal"><span class="pre">br</span></code> instruction.</p>
<p>A goto is implicitly attached to its UIP join by the input and output RM
values being part of a web of RM values connected by goto and phi nodes
and used in that join.</p>
<p>A join is represented by the <code class="docutils literal"><span class="pre">llvm.genx.simdcf.join</span></code> intrinsic. Its
inputs are the current EM value and the current RM value for this join.
Its results are the updated EM value (this join’s RM value is now effectively
all zeros so it not returned as a result), and a scalar bool that says whether
all channels are still disabled and execution should branch to the JIP.
This last result is then (optionally) used in a standard LLVM conditional
<code class="docutils literal"><span class="pre">br</span></code> instruction.</p>
<p>An instruction’s register write-back being gated by which channels are enabled
is modeled by the current EM value (or the appropriate size left slice of it)
being used as the predicate in a select or wrregion or shared function
intrinsic.</p>
<p>Note that EM is always 32 bit, but a join’s RM may be smaller as it has the same
vector width as the condition on all gotos that update it.</p>
<p>This model is equivalent to the BSpec model, as long as:</p>
<ul class="simple">
<li>there is only ever one EM value live at a time with an initial value in a
function of either all ones or the passed in call mask;</li>
<li>for each join point, there is only ever one RM value live at a time with an
initial value in a function of all zeros, and a value after the join point of
all zeros;</li>
<li>it is possible to re-order the code such that the “false” target of a
conditional branch that a goto or join is attached to is fall-through, and
all JIPs and UIPs are forward.</li>
</ul>
<p>Like any other variable with multiple values transformed to SSA, different
EM values may be joined with a phi node. Similarly, for a particular join point’s
RM, different RM values may be joined with a phi node.</p>
<p>The  <code class="docutils literal"><span class="pre">llvm.genx.simdcf.goto</span></code> and <code class="docutils literal"><span class="pre">llvm.genx.simdcf.join</span></code> intrinsics can
only be generated to <code class="docutils literal"><span class="pre">goto</span></code> and <code class="docutils literal"><span class="pre">join</span></code> instructions if the GenX backend
deems them to be used in a way that is equivalent to the BSpec model. Otherwise,
they are lowered to equivalent but slower code that implements the semantics
of the spec of the intrinsics below.</p>
<p>There are more detailed requirements on the use of these intrinsics to be able
to generate them to <code class="docutils literal"><span class="pre">goto</span></code> and <code class="docutils literal"><span class="pre">join</span></code> instructions documented in the
GenXSimdCFConformance pass.</p>
</div>
<div class="section" id="llvm-genx-simdcf-goto-goto-instruction">
<h4><a class="toc-backref" href="#id43"><code class="docutils literal"><span class="pre">llvm.genx.simdcf.goto</span></code> : goto instruction</a><a class="headerlink" href="#llvm-genx-simdcf-goto-goto-instruction" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>arg0: OldEM (old execution mask): v32i1</li>
<li>arg1: OldRM (old resume mask): vector of i1</li>
<li>arg2: SimdCond (the SIMD control flow condition): same type as arg1</li>
</ul>
<p>Return value: struct with the following elements:</p>
<ul class="simple">
<li>ret0: NewEM (updated execution mask): v32i1</li>
<li>ret1: NewRM (updated resume mask): same type as arg1</li>
<li>ret2: BranchCond: i1</li>
</ul>
<p>The elements of the returned struct are calculated as follows:</p>
<ul class="simple">
<li>NewEM = OldEM &amp; (SimdCond one extended to v16i1)</li>
<li>NewRM = OldRM | (OldEM &amp; ~(SimdCond &amp; (OldEM truncated to size of SimdCond)))</li>
<li>BranchCond = !any(NewEM truncated to size of SimdCond)</li>
</ul>
<p><code class="docutils literal"><span class="pre">llvm.genx.simdcf.goto</span></code> represents a Gen goto instruction, taking a
vector condition, modifying the global EM and the UIP’s RM, and
resulting in a scalar condition to be used in a conditional branch whose
“true” successor is the goto’s JIP.</p>
<p>If the BranchCond result is not used, then the goto’s JIP is set to the
join immediately after.</p>
<p>If the BranchCond result is used in a conditional branch, and JIP is
later than the earliest join point
where a channel would be re-enabled, then it is undefined whether the
resulting goto instruction’s JIP is as specified here, or an earlier join
point. (This rule is to allow for the vISA finalizer re-deriving the JIPs.)</p>
<p>If the goto intrinsic’s conditional branch simply branches over an empty block
with an unconditional branch, then the GenX backend takes the intrinsic and
the two branches to be a do..while back edge, giving a Gen <code class="docutils literal"><span class="pre">goto</span></code>
instruction with BranchCtrl=1, UIP set to the successor of the unconditional
branch (the top of the do..while loop), and JIP set to the following join
instruction.</p>
<p>Channels already disabled in EM remain disabled. For enabled channels,
any channel whose element in SimdCond is true becomes disabled in EM, and
the corresponding bit in RM is set such that the channel becomes re-enabled
upon reaching the RM’s join point. If all channels in EM are then disabled,
then BranchCond is true and the conditional branch in which it is used
branches to the next join point in sequence.</p>
<p>Note that SimdCond has the same sense as in the Gen goto instruction, but
the opposite sense to that in a vISA forward goto instruction.</p>
</div>
<div class="section" id="llvm-genx-simdcf-join-join-instruction">
<h4><a class="toc-backref" href="#id44"><code class="docutils literal"><span class="pre">llvm.genx.simdcf.join</span></code> : join instruction</a><a class="headerlink" href="#llvm-genx-simdcf-join-join-instruction" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>arg0: OldEM (old execution mask): v32i1</li>
<li>arg1: RM (resume mask): vector of i1</li>
</ul>
<p>Return value: struct with the following elements:</p>
<ul class="simple">
<li>ret0: NewEM (updated execution mask): v32i1</li>
<li>ret1: BranchCond: i1</li>
</ul>
<p>The elements of the returned struct are calculated as follows:</p>
<ul class="simple">
<li>NewEM = OldEM | (RM zero extended to v32i1)</li>
<li>BranchCond = !any(NewEM truncated to size of RM)</li>
</ul>
<p>This is marked as having side effects to stop LLVM removing an otherwise
unused join at an outer endif.</p>
<p><code class="docutils literal"><span class="pre">llvm.genx.simdcf.join</span></code> represents a Gen join instruction, using the join
point’s RM, modifying the global EM, and resulting in a scalar condition to
be used (optionally) in a conditional branch whose “true” successor is
the join’s JIP.</p>
<p>If the BranchCond result is not used, then the join’s JIP is undefined; this
case is used when it is known that at least one channel is enabled after
the join so JIP will never be used.</p>
<p>If the BranchCond result is used in a conditional branch, and JIP is
later than the earliest join point
where a channel would be re-enabled, then it is undefined whether the
resulting goto instruction’s JIP is as specified here, or an earlier join
point. (This rule is to allow for the vISA finalizer re-deriving the JIPs.)</p>
<p>Note that vISA does not have a join instruction; the vISA finalizer
recovers the join points from the goto instructions assuming a linear order.</p>
<p>Channels with a set bit in RM become enabled in EM. If all channels in EM are
still disabled, then BranchCond is true and the conditional branch in which it
is used branches to the next join point in sequence.</p>
</div>
</div>
<div class="section" id="alu-intrinsics">
<h3><a class="toc-backref" href="#id45">ALU intrinsics</a><a class="headerlink" href="#alu-intrinsics" title="Permalink to this headline">¶</a></h3>
<div class="section" id="add">
<h4><a class="toc-backref" href="#id46">add</a><a class="headerlink" href="#add" title="Permalink to this headline">¶</a></h4>
<p>Non-saturating add intrinsic is not needed. A vISA non-saturating add
where the result type is different to the operand type is represented
by trunc/zext/sext of each operand and then an LLVM IR Add instruction.</p>
</div>
<div class="section" id="llvm-genx-add-sat-add-instruction-with-saturation">
<h4><a class="toc-backref" href="#id47"><code class="docutils literal"><span class="pre">llvm.genx.*add.sat</span></code> : add instruction with saturation</a><a class="headerlink" href="#llvm-genx-add-sat-add-instruction-with-saturation" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">llvm.genx.ssadd.sat</span></code> : result signed, operands signed</li>
<li><code class="docutils literal"><span class="pre">llvm.genx.suadd.sat</span></code> : result signed, operands unsigned</li>
<li><code class="docutils literal"><span class="pre">llvm.genx.usadd.sat</span></code> : result unsigned, operands signed</li>
<li><code class="docutils literal"><span class="pre">llvm.genx.uuadd.sat</span></code> : result unsigned, operands unsigned</li>
<li>arg0: first input, any scalar/vector integer type, even i64</li>
<li>arg1: second input, same type as arg0</li>
<li><dl class="first docutils">
<dt>Return value: result, any scalar or vector integer type with same</dt>
<dd>vector width</dd>
</dl>
</li>
</ul>
<p>For an fp add, use the LLVM IR FAdd instruction, followed by
llvm.genx.sat if saturation is required.</p>
</div>
<div class="section" id="addc">
<h4><a class="toc-backref" href="#id48">addc</a><a class="headerlink" href="#addc" title="Permalink to this headline">¶</a></h4>
<p>No intrinsic for addc as it has two results.</p>
</div>
<div class="section" id="asr">
<h4><a class="toc-backref" href="#id49">asr</a><a class="headerlink" href="#asr" title="Permalink to this headline">¶</a></h4>
<p>asr intrinsic is not needed. Because asr cannot overflow, an asr that
saturates with a smaller result type than the execution type can be
represented by an LLVM IR Asr instruction then an llvm.genx.sstrunc.sat.</p>
</div>
<div class="section" id="llvm-genx-avg-integer-averaging-no-saturation">
<h4><a class="toc-backref" href="#id50"><code class="docutils literal"><span class="pre">llvm.genx.*avg</span></code> : integer averaging, no saturation</a><a class="headerlink" href="#llvm-genx-avg-integer-averaging-no-saturation" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">llvm.genx.ssavg</span></code> : result signed, operands signed</li>
<li><code class="docutils literal"><span class="pre">llvm.genx.suavg</span></code> : result signed, operands unsigned</li>
<li><code class="docutils literal"><span class="pre">llvm.genx.usavg</span></code> : result unsigned, operands signed</li>
<li><code class="docutils literal"><span class="pre">llvm.genx.uuavg</span></code> : result unsigned, operands unsigned</li>
<li>arg0: first input, any scalar/vector integer type (not i64)</li>
<li>arg1: second input, same type as arg0</li>
<li><dl class="first docutils">
<dt>Return value: result, any scalar/vector integer type (not i64)</dt>
<dd>with same vector width</dd>
</dl>
</li>
</ul>
</div>
<div class="section" id="llvm-genx-avg-sat-integer-averaging-with-saturation">
<h4><a class="toc-backref" href="#id51"><code class="docutils literal"><span class="pre">llvm.genx.*avg.sat</span></code> : integer averaging with saturation</a><a class="headerlink" href="#llvm-genx-avg-sat-integer-averaging-with-saturation" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">llvm.genx.ssavg.sat</span></code> : result signed, operands signed</li>
<li><code class="docutils literal"><span class="pre">llvm.genx.suavg.sat</span></code> : result signed, operands unsigned</li>
<li><code class="docutils literal"><span class="pre">llvm.genx.usavg.sat</span></code> : result unsigned, operands signed</li>
<li><code class="docutils literal"><span class="pre">llvm.genx.uuavg.sat</span></code> : result unsigned, operands unsigned</li>
<li>arg0: first input, any scalar/vector integer type (not i64)</li>
<li>arg1: second input, same type as arg0</li>
<li><dl class="first docutils">
<dt>Return value: result, any scalar/vector integer type (not i64)</dt>
<dd>with same vector width</dd>
</dl>
</li>
</ul>
</div>
<div class="section" id="llvm-genx-bfe-bitfield-extract">
<h4><a class="toc-backref" href="#id52"><code class="docutils literal"><span class="pre">llvm.genx.*bfe</span></code> : bitfield extract</a><a class="headerlink" href="#llvm-genx-bfe-bitfield-extract" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">llvm.genx.sbfe</span></code> : bitfield extract, signed result</li>
<li><code class="docutils literal"><span class="pre">llvm.genx.ubfe</span></code> : bitfield extract, unsigned result</li>
<li>arg0: first input, any scalar/vector i32 type</li>
<li>arg1: second input, same type as arg0</li>
<li>arg2: third input, same type as arg0</li>
<li>Return value: result, same type as arg0</li>
</ul>
</div>
<div class="section" id="llvm-genx-bfi-bitfield-insert">
<h4><a class="toc-backref" href="#id53"><code class="docutils literal"><span class="pre">llvm.genx.bfi</span></code> : bitfield insert</a><a class="headerlink" href="#llvm-genx-bfi-bitfield-insert" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>arg0: first input, any scalar/vector i32 type</li>
<li>arg1: second input, same type as arg0</li>
<li>arg2: third input, same type as arg0</li>
<li>arg3: fourth input, same type as arg0</li>
<li>Return value: result, same type as arg0</li>
</ul>
</div>
<div class="section" id="llvm-genx-bfrev-reverse-bits">
<h4><a class="toc-backref" href="#id54"><code class="docutils literal"><span class="pre">llvm.genx.bfrev</span></code> : reverse bits</a><a class="headerlink" href="#llvm-genx-bfrev-reverse-bits" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>arg0: first input, any scalar/vector i32 type</li>
<li>Return value: result, same type as arg0</li>
</ul>
</div>
<div class="section" id="llvm-genx-cbit-count-set-bits">
<h4><a class="toc-backref" href="#id55"><code class="docutils literal"><span class="pre">llvm.genx.cbit</span></code> : count set bits</a><a class="headerlink" href="#llvm-genx-cbit-count-set-bits" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>arg0: first input, any scalar/vector integer type</li>
<li>Return value: result, int32 of same width as arg0</li>
</ul>
</div>
<div class="section" id="cmp">
<h4><a class="toc-backref" href="#id56">cmp</a><a class="headerlink" href="#cmp" title="Permalink to this headline">¶</a></h4>
<p>No intrinsic needed as the LLVM IR ICmp and FCmp instructions cover
vISA functionality</p>
</div>
<div class="section" id="llvm-genx-cos-cos-instruction">
<h4><a class="toc-backref" href="#id57"><code class="docutils literal"><span class="pre">llvm.genx.cos</span></code> : cos instruction</a><a class="headerlink" href="#llvm-genx-cos-cos-instruction" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>arg0: input value, any scalar/vector half/float type</li>
<li>Return value: result, same type</li>
</ul>
</div>
<div class="section" id="div">
<h4><a class="toc-backref" href="#id58">div</a><a class="headerlink" href="#div" title="Permalink to this headline">¶</a></h4>
<p>No intrinsic needed as the LLVM IR SDiv, UDiv and FDiv instructions
cover vISA functionality</p>
</div>
<div class="section" id="llvm-genx-ieee-div-divide-ieee-variant">
<h4><a class="toc-backref" href="#id59"><code class="docutils literal"><span class="pre">llvm.genx.ieee.div</span></code> : Divide, IEEE variant</a><a class="headerlink" href="#llvm-genx-ieee-div-divide-ieee-variant" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>arg0: first input, any scalar/vector float/double type</li>
<li>arg1: second input, same type</li>
<li>Return value: result, same type</li>
</ul>
</div>
<div class="section" id="llvm-genx-dp2-dp2-instruction-dot-product-on-groups-of-4-elements">
<h4><a class="toc-backref" href="#id60"><code class="docutils literal"><span class="pre">llvm.genx.dp2</span></code> : dp2 instruction (dot product on groups of 4 elements)</a><a class="headerlink" href="#llvm-genx-dp2-dp2-instruction-dot-product-on-groups-of-4-elements" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>arg0: first input value, any vector float with a multiple of 4 elements</li>
<li>arg1: second input value, same type as arg0</li>
<li>Return value: result, same type</li>
</ul>
</div>
<div class="section" id="llvm-genx-dp3-dp3-instruction-dot-product-on-groups-of-3-elements">
<h4><a class="toc-backref" href="#id61"><code class="docutils literal"><span class="pre">llvm.genx.dp3</span></code> : dp3 instruction (dot product on groups of 3 elements)</a><a class="headerlink" href="#llvm-genx-dp3-dp3-instruction-dot-product-on-groups-of-3-elements" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>arg0: first input value, any vector float with a multiple of 4 elements</li>
<li>arg1: second input value, same type as arg0</li>
<li>Return value: result, same type</li>
</ul>
</div>
<div class="section" id="llvm-genx-dp4-dp4-instruction-dot-product-on-groups-of-4-elements">
<h4><a class="toc-backref" href="#id62"><code class="docutils literal"><span class="pre">llvm.genx.dp4</span></code> : dp4 instruction (dot product on groups of 4 elements)</a><a class="headerlink" href="#llvm-genx-dp4-dp4-instruction-dot-product-on-groups-of-4-elements" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>arg0: first input value, any vector float with a multiple of 4 elements</li>
<li>arg1: second input value, same type as arg0</li>
<li>Return value: result, same type</li>
</ul>
</div>
<div class="section" id="llvm-genx-dph-dph-instruction-dot-product-homogenous">
<h4><a class="toc-backref" href="#id63"><code class="docutils literal"><span class="pre">llvm.genx.dph</span></code> : dph instruction (dot product homogenous)</a><a class="headerlink" href="#llvm-genx-dph-dph-instruction-dot-product-homogenous" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>arg0: first input value, any vector float with a multiple of 4 elements</li>
<li>arg1: second input value, same type as arg0</li>
<li>Return value: result, same type</li>
</ul>
</div>
<div class="section" id="llvm-genx-exp-base-2-exponent">
<h4><a class="toc-backref" href="#id64"><code class="docutils literal"><span class="pre">llvm.genx.exp</span></code> : base 2 exponent</a><a class="headerlink" href="#llvm-genx-exp-base-2-exponent" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>arg0: input value, any scalar/vector half/float type</li>
<li>Return value: result, same type</li>
</ul>
</div>
<div class="section" id="llvm-genx-fbh-find-bit-high">
<h4><a class="toc-backref" href="#id65"><code class="docutils literal"><span class="pre">llvm.genx.*fbh</span></code> : find bit high</a><a class="headerlink" href="#llvm-genx-fbh-find-bit-high" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">llvm.genx.sfbh</span></code> : find bit high, signed operand</li>
<li><code class="docutils literal"><span class="pre">llvm.genx.ufbh</span></code> : find bit high, unsigned operand</li>
<li>arg0: input value, any scalar/vector i32 type</li>
<li>Return value: result, same type</li>
</ul>
</div>
<div class="section" id="llvm-genx-fbl-find-bit-low">
<h4><a class="toc-backref" href="#id66"><code class="docutils literal"><span class="pre">llvm.genx.fbl</span></code> : find bit low</a><a class="headerlink" href="#llvm-genx-fbl-find-bit-low" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>arg0: input value, any scalar/vector i32 type</li>
<li>Return value: result, same type</li>
</ul>
</div>
<div class="section" id="llvm-genx-frc-fractional-part">
<h4><a class="toc-backref" href="#id67"><code class="docutils literal"><span class="pre">llvm.genx.frc</span></code> : fractional part</a><a class="headerlink" href="#llvm-genx-frc-fractional-part" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>arg0: input value, any scalar/vector float type</li>
<li>Return value: result, same type</li>
</ul>
</div>
<div class="section" id="llvm-genx-inv-reciprocal">
<h4><a class="toc-backref" href="#id68"><code class="docutils literal"><span class="pre">llvm.genx.inv</span></code> : reciprocal</a><a class="headerlink" href="#llvm-genx-inv-reciprocal" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>arg0: input value, any scalar/vector half/float type</li>
<li>Return value: result, same type</li>
</ul>
</div>
<div class="section" id="llvm-genx-line-linear-equation">
<h4><a class="toc-backref" href="#id69"><code class="docutils literal"><span class="pre">llvm.genx.line</span></code> : linear equation</a><a class="headerlink" href="#llvm-genx-line-linear-equation" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>arg0: first input value, vector float with exactly 4 elements</li>
<li>arg1: second input value, vector float with a multiple of 4 elements</li>
<li>Return value: result, same type as arg1</li>
</ul>
</div>
<div class="section" id="llvm-genx-log-base-2-logarithm">
<h4><a class="toc-backref" href="#id70"><code class="docutils literal"><span class="pre">llvm.genx.log</span></code> : base 2 logarithm</a><a class="headerlink" href="#llvm-genx-log-base-2-logarithm" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>arg0: input value, any scalar/vector half/float type</li>
<li>Return value: result, same type</li>
</ul>
</div>
<div class="section" id="llvm-genx-lrp-linear-interpolation">
<h4><a class="toc-backref" href="#id71"><code class="docutils literal"><span class="pre">llvm.genx.lrp</span></code> : linear interpolation</a><a class="headerlink" href="#llvm-genx-lrp-linear-interpolation" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>arg0: first input value, any vector float with a multiple of 4 elements</li>
<li>arg1: second input value, same type as arg0</li>
<li>arg2: third input value, same type as arg0</li>
<li>Return value: result, same type</li>
</ul>
</div>
<div class="section" id="llvm-genx-lzd-leading-zero-detection">
<h4><a class="toc-backref" href="#id72"><code class="docutils literal"><span class="pre">llvm.genx.lzd</span></code> : leading zero detection</a><a class="headerlink" href="#llvm-genx-lzd-leading-zero-detection" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>arg0: input value, any scalar/vector i32 type</li>
<li>Return value: result, same type</li>
</ul>
</div>
<div class="section" id="llvm-genx-mad-mad-instruction-no-saturation">
<h4><a class="toc-backref" href="#id73"><code class="docutils literal"><span class="pre">llvm.genx.*mad</span></code> : mad instruction, no saturation</a><a class="headerlink" href="#llvm-genx-mad-mad-instruction-no-saturation" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">llvm.genx.ssmad</span></code> : result signed, operands signed</li>
<li><code class="docutils literal"><span class="pre">llvm.genx.sumad</span></code> : result signed, operands unsigned</li>
<li><code class="docutils literal"><span class="pre">llvm.genx.usmad</span></code> : result unsigned, operands signed</li>
<li><code class="docutils literal"><span class="pre">llvm.genx.uumad</span></code> : result unsigned, operands unsigned</li>
</ul>
<p>result := arg0 * arg1 + arg2</p>
<ul class="simple">
<li><dl class="first docutils">
<dt>Return value: result, any scalar or vector integer type with same</dt>
<dd>vector width</dd>
</dl>
</li>
<li>arg0: first input, any scalar/vector integer type (not i64)</li>
<li>arg1: second input, same type as arg0</li>
<li>arg2: third input, same type as result</li>
</ul>
</div>
<div class="section" id="llvm-genx-mad-sat-mad-instruction-with-saturation">
<h4><a class="toc-backref" href="#id74"><code class="docutils literal"><span class="pre">llvm.genx.*mad.sat</span></code> : mad instruction with saturation</a><a class="headerlink" href="#llvm-genx-mad-sat-mad-instruction-with-saturation" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">llvm.genx.ssmad.sat</span></code> : result signed, operands signed</li>
<li><code class="docutils literal"><span class="pre">llvm.genx.sumad.sat</span></code> : result signed, operands unsigned</li>
<li><code class="docutils literal"><span class="pre">llvm.genx.usmad.sat</span></code> : result unsigned, operands signed</li>
<li><code class="docutils literal"><span class="pre">llvm.genx.uumad.sat</span></code> : result unsigned, operands unsigned</li>
</ul>
<p>result := sat(arg0 * arg1 + arg2)</p>
<ul class="simple">
<li><dl class="first docutils">
<dt>Return value: result, any scalar or vector integer type with same</dt>
<dd>vector width</dd>
</dl>
</li>
<li>arg0: first input, any scalar/vector integer type (not i64)</li>
<li>arg1: second input, same type as arg0</li>
<li>arg2: third input, same type as result</li>
</ul>
</div>
<div class="section" id="llvm-genx-max-max-instruction">
<h4><a class="toc-backref" href="#id75"><code class="docutils literal"><span class="pre">llvm.genx.*max</span></code> : max instruction</a><a class="headerlink" href="#llvm-genx-max-max-instruction" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">llvm.genx.smax</span></code> : result and operands signed</li>
<li><code class="docutils literal"><span class="pre">llvm.genx.umax</span></code> : result and operands unsigned</li>
<li><code class="docutils literal"><span class="pre">llvm.genx.fmax</span></code> : result and operands float</li>
<li>arg0: first input, any scalar/vector integer/float type, even i64</li>
<li>arg1: second input, same type as arg0</li>
<li><dl class="first docutils">
<dt>Return value: result, any scalar, vector integer/float type with same</dt>
<dd>vector width</dd>
</dl>
</li>
</ul>
<p>There is no need for a saturating variant of this intrinsic.
Because max cannot overflow, a saturating max can be represented
by this non-saturating max followed by the applicable one of the
saturating trunc intrinsics.</p>
</div>
<div class="section" id="llvm-genx-min-min-instruction">
<h4><a class="toc-backref" href="#id76"><code class="docutils literal"><span class="pre">llvm.genx.*min</span></code> : min instruction</a><a class="headerlink" href="#llvm-genx-min-min-instruction" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">llvm.genx.smin</span></code> : result and operands signed</li>
<li><code class="docutils literal"><span class="pre">llvm.genx.umin</span></code> : result and operands unsigned</li>
<li><code class="docutils literal"><span class="pre">llvm.genx.fmin</span></code> : result and operands float</li>
<li>arg0: first input, any scalar/vector integer/float type, even i64</li>
<li>arg1: second input, same type as arg0</li>
<li><dl class="first docutils">
<dt>Return value: result, any scalar or vector integer/float type with same</dt>
<dd>vector width</dd>
</dl>
</li>
</ul>
<p>There is no need for a saturating variant of this intrinsic.
Because min cannot overflow, a saturating min can be represented
by this non-saturating min followed by the applicable one of the
saturating trunc intrinsics.</p>
</div>
<div class="section" id="mod">
<h4><a class="toc-backref" href="#id77">mod</a><a class="headerlink" href="#mod" title="Permalink to this headline">¶</a></h4>
<p>No intrinsic needed as the LLVM IR SRem, URem and FRem instructions
cover vISA functionality</p>
</div>
<div class="section" id="mul">
<h4><a class="toc-backref" href="#id78">mul</a><a class="headerlink" href="#mul" title="Permalink to this headline">¶</a></h4>
<p>Still need non-saaturating mul intrinsic as def-hoist/copy-prop in jitter
cannot fully remove the trunc/zext/sext on each operand.</p>
</div>
<div class="section" id="llvm-genx-mul-mul-instruction-no-saturation">
<h4><a class="toc-backref" href="#id79"><code class="docutils literal"><span class="pre">llvm.genx.*mul</span></code> : mul instruction, no saturation</a><a class="headerlink" href="#llvm-genx-mul-mul-instruction-no-saturation" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">llvm.genx.ssmul</span></code> : result signed, operands signed, signed</li>
<li><code class="docutils literal"><span class="pre">llvm.genx.sumul</span></code> : result signed, operands signed, unsigned</li>
<li><code class="docutils literal"><span class="pre">llvm.genx.usmul</span></code> : result signed, operands unsigned, signed</li>
<li><code class="docutils literal"><span class="pre">llvm.genx.uumul</span></code> : result signed, operands unsigned, unsigned</li>
</ul>
<p>result := arg0 * arg1</p>
<ul class="simple">
<li><dl class="first docutils">
<dt>Return value: result, any scalar or vector integer type with same</dt>
<dd>vector width</dd>
</dl>
</li>
<li>arg0: first input, any scalar/vector integer type (not i64)</li>
<li>arg1: second input, same type as arg0</li>
</ul>
</div>
<div class="section" id="llvm-genx-mul-sat-mul-instruction-with-saturation">
<h4><a class="toc-backref" href="#id80"><code class="docutils literal"><span class="pre">llvm.genx.*mul.sat</span></code> : mul instruction with saturation</a><a class="headerlink" href="#llvm-genx-mul-sat-mul-instruction-with-saturation" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">llvm.genx.ssmul.sat</span></code> : result signed, operands signed</li>
<li><code class="docutils literal"><span class="pre">llvm.genx.sumul.sat</span></code> : result signed, operands unsigned</li>
<li><code class="docutils literal"><span class="pre">llvm.genx.usmul.sat</span></code> : result unsigned, operands signed</li>
<li><code class="docutils literal"><span class="pre">llvm.genx.uumul.sat</span></code> : result unsigned, operands unsigned</li>
<li>arg0: first input, any scalar/vector integer type (not i64)</li>
<li>arg1: second input, same type as arg0</li>
<li><dl class="first docutils">
<dt>Return value: result, any scalar/vector integer type with same</dt>
<dd>vector width, even i64</dd>
</dl>
</li>
</ul>
<p>For an fp mul, use the LLVM IR FMul instruction, followed by
llvm.genx.sat if saturation is required.</p>
</div>
<div class="section" id="llvm-genx-mulh-mulh-instruction-no-saturation">
<h4><a class="toc-backref" href="#id81"><code class="docutils literal"><span class="pre">llvm.genx.*mulh</span></code> : mulh instruction, no saturation</a><a class="headerlink" href="#llvm-genx-mulh-mulh-instruction-no-saturation" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">llvm.genx.smulh</span></code> : signed</li>
<li><code class="docutils literal"><span class="pre">llvm.genx.umulh</span></code> : unsigned</li>
<li>arg0: first input, any scalar/vector i32 type</li>
<li>arg1: second input, same type as arg0</li>
<li>Return value: result, same type as arg0</li>
</ul>
</div>
<div class="section" id="not">
<h4><a class="toc-backref" href="#id82">not</a><a class="headerlink" href="#not" title="Permalink to this headline">¶</a></h4>
<p>Intrinsic not needed; use LLVM IR Xor instruction with -1</p>
</div>
<div class="section" id="or">
<h4><a class="toc-backref" href="#id83">or</a><a class="headerlink" href="#or" title="Permalink to this headline">¶</a></h4>
<p>Intrinsic not needed; use LLVM IR Or instruction</p>
</div>
<div class="section" id="llvm-genx-pln-plane-equation">
<h4><a class="toc-backref" href="#id84"><code class="docutils literal"><span class="pre">llvm.genx.pln</span></code> : plane equation</a><a class="headerlink" href="#llvm-genx-pln-plane-equation" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>arg0: first input value, vector float with exactly 4 elements</li>
<li>arg1: second input value, vector float with a multiple of 16 elements</li>
<li>Return value: result, vector float with half as many elements as arg1</li>
</ul>
</div>
<div class="section" id="llvm-genx-pow-power">
<h4><a class="toc-backref" href="#id85"><code class="docutils literal"><span class="pre">llvm.genx.pow</span></code> : power</a><a class="headerlink" href="#llvm-genx-pow-power" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>arg0: first input, any scalar/vector half/float type</li>
<li>arg1: second input, same type</li>
<li>Return value: result, same type</li>
</ul>
</div>
<div class="section" id="llvm-genx-rndd-round-down">
<h4><a class="toc-backref" href="#id86"><code class="docutils literal"><span class="pre">llvm.genx.rndd</span></code> : round down</a><a class="headerlink" href="#llvm-genx-rndd-round-down" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>arg0: input value, any scalar/vector float type</li>
<li>Return value: result, same type</li>
</ul>
</div>
<div class="section" id="llvm-genx-rnde-round-to-even">
<h4><a class="toc-backref" href="#id87"><code class="docutils literal"><span class="pre">llvm.genx.rnde</span></code> : round to even</a><a class="headerlink" href="#llvm-genx-rnde-round-to-even" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>arg0: input value, any scalar/vector float type</li>
<li>Return value: result, same type</li>
</ul>
</div>
<div class="section" id="llvm-genx-rndu-round-up">
<h4><a class="toc-backref" href="#id88"><code class="docutils literal"><span class="pre">llvm.genx.rndu</span></code> : round up</a><a class="headerlink" href="#llvm-genx-rndu-round-up" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>arg0: input value, any scalar/vector float type</li>
<li>Return value: result, same type</li>
</ul>
</div>
<div class="section" id="llvm-genx-rndz-round-to-zero">
<h4><a class="toc-backref" href="#id89"><code class="docutils literal"><span class="pre">llvm.genx.rndz</span></code> : round to zero</a><a class="headerlink" href="#llvm-genx-rndz-round-to-zero" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>arg0: input value, any scalar/vector float type</li>
<li>Return value: result, same type</li>
</ul>
</div>
<div class="section" id="llvm-genx-rsqrt-reciprocal-square-root">
<h4><a class="toc-backref" href="#id90"><code class="docutils literal"><span class="pre">llvm.genx.rsqrt</span></code> : reciprocal square root</a><a class="headerlink" href="#llvm-genx-rsqrt-reciprocal-square-root" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>arg0: input value, any scalar/vector half/float type</li>
<li>Return value: result, same type</li>
</ul>
</div>
<div class="section" id="llvm-genx-sad2-two-wide-sum-of-absolute-differences">
<h4><a class="toc-backref" href="#id91"><code class="docutils literal"><span class="pre">llvm.genx.*sad2</span></code> : two-wide sum of absolute differences</a><a class="headerlink" href="#llvm-genx-sad2-two-wide-sum-of-absolute-differences" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">llvm.genx.ssad2</span></code> : signed argument and result</li>
<li><code class="docutils literal"><span class="pre">llvm.genx.usad2</span></code> : unsigned argument and result</li>
<li>arg0: first input, vector of i8, multiple of 2 wide</li>
<li>arg1: second input, same type</li>
<li>Return value: result, vector of i16 of same vector width</li>
</ul>
</div>
<div class="section" id="llvm-genx-sad2add-two-wide-sum-of-absolute-differences-and-add">
<h4><a class="toc-backref" href="#id92"><code class="docutils literal"><span class="pre">llvm.genx.*sad2add</span></code> : two-wide sum of absolute differences and add</a><a class="headerlink" href="#llvm-genx-sad2add-two-wide-sum-of-absolute-differences-and-add" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">llvm.genx.sssad2add</span></code> : signed result and args</li>
<li><code class="docutils literal"><span class="pre">llvm.genx.uusad2add</span></code> : unsigned result and args</li>
<li><code class="docutils literal"><span class="pre">llvm.genx.ussad2add</span></code> : unsigned result and signed args</li>
<li><code class="docutils literal"><span class="pre">llvm.genx.susad2add</span></code> : signed result and unsigned args</li>
<li>arg0: first input, vector of i8, multiple of 2 wide</li>
<li>arg1: second input, same type</li>
<li>arg2: third input, vector of i16 of same vector width</li>
<li>Return value: result, same type as arg2</li>
</ul>
</div>
<div class="section" id="llvm-genx-sad2add-sat-two-wide-sum-of-absolute-differences-and-add-saturated">
<h4><a class="toc-backref" href="#id93"><code class="docutils literal"><span class="pre">llvm.genx.*sad2add.sat</span></code> : two-wide sum of absolute differences and add, saturated</a><a class="headerlink" href="#llvm-genx-sad2add-sat-two-wide-sum-of-absolute-differences-and-add-saturated" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">llvm.genx.sssad2add.sat</span></code> : signed result and args</li>
<li><code class="docutils literal"><span class="pre">llvm.genx.uusad2add.sat</span></code> : unsigned result and args</li>
<li><code class="docutils literal"><span class="pre">llvm.genx.ussad2add.sat</span></code> : unsigned result and signed args</li>
<li><code class="docutils literal"><span class="pre">llvm.genx.susad2add.sat</span></code> : signed result and unsigned args</li>
<li>arg0: first input, vector of i8, multiple of 2 wide</li>
<li>arg1: second input, same type</li>
<li>arg2: third input, vector of i16 of same vector width</li>
<li>Return value: result, same type as arg2</li>
</ul>
</div>
<div class="section" id="llvm-genx-shl-shl-instruction-no-saturation">
<h4><a class="toc-backref" href="#id94"><code class="docutils literal"><span class="pre">llvm.genx.*shl</span></code> : shl instruction, no saturation</a><a class="headerlink" href="#llvm-genx-shl-shl-instruction-no-saturation" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">llvm.genx.ssshl</span></code> : result signed, operands signed</li>
<li><code class="docutils literal"><span class="pre">llvm.genx.sushl</span></code> : result signed, operands unsigned</li>
<li><code class="docutils literal"><span class="pre">llvm.genx.usshl</span></code> : result unsigned, operands signed</li>
<li><code class="docutils literal"><span class="pre">llvm.genx.uushl</span></code> : result unsigned, operands unsigned</li>
<li>arg0: first input, any scalar/vector integer type, even i64</li>
<li>arg1: second input, same type as arg0</li>
<li><dl class="first docutils">
<dt>Return value: result, any scalar or vector integer type with same</dt>
<dd>vector width, even i64</dd>
</dl>
</li>
</ul>
</div>
<div class="section" id="llvm-genx-shl-sat-shl-instruction-with-saturation">
<h4><a class="toc-backref" href="#id95"><code class="docutils literal"><span class="pre">llvm.genx.*shl.sat</span></code> : shl instruction with saturation</a><a class="headerlink" href="#llvm-genx-shl-sat-shl-instruction-with-saturation" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">llvm.genx.ssshl.sat</span></code> : result signed, operands signed</li>
<li><code class="docutils literal"><span class="pre">llvm.genx.sushl.sat</span></code> : result signed, operands unsigned</li>
<li><code class="docutils literal"><span class="pre">llvm.genx.usshl.sat</span></code> : result unsigned, operands signed</li>
<li><code class="docutils literal"><span class="pre">llvm.genx.uushl.sat</span></code> : result unsigned, operands unsigned</li>
<li>arg0: first input, any scalar/vector integer type, even i64</li>
<li>arg1: second input, same type as arg0</li>
<li><dl class="first docutils">
<dt>Return value: result, any scalar/vector integer type with same</dt>
<dd>vector width, even i64</dd>
</dl>
</li>
</ul>
</div>
<div class="section" id="shr">
<h4><a class="toc-backref" href="#id96">shr</a><a class="headerlink" href="#shr" title="Permalink to this headline">¶</a></h4>
<p>Intrinsic is not needed. Because shr cannot overflow, an shr that
saturates with a smaller result type than the execution type can be
represented by an LLVM IR Shr instruction then an llvm.genx.sstrunc.sat.</p>
</div>
<div class="section" id="llvm-genx-sin-reciprocal-square-root">
<h4><a class="toc-backref" href="#id97"><code class="docutils literal"><span class="pre">llvm.genx.sin</span></code> : reciprocal square root</a><a class="headerlink" href="#llvm-genx-sin-reciprocal-square-root" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>arg0: input value, any scalar/vector half/float type</li>
<li>Return value: result, same type</li>
</ul>
</div>
<div class="section" id="llvm-genx-sqrt-reciprocal-square-root">
<h4><a class="toc-backref" href="#id98"><code class="docutils literal"><span class="pre">llvm.genx.sqrt</span></code> : reciprocal square root</a><a class="headerlink" href="#llvm-genx-sqrt-reciprocal-square-root" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>arg0: input value, any scalar/vector half/float type</li>
<li>Return value: result, same type</li>
</ul>
</div>
<div class="section" id="llvm-genx-ieee-sqrt-reciprocal-square-root-ieee-variant">
<h4><a class="toc-backref" href="#id99"><code class="docutils literal"><span class="pre">llvm.genx.ieee.sqrt</span></code> : reciprocal square root, IEEE variant</a><a class="headerlink" href="#llvm-genx-ieee-sqrt-reciprocal-square-root-ieee-variant" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>arg0: input value, any scalar/vector float/double type</li>
<li>Return value: result, same type</li>
</ul>
</div>
<div class="section" id="subb">
<h4><a class="toc-backref" href="#id100">subb</a><a class="headerlink" href="#subb" title="Permalink to this headline">¶</a></h4>
<p>No intrinsic for subb as it has two results.</p>
</div>
<div class="section" id="xor">
<h4><a class="toc-backref" href="#id101">xor</a><a class="headerlink" href="#xor" title="Permalink to this headline">¶</a></h4>
<p>Intrinsic not needed; use LLVM IR Xor instruction</p>
</div>
</div>
<div class="section" id="visa-reserved-register-intrinsics">
<h3><a class="toc-backref" href="#id102">vISA reserved register intrinsics</a><a class="headerlink" href="#visa-reserved-register-intrinsics" title="Permalink to this headline">¶</a></h3>
<div class="section" id="llvm-genx-thread-read-thread-id-register">
<h4><a class="toc-backref" href="#id103"><code class="docutils literal"><span class="pre">llvm.genx.thread.*</span></code> : read thread ID register</a><a class="headerlink" href="#llvm-genx-thread-read-thread-id-register" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">llvm.genx.thread.x</span></code> : read vISA v1 (%thread_x)</li>
<li><code class="docutils literal"><span class="pre">llvm.genx.thread.y</span></code> : read vISA v2 (%thread_y)</li>
<li>Return value:  i16 the value read</li>
</ul>
</div>
<div class="section" id="llvm-genx-group-id-read-group-id-register">
<h4><a class="toc-backref" href="#id104"><code class="docutils literal"><span class="pre">llvm.genx.group.id.*</span></code> : read group ID register</a><a class="headerlink" href="#llvm-genx-group-id-read-group-id-register" title="Permalink to this headline">¶</a></h4>
<p><code class="docutils literal"><span class="pre">llvm.genx.group.id.x</span></code> : read vISA v7 (%group_id_x)
<code class="docutils literal"><span class="pre">llvm.genx.group.id.y</span></code> : read vISA v8 (%group_id_y)
<code class="docutils literal"><span class="pre">llvm.genx.group.id.z</span></code> : read vISA v23 (%group_id_z)</p>
<ul class="simple">
<li>Return value:  i32 the value read</li>
</ul>
</div>
<div class="section" id="llvm-genx-timestamp-read-visa-v11-timestamp">
<h4><a class="toc-backref" href="#id105"><code class="docutils literal"><span class="pre">llvm.genx.timestamp</span></code> : read vISA v11 (%timestamp)</a><a class="headerlink" href="#llvm-genx-timestamp-read-visa-v11-timestamp" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>Return value:  vxi32 the value read</li>
</ul>
<p>The vector width must be power of 2 and no larger than 4.</p>
</div>
<div class="section" id="llvm-genx-r0-read-visa-v12-r0">
<h4><a class="toc-backref" href="#id106"><code class="docutils literal"><span class="pre">llvm.genx.r0</span></code> : read vISA v12 (%r0)</a><a class="headerlink" href="#llvm-genx-r0-read-visa-v12-r0" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>Return value:  vxi32 or i32 the value read</li>
</ul>
<p>The vector width must be power of 2 and no larger than 8.</p>
</div>
<div class="section" id="llvm-genx-sr0-read-visa-v18-sr0">
<h4><a class="toc-backref" href="#id107"><code class="docutils literal"><span class="pre">llvm.genx.sr0</span></code> : read vISA v18 (%sr0)</a><a class="headerlink" href="#llvm-genx-sr0-read-visa-v18-sr0" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>Return value:  vxi32 the value read</li>
</ul>
<p>The vector width must be 4</p>
</div>
<div class="section" id="llvm-genx-get-color-read-color-value-of-the-thread-origin">
<h4><a class="toc-backref" href="#id108"><code class="docutils literal"><span class="pre">llvm.genx.get.color</span></code> : read color value of the thread origin</a><a class="headerlink" href="#llvm-genx-get-color-read-color-value-of-the-thread-origin" title="Permalink to this headline">¶</a></h4>
<p>Return Value: i16 the value read</p>
<p>This may not be the most appropriate way to access this value,
but is a stop-gap solution.</p>
</div>
<div class="section" id="llvm-genx-get-hwid-read-hw-id-value">
<h4><a class="toc-backref" href="#id109"><code class="docutils literal"><span class="pre">llvm.genx.get.hwid</span></code> : read hw_id value</a><a class="headerlink" href="#llvm-genx-get-hwid-read-hw-id-value" title="Permalink to this headline">¶</a></h4>
<p>Return Value: i32 the value read</p>
</div>
<div class="section" id="llvm-genx-set-pause-set-the-pause-register-v11-4">
<h4><a class="toc-backref" href="#id110"><code class="docutils literal"><span class="pre">llvm.genx.set.pause</span></code> : set the pause register (v11.4)</a><a class="headerlink" href="#llvm-genx-set-pause-set-the-pause-register-v11-4" title="Permalink to this headline">¶</a></h4>
<p>arg0: length of pause 10 bits (0-4 must be 0)</p>
<p>Return Value: none</p>
<p>Set the pause value - this pauses instruction issue until the value has been
decremented to 0 (decrements every 32 clocks)</p>
<p>We set this intrinsic to have side-effects (last field empty) to stop it being removed as it
otherwise looks dead</p>
</div>
<div class="section" id="llvm-genx-dummy-mov-insert-a-dummy-mov-to-v0">
<h4><a class="toc-backref" href="#id111"><code class="docutils literal"><span class="pre">llvm.genx.dummy.mov</span></code> : insert a dummy mov to v0</a><a class="headerlink" href="#llvm-genx-dummy-mov-insert-a-dummy-mov-to-v0" title="Permalink to this headline">¶</a></h4>
<p>arg0: a value that we want to mov to v0 (usually to trigger a scoreboard dependency)</p>
<p>Return Value: none</p>
<p>This is primarily used to set up scoreboard dependencies. If a value is mov’ed to v0 then it
will trigger a scoreboard dependency check.
As a word (16 bits) is usually the basic type of value that is worked with, you only need to
dummy mov one of these from any payload to correctly trigger the dependency</p>
<p>We set this intrinsic to have side-effects (last field empty) to stop it being removed as it
otherwise looks dead and also to prevent any kind of code motion optimisation</p>
</div>
</div>
<div class="section" id="shared-function-intrinsics">
<h3><a class="toc-backref" href="#id112">Shared function intrinsics</a><a class="headerlink" href="#shared-function-intrinsics" title="Permalink to this headline">¶</a></h3>
<p>These are in the order they appear in the vISA spec, not in
alphabetical order.</p>
<div class="section" id="llvm-genx-dword-atomic-dword-atomic-with-binary-operator">
<h4><a class="toc-backref" href="#id113"><code class="docutils literal"><span class="pre">llvm.genx.dword.atomic.*</span></code> : dword atomic with binary operator</a><a class="headerlink" href="#llvm-genx-dword-atomic-dword-atomic-with-binary-operator" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">llvm.genx.dword.atomic.add</span></code> : vISA DWORD_ATOMIC ADD instruction</li>
<li><code class="docutils literal"><span class="pre">llvm.genx.dword.atomic.sub</span></code> : vISA DWORD_ATOMIC SUB instruction</li>
<li><code class="docutils literal"><span class="pre">llvm.genx.dword.atomic.min</span></code> : vISA DWORD_ATOMIC MIN instruction</li>
<li><code class="docutils literal"><span class="pre">llvm.genx.dword.atomic.max</span></code> : vISA DWORD_ATOMIC MAX instruction</li>
<li><code class="docutils literal"><span class="pre">llvm.genx.dword.atomic.xchg</span></code> : vISA DWORD_ATOMIC XCHG instruction</li>
<li><code class="docutils literal"><span class="pre">llvm.genx.dword.atomic.and</span></code> : vISA DWORD_ATOMIC AND instruction</li>
<li><code class="docutils literal"><span class="pre">llvm.genx.dword.atomic.or</span></code> : vISA DWORD_ATOMIC OR instruction</li>
<li><code class="docutils literal"><span class="pre">llvm.genx.dword.atomic.xor</span></code> : vISA DWORD_ATOMIC XOR instruction</li>
<li><code class="docutils literal"><span class="pre">llvm.genx.dword.atomic.imin</span></code> : vISA DWORD_ATOMIC IMIN instruction</li>
<li><code class="docutils literal"><span class="pre">llvm.genx.dword.atomic.imax</span></code> : vISA DWORD_ATOMIC IMAX instruction</li>
<li>(Exec_size inferred from element offset type)</li>
<li>arg0: vXi1 predicate</li>
<li>arg1: i32 surface index</li>
<li>arg2: vXi32 element offset in bytes</li>
<li>arg3: vXi32 src</li>
<li>arg4: vXi32 original value of the register that the data is read into</li>
<li>Return value: vXi32 the old value read</li>
</ul>
<p>Predicate, element offset, src, and the return value must all have the
same vector width, which must be 1, 8 or 16.</p>
</div>
<div class="section" id="llvm-genx-dword-atomic-dword-atomic-with-fmin-fmax-operation">
<h4><a class="toc-backref" href="#id114"><code class="docutils literal"><span class="pre">llvm.genx.dword.atomic.*</span></code> : dword atomic with fmin/fmax operation</a><a class="headerlink" href="#llvm-genx-dword-atomic-dword-atomic-with-fmin-fmax-operation" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">llvm.genx.dword.atomic.fmin</span></code> : vISA DWORD_ATOMIC FMIN instruction</li>
<li><code class="docutils literal"><span class="pre">llvm.genx.dword.atomic.fmax</span></code> : vISA DWORD_ATOMIC FMAX instruction</li>
<li>(Exec_size inferred from element offset type)</li>
<li>arg0: vXi1 predicate</li>
<li>arg1: i32 surface index</li>
<li>arg2: vXi32 element offset in bytes</li>
<li>arg3: vXfloat src</li>
<li>arg4: vXfloat original value of the register that the data is read into</li>
<li>Return value: vXfloat the old value read</li>
</ul>
<p>Predicate, element offset, src, and the return value must all have the
same vector width, which must be 1, 8 or 16.</p>
</div>
<div class="section" id="llvm-genx-dword-atomic-dword-atomic-with-inc-dec-operation">
<h4><a class="toc-backref" href="#id115"><code class="docutils literal"><span class="pre">llvm.genx.dword.atomic.*</span></code> : dword atomic with inc/dec operation</a><a class="headerlink" href="#llvm-genx-dword-atomic-dword-atomic-with-inc-dec-operation" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">llvm.genx.dword.atomic.inc</span></code> : vISA DWORD_ATOMIC INC instruction</li>
<li><code class="docutils literal"><span class="pre">llvm.genx.dword.atomic.dec</span></code> : vISA DWORD_ATOMIC DEC instruction</li>
<li>(Exec_size inferred from element offset type)</li>
<li>arg0: vXi1 predicate</li>
<li>arg1: i32 surface index</li>
<li>arg2: vXi32 element offset in bytes</li>
<li>arg3: vXi32 original value of the register that the data is read into</li>
<li>Return value: vXi32 the old value read</li>
</ul>
<p>Predicate, element offset, src, and the return value must all have the
same vector width, which must be 1, 8 or 16.</p>
</div>
<div class="section" id="llvm-genx-dword-atomic-cmpxchg-visa-dword-atomic-cmpxchg-instruction">
<h4><a class="toc-backref" href="#id116"><code class="docutils literal"><span class="pre">llvm.genx.dword.atomic.cmpxchg</span></code> : vISA DWORD_ATOMIC CMPXCHG instruction</a><a class="headerlink" href="#llvm-genx-dword-atomic-cmpxchg-visa-dword-atomic-cmpxchg-instruction" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>(Exec_size inferred from element offset type)</li>
<li>arg0: vXi1 predicate</li>
<li>arg1: i32 surface index</li>
<li>arg2: vXi32 element offset in bytes</li>
<li>arg3: vXi32 src0</li>
<li>arg4: vXi32 src1</li>
<li>arg5: vXi32 original value of the register that the data is read into</li>
<li>Return value: vXi32 the old value read</li>
</ul>
<p>Predicate, element offset, src, and the return value must all have the
same vector width, which must be 1, 8 or 16.</p>
</div>
<div class="section" id="llvm-genx-dword-atomic-fcmpwr-visa-dword-atomic-fcmpwr-instruction">
<h4><a class="toc-backref" href="#id117"><code class="docutils literal"><span class="pre">llvm.genx.dword.atomic.fcmpwr</span></code> : vISA DWORD_ATOMIC FCMPWR instruction</a><a class="headerlink" href="#llvm-genx-dword-atomic-fcmpwr-visa-dword-atomic-fcmpwr-instruction" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>(Exec_size inferred from element offset type)</li>
<li>arg0: vXi1 predicate</li>
<li>arg1: i32 surface index</li>
<li>arg2: vXi32 element offset in bytes</li>
<li>arg3: vXfloat src0</li>
<li>arg4: vXfloat src1</li>
<li>arg5: vXfloat original value of the register that the data is read into</li>
<li>Return value: vXfloat the old value read</li>
</ul>
<p>Predicate, element offset, src, and the return value must all have the
same vector width, which must be 1, 8 or 16.</p>
</div>
<div class="section" id="llvm-genx-typed-atomic-atomic-typed-with-binary-operator">
<h4><a class="toc-backref" href="#id118"><code class="docutils literal"><span class="pre">llvm.genx.typed.atomic.*</span></code> : atomic typed with binary operator</a><a class="headerlink" href="#llvm-genx-typed-atomic-atomic-typed-with-binary-operator" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">llvm.genx.typed.atomic.add</span></code> : vISA TYPED_ATOMIC ADD instruction</li>
<li><code class="docutils literal"><span class="pre">llvm.genx.typed.atomic.sub</span></code> : vISA TYPED_ATOMIC SUB instruction</li>
<li><code class="docutils literal"><span class="pre">llvm.genx.typed.atomic.min</span></code> : vISA TYPED_ATOMIC MIN instruction</li>
<li><code class="docutils literal"><span class="pre">llvm.genx.typed.atomic.max</span></code> : vISA TYPED_ATOMIC MAX instruction</li>
<li><code class="docutils literal"><span class="pre">llvm.genx.typed.atomic.xchg</span></code> : vISA TYPED_ATOMIC XCHG instruction</li>
<li><code class="docutils literal"><span class="pre">llvm.genx.typed.atomic.and</span></code> : vISA TYPED_ATOMIC AND instruction</li>
<li><code class="docutils literal"><span class="pre">llvm.genx.typed.atomic.or</span></code> : vISA TYPED_ATOMIC OR instruction</li>
<li><code class="docutils literal"><span class="pre">llvm.genx.typed.atomic.xor</span></code> : vISA TYPED_ATOMIC XOR instruction</li>
<li><code class="docutils literal"><span class="pre">llvm.genx.typed.atomic.imin</span></code> : vISA TYPED_ATOMIC IMIN instruction</li>
<li><code class="docutils literal"><span class="pre">llvm.genx.typed.atomic.imax</span></code> : vISA TYPED_ATOMIC IMAX instruction</li>
<li>(Exec_size inferred from element offset type)</li>
<li>arg0: vXi1 predicate</li>
<li>arg1: i32 surface index</li>
<li>arg2: vXT src</li>
<li>arg3: vXi32 u</li>
<li>arg4: vXi32 v - can be a constant 0 and becomes undef in lowering</li>
<li>arg5: vXi32 r - can be a constant 0 and becomes undef in lowering</li>
<li>arg6: vXi32 LOD - can be constant 0 and becomes undef in lowering</li>
<li>Return value: vXi32 the old value read</li>
</ul>
<p>Predicate, element offset, src, and the return value must all have the
same vector width (which in reality must be 8)</p>
</div>
<div class="section" id="llvm-genx-typed-atomic-atomic-typed-with-fmin-fmax-operation">
<h4><a class="toc-backref" href="#id119"><code class="docutils literal"><span class="pre">llvm.genx.typed.atomic.*</span></code> : atomic typed with fmin/fmax operation</a><a class="headerlink" href="#llvm-genx-typed-atomic-atomic-typed-with-fmin-fmax-operation" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">llvm.genx.typed.atomic.fmin</span></code> : vISA TYPED_ATOMIC FMIN instruction</li>
<li><code class="docutils literal"><span class="pre">llvm.genx.typed.atomic.fmax</span></code> : vISA TYPED_ATOMIC FMAX instruction</li>
<li>(Exec_size inferred from element offset type)</li>
<li>arg0: vXi1 predicate</li>
<li>arg1: i32 surface index</li>
<li>arg2: vXfloat src</li>
<li>arg3: vXi32 u</li>
<li>arg4: vXi32 v - can be a constant 0 and becomes undef in lowering</li>
<li>arg5: vXi32 r - can be a constant 0 and becomes undef in lowering</li>
<li>arg6: vXi32 LOD - can be a constant 0 and becomes undef in lowering</li>
<li>Return value: vXfloat the old value read</li>
</ul>
<p>Predicate, element offset, src, and the return value must all have the
same vector width (which in reality must be 8)</p>
</div>
<div class="section" id="llvm-genx-typed-atomic-atomic-typed-with-inc-dec-operation">
<h4><a class="toc-backref" href="#id120"><code class="docutils literal"><span class="pre">llvm.genx.typed.atomic.*</span></code> : atomic typed with inc/dec operation</a><a class="headerlink" href="#llvm-genx-typed-atomic-atomic-typed-with-inc-dec-operation" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">llvm.genx.typed.atomic.inc</span></code> : vISA TYPED_ATOMIC INC instruction</li>
<li><code class="docutils literal"><span class="pre">llvm.genx.typed.atomic.dec</span></code> : vISA TYPED_ATOMIC DEC instruction</li>
<li>(Exec_size inferred from element offset type)</li>
<li>arg0: vXi1 predicate</li>
<li>arg1: i32 surface index</li>
<li>arg2: vXi32 u</li>
<li>arg3: vXi32 v - can be a constant 0 and becomes undef in lowering</li>
<li>arg4: vXi32 r - can be a constant 0 and becomes undef in lowering</li>
<li>arg5: vXi32 LOD - can be a constant 0 and becomes undef in lowering</li>
<li>Return value: vXi32 the old value read</li>
</ul>
<p>Predicate, element offset, src, and the return value must all have the
same vector width (which in reality must be 8)</p>
</div>
<div class="section" id="llvm-genx-typed-atomic-cmpxchg-visa-typed-atomic-cmpxchg-instruction">
<h4><a class="toc-backref" href="#id121"><code class="docutils literal"><span class="pre">llvm.genx.typed.atomic.cmpxchg</span></code> : vISA TYPED_ATOMIC CMPXCHG instruction</a><a class="headerlink" href="#llvm-genx-typed-atomic-cmpxchg-visa-typed-atomic-cmpxchg-instruction" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>(Exec_size inferred from element offset type)</li>
<li>arg0: vXi1 predicate</li>
<li>arg1: i32 surface index</li>
<li>arg2: vXT src0</li>
<li>arg3: vXT src1</li>
<li>arg3: vXi32 u</li>
<li>arg4: vXi32 v - can be a constant 0 and becomes undef in lowering</li>
<li>arg5: vXi32 r - can be a constant 0 and becomes undef in lowering</li>
<li>arg6: vXi32 LOD - can be a constant 0 and becomes undef in lowering</li>
<li>Return value: vXi32 the old value read</li>
</ul>
<p>Predicate, element offset, src, and the return value must all have the
same vector width (which in reality must be 8)</p>
</div>
<div class="section" id="llvm-genx-typed-atomic-fcmpwr-visa-typed-atomic-fcmpwr-instruction">
<h4><a class="toc-backref" href="#id122"><code class="docutils literal"><span class="pre">llvm.genx.typed.atomic.fcmpwr</span></code> : vISA TYPED_ATOMIC FCMPWR instruction</a><a class="headerlink" href="#llvm-genx-typed-atomic-fcmpwr-visa-typed-atomic-fcmpwr-instruction" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>(Exec_size inferred from element offset type)</li>
<li>arg0: vXi1 predicate</li>
<li>arg1: i32 surface index</li>
<li>arg2: vXfloat src0</li>
<li>arg2: vXfloat src1</li>
<li>arg3: vXi32 u</li>
<li>arg4: vXi32 v - can be a constant 0 and becomes undef in lowering</li>
<li>arg5: vXi32 r - can be a constant 0 and becomes undef in lowering</li>
<li>arg6: vXi32 LOD - can be a constant 0 and becomes undef in lowering</li>
<li>Return value: vXfloat the old value read</li>
</ul>
<p>Predicate, element offset, src, and the return value must all have the
same vector width (which in reality must be 8)</p>
</div>
<div class="section" id="llvm-genx-gather-orig-visa-gather-instruction">
<h4><a class="toc-backref" href="#id123"><code class="docutils literal"><span class="pre">llvm.genx.gather.orig</span></code> : vISA GATHER instruction</a><a class="headerlink" href="#llvm-genx-gather-orig-visa-gather-instruction" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>arg0: Elt_size inferred from argument type</li>
<li>arg1: i32 is_modified, constant</li>
<li>(Num_elts inferred from data type)</li>
<li>arg2: i32 surface index</li>
<li>arg3: i32 global offset in elements</li>
<li>arg4: vXi32 element offset in elements</li>
<li>arg5: old value of the data read</li>
<li>Return value: the data read</li>
</ul>
<p>The vector width of the return value is the number of elements to read,
which must be 1, 8 or 16.</p>
<p>The element offset arg must have the same vector width.</p>
</div>
<div class="section" id="llvm-genx-gather-scaled-visa-gather-scaled-instruction">
<h4><a class="toc-backref" href="#id124"><code class="docutils literal"><span class="pre">llvm.genx.gather.scaled</span></code> : vISA GATHER_SCALED instruction</a><a class="headerlink" href="#llvm-genx-gather-scaled-visa-gather-scaled-instruction" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>(Exec_size inferred from element offset type)</li>
<li><dl class="first docutils">
<dt>arg0: vXi1 predicate</dt>
<dd>(block size MBZ, means 1 byte)</dd>
</dl>
</li>
<li>arg1: i32 log2 num blocks, constant (0/1/2 for num blocks 1/2/4)</li>
<li>arg2: i16 scale, constant</li>
<li>arg3: i32 surface index</li>
<li>arg4: i32 global offset in bytes</li>
<li>arg5: vXi32 element offset in bytes (X = 8 or 16)</li>
<li>arg6: old value of the data read</li>
<li>Return value: the data read</li>
</ul>
<p>The vector width of the element offset arg is the number of elements to
read, which must be 8 or 16.</p>
<p>The predicate arg must have the same vector width.</p>
<p>The block size must be 1 byte.</p>
<p>Only T0 (SLM) and T5 (stateless) are supported.</p>
<p>The old value of the data read (the return value) must have UD, D or
F type. For 1 and 2 byte (1 x num blocks) reads the upper bytes have
undefined values in the returned value.</p>
<p>This instruction is available for SKL+ in general and it works for pre-SKL
only when scale is 0.</p>
</div>
<div class="section" id="llvm-genx-gather4-orig-visa-gather4-instruction">
<h4><a class="toc-backref" href="#id125"><code class="docutils literal"><span class="pre">llvm.genx.gather4.orig</span></code> : vISA GATHER4 instruction</a><a class="headerlink" href="#llvm-genx-gather4-orig-visa-gather4-instruction" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>arg0: i32 channel mask, constant</li>
<li>arg1: i32 is_modified, constant</li>
<li>arg2: vXi1 predicate (Num_elts inferred from element offset type)</li>
<li>arg3: i32 surface index</li>
<li>arg4: i32 global offset in i32s</li>
<li>arg5: vXi32 element offset in i32s</li>
<li>arg6: old value of the data read</li>
<li>Return value: the data read</li>
</ul>
<p>The vector width of the element offset arg is the number of elements to
read, which must be 8 or 16.</p>
<p>The instruction reads up to 4 channels per element, with the lowest 4
bits of the channel mask arg giving the mask of channels _not_ to read.
The number of 0 bits in that lower 4 bits of the channel mask arg is the
number of channels to read per element.
The vector width of the return value must be the number of elements
times the number of channels to read per element.
The element type of the return value must be i32 or float.</p>
</div>
<div class="section" id="llvm-genx-gather4-scaled-visa-gather4-scaled-instruction">
<h4><a class="toc-backref" href="#id126"><code class="docutils literal"><span class="pre">llvm.genx.gather4.scaled</span></code> : vISA GATHER4_SCALED instruction</a><a class="headerlink" href="#llvm-genx-gather4-scaled-visa-gather4-scaled-instruction" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>(Exec_size inferred from element offset type)</li>
<li>arg0: vXi1 predicate</li>
<li>arg1: i32 channel mask, constant</li>
<li>arg2: i16 scale, constant</li>
<li>arg3: i32 surface index</li>
<li>arg4: i32 global offset in bytes</li>
<li>arg5: vXi32 element offset in bytes</li>
<li>arg6: old value of the data read</li>
<li>Return value: the data read</li>
</ul>
<p>The vector width of the element offset arg is the number of elements to
read, which must be 8 or 16.
The predicate arg must have the same vector width.
The instruction reads up to 4 channels per element, with the lowest 4
bits of the channel mask arg giving the mask of channels _not_ to read.
The number of 0 bits in that lower 4 bits of the channel mask arg is the
number of channels to read per element.
The vector width of the return value must be the number of elements
times the number of channels to read per element.
The element type of the return value must be i32 or float.</p>
</div>
<div class="section" id="llvm-genx-gather4-typed-visa-gather4-typed-instruction">
<h4><a class="toc-backref" href="#id127"><code class="docutils literal"><span class="pre">llvm.genx.gather4.typed</span></code> : vISA GATHER4_TYPED instruction</a><a class="headerlink" href="#llvm-genx-gather4-typed-visa-gather4-typed-instruction" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>arg0: i32 channel mask, constant</li>
<li>arg1: vXi1 predicate (Num_elts inferred from element offset type)</li>
<li>arg2: i32 surface index</li>
<li>arg3: vXi32 U pixel address</li>
<li>arg4: vXi32 V pixel address</li>
<li>arg5: vXi32 R pixel address</li>
<li>arg6: old value of the data read</li>
<li>Return value: the data read</li>
</ul>
<p>The vector widths of the U pixel address, V pixel address and R pixel
address args must be equal and are the number of elements to read, which
must be 8 or 16. (16 is split into 2x 8 by the GenX backend.)
The predicate arg must have the same vector width.
The instruction reads up to 4 channels per element, with the lowest 4
bits of the channel mask arg giving the mask of channels to read.
The number of 1 bits in that lower 4 bits of the channel mask arg is the
number of channels to read per element. Mask “0000” is not allowed.
The vector width of the return value must be the number of elements
times the number of channels to read per element.
The element type of the return value must be i32 or float.</p>
</div>
<div class="section" id="llvm-genx-media-ld-visa-media-ld-instruction">
<h4><a class="toc-backref" href="#id128"><code class="docutils literal"><span class="pre">llvm.genx.media.ld</span></code> : vISA MEDIA_LD instruction</a><a class="headerlink" href="#llvm-genx-media-ld-visa-media-ld-instruction" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>arg0: i32 modifiers, constant</li>
<li>arg1: i32 surface index</li>
<li>arg2: i32 plane, constant</li>
<li>arg3: i32 block width in bytes, constant</li>
<li>(block height inferred from return type size and block width)</li>
<li>arg4: i32 x byte offset</li>
<li>arg5: i32 y byte offset</li>
<li>Return value: the data read.</li>
</ul>
<p>The number of bytes taken by a row in the return value, the “rounded
block width”, is the block width rounded up to the next power of two
no less than 4. The size of the return type must be a multiple of
this rounded block width, and the multiplier is the block height.</p>
<p>The block width has a maximum of 32 (64 on BDW+). The maxmimum byte
size of the return type is 256.</p>
</div>
<div class="section" id="llvm-genx-media-st-visa-media-st-instruction">
<h4><a class="toc-backref" href="#id129"><code class="docutils literal"><span class="pre">llvm.genx.media.st</span></code> : vISA MEDIA_ST instruction</a><a class="headerlink" href="#llvm-genx-media-st-visa-media-st-instruction" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>arg0: i32 modifiers, constant</li>
<li>arg1: i32 surface index</li>
<li>arg2: i32 plane, constant</li>
<li>arg3: i32 block width in bytes, constant</li>
<li>(block height inferred from data type size and block width)</li>
<li>arg4: i32 x byte offset</li>
<li>arg5: i32 y byte offset</li>
<li>arg6: data to write</li>
</ul>
<p>The number of bytes taken by a row in the return value, the “rounded
block width”, is the block width rounded up to the next power of two
no less than 4. The size of the data to write type must be a multiple of
this rounded block width, and the multiplier is the block height.</p>
<p>The block width has a maximum of 32 (64 on BDW+). The maxmimum byte
size of the data to write is 256.</p>
</div>
<div class="section" id="llvm-genx-oword-ld-oword-load-instruction">
<h4><a class="toc-backref" href="#id130"><code class="docutils literal"><span class="pre">llvm.genx.oword.ld*</span></code> : oword load instruction</a><a class="headerlink" href="#llvm-genx-oword-ld-oword-load-instruction" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">llvm.genx.oword.ld</span></code> : vISA OWORD_LD instruction</li>
<li><code class="docutils literal"><span class="pre">llvm.genx.oword.ld.unaligned</span></code> : vISA OWORD_LD_UNALIGNED instruction</li>
<li>(log2 number of owords inferred from return type)</li>
<li>arg0: i32 is_modified, constant</li>
<li>arg1: i32 surface index</li>
<li>arg2: i32 offset (in owords for .ld / in bytes for .ld.unaligned)</li>
<li>Return value: the data read.</li>
</ul>
<p>The byte size of the return type must be 16, 32, 64, or 128.</p>
</div>
<div class="section" id="llvm-genx-oword-st-visa-oword-st-instruction">
<h4><a class="toc-backref" href="#id131"><code class="docutils literal"><span class="pre">llvm.genx.oword.st</span></code> : vISA OWORD_ST instruction</a><a class="headerlink" href="#llvm-genx-oword-st-visa-oword-st-instruction" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>(log2 number of owords inferred from return type)</li>
<li>arg0: i32 surface index</li>
<li>arg1: i32 offset (in owords)</li>
<li>arg2: data to write</li>
</ul>
<p>The byte size of the data to write must be 16, 32, 64, or 128.</p>
</div>
<div class="section" id="llvm-genx-scatter-orig-visa-scatter-instruction">
<h4><a class="toc-backref" href="#id132"><code class="docutils literal"><span class="pre">llvm.genx.scatter.orig</span></code> : vISA SCATTER instruction</a><a class="headerlink" href="#llvm-genx-scatter-orig-visa-scatter-instruction" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>arg0: Elt_size from argument element type</li>
<li>arg1: i32 surface index</li>
<li>arg2: i32 global offset in elements</li>
<li>arg3: vXi32 element offset in elements</li>
<li>arg4: the data to write. The first &lt;num_elts&gt; elements will be used.</li>
</ul>
<p>The operand must have one of UD, D, F type; for 1 and 2 byte accesses the upper
bits will be ignored.</p>
<p>The vector width of the data to write is the number of elements to write,
which must be 1, 8 or 16.
The element offset arg must have the same vector width.</p>
</div>
<div class="section" id="llvm-genx-scatter-scaled-visa-scatter-scaled-instruction">
<h4><a class="toc-backref" href="#id133"><code class="docutils literal"><span class="pre">llvm.genx.scatter.scaled</span></code> : vISA SCATTER_SCALED instruction</a><a class="headerlink" href="#llvm-genx-scatter-scaled-visa-scatter-scaled-instruction" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>(Exec_size inferred from element offset type)</li>
<li><dl class="first docutils">
<dt>arg0: vXi1 predicate</dt>
<dd>(block size MBZ, means 1 byte)</dd>
</dl>
</li>
<li>arg1: i32 log2 num blocks, constant (0/1/2 for num blocks 1/2/4)</li>
<li>arg2: i16 scale, constant</li>
<li>arg3: i32 surface index</li>
<li>arg4: i32 global offset in bytes</li>
<li>arg5: vXi32 element offset (X = 8 or 16)</li>
<li>arg6: data to write</li>
</ul>
<p>The vector width of the element offset arg is the number of elements to
write, which must be 8 or 16.</p>
<p>The predicate arg must have the same vector width.</p>
<p>The block size must be 1 byte.</p>
<p>Only T0 (SLM) and T5 (stateless) are supported.</p>
<p>The data type to write must have UD, D or F type. For 1 and 2 byte (1 x num
blocks) accesses the upper bytes will be ignored.</p>
<p>This instruction is available for SKL+ in general and it works for pre-SKL
only when scale is 0.</p>
</div>
<div class="section" id="llvm-genx-scatter4-orig-visa-scatter4-instruction">
<h4><a class="toc-backref" href="#id134"><code class="docutils literal"><span class="pre">llvm.genx.scatter4.orig</span></code> : vISA SCATTER4 instruction</a><a class="headerlink" href="#llvm-genx-scatter4-orig-visa-scatter4-instruction" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>arg0: i32 channel mask, constant</li>
<li>arg1: vXi1 predicate (Num_elts inferred from element offset type)</li>
<li>arg2: i32 surface index</li>
<li>arg3: i32 global offset in i32s</li>
<li>arg4: vXi32 element offset in i32s</li>
<li>arg5: the data to write</li>
</ul>
<p>The vector width of the element offset arg is the number of elements to
read, which must be 8 or 16.
The predicate arg must either have the same vector width, or be a scalar
i1 constant with value 1.
The instruction writes up to 4 channels per element, with the lowest 4
bits of the channel mask arg giving the mask of channels _not_ to write.
The number of 0 bits in that lower 4 bits of the channel mask arg is the
number of channels to write per element.
The vector width of the data to write arg must be the number of elements
times the number of channels to write per element.
The element type of the data to write must be i32 or float.</p>
</div>
<div class="section" id="llvm-genx-scatter4-scaled-visa-scatter4-scaled-instruction">
<h4><a class="toc-backref" href="#id135"><code class="docutils literal"><span class="pre">llvm.genx.scatter4.scaled</span></code> : vISA SCATTER4_SCALED instruction</a><a class="headerlink" href="#llvm-genx-scatter4-scaled-visa-scatter4-scaled-instruction" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>(Exec_size inferred from element offset type)</li>
<li>arg0: vXi1 predicate</li>
<li>arg1: i32 channel mask, constant</li>
<li>arg2: i16 scale, constant</li>
<li>arg3: i32 surface index</li>
<li>arg4: i32 global offset in bytes</li>
<li>arg5: vXi32 element offset in bytes</li>
<li>arg6: data to write</li>
</ul>
<p>The vector width of the element offset arg is the number of elements to
write, which must be 8 or 16.
The predicate arg must have the same vector width.
The instruction writes up to 4 channels per element, with the lowest 4
bits of the channel mask arg giving the mask of channels _not_ to read.
The number of 0 bits in that lower 4 bits of the channel mask arg is the
number of channels to write per element.
The channels to write must be contiguous and starting at channel 0.
The vector width of the data to write must be the number of elements
times the number of channels to write per element.
The element type of the data to write must be i32 or float.</p>
</div>
<div class="section" id="llvm-genx-scatter4-typed-visa-scatter4-typed-instruction">
<h4><a class="toc-backref" href="#id136"><code class="docutils literal"><span class="pre">llvm.genx.scatter4.typed</span></code> : vISA SCATTER4_TYPED instruction</a><a class="headerlink" href="#llvm-genx-scatter4-typed-visa-scatter4-typed-instruction" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>arg0: i32 channel mask, constant</li>
<li>arg1: vXi1 predicate (Num_elts inferred from U pixel address type)</li>
<li>arg2: i32 surface index</li>
<li>arg3: v8Xi32 U pixel address</li>
<li>arg4: v8Xi32 V pixel address</li>
<li>arg5: v8Xi32 R pixel address</li>
<li>arg6: data to write</li>
</ul>
<p>The vector widths of the U pixel address, V pixel address and R pixel
address args must be equal and are the number of elements to write, which
must be 8 or 16. (16 is split into 2x 8 by the GenX backend.)
The predicate arg must have the same vector width.
The instruction writes up to 4 channels per element, with the lowest 4
bits of the channel mask arg giving the mask of channels to write.
The number of 1 bits in that lower 4 bits of the channel mask arg is the
number of channels to write per element. Mask “0000” is not allowed.
The vector width of the return value must be the number of elements
times the number of channels to read per element.
The element type of the source value must be i32 or float.</p>
</div>
<div class="section" id="llvm-genx-transpose-ld-visa-transpose-ld-instruction">
<h4><a class="toc-backref" href="#id137"><code class="docutils literal"><span class="pre">llvm.genx.transpose.ld</span></code> : vISA TRANSPOSE_LD instruction</a><a class="headerlink" href="#llvm-genx-transpose-ld-visa-transpose-ld-instruction" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>arg0: i32 surface index</li>
<li>arg1: i32 log2 block width in i32s, constant (0-3)</li>
<li>(log2 block height inferred from block width and data type, 0-3)</li>
<li>arg2: i32 X offset</li>
<li>arg3: i32 Y offset</li>
<li>Return value: the data read</li>
</ul>
<p>The vector width of the return value is the number of elements to read.
This must be a multiple of the block width. The block height is then
inferred from those values.
The element type of the return value must be i32 or float.</p>
</div>
<div class="section" id="llvm-genx-untyped-atomic-visa-untyped-atomic-with-binary-operator">
<h4><a class="toc-backref" href="#id138"><code class="docutils literal"><span class="pre">llvm.genx.untyped.atomic.*</span></code> : vISA UNTYPED_ATOMIC with binary operator</a><a class="headerlink" href="#llvm-genx-untyped-atomic-visa-untyped-atomic-with-binary-operator" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">llvm.genx.untyped.atomic.add</span></code> : vISA UNTYPED_ATOMIC ADD instruction</li>
<li><code class="docutils literal"><span class="pre">llvm.genx.untyped.atomic.sub</span></code> : vISA UNTYPED_ATOMIC SUB instruction</li>
<li><code class="docutils literal"><span class="pre">llvm.genx.untyped.atomic.min</span></code> : vISA UNTYPED_ATOMIC MIN instruction</li>
<li><code class="docutils literal"><span class="pre">llvm.genx.untyped.atomic.max</span></code> : vISA UNTYPED_ATOMIC MAX instruction</li>
<li><code class="docutils literal"><span class="pre">llvm.genx.untyped.atomic.xchg</span></code> : vISA UNTYPED_ATOMIC XCHG instruction</li>
<li><code class="docutils literal"><span class="pre">llvm.genx.untyped.atomic.and</span></code> : vISA UNTYPED_ATOMIC AND instruction</li>
<li><code class="docutils literal"><span class="pre">llvm.genx.untyped.atomic.or</span></code> : vISA UNTYPED_ATOMIC OR instruction</li>
<li><code class="docutils literal"><span class="pre">llvm.genx.untyped.atomic.xor</span></code> : vISA UNTYPED_ATOMIC XOR instruction</li>
<li><code class="docutils literal"><span class="pre">llvm.genx.untyped.atomic.imin</span></code> : vISA UNTYPED_ATOMIC IMIN instruction</li>
<li><code class="docutils literal"><span class="pre">llvm.genx.untyped.atomic.imax</span></code> : vISA UNTYPED_ATOMIC IMAX instruction</li>
<li>arg0: vXi1 predicate (Num_elts inferred from element offset type)</li>
<li>arg1: i32 surface index</li>
<li>arg2: i32 global offset in i32s</li>
<li>arg3: vXi32 element offset in i32s</li>
<li>arg4: vXi32 src</li>
<li>arg5: vXi32 original value of the register that the data is read into</li>
<li>Return value: vXi32 the old value read</li>
</ul>
<p>Predicate, element offset, src, and the return value must all have the</p>
</div>
<div class="section" id="llvm-genx-untyped-atomic-visa-untyped-atomic-with-inc-dec">
<h4><a class="toc-backref" href="#id139"><code class="docutils literal"><span class="pre">llvm.genx.untyped.atomic.*</span></code> : vISA UNTYPED_ATOMIC with inc/dec</a><a class="headerlink" href="#llvm-genx-untyped-atomic-visa-untyped-atomic-with-inc-dec" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">llvm.genx.untyped.atomic.inc</span></code> : vISA UNTYPED_ATOMIC INC instruction</li>
<li><code class="docutils literal"><span class="pre">llvm.genx.untyped.atomic.dec</span></code> : vISA UNTYPED_ATOMIC DEC instruction</li>
<li>arg0: vXi1 predicate (Num_elts inferred from element offset type)</li>
<li>arg1: i32 surface index</li>
<li>arg2: i32 global offset in i32s</li>
<li>arg3: vXi32 element offset in i32s</li>
<li>arg4: vXi32 original value of the register that the data is read into</li>
<li>Return value: vXi32 the old value read</li>
</ul>
<p>Predicate, element offset and the return value must have the same vector
width, which must be 8 or 16.</p>
</div>
<div class="section" id="llvm-genx-untyped-atomic-cmpxchg-visa-untyped-atomic-cmpxchg-instruction">
<h4><a class="toc-backref" href="#id140"><code class="docutils literal"><span class="pre">llvm.genx.untyped.atomic.cmpxchg</span></code> : vISA UNTYPED_ATOMIC CMPXCHG instruction</a><a class="headerlink" href="#llvm-genx-untyped-atomic-cmpxchg-visa-untyped-atomic-cmpxchg-instruction" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>arg0: vXi1 predicate (Num_elts inferred from element offset type)</li>
<li>arg1: i32 surface index</li>
<li>arg2: i32 global offset in i32s</li>
<li>arg3: vXi32 element offset in i32s</li>
<li>arg4: vXi32 src0</li>
<li>arg5: vXi32 src1</li>
<li>arg6: vXi32 original value of the register that the data is read into</li>
<li>Return value: vXi32 the old value read</li>
</ul>
<p>Predicate, element offset, src0, src1, and the return value must all have
the same vector width, which must be 8 or 16.</p>
</div>
<div class="section" id="llvm-genx-svm-block-ld-visa-svm-block-ld-instruction">
<h4><a class="toc-backref" href="#id141"><code class="docutils literal"><span class="pre">llvm.genx.svm.block.ld*</span></code> : vISA SVM BLOCK_LD instruction</a><a class="headerlink" href="#llvm-genx-svm-block-ld-visa-svm-block-ld-instruction" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">llvm.genx.svm.block.ld</span></code> : vISA SVM BLOCK_LD instruction with oword alignment</li>
<li><code class="docutils literal"><span class="pre">llvm.genx.svm.block.ld.unaligned</span></code> : vISA SVM BLOCK_LD instruction with
dword alignment</li>
<li>(log2 number of oword inferred from data type)</li>
<li>arg0: i64 address</li>
<li>Return value: data read</li>
</ul>
<p>The data read must have a size that is a power of two from 16 to 128
bytes.</p>
</div>
<div class="section" id="llvm-genx-svm-block-st-visa-svm-block-st-instruction">
<h4><a class="toc-backref" href="#id142"><code class="docutils literal"><span class="pre">llvm.genx.svm.block.st</span></code> : vISA SVM BLOCK_ST instruction</a><a class="headerlink" href="#llvm-genx-svm-block-st-visa-svm-block-st-instruction" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>(log2 number of oword inferred from data type)</li>
<li>arg0: i64 address</li>
<li>arg1: data to write</li>
</ul>
<p>The data to write must have a size that is a power of two from 16 to 128
bytes.</p>
</div>
<div class="section" id="llvm-genx-svm-gather-visa-svm-gather-instruction">
<h4><a class="toc-backref" href="#id143"><code class="docutils literal"><span class="pre">llvm.genx.svm.gather</span></code> : vISA SVM GATHER instruction</a><a class="headerlink" href="#llvm-genx-svm-gather-visa-svm-gather-instruction" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>(exec size inferred from address vector width)</li>
<li>arg0: vXi1 predicate (Num_elts inferred from this arg)</li>
<li>(block size inferred from data element type)</li>
<li>arg1: i32 log2 num blocks, constant (0/1/2/3 for num blocks 1/2/4/8)</li>
<li>arg2: vXi64 address (X = 8 or 16)</li>
<li>arg3: old value of the data read</li>
<li>Return value: data read</li>
</ul>
<p>The return value element type is i8 for block size 1, i32/float for
block size 4, or i64/double for block size 8.
The return value vector width is the address vector width times
number of blocks (rounded up to 4 if block size is 1).</p>
</div>
<div class="section" id="llvm-genx-svm-gather4-scaled-visa-svm-gather4-scaled-instruction">
<h4><a class="toc-backref" href="#id144"><code class="docutils literal"><span class="pre">llvm.genx.svm.gather4.scaled</span></code> : vISA SVM GATHER4_SCALED instruction</a><a class="headerlink" href="#llvm-genx-svm-gather4-scaled-visa-svm-gather4-scaled-instruction" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>(exec_size inferred from element offset type)</li>
<li>arg0: vXi1 predicate</li>
<li>arg1: i32 channel mask, constant</li>
<li>arg3: i16 scale, constant</li>
<li>arg4: i64 global address in bytes</li>
<li>arg5: vXi64 element offset in bytes</li>
<li>arg6: old value of the data read</li>
<li>Return value: the data read</li>
</ul>
<p>The vector width of the element offset arg is the number of elements to
read, which must be 8 or 16.
The predicate arg must either have the same vector width, or be a scalar
i1 constant with value 1.
The instruction reads up to 4 channels per element, with the lowest 4
bits of the channel mask arg giving the mask of channels _not_ to read.
The number of 0 bits in that lower 4 bits of the channel mask arg is the
number of channels to read per element.
The vector width of the return value must be the number of elements
times the number of channels to read per element.
The element type of the return value must be i32 or float.</p>
</div>
<div class="section" id="llvm-genx-svm-scatter-visa-svm-scatter-instruction">
<h4><a class="toc-backref" href="#id145"><code class="docutils literal"><span class="pre">llvm.genx.svm.scatter</span></code> : vISA SVM SCATTER instruction</a><a class="headerlink" href="#llvm-genx-svm-scatter-visa-svm-scatter-instruction" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>(exec size inferred from address vector width)</li>
<li>arg0: vXi1 predicate (Num_elts inferred from element offset type)</li>
<li>(block size inferred from data element type)</li>
<li>arg1: i32 log2 num blocks, constant (0/1/2/3 for num blocks 1/2/4/8)</li>
<li>arg2: vXi64 address (X = 8 or 16)</li>
<li>arg3: data to write</li>
</ul>
<p>The data to write element type is i8 for block size 1, i32/float for
block size 4, or i64/double for block size 8.
The data vector width is the address vector width times
number of blocks (rounded up to 4 if block size is 1).</p>
</div>
<div class="section" id="llvm-genx-svm-scatter4-scaled-visa-svm-scatter4-scaled-instruction">
<h4><a class="toc-backref" href="#id146"><code class="docutils literal"><span class="pre">llvm.genx.svm.scatter4.scaled</span></code> : vISA SVM SCATTER4_SCALED instruction</a><a class="headerlink" href="#llvm-genx-svm-scatter4-scaled-visa-svm-scatter4-scaled-instruction" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>(exec_size inferred from element offset type)</li>
<li>arg0: vXi1 predicate</li>
<li>arg1: i32 channel mask, constant</li>
<li>arg3: i16 scale, constant</li>
<li>arg4: i64 global address in bytes</li>
<li>arg5: vXi64 element offset in bytes</li>
<li>arg6: data to write</li>
</ul>
<p>The vector width of the element offset arg is the number of elements to
read, which must be 8 or 16.
The predicate arg must either have the same vector width, or be a scalar
i1 constant with value 1.
The instruction writes up to 4 channels per element, with the lowest 4
bits of the channel mask arg giving the mask of channels _not_ to read.
The number of 0 bits in that lower 4 bits of the channel mask arg is the
number of channels to write per element.
The vector width of the data to write arg must be the number of elements
times the number of channels to read per element.
The element type of the data to write arg must be i32 or float.</p>
</div>
<div class="section" id="llvm-genx-svm-atomic-visa-svm-atomic-with-binary-operator">
<h4><a class="toc-backref" href="#id147"><code class="docutils literal"><span class="pre">llvm.genx.svm.atomic.*</span></code> : vISA SVM_ATOMIC with binary operator</a><a class="headerlink" href="#llvm-genx-svm-atomic-visa-svm-atomic-with-binary-operator" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">llvm.genx.svm.atomic.add</span></code> : vISA SVM_ATOMIC ADD instruction</li>
<li><code class="docutils literal"><span class="pre">llvm.genx.svm.atomic.sub</span></code> : vISA SVM_ATOMIC SUB instruction</li>
<li><code class="docutils literal"><span class="pre">llvm.genx.svm.atomic.min</span></code> : vISA SVM_ATOMIC MIN instruction</li>
<li><code class="docutils literal"><span class="pre">llvm.genx.svm.atomic.max</span></code> : vISA SVM_ATOMIC MAX instruction</li>
<li><code class="docutils literal"><span class="pre">llvm.genx.svm.atomic.xchg</span></code> : vISA SVM_ATOMIC XCHG instruction</li>
<li><code class="docutils literal"><span class="pre">llvm.genx.svm.atomic.and</span></code> : vISA SVM_ATOMIC AND instruction</li>
<li><code class="docutils literal"><span class="pre">llvm.genx.svm.atomic.or</span></code> : vISA SVM_ATOMIC OR instruction</li>
<li><code class="docutils literal"><span class="pre">llvm.genx.svm.atomic.xor</span></code> : vISA SVM_ATOMIC XOR instruction</li>
<li><code class="docutils literal"><span class="pre">llvm.genx.svm.atomic.imin</span></code> : vISA SVM_ATOMIC IMIN instruction</li>
<li><code class="docutils literal"><span class="pre">llvm.genx.svm.atomic.imax</span></code> : vISA SVM_ATOMIC IMAX instruction</li>
<li>arg0: vXi1 predicate (Num_elts inferred from this arg)</li>
<li>arg1: vXi64 element addresses in bytes</li>
<li>arg2: vXi32/vXi64 src</li>
<li>arg3: original value of the register that the data is read into</li>
<li>Return value: vXi32/vXi64 the old value read</li>
</ul>
<p>Predicate, element offset, src, and the return value must all have the
same vector width, which must be 1, 2, 4, or 8.</p>
</div>
<div class="section" id="llvm-genx-svm-atomic-visa-svm-atomic-with-inc-dec">
<h4><a class="toc-backref" href="#id148"><code class="docutils literal"><span class="pre">llvm.genx.svm.atomic.*</span></code> : vISA SVM_ATOMIC with inc/dec</a><a class="headerlink" href="#llvm-genx-svm-atomic-visa-svm-atomic-with-inc-dec" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">llvm.genx.svm.atomic.inc</span></code> : vISA SVM_ATOMIC INC instruction</li>
<li><code class="docutils literal"><span class="pre">llvm.genx.svm.atomic.dec</span></code> : vISA SVM_ATOMIC DEC instruction</li>
<li>arg0: vXi1 predicate (Num_elts inferred from this arg)</li>
<li>arg1: vXi64 element addresses in bytes</li>
<li>arg2: vXi32/vXi64 src</li>
<li>arg3: original value of the register that the data is read into</li>
<li>Return value: vXi32/vXi64 the old value read</li>
</ul>
<p>Predicate, element offset and the return value must have the same vector
width, which must be 1, 2, 4 or 8.</p>
</div>
<div class="section" id="llvm-genx-svm-atomic-cmpxchg-visa-svm-atomic-cmpxchg-instruction">
<h4><a class="toc-backref" href="#id149"><code class="docutils literal"><span class="pre">llvm.genx.svm.atomic.cmpxchg</span></code> : vISA SVM_ATOMIC CMPXCHG instruction</a><a class="headerlink" href="#llvm-genx-svm-atomic-cmpxchg-visa-svm-atomic-cmpxchg-instruction" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>arg0: vXi1 predicate (Num_elts inferred from element offset type)</li>
<li>arg1: vXi64 element addresses in bytes</li>
<li>arg2: vXi32/vXi64 src0</li>
<li>arg3: vXi32/vXi64 src1</li>
<li>arg4: original value of the register that the data is read into</li>
<li>Return value: vXi32/vXi64 the old value read</li>
</ul>
<p>Predicate, element offset, src0, src1, and the return value must all have
the same vector width, which must be 1, 2, 4 or 8.</p>
</div>
<div class="section" id="id2">
<h4><a class="toc-backref" href="#id150"><code class="docutils literal"><span class="pre">llvm.genx.svm.atomic.*</span></code> : vISA SVM_ATOMIC with binary operator</a><a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">llvm.genx.svm.atomic.fmin</span></code> : vISA SVM_ATOMIC FMIN instruction</li>
<li><code class="docutils literal"><span class="pre">llvm.genx.svm.atomic.fmax</span></code> : vISA SVM_ATOMIC FMAX instruction</li>
<li>arg0: vXi1 predicate (Num_elts inferred from this arg)</li>
<li>arg1: vXi64 element addresses in bytes</li>
<li>arg2: vXf32 src</li>
<li>arg3: original value of the register that the data is read into</li>
<li>Return value: vXf32 the old value read</li>
</ul>
<p>Predicate, element offset, src, and the return value must all have the
same vector width, which must be 1, 2, 4, or 8.</p>
</div>
<div class="section" id="llvm-genx-svm-atomic-fcmpwr-visa-svm-atomic-fcmpwr-instruction">
<h4><a class="toc-backref" href="#id151"><code class="docutils literal"><span class="pre">llvm.genx.svm.atomic.fcmpwr</span></code> : vISA SVM_ATOMIC FCMPWR instruction</a><a class="headerlink" href="#llvm-genx-svm-atomic-fcmpwr-visa-svm-atomic-fcmpwr-instruction" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>arg0: vXi1 predicate (Num_elts inferred from element offset type)</li>
<li>arg1: vXi64 element addresses in bytes</li>
<li>arg2: vXf32 src0</li>
<li>arg3: vXf32 src1</li>
<li>arg4: original value of the register that the data is read into</li>
<li>Return value: vXf32 the old value read</li>
</ul>
<p>Predicate, element offset, src0, src1, and the return value must all have
the same vector width, which must be 1, 2, 4 or 8.</p>
</div>
<div class="section" id="llvm-genx-load-visa-load-sampler-load-instruction">
<h4><a class="toc-backref" href="#id152"><code class="docutils literal"><span class="pre">llvm.genx.load</span></code> : vISA LOAD (sampler load) instruction</a><a class="headerlink" href="#llvm-genx-load-visa-load-sampler-load-instruction" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>arg0: i32 channel mask, constant (simd_mode inferred from pixel address operands)</li>
<li>arg1: i32 surface index</li>
<li>arg2: vXi32 U pixel address</li>
<li>arg3: vXi32 V pixel address</li>
<li>arg4: vXi32 R pixel address</li>
<li>Return value: the data read</li>
</ul>
<p>The vector widths of the U pixel address, V pixel address and R pixel
address args must be equal, and either 8 or 16.</p>
<p>The instruction reads up to 4 channels per element, with the lowest 4
bits of the channel mask arg giving the mask of channels _not_ to read.
The number of 0 bits in that lower 4 bits of the channel mask arg is the
number of channels to read per element.</p>
<p>For SIMD8 pre-BDW, the vector width of the data read must be 32.
For SIMD8 BDW+, or for SIMD16, the vector width of the data read must be
the SIMD width times the number of enabled channels.</p>
<p>The element type of the return value must be i32 or float.</p>
</div>
<div class="section" id="llvm-genx-sample-visa-sample-instruction">
<h4><a class="toc-backref" href="#id153"><code class="docutils literal"><span class="pre">llvm.genx.sample</span></code> : vISA SAMPLE instruction</a><a class="headerlink" href="#llvm-genx-sample-visa-sample-instruction" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>arg0: i32 channel mask, constant (simd_mode inferred from pixel address operands)</li>
<li>arg1: i32 sampler index</li>
<li>arg2: i32 surface index</li>
<li>arg3: vXfloat U pixel address</li>
<li>arg4: vXfloat V pixel address</li>
<li>arg5: vXfloat R pixel address</li>
<li>Return value: the data read</li>
</ul>
<p>The vector widths of the U pixel address, V pixel address and R pixel
address args must be equal, and either 8 or 16.</p>
<p>The instruction reads up to 4 channels per element, with the lowest 4
bits of the channel mask arg giving the mask of channels _not_ to read.
The number of 0 bits in that lower 4 bits of the channel mask arg is the
number of channels to read per element.</p>
<p>For SIMD8 pre-BDW, the vector width of the data read must be 32.
For SIMD8 BDW+, or for SIMD16, the vector width of the data read must be
the SIMD width times the number of enabled channels.</p>
<p>The element type of the return value must be i32 or float.</p>
</div>
<div class="section" id="llvm-genx-sample-unorm-visa-sample-unorm-instruction">
<h4><a class="toc-backref" href="#id154"><code class="docutils literal"><span class="pre">llvm.genx.sample.unorm</span></code> : vISA SAMPLE_UNORM instruction</a><a class="headerlink" href="#llvm-genx-sample-unorm-visa-sample-unorm-instruction" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>arg0: i32 channel mask, constant</li>
<li>arg1: i32 sampler index</li>
<li>arg2: i32 surface index</li>
<li>arg3: float U pixel address</li>
<li>arg4: float V pixel address</li>
<li>arg5: float DeltaU</li>
<li>arg6: float DeltaV</li>
<li>Return value: v8i16 the data read</li>
</ul>
<p>The instruction reads up to 4 channels per element, with the lowest 4
bits of the channel mask arg giving the mask of channels _not_ to read.
The number of 0 bits in that lower 4 bits of the channel mask arg is the
number of channels to read per element.</p>
</div>
<div class="section" id="llvm-genx-3d-sample-visa-3d-sample-instruction">
<h4><a class="toc-backref" href="#id155"><code class="docutils literal"><span class="pre">llvm.genx.3d.sample</span></code> : vISA 3D_SAMPLE instruction</a><a class="headerlink" href="#llvm-genx-3d-sample-visa-3d-sample-instruction" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>arg0: i32 opcode, constant</li>
<li>arg1: vXi1 predicate mask, used to determine execution size</li>
<li>arg2: i32 channel mask, constant</li>
<li>arg3: i16 aoffimmi</li>
<li>arg4: i32 sampler index</li>
<li>arg5: i32 surface index</li>
<li>argN: vXf or vXhf operand, for 6 &lt;= N &lt;= 20</li>
<li>Return value: the data read</li>
</ul>
</div>
<div class="section" id="llvm-genx-3d-load-visa-3d-load-instruction">
<h4><a class="toc-backref" href="#id156"><code class="docutils literal"><span class="pre">llvm.genx.3d.load</span></code> : vISA 3D_LOAD instruction</a><a class="headerlink" href="#llvm-genx-3d-load-visa-3d-load-instruction" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>arg0: i32 opcode, constant</li>
<li>arg1: vXi1 predicate mask, used to determine execution size</li>
<li>arg2: i32 channel mask, constant</li>
<li>arg3: i16 aoffimmi</li>
<li>arg4: i32 surface index</li>
<li>argN: vXf or vXhf operand, for 5 &lt;= N &lt;= 19</li>
<li>Return value: the data read</li>
</ul>
</div>
<div class="section" id="llvm-genx-avs-visa-avs-instruction">
<h4><a class="toc-backref" href="#id157"><code class="docutils literal"><span class="pre">llvm.genx.avs</span></code> : vISA AVS instruction</a><a class="headerlink" href="#llvm-genx-avs-visa-avs-instruction" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>arg0: i32 channel mask, constant</li>
<li>arg1: i32 sampler index</li>
<li>arg2: i32 surface index</li>
<li>arg3: float U offset</li>
<li>arg4: float V offset</li>
<li>arg5: float deltaU</li>
<li>arg6: float deltaV</li>
<li>arg7: float u2d</li>
<li>arg8: i32 groupID</li>
<li>arg9: i32 verticalBlockNumber</li>
<li>arg10: i32 Output format control, constant</li>
<li>arg11: float v2d</li>
<li>arg12: i32 execMode, constant</li>
<li>arg13: i8 IEFBypass</li>
<li>Return value: the data read.</li>
</ul>
<p>The actual data returned is determined by a combination of &lt;channel&gt;,
&lt;cntrl&gt;, &lt;execMode&gt;, as well as whether output shuffle is enabled in the
sampler state.</p>
<p>SIMD Control Flow: channel enable is ignored.</p>
</div>
<div class="section" id="llvm-genx-barrier-visa-barrier-instruction">
<h4><a class="toc-backref" href="#id158"><code class="docutils literal"><span class="pre">llvm.genx.barrier</span></code> : vISA BARRIER instruction</a><a class="headerlink" href="#llvm-genx-barrier-visa-barrier-instruction" title="Permalink to this headline">¶</a></h4>
</div>
<div class="section" id="llvm-genx-sbarrier-visa-sbarrier-instruction">
<h4><a class="toc-backref" href="#id159"><code class="docutils literal"><span class="pre">llvm.genx.sbarrier</span></code> : vISA SBARRIER instruction</a><a class="headerlink" href="#llvm-genx-sbarrier-visa-sbarrier-instruction" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>arg0: i8 signal flag, constant</li>
</ul>
</div>
<div class="section" id="llvm-genx-cache-flush-visa-cache-flush-instruction">
<h4><a class="toc-backref" href="#id160"><code class="docutils literal"><span class="pre">llvm.genx.cache.flush</span></code> : vISA CACHE_FLUSH instruction</a><a class="headerlink" href="#llvm-genx-cache-flush-visa-cache-flush-instruction" title="Permalink to this headline">¶</a></h4>
</div>
<div class="section" id="llvm-genx-fence-visa-fence-instruction">
<h4><a class="toc-backref" href="#id161"><code class="docutils literal"><span class="pre">llvm.genx.fence</span></code> : vISA FENCE instruction</a><a class="headerlink" href="#llvm-genx-fence-visa-fence-instruction" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>arg0: i8 mask, constant</li>
</ul>
</div>
<div class="section" id="llvm-genx-wait-visa-wait-instruction">
<h4><a class="toc-backref" href="#id162"><code class="docutils literal"><span class="pre">llvm.genx.wait</span></code> : vISA WAIT instruction</a><a class="headerlink" href="#llvm-genx-wait-visa-wait-instruction" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>arg0: i8 thread mask</li>
</ul>
</div>
<div class="section" id="llvm-genx-yield-visa-yield-instruction">
<h4><a class="toc-backref" href="#id163"><code class="docutils literal"><span class="pre">llvm.genx.yield</span></code> : vISA YIELD instruction</a><a class="headerlink" href="#llvm-genx-yield-visa-yield-instruction" title="Permalink to this headline">¶</a></h4>
</div>
<div class="section" id="llvm-genx-raw-send-visa-raw-send-instruction">
<h4><a class="toc-backref" href="#id164"><code class="docutils literal"><span class="pre">llvm.genx.raw.send</span></code> : vISA RAW_SEND instruction</a><a class="headerlink" href="#llvm-genx-raw-send-visa-raw-send-instruction" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>arg0  i32 modifier whether it is send or sendc, constant</li>
<li><dl class="first docutils">
<dt>(exec_size inferred from predicate vector width, defaulting to 16</dt>
<dd>if predicate is i1)</dd>
</dl>
</li>
<li>arg1: i1/vXi1 predicate</li>
<li>arg2: i32 extended message descriptor, constant</li>
<li>(numsrc inferred from src size)</li>
<li>(numdst inferred from dst size)</li>
<li>arg3: i32 desc</li>
<li>arg4: src</li>
<li>arg5: old_dst</li>
<li>Return value: dst</li>
</ul>
<p>The SEND instruction has a field for the size of each of src
and dst. These are inferred by rounding the size of each of src and
dst up to the next whole GRF.</p>
<p>If the send writes to the whole of dst, or the program does not care what
was in those registers before, then set old_dst to UndefValue (of the same
type as dst). If on the other hand the send is predicated and the program
needs to see what was in the parts of destination registers not written
by the send, then use old_dst as the “old value of destination registers”
input.</p>
<p>The predicate must be constant i1 with value 1 for a message that is not
predicatable. For a predicatable message, it must be a vector of i1 with
width determining the execution size.</p>
</div>
<div class="section" id="llvm-genx-raw-send-noresult-visa-raw-send-instruction-with-no-result">
<h4><a class="toc-backref" href="#id165"><code class="docutils literal"><span class="pre">llvm.genx.raw.send.noresult</span></code> : vISA RAW_SEND instruction with no result</a><a class="headerlink" href="#llvm-genx-raw-send-noresult-visa-raw-send-instruction-with-no-result" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>arg0  i32 modifier whether it is send or sendc, constant</li>
<li><dl class="first docutils">
<dt>(exec_size inferred from predicate vector width, defaulting to 16</dt>
<dd>if predicate is i1)</dd>
</dl>
</li>
<li>arg1: i1/vXi1 predicate</li>
<li>arg2: i32 extended message descriptor, constant</li>
<li><dl class="first docutils">
<dt>(numsrc inferred from src size)</dt>
<dd>(numdst is 0)</dd>
</dl>
</li>
<li>arg3: i32 desc</li>
<li>arg4: src</li>
</ul>
<p>The SEND instruction has a field for the size of src. This is inferred by
rounding the size of src up to the next whole GRF.</p>
<p>The predicate must be constant i1 with value 1 for a message that is not
predicatable. For a predicatable message, it must be a vector of i1 with
width determining the execution size.</p>
</div>
<div class="section" id="llvm-genx-raw-sends-visa-raw-sends-instruction">
<h4><a class="toc-backref" href="#id166"><code class="docutils literal"><span class="pre">llvm.genx.raw.sends</span></code> : vISA RAW_SENDS instruction</a><a class="headerlink" href="#llvm-genx-raw-sends-visa-raw-sends-instruction" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>arg0  i32 modifier whether it is send or sendc, constant</li>
<li><dl class="first docutils">
<dt>(exec_size inferred from predicate vector width, defaulting to 16</dt>
<dd>if predicate is i1)</dd>
</dl>
</li>
<li>arg1: i1/vXi1 predicate</li>
<li>arg2: i32 extended message descriptor, constant</li>
<li>(numsrc inferred from src size)</li>
<li>(numsrc2 inferred from src2 size)</li>
<li>(numdst inferred from dst size)</li>
<li>arg3: i32 desc</li>
<li>arg4: src</li>
<li>arg5: src2</li>
<li>arg6: old_dst</li>
<li>Return value: dst</li>
</ul>
<p>The SENDS instruction has a field for the size of each of src, src2
and dst. These are inferred by rounding the size of each of src, src2 and
dst up to the next whole GRF.</p>
<p>If the send writes to the whole of dst, or the program does not care what
was in those registers before, then set old_dst to UndefValue (of the same
type as dst). If on the other hand the send is predicated and the program
needs to see what was in the parts of destination registers not written
by the send, then use old_dst as the “old value of destination registers”
input.</p>
<p>The predicate must be constant i1 with value 1 for a message that is not
predicatable. For a predicatable message, it must be a vector of i1 with
width determining the execution size.</p>
</div>
<div class="section" id="llvm-genx-raw-sends-noresult-visa-raw-sends-instruction-with-no-result">
<h4><a class="toc-backref" href="#id167"><code class="docutils literal"><span class="pre">llvm.genx.raw.sends.noresult</span></code> : vISA RAW_SENDS instruction with no result</a><a class="headerlink" href="#llvm-genx-raw-sends-noresult-visa-raw-sends-instruction-with-no-result" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>arg0  i32 modifier whether it is send or sendc, constant</li>
<li><dl class="first docutils">
<dt>(exec_size inferred from predicate vector width, defaulting to 16</dt>
<dd>if predicate is i1)</dd>
</dl>
</li>
<li>arg1: i1/vXi1 predicate</li>
<li>arg2: i32 extended message descriptor</li>
<li>(numsrc inferred from src size)</li>
<li>(numsrc2 inferred from src2 size)</li>
<li>(numdst is 0)</li>
<li>arg3: i32 desc</li>
<li>arg4: src</li>
<li>arg5: src2</li>
</ul>
<p>The SENDS instruction has a field for the size of each of src and src2.
These are inferred by rounding the size of each of src and src2 up to the
next whole GRF.</p>
<p>The predicate must be constant i1 with value 1 for a message that is not
predicatable. For a predicatable message, it must be a vector of i1 with
width determining the execution size.</p>
<div class="section" id="video-analytics-instrinsics">
<h5><a class="toc-backref" href="#id168">Video Analytics Instrinsics</a><a class="headerlink" href="#video-analytics-instrinsics" title="Permalink to this headline">¶</a></h5>
</div>
</div>
<div class="section" id="llvm-genx-va-convolve2d-visa-va-2d-convolve-instruction">
<h4><a class="toc-backref" href="#id169"><code class="docutils literal"><span class="pre">llvm.genx.va.convolve2d</span></code> vISA VA 2d Convolve instruction</a><a class="headerlink" href="#llvm-genx-va-convolve2d-visa-va-2d-convolve-instruction" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>arg0: i32 sampler index</li>
<li>arg1: i32 surface index</li>
<li>arg2: float normalized x-coordinate</li>
<li>arg3: float normalized y-coordinate</li>
<li>arg4: i32 properties value specifying return data format and input region size, constant</li>
<li>Return value: v64i16 or v16i16 matrix, depending on properties value</li>
</ul>
</div>
<div class="section" id="llvm-genx-va-hdc-convolve2d-visa-va-hdc-2d-convolve-instruction">
<h4><a class="toc-backref" href="#id170"><code class="docutils literal"><span class="pre">llvm.genx.va.hdc.convolve2d</span></code> vISA VA HDC 2d Convolve instruction</a><a class="headerlink" href="#llvm-genx-va-hdc-convolve2d-visa-va-hdc-2d-convolve-instruction" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>arg0: i32 sampler index</li>
<li>arg1: i32 surface index</li>
<li>arg2: float normalized x-coordinate</li>
<li>arg3: float normalized y-coordinate</li>
<li>arg4: i32 properties value specifying return data format and input region size, constant</li>
<li>arg5: i32 destination surface</li>
<li>arg6: i16 destination surface x-offset</li>
<li>arg7: i16 destination surface y-offset</li>
</ul>
</div>
<div class="section" id="llvm-genx-va-erode-visa-va-erode-instruction">
<h4><a class="toc-backref" href="#id171"><code class="docutils literal"><span class="pre">llvm.genx.va.erode</span></code> vISA VA Erode instruction</a><a class="headerlink" href="#llvm-genx-va-erode-visa-va-erode-instruction" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>arg0: i32 sampler index</li>
<li>arg1: i32 surface index</li>
<li>arg2: float normalized x-coordinate</li>
<li>arg3: float normalized y-coordinate</li>
<li>arg4: i32 properties value specifying return data format, constant</li>
<li>Return value: vXi32</li>
</ul>
</div>
<div class="section" id="llvm-genx-va-hdc-erode-visa-va-hdc-erode-instruction">
<h4><a class="toc-backref" href="#id172"><code class="docutils literal"><span class="pre">llvm.genx.va.hdc.erode</span></code> vISA VA HDC Erode instruction</a><a class="headerlink" href="#llvm-genx-va-hdc-erode-visa-va-hdc-erode-instruction" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>arg0: i32 sampler index</li>
<li>arg1: i32 surface index</li>
<li>arg2: float normalized x-coordinate</li>
<li>arg3: float normalized y-coordinate</li>
<li>arg4: i32 destination surface</li>
<li>arg5: i16 destination surface x-offset</li>
<li>arg6: i16 destination surface y-offset</li>
</ul>
</div>
<div class="section" id="llvm-genx-va-dilate-visa-va-dilate-instruction">
<h4><a class="toc-backref" href="#id173"><code class="docutils literal"><span class="pre">llvm.genx.va.dilate</span></code> vISA VA Dilate instruction</a><a class="headerlink" href="#llvm-genx-va-dilate-visa-va-dilate-instruction" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>arg0: i32 sampler index</li>
<li>arg1: i32 surface index</li>
<li>arg2: float normalized x-coordinate</li>
<li>arg3: float normalized y-coordinate</li>
<li>arg4: i32 properties value specifying return data format, constant</li>
<li>Return value: vXi32</li>
</ul>
</div>
<div class="section" id="llvm-genx-va-hdc-dilate-visa-va-hdc-dilate-instruction">
<h4><a class="toc-backref" href="#id174"><code class="docutils literal"><span class="pre">llvm.genx.va.hdc.dilate</span></code> vISA VA HDC Dilate instruction</a><a class="headerlink" href="#llvm-genx-va-hdc-dilate-visa-va-hdc-dilate-instruction" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>arg0: i32 sampler index</li>
<li>arg1: i32 surface index</li>
<li>arg2: float normalized x-coordinate</li>
<li>arg3: float normalized y-coordinate</li>
<li>arg4: i32 destination surface</li>
<li>arg5: i16 destination surface x-offset</li>
<li>arg6: i16 destination surface y-offset</li>
</ul>
</div>
<div class="section" id="llvm-genx-va-minmax-visa-minmax-instruction">
<h4><a class="toc-backref" href="#id175"><code class="docutils literal"><span class="pre">llvm.genx.va.minmax</span></code> vISA MinMax instruction</a><a class="headerlink" href="#llvm-genx-va-minmax-visa-minmax-instruction" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>arg0: i32 surface index</li>
<li>arg1: float normalized x-coordinate</li>
<li>arg2: float normalized y-coordinate</li>
<li>arg3: i32 enable specific minmax functionality</li>
<li>Return: v32i8 or v16i16 depending on the surface format</li>
</ul>
</div>
<div class="section" id="llvm-genx-va-minmax-filter-visa-minmax-filter-instruction">
<h4><a class="toc-backref" href="#id176"><code class="docutils literal"><span class="pre">llvm.genx.va.minmax.filter</span></code> vISA MinMax Filter instruction</a><a class="headerlink" href="#llvm-genx-va-minmax-filter-visa-minmax-filter-instruction" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>arg0: i32 sampler index</li>
<li>arg1: i32 surface index</li>
<li>arg2: float normalized x-coordinate</li>
<li>arg3: float normalized y-coordinate</li>
<li>arg4: i32 specifies the size of the minmax value returned, constant</li>
<li>arg5: i32 specifies the return data format, constant</li>
<li>arg6: i32 enable specific minmax functionality</li>
<li>Return: vXi8 or vXi16 depending on return data size and format</li>
</ul>
</div>
<div class="section" id="llvm-genx-va-hdc-minmax-filter-visa-hdc-minmax-filter-instruction">
<h4><a class="toc-backref" href="#id177"><code class="docutils literal"><span class="pre">llvm.genx.va.hdc.minmax.filter</span></code> vISA HDC MinMax Filter instruction</a><a class="headerlink" href="#llvm-genx-va-hdc-minmax-filter-visa-hdc-minmax-filter-instruction" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>arg0: i32 sampler index</li>
<li>arg1: i32 surface index</li>
<li>arg2: float normalized x-coordinate</li>
<li>arg3: float normalized y-coordinate</li>
<li>arg4: i32 return data format, constant</li>
<li>arg5: i32 enable the specific minmax functionality, constant</li>
<li>arg6: i32 destination surface index</li>
<li>arg7: i16 destination surface x-offset</li>
<li>arg8: i16 destination surface y-offset</li>
</ul>
</div>
<div class="section" id="llvm-genx-va-bool-centroid-visa-boolean-centroid-instruction">
<h4><a class="toc-backref" href="#id178"><code class="docutils literal"><span class="pre">llvm.genx.va.bool.centroid</span></code> vISA Boolean Centroid instruction</a><a class="headerlink" href="#llvm-genx-va-bool-centroid-visa-boolean-centroid-instruction" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>arg0: i32 sampler index</li>
<li>arg1: float normalized x-coordinate</li>
<li>arg2: float normalized y-coordinate</li>
<li>arg3: i8 vertical size</li>
<li>arg4: i8 horizontal size</li>
<li>Return: v16i8 or v16i16 depending on surface format</li>
</ul>
</div>
<div class="section" id="llvm-genx-va-centroid-visa-centroid-instruction">
<h4><a class="toc-backref" href="#id179"><code class="docutils literal"><span class="pre">llvm.genx.va.centroid</span></code> vISA Centroid instruction</a><a class="headerlink" href="#llvm-genx-va-centroid-visa-centroid-instruction" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>arg0: i32 sampler index</li>
<li>arg1: float normalized x-coordinate</li>
<li>arg2: float normalized y-coordinate</li>
<li>arg3: i8 vertical size</li>
<li>Return: v32i32</li>
</ul>
</div>
<div class="section" id="llvm-genx-va-1d-convolve-horizontal-visa-1d-convolve-horizontal-instruction">
<h4><a class="toc-backref" href="#id180"><code class="docutils literal"><span class="pre">llvm.genx.va.1d.convolve.horizontal</span></code> vISA 1d convolve horizontal instruction</a><a class="headerlink" href="#llvm-genx-va-1d-convolve-horizontal-visa-1d-convolve-horizontal-instruction" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>arg0: i32 sampler index</li>
<li>arg1: i32 surface index</li>
<li>arg2: float normalized x-coordinate</li>
<li>arg3: float normalized y-coordinate</li>
<li>arg4: i32 mode, constant</li>
<li>Return: v16i16 or v64i16 depending on mode</li>
</ul>
</div>
<div class="section" id="llvm-genx-va-hdc-1d-convolve-horizontal-visa-hdc-1d-convolve-horizontal-instruction">
<h4><a class="toc-backref" href="#id181"><code class="docutils literal"><span class="pre">llvm.genx.va.hdc.1d.convolve.horizontal</span></code> vISA HDC 1d convolve horizontal instruction</a><a class="headerlink" href="#llvm-genx-va-hdc-1d-convolve-horizontal-visa-hdc-1d-convolve-horizontal-instruction" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>arg0: i32 sampler index</li>
<li>arg1: i32 surface index</li>
<li>arg2: float normalized x-coordinate</li>
<li>arg3: float normalized y-coordinate</li>
<li>arg4: i32 pixel size, constant</li>
<li>arg5: i32 destination surface index</li>
<li>arg6: i16 destination surface x-offset</li>
<li>arg7: i16 destination surface y-offset</li>
</ul>
</div>
<div class="section" id="llvm-genx-va-1d-convolve-vertical-visa-1d-convolve-vertical-instruction">
<h4><a class="toc-backref" href="#id182"><code class="docutils literal"><span class="pre">llvm.genx.va.1d.convolve.vertical</span></code> vISA 1d convolve vertical instruction</a><a class="headerlink" href="#llvm-genx-va-1d-convolve-vertical-visa-1d-convolve-vertical-instruction" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>arg0: i32 sampler index</li>
<li>arg1: i32 surface index</li>
<li>arg2: float normalized x-coordinate</li>
<li>arg3: float normalized y-coordinate</li>
<li>arg4: i32 mode, constant</li>
<li>Return: v16i16 or v64i16 depending on mode</li>
</ul>
</div>
<div class="section" id="llvm-genx-va-hdc-1d-convolve-vertical-visa-hdc-1d-convolve-vertical-instruction">
<h4><a class="toc-backref" href="#id183"><code class="docutils literal"><span class="pre">llvm.genx.va.hdc.1d.convolve.vertical</span></code> vISA HDC 1d convolve vertical instruction</a><a class="headerlink" href="#llvm-genx-va-hdc-1d-convolve-vertical-visa-hdc-1d-convolve-vertical-instruction" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>arg0: i32 sampler index</li>
<li>arg1: i32 surface index</li>
<li>arg2: float normalized x-coordinate</li>
<li>arg3: float normalized y-coordinate</li>
<li>arg4: i32 pixel size, constant</li>
<li>arg5: i32 destination surface index</li>
<li>arg6: i16 destination surface x-offset</li>
<li>arg7: i16 destination surface y-offset</li>
</ul>
</div>
<div class="section" id="llvm-genx-va-1pixel-convolve-visa-1-pixel-convolve-instruction">
<h4><a class="toc-backref" href="#id184"><code class="docutils literal"><span class="pre">llvm.genx.va.1pixel.convolve</span></code> vISA 1 Pixel Convolve instruction</a><a class="headerlink" href="#llvm-genx-va-1pixel-convolve-visa-1-pixel-convolve-instruction" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>arg0: i32 sampler index</li>
<li>arg1: i32 surface index</li>
<li>arg2: float normalized x-coordinate</li>
<li>arg3: float normalized y-coordinate</li>
<li>arg4: i32 mode, constant</li>
<li>arg5: v32i16 offsets</li>
<li>Return: v64i16 or v16i16 depending on mode.</li>
</ul>
</div>
<div class="section" id="llvm-genx-va-hdc-1pixel-convolve-visa-hdc-1-pixel-convolve-instruction">
<h4><a class="toc-backref" href="#id185"><code class="docutils literal"><span class="pre">llvm.genx.va.hdc.1pixel.convolve</span></code> vISA HDC 1 Pixel Convolve instruction</a><a class="headerlink" href="#llvm-genx-va-hdc-1pixel-convolve-visa-hdc-1-pixel-convolve-instruction" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>arg0: i32 sampler index</li>
<li>arg1: i32 surface index</li>
<li>arg2: float normalized x-coordinate</li>
<li>arg3: float normalized y-coordinate</li>
<li>arg4: i32 pixel size, constant</li>
<li>arg5: v32i16 offsets</li>
<li>arg6: i32 destination surface index</li>
<li>arg7: i16 destination surface x-offset</li>
<li>arg8: i16 destination surface y-offset</li>
</ul>
</div>
<div class="section" id="llvm-genx-va-1pixel-convolve-1x1mode-visa-1-pixel-convolve-1x1-mode-instruction">
<h4><a class="toc-backref" href="#id186"><code class="docutils literal"><span class="pre">llvm.genx.va.1pixel.convolve.1x1mode</span></code> vISA 1 Pixel Convolve (1x1 mode) instruction</a><a class="headerlink" href="#llvm-genx-va-1pixel-convolve-1x1mode-visa-1-pixel-convolve-1x1-mode-instruction" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>arg0: i32 sampler index</li>
<li>arg1: i32 surface index</li>
<li>arg2: float normalized x-coordinate</li>
<li>arg3: float normalized y-coordinate</li>
<li>Return: v64i16 or v16i16 depending on mode.</li>
</ul>
</div>
<div class="section" id="llvm-genx-va-lbp-creation-visa-lbp-creation-instruction">
<h4><a class="toc-backref" href="#id187"><code class="docutils literal"><span class="pre">llvm.genx.va.lbp.creation</span></code> vISA LBP Creation instruction</a><a class="headerlink" href="#llvm-genx-va-lbp-creation-visa-lbp-creation-instruction" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>arg0: i32 surface index</li>
<li>arg1: float normalized x-coordinate</li>
<li>arg2: float normalized y-coordinate</li>
<li>arg3: mode, constant</li>
<li>Return: v64i8 or v128i8 depending on mode</li>
</ul>
</div>
<div class="section" id="llvm-genx-va-hdc-lbp-creation-visa-hdc-lbp-creation-instruction">
<h4><a class="toc-backref" href="#id188"><code class="docutils literal"><span class="pre">llvm.genx.va.hdc.lbp.creation</span></code> vISA HDC LBP Creation instruction</a><a class="headerlink" href="#llvm-genx-va-hdc-lbp-creation-visa-hdc-lbp-creation-instruction" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>arg0: i32 surface index</li>
<li>arg1: float normalized x-coordinate</li>
<li>arg2: float normalized y-coordinate</li>
<li>arg3: mode, constant</li>
<li>arg4: i32 destination surface index</li>
<li>arg5: i16 destination surface x-offset</li>
<li>arg6: i16 destination surface y-offset</li>
</ul>
</div>
<div class="section" id="llvm-genx-va-lbp-correlation-visa-lbp-correlation-instruction">
<h4><a class="toc-backref" href="#id189"><code class="docutils literal"><span class="pre">llvm.genx.va.lbp.correlation</span></code> vISA LBP Correlation instruction</a><a class="headerlink" href="#llvm-genx-va-lbp-correlation-visa-lbp-correlation-instruction" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>arg0: i32 surface index</li>
<li>arg1: float normalized x-coordinate</li>
<li>arg2: float normalized y-coordinate</li>
<li>arg3: i16 horizontal disparity</li>
<li>Return: v64i8</li>
</ul>
</div>
<div class="section" id="llvm-genx-va-hdc-lbp-correlation-visa-hdc-lbp-correlation-instruction">
<h4><a class="toc-backref" href="#id190"><code class="docutils literal"><span class="pre">llvm.genx.va.hdc.lbp.correlation</span></code> vISA HDC LBP Correlation instruction</a><a class="headerlink" href="#llvm-genx-va-hdc-lbp-correlation-visa-hdc-lbp-correlation-instruction" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>arg0: i32 surface index</li>
<li>arg1: float normalized x-coordinate</li>
<li>arg2: float normalized y-coordinate</li>
<li>arg3: i16 horizontal disparity</li>
<li>arg4: i32 destination surface index</li>
<li>arg5: i16 destination surface x-offset</li>
<li>arg6: i16 destination surface y-offset</li>
</ul>
</div>
<div class="section" id="llvm-genx-va-correlation-search-visa-correlation-search-instruction">
<h4><a class="toc-backref" href="#id191"><code class="docutils literal"><span class="pre">llvm.genx.va.correlation.search</span></code> vISA Correlation Search instruction</a><a class="headerlink" href="#llvm-genx-va-correlation-search-visa-correlation-search-instruction" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>arg0: i32 surface index</li>
<li>arg1: float normalized x-coordinate</li>
<li>arg2: float normalized y-coordinate</li>
<li>arg3: float normalized vertical origin</li>
<li>arg4: float normalized horizontal origin</li>
<li>arg5: i8 x-direction size</li>
<li>arg6: i8 y-direction size</li>
<li>arg7: i8 x-direction search size</li>
<li>arg8: i8 y-direction search size</li>
<li>Return: vXi32</li>
</ul>
</div>
<div class="section" id="llvm-genx-va-flood-fill-visa-flood-fill-instruction">
<h4><a class="toc-backref" href="#id192"><code class="docutils literal"><span class="pre">llvm.genx.va.flood.fill</span></code> vISA Flood Fill instruction</a><a class="headerlink" href="#llvm-genx-va-flood-fill-visa-flood-fill-instruction" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>arg0: i8 Is8Connect, constant (valid values 0 or 1).</li>
<li>arg1: v10i16 pixel mask horizontal direction</li>
<li>arg2: i16 pixel mask vertical direction left</li>
<li>arg3: i16 pixel mask vertical direction right</li>
<li>arg4: i16 loop count</li>
<li>Return: v8i16</li>
</ul>
</div>
</div>
</div>
</div>


          </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="CoverageMappingFormat.html" title="LLVM Code Coverage Mapping Format"
             >next</a> |</li>
        <li class="right" >
          <a href="GenXDesign.html" title="GenX backend design"
             >previous</a> |</li>
  <li><a href="http://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="index.html">Documentation</a>&raquo;</li>

          <li class="nav-item nav-item-1"><a href="GenXIndex.html" >GenX backend documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2003-2019, LLVM Project.
      Last updated on Wed Feb 13 10:08:12 2019 -0800.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.1.
    </div>
  </body>
</html>