/*========================== begin_copyright_notice ============================

Copyright (C) 2021 Intel Corporation

SPDX-License-Identifier: MIT

============================= end_copyright_notice ===========================*/

#include <iostream>

// Declares a set of functions to compute common mathematical operations
#include <cmath>

// C++ string
#include <string>

// The only CM runtime header file that you need is cm_rt.h.
// It includes all of the CM runtime.
#include "cm_rt.h"
#include "cm_loadprogram.h"

// Includes cm_rt_helpers.h to convert the integer return code returned from
// the CM runtime to a meaningful string message.
#include "common/cm_rt_helpers.h"

// Includes isa_helpers.h to load the ISA file generated by the CM compiler.
#include "common/isa_helpers.h"

#define BODIES_CHUNK 32
#define ELEMS_BODY 4

// Compares the results calculated by the GPU with reference data.
// Error must be within range.
bool CompareResult(float *cpu_pos,
                   float *cm_pos,
                   int num_bodies,
                   float range) {
  for (int i = 0; i < num_bodies; i++) {
    if (fabs(cpu_pos[i * 4] - cm_pos[i * 4]) > range ||
        fabs(cpu_pos[i * 4 + 1] - cm_pos[i * 4 + 1]) > range ||
        fabs(cpu_pos[i * 4 + 2] - cm_pos[i * 4 + 2]) > range) {
      printf("%d-th body has different result\n", i);

      printf("cpu_pos[%d] = %f  cm_pos[%d] = %f\n",
             i * 4,
             cpu_pos[i * 4],
             i * 4,
             cm_pos[i * 4]);

      printf("cpu_pos[%d] = %f  cm_pos[%d] = %f\n",
             i * 4 + 1,
             cpu_pos[i * 4 + 1],
             i * 4 + 1,
             cm_pos[i * 4 + 1]);

      printf("cpu_pos[%d] = %f  cm_pos[%d] = %f\n",
             i * 4 + 2,
             cpu_pos[i * 4 + 2],
             i * 4 + 2,
             cm_pos[i * 4 + 2]);

      return false;
    }
  }
  return true;
}

int main(int argc, char *argv[]) {
  int num_bodies = 128;

  // Creates pos, vel and col arrays.
  float *h_pos = new float[num_bodies * ELEMS_BODY];
  float *h_vel = new float[num_bodies * ELEMS_BODY];
  float *h_color = new float[num_bodies * ELEMS_BODY];
  if (!h_pos || !h_vel || !h_color) {
    std::cout << "allocate memory failed!" << std::endl;
    delete[] h_pos;
    delete[] h_vel;
    delete[] h_color;
    std::exit(1);
  }

  // Reads in the input data from file "color_in.dat" to h_color.
  FILE *f = fopen("color_in.dat", "rb");
  int ret = fread(h_color, 1, sizeof(float) * num_bodies * ELEMS_BODY, f);
  if (ret != sizeof(float) * num_bodies * ELEMS_BODY) {
    std::exit(1);
  }
  fclose(f);

  // Reads in the input data from file "pos_in.dat" to h_pos.
  f = fopen("pos_in.dat", "rb");
  ret = fread(h_pos, 1, sizeof(float) * num_bodies * ELEMS_BODY, f);
  if (ret != sizeof(float) * num_bodies * ELEMS_BODY) {
    std::exit(1);
  }
  fclose(f);

  // Reads in the input data from file "vel_in.dat" to h_vel.
  f = fopen("vel_in.dat", "rb");
  ret = fread(h_vel, 1, sizeof(float) * num_bodies * ELEMS_BODY, f);
  if (ret != sizeof(float) * num_bodies * ELEMS_BODY) {
    std::exit(1);
  }
  fclose(f);

  float *new_pos = new float[num_bodies * ELEMS_BODY];
  float *new_vel = new float[num_bodies * ELEMS_BODY];
  if (!new_pos || !new_vel) {
    std::cout << "allocate memory failed!" << std::endl;
    delete[] new_pos;
    delete[] new_vel;
    std::exit(1);
  }

  // Creates a CmDevice from scratch.
  // Param device: pointer to the CmDevice object.
  // Param version: CM API version supported by the runtime library.
  CmDevice *device = nullptr;
  unsigned int version = 0;
  cm_result_check(::CreateCmDevice(device, version));

  // The file nbody_SLM_release_genx.isa is generated when the kernels in the
  // file nbody_SLM_release_genx.cpp are compiled by the CM compiler. There
  // is one kernel included here, "cmNBody".
  // Reads in the virtual ISA from "nbody_SLM_release_genx.isa" to the code
  // buffer.
  std::string isa_code = cm::util::isa::loadFile("nbody_SLM_release_genx.isa");
  if (isa_code.size() == 0) {
    std::cerr << "Error: empty ISA binary.\n";
    std::exit(1);
  }

  // Creates a CmProgram object consisting of the kernel loaded from the code
  // buffer.
  // Param isa_code.data(): Pointer to the code buffer containing the virtual
  // ISA.
  // Param isa_code.size(): Size in bytes of the code buffer containing the
  // virtual ISA.
  CmProgram *program = nullptr;
  cm_result_check(CmDevLoadProgram(device, const_cast<char*>(isa_code.data()),
                                      isa_code.size(),
                                      program));

  // Creates the cmNBody kernel.
  // Param program: CM Program from which the kernel is created.
  // Param "cmNBody": The kernel name which should be no more than 256 bytes
  // including the null terminator.
  CmKernel *kernel = nullptr;
  cm_result_check(device->CreateKernel(program,
                                       "cmNBody",
                                       kernel));

  // Each CmKernel can be executed by multiple concurrent threads.
  // Calculates the number of threads to spawn on the GPU for this kernel.
  int threads = num_bodies / BODIES_CHUNK;

  // In this case, we want to maximize the group size to get the most
  // data-share, so we need to query the maximum group size that target
  // machine can support.
  size_t size = 4;
  int max_thread_count_per_thread_group = 0;
  cm_result_check(device->GetCaps(
      CAP_USER_DEFINED_THREAD_COUNT_PER_THREAD_GROUP,
      size,
      &max_thread_count_per_thread_group));
  int group_count = (threads + max_thread_count_per_thread_group - 1) /
      max_thread_count_per_thread_group;
  while (threads % group_count != 0) {
    group_count++;
  }

  // Creates a thread group space.
  // This function creates a thread group space specified by the height and
  // width dimensions of the group space, and the height and width dimensions
  // of the thread space within a group.In the GPGPU mode, the host program
  // needs to specify the group space and the thread space within each group.
  // This group and thread space information can be subsequently used to
  // execute a kernel in that space later.
  CmThreadGroupSpace *thread_group_space = nullptr;
  cm_result_check(device->CreateThreadGroupSpace(threads / group_count,
                                                 1,
                                                 group_count,
                                                 1,
                                                 thread_group_space));

  // CmBuffer represents a 1D surface in video memory.
  // This function creates a CmBuffer in memory with linear layout.
  CmBuffer *surf1 = nullptr;
  device->CreateBuffer(num_bodies * ELEMS_BODY * sizeof(float), surf1);
  cm_result_check(surf1->WriteSurface((unsigned char *)h_pos, nullptr));

  // Gets the input surface index.
  SurfaceIndex *input_surface_idx1 = nullptr;
  cm_result_check(surf1->GetIndex(input_surface_idx1));

  CmBuffer *surf2 = nullptr;
  device->CreateBuffer(num_bodies * ELEMS_BODY * sizeof(float), surf2);
  cm_result_check(surf2->WriteSurface((unsigned char *)h_vel, nullptr));

  // Gets the input surface index.
  SurfaceIndex *input_surface_idx2 = nullptr;
  cm_result_check(surf2->GetIndex(input_surface_idx2));

  CmBuffer *surf3 = nullptr;
  device->CreateBuffer(num_bodies * ELEMS_BODY * sizeof(float), surf3);

  // Gets the output surface index.
  SurfaceIndex *output_surface_idx1 = nullptr;
  cm_result_check(surf3->GetIndex(output_surface_idx1));

  CmBuffer *surf4 = nullptr;
  device->CreateBuffer(num_bodies * ELEMS_BODY * sizeof(float), surf4);

  // Gets the output surface index.
  SurfaceIndex *output_surface_idx2 = nullptr;
  cm_result_check(surf4->GetIndex(output_surface_idx2));

  // Sets a per kernel argument.
  // Sets input surface index 1 as the first argument of cmNBody kernel.
  // Sets input surface index 2 as the second argument of cmNBody kernel.
  // Sets output surface index 1 as the third argument of cmNBody kernel.
  // Sets output surface index 2 as the fourth argument of cmNBody kernel.
  // Sets g_delta_time as the fifth argument of cmNBody kernel.
  // Sets g_damping as the sixth argument of cmNBody kernel.
  // Sets soften as the seventh argument of cmNBody kernel.
  // Sets num_bodies as the eighth argument of cmNBody kernel.
  cm_result_check(kernel->SetKernelArg(0,
                                       sizeof(SurfaceIndex),
                                       input_surface_idx1));
  cm_result_check(kernel->SetKernelArg(1,
                                       sizeof(SurfaceIndex),
                                       input_surface_idx2));
  cm_result_check(kernel->SetKernelArg(2,
                                       sizeof(SurfaceIndex),
                                       output_surface_idx1));
  cm_result_check(kernel->SetKernelArg(3,
                                       sizeof(SurfaceIndex),
                                       output_surface_idx2));
  float g_delta_time = 0.001f;
  cm_result_check(kernel->SetKernelArg(4,
                                       sizeof(float),
                                       &g_delta_time));
  float g_damping = 1.0f;
  cm_result_check(kernel->SetKernelArg(5,
                                       sizeof(float),
                                       &g_damping));
  float soften = 0.1f;
  cm_result_check(kernel->SetKernelArg(6,
                                       sizeof(float),
                                       &soften));
  cm_result_check(kernel->SetKernelArg(7,
                                       sizeof(float),
                                       &num_bodies));

  // Creates a task queue.
  // The CmQueue is an in-order queue. Tasks get executed according to the
  // order they are enqueued. The next task does not start execution until the
  // current task finishes.
  CmQueue *cmd_queue = nullptr;
  cm_result_check(device->CreateQueue(cmd_queue));

  // Creates a CmTask object.
  // The CmTask object is a container for CmKernel pointers. It is used to
  // enqueue the kernels for execution.
  CmTask *task = nullptr;
  cm_result_check(device->CreateTask(task));

  // Adds a CmKernel pointer to CmTask.
  // This task has one kernel, "cmNBody".
  cm_result_check(task->AddKernel(kernel));

  // Launches the task on the GPU. Enqueue is a non-blocking call, i.e. the
  // function returns immediately without waiting for the GPU to start or
  // finish execution of the task. The runtime will query the HW status. If
  // the hardware is not busy, the runtime will submit the task to the
  // driver/HW; otherwise, the runtime will submit the task to the driver/HW
  // at another time.
  // An event, "sync_event", is created to track the status of the task.
  CmEvent *sync_event = nullptr;
  cm_result_check(cmd_queue->EnqueueWithGroup(task,
                                              sync_event,
                                              thread_group_space));

  // Destroys a CmTask object.
  // CmTask will be destroyed when CmDevice is destroyed.
  // Here, the application destroys the CmTask object by itself.
  cm_result_check(device->DestroyTask(task));

  // Destroys a CmThreadGroupSpace object.
  // CmThreadGroupSpace will be destroyed when CmDevice is destroyed.
  // Here, the application destroys the CmThreadGroupSpace by itself.
  if (thread_group_space) {
    device->DestroyThreadGroupSpace(thread_group_space);
  }

  // Reads the output surface content to the system memory using the CPU.
  // The size of data copied is the size of data in Surface.
  // It is a blocking call. The function will not return until the copy
  // operation is completed.
  // The dependent event "sync_event" ensures that the reading of the surface
  // will not happen until its state becomes CM_STATUS_FINISHED.
  cm_result_check(surf3->ReadSurface((unsigned char *)new_pos, sync_event));
  cm_result_check(surf4->ReadSurface((unsigned char *)new_vel, sync_event));

  // Destroys the CmDevice.
  // Also destroys surfaces, kernels, tasks, thread spaces, and queues that
  // were created using this device instance that have not explicitly been
  // destroyed by calling the respective destroy functions.
  cm_result_check(::DestroyCmDevice(device));

  float *cpu_pos = new float[num_bodies * ELEMS_BODY * sizeof(float)];

  // Opens the right reference data file according to num_bodies.
  if (num_bodies == 16384) {
    f = fopen("nbody_gold.dat", "rb");
  } else if (num_bodies == 128) {
    f = fopen("nbody_gold_128.dat", "rb");
  } else {
    printf("Example only tests against 16384 and 128 sized.\n");
    std::exit(1);
  }

  // Reads in the reference data.
  ret = fread(cpu_pos, 1, sizeof(float) * num_bodies * ELEMS_BODY, f);
  if (ret != sizeof(float) * num_bodies * ELEMS_BODY) {
    std::exit(1);
  }
  fclose(f);

  // Compares results calculated by the GPU with the reference data.
  // Test is paseed if difference within tolerence. Otherwise test is failed.
  bool result = CompareResult(cpu_pos, new_pos, num_bodies, .0005f);
  printf("Test %s\n", (result) ? "PASSED" : "FAILED");

  delete[] h_pos;
  delete[] h_vel;
  delete[] h_color;
  delete[] new_pos;
  delete[] new_vel;

  if (!result) {
    return -1;
  }
  return 0;
}
