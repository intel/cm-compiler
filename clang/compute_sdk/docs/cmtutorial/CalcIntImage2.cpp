/*========================== begin_copyright_notice ============================

Copyright (C) 2021 Intel Corporation

SPDX-License-Identifier: MIT

============================= end_copyright_notice ===========================*/

#include <cstdio>

// Includes cm_rt_helpers.h to convert the integer return code returned from
// the CM runtime to a meaningful string message.
#include "common/cm_rt_helpers.h"

// Includes isa_helpers.h to load the ISA file generated by the CM compiler.
#include "common/isa_helpers.h"

#include "cm_loadprogram.h"

// This function is used to calculate integral image using the CPU.
// Every output pixel is the summation of all pixels in the sub-image
// from (0, 0) to (x, y).
void CpuCalcInt(unsigned char *src_image,
                unsigned int *dst_image,
                int width,
                int height) {
    int row_sum = 0;
    for (int row = 0; row < height; row++) {
        row_sum = 0;
        for (int col = 0; col < width; col++) {
            row_sum += src_image[row * width + col];
            if (row > 0)
                dst_image[row * width + col] =
                    dst_image[(row - 1) * width + col] + row_sum;
            else
                dst_image[row * width + col] = row_sum;
        }
    }
}

// Compares the CPU result with the GPU result.
// If they are identical, the result is correct.
// Or else there is something wrong.
bool CheckResult(unsigned int *cpu_result,
                 unsigned int *gpu_result,
                 int width,
                 int height) {
    for (int row = 0; row < height; row++) {
        for (int col = 0; col < width; col++) {
            if (cpu_result[row * width + col] !=
                gpu_result[row * width + col]) {
                printf("CPU and GPU result mismatch at (%d, %d)\n", row, col);
                printf("CPU = %d\n", cpu_result[row * width + col]);
                printf("GPU = %d\n", gpu_result[row * width + col]);
                return false;
            }
        }
    }
    return true;
}

// This function is used to calculate Integral graph using the GPU.
int GpuCalcInt(unsigned char *src_image,
               unsigned int *gpu_dst,
               int width,
               int height) {
    // Creates a CmDevice from scratch.
    // Param device: pointer to the CmDevice object.
    // Param version: CM API version supported by the runtime library.
    CmDevice *device = nullptr;
    unsigned int version = 0;
    cm_result_check(::CreateCmDevice(device, version));

    // The file CalcIntImage2_genx.isa is generated when the kernels in the file
    // CalcIntImage2_genx.cpp are compiled by the CM compiler.
    // Reads in the virtual ISA from "CalcIntImage2_genx.isa" to the code
    // buffer.
    std::string isa_code = cm::util::isa::loadFile("CalcIntImage2_genx.isa");
    if (isa_code.size() == 0) {
        std::cerr << "Error: empty ISA binary.\n";
        std::exit(1);
    }

    // Creates a CmProgram object consisting of the kernels loaded from the code
    // buffer.
    // Param isa_code.data(): Pointer to the code buffer containing the virtual
    // ISA.
    // Param isa_code.size(): Size in bytes of the code buffer containing the
    // virtual ISA.
    CmProgram *program = nullptr;
    cm_result_check(CmDevLoadProgram(device, const_cast<char *>(isa_code.data()),
                                        isa_code.size(),
                                        program));

    // Creates the kernel.
    // Param program: CM Program from which the kernel is created.
    // Param "CalcIntImage": The kernel name which should be no more than 256 bytes
    // including the null terminator.
    CmKernel *kernel = nullptr;
    cm_result_check(device->CreateKernel(program,
                                         "CalcIntImage",
                                         kernel));

    // Creates input surface with given width and height in pixels and format.
    CmSurface2D *input_surface = nullptr;
    cm_result_check(device->CreateSurface2D(width,
                                            height,
                                            CM_SURFACE_FORMAT_A8,
                                            input_surface));

    // Creates the output surface. The width, height and format is the same as
    // the input surface.
    CmSurface2D *output_surface = nullptr;
    cm_result_check(device->CreateSurface2D(width,
                                            height,
                                            CM_SURFACE_FORMAT_A8R8G8B8,
                                            output_surface));

    // Copies system memory content to the input surface using the CPU. The
    // system memory content is the data of the input image. The size of data
    // copied is the size of data in the surface.
    cm_result_check(input_surface->WriteSurface(src_image, nullptr));

    // Each CmKernel can be executed by multiple concurrent threads.
    // Here, for "CalcIntImage" kernel, each thread works on a block of 16x16
    // pixels.
    int thread_width = width / 16;
    int thread_height = (height + 15) >> 4;

    // Creates a CmThreadSpace object.
    // There are two usage models for the thread space. One is to define the
    // dependency between threads to run in the GPU. The other is to define a
    // thread space where each thread can get a pair of coordinates during
    // kernel execution. For this example, we use both usage models.
    CmThreadSpace *thread_space = nullptr;
    cm_result_check(device->CreateThreadSpace(thread_width,
                                              thread_height,
                                              thread_space));

    // Selects thread dependency pattern.
    // 45-degree wave-front dependency: every block needs.
    // Results from its three neighbors: up, left, and up-left.
    cm_result_check(thread_space->SelectThreadDependencyPattern(CM_WAVEFRONT));

    // When a surface is created by the CmDevice a SurfaceIndex object is
    // created. This object contains a unique index value that is mapped to the
    // surface.
    // Gets the input surface index.
    SurfaceIndex *input_surface_idx = nullptr;
    cm_result_check(input_surface->GetIndex(input_surface_idx));

    // Gets the output surface index.
    SurfaceIndex *output_surface_idx = nullptr;
    cm_result_check(output_surface->GetIndex(output_surface_idx));

    // Sets a per kernel argument.
    // Sets input surface index as the first argument of linear kernel.
    // Sets output surface index as the second argument of linear kernel.
    cm_result_check(kernel->SetKernelArg(0,
                                         sizeof(SurfaceIndex),
                                         input_surface_idx));
    cm_result_check(kernel->SetKernelArg(1,
                                         sizeof(SurfaceIndex),
                                         output_surface_idx));

    // Creates a task queue.
    // The CmQueue is an in-order queue. Tasks get executed according to the
    // order they are enqueued. The next task does not start execution until the
    // current task finishes.
    CmQueue *cmd_queue = nullptr;
    cm_result_check(device->CreateQueue(cmd_queue));

    // Creates a CmTask object.
    // The CmTask object is a container for CmKernel pointers. It is used to
    // enqueue the kernels for execution.
    CmTask *task = nullptr;
    cm_result_check(device->CreateTask(task));

    // Adds a CmKernel pointer to CmTask.
    // This task has only one kernel, which is "CalcIntImage".
    cm_result_check(task->AddKernel(kernel));

    // Launches the task on the GPU. Enqueue is a non-blocking call, i.e. the
    // function returns immediately without waiting for the GPU to start or
    // finish execution of the task. The runtime will query the HW status. If
    // the hardware is not busy, the runtime will submit the task to the
    // driver/HW; otherwise, the runtime will submit the task to the driver/HW
    // at another time.
    // An event, "sync_event", is created to track the status of the task.
    CmEvent *sync_event = nullptr;
    cm_result_check(cmd_queue->Enqueue(task,
                                       sync_event,
                                       thread_space));

    // Destroys a CmTask object.
    // CmTask will be destroyed when CmDevice is destroyed.
    // Here, the application destroys the CmTask object by itself.
    cm_result_check(device->DestroyTask(task));

    // Destroys a CmThreadSpace object.
    // CmThreadSpace will be destroyed when CmDevice is destroyed.
    // Here, the application destroys the CmThreadSpace object by itself.
    cm_result_check(device->DestroyThreadSpace(thread_space));

    // Reads the output surface content to the system memory using the CPU.
    // The size of data copied is the size of data in Surface.
    // It is a blocking call. The function will not return until the copy
    // operation is completed.
    // The dependent event "sync_event" ensures that the reading of the surface
    // will not happen until its state becomes CM_STATUS_FINISHED.
    cm_result_check(output_surface->ReadSurface((unsigned char *)gpu_dst,
                                                sync_event));

    // Queries the execution time of a task in the unit of nanoseconds.
    // The execution time is measured from the time the task started execution
    // in the GPU to the time when the task finished execution.
    UINT64 execution_time = 0;
    cm_result_check(sync_event->GetExecutionTime(execution_time));
    printf("Kernel CalcHoriIntImage execution time is %4.4fms\n",
            execution_time / 1000000.0);

    // Destroys the CmDevice.
    // Also destroys surfaces, kernels, tasks, thread spaces, and queues that
    // were created using this device instance that have not explicitly been
    // destroyed by calling the respective destroy functions.
    cm_result_check(::DestroyCmDevice(device));

    return 0;
}

int main(int argc, char *argv[]) {
    int result = 0;
    int width = 1920;
    int height = 1080;

    // Loads an input image named "bbc.y".
    FILE *in = fopen("bbc.y", "rb");
    if (in == NULL) {
        perror("bbc.y");
        return -1;
    }

    // Checks the value of width, height of the image.
    // Only images with width and height a multiple of 8 are supported.
    if ((width & 7) || (height & 7)) {
        printf("image width and height must be a multiple of 8\n");
        return -1;
    }

    // Allocates system memory for input image and the CPU result and
    // the GPU result.
    unsigned char *src_image = new unsigned char[width * height];
    unsigned int *dst_image = new unsigned int[width * height * 4];
    unsigned int *gpu_dst = new unsigned int[width * height * 4];
    if (!src_image || !dst_image) {
        printf("Allocate memory fail!\n");
        return -1;
    }

    // Initializes dst_image with empty value.
    memset(dst_image, 0, width * height);

    // Initializes src_image with input image.
    if (fread(src_image, 1, width * height, in) != width * height) {
        perror("bbc.y");
        return -1;
    }
    fclose(in);

    // Calcutes result with the CPU.
    CpuCalcInt(src_image, dst_image, width, height);

    // Calcutes result with the GPU.
    GpuCalcInt(src_image, gpu_dst, width, height);

    // Checks result
    bool passed = CheckResult(dst_image, gpu_dst, width, height);

    // Frees memory
    delete[] src_image;
    delete[] dst_image;
    delete[] gpu_dst;

    if (passed) {
        printf("PASSED\n");
        return 0;
    } else {
        printf("FAILED\n");
        return -1;
    }
}
