/*========================== begin_copyright_notice ============================

Copyright (C) 2021 Intel Corporation

SPDX-License-Identifier: MIT

============================= end_copyright_notice ===========================*/

#include <cstdio>

// The only CM runtime header file that you need is cm_rt.h.
// It includes all of the CM runtime.
#include "cm_rt.h"
#include "cm_loadprogram.h"

// Includes bitmap_helpers.h for bitmap file open/save/compare operations.
#include "common/bitmap_helpers.h"

// Includes cm_rt_helpers.h to convert the integer return code returned from
// the CM runtime to a meaningful string message.
#include "common/cm_rt_helpers.h"

// Includes isa_helpers.h to load the ISA file generated by the CM compiler.
#include "common/isa_helpers.h"

using cm::util::bitmap::BitMap;
using std::cout;
using std::endl;

int test(bool per_kernel_thread_space) {
    // Loads an input image named "linear_in.bmp".
    auto input_image = BitMap::load("linear_in.bmp");

    // Gets the width and height of the input image.
    unsigned int width = input_image.getWidth();
    unsigned int height = input_image.getHeight();
    printf("Width = %d\n", width);
    printf("Height = %d\n", height);

    // Checks the value of width, height and bpp(bits per pixel) of the image.
    // Only images in 8-bit RGB format are supported.
    // Only images with width and height a multiple of 8 are supported.
    if ((width & 7) || (height & 7) || (input_image.getBPP() != 24)) {
        std::cerr << "Error: Only images in 8-bit RGB format with width and "
                  << "height a multiple of 8 are supported.\n";
        std::exit(1);
    }

    // Copies input image to output except for the data.
    auto output_image = input_image;

    // Sets image size in bytes. There are a total of width*height pixels and
    // each pixel occupies (out.getBPP()/8) bytes.
    unsigned int img_size = width * height * output_image.getBPP() / 8;

    // Sets output to blank image.
    output_image.setData(new unsigned char[img_size]);

    // Creates a CmDevice from scratch.
    // Param device: pointer to the CmDevice object.
    // Param version: CM API version supported by the runtime library.
    CmDevice *device = nullptr;
    unsigned int version = 0;
    cm_result_check(::CreateCmDevice(device, version));

    // Gets necessary information in order to create and use CmSurface2DUP as
    // input surface later.
    // To create CmSurface2DUP, user needs to allocate such amount of system
    // memory which is equal to or larger than physical size returned here.
    // When accessing the system memory, user needs to be aware of the pitch,
    // which is equal to pixel_width * byte_per_pixel + necessary_padding.
    unsigned int input_surface_pitch = 0;
    unsigned int input_surface_size = 0;
    cm_result_check(device->GetSurface2DInfo(width * 3 / 4,
                                             height,
                                             CM_SURFACE_FORMAT_A8R8G8B8,
                                             input_surface_pitch,
                                             input_surface_size));

    // Creates a CmSurface2DUP as input surface in UP (User Provided) system memory
    // with given surface width and height in pixel, and format. The UP system memory
    // must be page (4K Bytes) aligned. The size of the system memory must be
    // larger than or equal to the size returned by GetSurface2DInfo.
    // Application can either access the memory through the memory pointer from
    // the CPU, or access the 2D surface created upon the same memory from the GPU.
    CmSurface2DUP *input_surface = nullptr;
    void *sysmem_src = CM_ALIGNED_MALLOC(input_surface_size, 0x1000);
    cm_result_check(device->CreateSurface2DUP(width * 3 / 4,
                                              height,
                                              CM_SURFACE_FORMAT_A8R8G8B8,
                                              sysmem_src,
                                              input_surface));

    // Copies the input image data to the system memory provided to create
    // CmSurface2DUP using the CPU.
    memcpy(sysmem_src, input_image.getData(), width * height * 3);

    // Gets necessary information in order to create and use CmSurface2DUP
    // as output surface later.
    unsigned int output_surface_pitch = 0;
    unsigned int output_surface_size = 0;
    cm_result_check(device->GetSurface2DInfo(width * 3 / 4,
                                             height,
                                             CM_SURFACE_FORMAT_A8R8G8B8,
                                             output_surface_pitch,
                                             output_surface_size));

    // Creates a CmSurface2DUP in UP (User Provided) system memory to serve
    // as the output surface.
    CmSurface2DUP *output_surface = nullptr;
    void *sysmem_dst = CM_ALIGNED_MALLOC(output_surface_size, 0x1000);
    cm_result_check(device->CreateSurface2DUP(width * 3 / 4,
                                              height,
                                              CM_SURFACE_FORMAT_A8R8G8B8,
                                              sysmem_dst,
                                              output_surface));

    // The file linear_up_walker1_genx.isa is generated when the kernels in
    // the file linear_up_walker1_genx.cpp are compiled by the CM compiler.
    // Reads in the virtual ISA from "linear_up_walker1_genx.isa" to the code
    // buffer.
    std::string isa_code = cm::util::isa::loadFile("linear_up_walker1_genx.isa");
    if (isa_code.size() == 0) {
        std::cerr << "Error: empty ISA binary.\n";
        std::exit(1);
    }

    // Creates a CmProgram object consisting of kernels loaded from the code
    // buffer.
    // Param isa_code.data(): Pointer to the code buffer containing the virtual
    // ISA.
    // Param isa_code.size(): Size in bytes of the code buffer containing the
    // virtual ISA.
    CmProgram *program = nullptr;
    cm_result_check(CmDevLoadProgram(device, const_cast<char *>(isa_code.data()),
                                        isa_code.size(),
                                        program));

    // Creates the linear kernel.
    // Param program: CM Program from which the kernel is created.
    // Param "linear": The kernel name which should be no more than 256 bytes
    // including the null terminator.
    CmKernel *kernel = nullptr;
    cm_result_check(device->CreateKernel(program,
                                         "linear",
                                         kernel));

    // Each CmKernel can be executed by multiple concurrent threads.
    // Here, for "linear" kernel, each thread works on a block of 6x8 pixels.
    // The thread width is equal to surface width divided by 8.
    // The thread height is equal to surface height divided by 6.
    int thread_width = width * 3 / 24;
    int thread_height = height / 6;

    // Creates a CmThreadSpace object.
    // There are two usage models for the thread space. One is to define the
    // dependency between threads to run in the GPU. The other is to define a
    // thread space where each thread can get a pair of coordinates during
    // kernel execution. For this example, we use the latter usage model.
    CmThreadSpace *thread_space = nullptr;
    cm_result_check(device->CreateThreadSpace(thread_width,
                                              thread_height,
                                              thread_space));

    if (per_kernel_thread_space) {
        // Associates a thread space to this kernel.
        cm_result_check(kernel->AssociateThreadSpace(thread_space));
    }

    // When a surface is created by the CmDevice a SurfaceIndex object is
    // created. This object contains a unique index value that is mapped to the
    // surface.
    // Gets the input surface index.
    SurfaceIndex *input_surface_idx = nullptr;
    cm_result_check(input_surface->GetIndex(input_surface_idx));

    // Gets the output surface index.
    SurfaceIndex *output_surface_idx = nullptr;
    cm_result_check(output_surface->GetIndex(output_surface_idx));

    // Sets a per kernel argument.
    // Sets input surface index as the first argument of linear kernel.
    // Sets output surface index as the second argument of linear kernel.
    cm_result_check(kernel->SetKernelArg(0,
                                         sizeof(SurfaceIndex),
                                         input_surface_idx));
    cm_result_check(kernel->SetKernelArg(1,
                                         sizeof(SurfaceIndex),
                                         output_surface_idx));

    // Creates a task queue.
    // The CmQueue is an in-order queue. Tasks get executed according to
    // the order they get enqueued. The next task doesn't start execution
    // until the current task finishes.
    CmQueue *cmd_queue = nullptr;
    cm_result_check(device->CreateQueue(cmd_queue));

    // Creates a CmTask object.
    // CmTask object is a container for CmKernel pointers. It is used to
    // enqueue the kernels for execution.
    CmTask *task = nullptr;
    cm_result_check(device->CreateTask(task));

    // Adds a CmKernel pointer to CmTask.
    // This task has only one kernel, which is linear.
    cm_result_check(task->AddKernel(kernel));

    // Launches the task on the GPU. Enqueue is a non-blocking call, i.e. the
    // function returns immediately without waiting for the GPU to start or
    // finish execution of the task. The runtime will query the HW status. If
    // the hardware is not busy, the runtime will submit the task to the
    // driver/HW; otherwise, the runtime will submit the task to the driver/HW
    // at another time.
    // An event, "sync_event", is created to track the status of the task.
    CmEvent *sync_event = nullptr;
    if (per_kernel_thread_space) {
        // For per-kernel thread space, each kernel has associated its own
        // thread space. Therefore, do not need specify thread space when
        // calling Enqueue.
        cm_result_check(cmd_queue->Enqueue(task, sync_event));
    } else {
        // For per-task thread space, all kernels within the task share the
        // same thread space.
        cm_result_check(cmd_queue->Enqueue(task, sync_event, thread_space));
    }

    // Waits for the task associated with "sync_event" finishing execution
    // on the GPU.
    unsigned long time_out = -1;
    cm_result_check(sync_event->WaitForTaskFinished(time_out));

    // Destroys a CmTask object.
    // CmTask will be destroyed when CmDevice is destroyed.
    // Here, the application destroys the CmTask object by itself.
    cm_result_check(device->DestroyTask(task));

    // Destroys a CmThreadSpace object.
    // CmThreadSpace will be destroyed when CmDevice is destroyed.
    // Here, the application destroys the CmThreadSpace object by itself.
    cm_result_check(device->DestroyThreadSpace(thread_space));

    // Queries the execution time of a task in the unit of nanoseconds.
    // The execution time is measured from the time the task started
    // execution in the GPU to the time when the task finished execution.
    UINT64 execution_time = 0;
    cm_result_check(sync_event->GetExecutionTime(execution_time));
    cout << "Kernel linear execution time is " << execution_time
         << " nanoseconds" << endl;

    // In linear kernel, the GPU will write the output data to the output
    // surface. As this output surface is a CmSurface2DUP, application can
    // either access the memory through the memory pointer from the CPU or
    // access the surface created upon the same memory from the GPU.
    // Here uses the CPU copy to read the output data, and saves the data
    // into the file "linear_out.bmp".
    memcpy(output_image.getData(), sysmem_dst, width * height * 3);
    output_image.save("linear_out.bmp");

    // Destroys the CmDevice.
    // Also destroys surfaces, kernels, and the queue that were created
    // using this device instance that haven't explicitly been destroyed by
    // calling respective destroy functions.
    cm_result_check(::DestroyCmDevice(device));

    // Frees memory.
    CM_ALIGNED_FREE(sysmem_src);
    CM_ALIGNED_FREE(sysmem_dst);

    // Compares each pixel of output image with the gold image. Sets the tolerence
    // of each pixel difference as 5. If the difference of all pixels is within
    // this tolerance, the result is correct. Or else there is something wrong.
    bool passed = BitMap::checkResult("linear_out.bmp",
                                      "linear_gold_hw.bmp",
                                      5);

    if (passed) {
        cout << "PASSED" << endl;
        return 0;
    } else {
        cout << "FAILED" << endl;
        return -1;
    }
}

int main(int argc, char * argv[]) {
    int result = 0;

    // Tests using per-task thread space.
    // Tests using per-kernel thread space.
    if (test(false) != 0 || test(true) != 0)
        result = -1;

    return result;
}
